{
  "file_name": "Maintaining Knowledge about Temporal Intervals - 1983.pdf",
  "task_id": "e486b275-1bc0-49c3-ae9c-0f8b7a10216a",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "d9f0d425-b207-4ad3-b813-1f11d51b6f4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "/ESEARCH \r\nCOKrNBlmONS \r\nMaintaining Knowledge \r\nabout Temporal \r\nIntervals \r\nJAMES F. ALLEN The University of Rochester \r\nlames F. Allen's main \r\ninterests are in artificial \r\nintelligence in particular \r\nnatural language processing \r\nand the representation of \r\nknowledge. \r\nAuthor's Present Address: \r\nJames F. Allen, Computer \r\nScience Department, \r\nUniversity of Rochester. \r\nRochester. NY 14627. \r\nThe research described in \r\nthis paper was supported in \r\npart by the National Science \r\nFoundation under Grants \r\nIST-g0-12418 and \r\nIST-82-10564. and in part \r\nby the Office of Naval \r\nResearch under Grant \r\nN00014-80-C-0197. \r\nPermission to copy without \r\nfee all or part of this material \r\nis granted provided that the \r\ncopies are not made or \r\ndistributed for direct \r\ncommercial advantage, the \r\nACM copyright notice and \r\nthe title of the publication \r\nand its date appear, and \r\nnotice is given that copying \r\nis by permission of the \r\nAssociation for Computing \r\nMachinery. To copy \r\notherwise, or to republish, \r\nrequires a fee and/or specific \r\npermission. © 1983 ACM \r\n0001-0782/83/1100.0832 75¢ \r\n1. INTRODUCTION \r\nThe problem of representing temporal knowledge and tem\u0002poral reasoning arises in a wide range of disciplines, including \r\ncomputer science, philosophy, psychology, and linguistics. In \r\ncomputer science, it is a core problem of information systems, \r\nprogram verification, artificial intelligence, and other areas \r\ninvolving process modeling. (For a recent survey of work in \r\ntemporal representation, see the special sections in the April \r\n1982 issues of the ACM SIGART and SIGMOD Newsletters.) \r\nInformation systems, for example, must deal with the p~b\u0002lem of outdated data. One approach to this is simply to delete \r\noutdated data; however, this eliminates the possibility of ac\u0002cessing any information except that which involves facts that \r\nare presently true. In order to consider queries such as, \r\n\"Which employees worked for us last year and made over \r\n$15,000/' we need to represent temporal information. In some \r\napplications, such as keeping medical records, the time course \r\nof events becomes a critical part of the data. \r\nIn artificial intelligence, models of problem solving require \r\nsophisticated world models that can capture change. In plan\u0002ning the activities of a robot, for instance, one must model the \r\neffects of the robot's actions on the world to ensure that a \r\nplan will be effective. In natural language processing re\u0002searchers are concerned with extracting and capturing tem\u0002poral and tense information in sentences. This knowledge is \r\nnecessary to be able to answer queries about the sentences \r\nlater. Further progress in these areas requires more powerful \r\nrepresentations of temporal knowledge than have previously \r\nbeen available. \r\nThis paper addresses the problem from the perspective of \r\nartificial intelligence. It describes a temporal representation \r\nthat takes the notion of a temporal interval as primitive. It \r\nthen describes a method of representing the relationships be\u0002tween temporal intervals in a hierarchical manner using con\u0002straint propagation techniques. By using reference intervals, \r\nABSTRACT: An interval-based \r\ntemporal logic is introduced, \r\ntogether with a computationally \r\neffective reasoning algorithm based \r\non constraint propagation. This \r\nsystem is notable in offering a \r\ndelicate balance between \r\nexpressive power and the efficiency \r\nof its deductive engine. A notion of \r\nreference intervals is introduced \r\nwhich captu~s the temporal \r\nhierarchy implicit in many \r\ndomains, and which can be used to \r\nprecisely control the amount of \r\ndeduction performed automatically \r\nby the system. Examples are \r\nprovided for a database containing \r\nhistorical data, a database used for \r\nmodeling processes and proce~ \r\ninteraction, and a database for an \r\ninteractive system where the \r\npresent moment is continually \r\nbeing updated. \r\n832 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/d9f0d425-b207-4ad3-b813-1f11d51b6f4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ddaae2451ba8758862e0c4dec92311bce0be8e81325bee61e0a9dfe4eb4db03a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 563
      },
      {
        "segments": [
          {
            "segment_id": "d9f0d425-b207-4ad3-b813-1f11d51b6f4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "/ESEARCH \r\nCOKrNBlmONS \r\nMaintaining Knowledge \r\nabout Temporal \r\nIntervals \r\nJAMES F. ALLEN The University of Rochester \r\nlames F. Allen's main \r\ninterests are in artificial \r\nintelligence in particular \r\nnatural language processing \r\nand the representation of \r\nknowledge. \r\nAuthor's Present Address: \r\nJames F. Allen, Computer \r\nScience Department, \r\nUniversity of Rochester. \r\nRochester. NY 14627. \r\nThe research described in \r\nthis paper was supported in \r\npart by the National Science \r\nFoundation under Grants \r\nIST-g0-12418 and \r\nIST-82-10564. and in part \r\nby the Office of Naval \r\nResearch under Grant \r\nN00014-80-C-0197. \r\nPermission to copy without \r\nfee all or part of this material \r\nis granted provided that the \r\ncopies are not made or \r\ndistributed for direct \r\ncommercial advantage, the \r\nACM copyright notice and \r\nthe title of the publication \r\nand its date appear, and \r\nnotice is given that copying \r\nis by permission of the \r\nAssociation for Computing \r\nMachinery. To copy \r\notherwise, or to republish, \r\nrequires a fee and/or specific \r\npermission. © 1983 ACM \r\n0001-0782/83/1100.0832 75¢ \r\n1. INTRODUCTION \r\nThe problem of representing temporal knowledge and tem\u0002poral reasoning arises in a wide range of disciplines, including \r\ncomputer science, philosophy, psychology, and linguistics. In \r\ncomputer science, it is a core problem of information systems, \r\nprogram verification, artificial intelligence, and other areas \r\ninvolving process modeling. (For a recent survey of work in \r\ntemporal representation, see the special sections in the April \r\n1982 issues of the ACM SIGART and SIGMOD Newsletters.) \r\nInformation systems, for example, must deal with the p~b\u0002lem of outdated data. One approach to this is simply to delete \r\noutdated data; however, this eliminates the possibility of ac\u0002cessing any information except that which involves facts that \r\nare presently true. In order to consider queries such as, \r\n\"Which employees worked for us last year and made over \r\n$15,000/' we need to represent temporal information. In some \r\napplications, such as keeping medical records, the time course \r\nof events becomes a critical part of the data. \r\nIn artificial intelligence, models of problem solving require \r\nsophisticated world models that can capture change. In plan\u0002ning the activities of a robot, for instance, one must model the \r\neffects of the robot's actions on the world to ensure that a \r\nplan will be effective. In natural language processing re\u0002searchers are concerned with extracting and capturing tem\u0002poral and tense information in sentences. This knowledge is \r\nnecessary to be able to answer queries about the sentences \r\nlater. Further progress in these areas requires more powerful \r\nrepresentations of temporal knowledge than have previously \r\nbeen available. \r\nThis paper addresses the problem from the perspective of \r\nartificial intelligence. It describes a temporal representation \r\nthat takes the notion of a temporal interval as primitive. It \r\nthen describes a method of representing the relationships be\u0002tween temporal intervals in a hierarchical manner using con\u0002straint propagation techniques. By using reference intervals, \r\nABSTRACT: An interval-based \r\ntemporal logic is introduced, \r\ntogether with a computationally \r\neffective reasoning algorithm based \r\non constraint propagation. This \r\nsystem is notable in offering a \r\ndelicate balance between \r\nexpressive power and the efficiency \r\nof its deductive engine. A notion of \r\nreference intervals is introduced \r\nwhich captu~s the temporal \r\nhierarchy implicit in many \r\ndomains, and which can be used to \r\nprecisely control the amount of \r\ndeduction performed automatically \r\nby the system. Examples are \r\nprovided for a database containing \r\nhistorical data, a database used for \r\nmodeling processes and proce~ \r\ninteraction, and a database for an \r\ninteractive system where the \r\npresent moment is continually \r\nbeing updated. \r\n832 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/d9f0d425-b207-4ad3-b813-1f11d51b6f4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ddaae2451ba8758862e0c4dec92311bce0be8e81325bee61e0a9dfe4eb4db03a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 563
      },
      {
        "segments": [
          {
            "segment_id": "2e5aeff6-234a-475c-a720-83428f8af0b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nthe amount of computation involved when adding a fact can \r\nbe controlled in a predictable manner. This representation is \r\ndesigned explicitly to deal with the problem that much of our \r\ntemporal knowledge is relative, and hence cannot be de\u0002scribed by a date (or even a \"fuzzy\" date). \r\nWe start with a survey of current techniques for modeling \r\ntime, and point out various problems that need to be ado \r\ndressed. After a discussion of the relative merits of interval\u0002based systems versus point-based systems in Section 3, a sim\u0002ple interval-based deduction technique based on constraint \r\npropagation is introduced in Section 4. This scheme is then \r\naugmented in Section 5 with reference intervals, and exam\u0002ples in three different domains are presented. In the final \r\nsections of the paper, extensions to the basic system are pro\u0002posed in some detail. These would extend the representation \r\nto include reasoning about the duration of intervals, reasoning \r\nabout dates when they are available, and reasoning about the \r\nfuture given knowledge of what is true at the present. \r\nThe system as described in Section 5 has been imple\u0002mented and is being used in a variety of research projects \r\nwhich are briefly described in Section 6. Of the extensions, \r\nthe duration reasoner is fully implemented and incorporated \r\ninto the system, whereas the date reasoner has been designed \r\nbut not implemented. \r\n2. BACKGROUND \r\nBefore we consider some previous approaches to temporal \r\nrepresentation, let us summarize some important characteris\u0002tics that are relevant to our work: \r\n• The representation should allow significant imprecision. \r\nMuch temporal knowledge is strictly relative (e.g., A is \r\nbefore B) and has little relation to absolute dates. \r\n• The representation should allow uncertainty of informa\u0002tion. Often, the exact relationship between two times is \r\nnot known, but some contraints on how they could be \r\nrelated are known. \r\n• The representation should allow one to vary the grain of \r\nreasoning. For example, when modeling knowledge of \r\nhistory, one may only need to consider time in terms of \r\ndays, or even years. When modeling knowledge of com\u0002puter design, one may need to consider times on the \r\norder of nanoseconds or less. \r\n• The model should support persistence. It should facili\u0002tate default reasoning of the type, \"If I parked my car in \r\nlot A this morning, it should still be there now,\" even \r\nthough proof is not possible (the car may have been \r\ntowed or stolen). \r\nThis does not exhaust all the issues, and others will come \r\nup as they become relevant. It provides us with a starting \r\ncriteria, however, for examining previous approaches. Pre\u0002vious work can be divided roughly into four categories: state \r\nspace approaches, date line systems, before/after chaining, \r\nand formal models. \r\nState space approaches (e.g., [7, 17]) provide a crude sense \r\nof time that is useful in simple problem-solving tasks. A state \r\nis a description of the world (i.e., a database of facts) at an \r\ninstantaneous point in time. Actions are modeled in such \r\nsystems as functions mapping between states. For example, if \r\nan action occurs that causes P to become true and causes fact \r\nQ to be no longer true, its effect is simulated by simply adding \r\nfact P to the current state and deleting fact Q. If the previous \r\nstates are retained, we have a representation of time as a \r\nseries of databases describing the world in successive states. In \r\ngeneral, however, it is too expensive to maintain all the pre\u0002vious states, so most systems only maintain the present state. \r\nWhile this technique is useful in some applications, it does \r\nnot address many of the issues that concern us. Note that \r\nsuch systems do provide a notion of persistence, however. \r\nOnce a fact is asserted, it remains true until it is explicitly \r\ndeleted. \r\nIn datebase systems (e.g., [4, 5, 12, 13]), each fact is indexed \r\nby a date. A date is a representation of a time such that \r\nthe temporal ordering between two dates can be computed by \r\nfairly simple operations. For example, we could use the inte\u0002gers as dates, and then temporal ordering could be computed \r\nusing a simple numeric comparison. Of course, more compli\u0002cated schemes based on calendar dates and times are typi\u0002cally more useful. Because of the nice computational proper\u0002ties, this is the approach of choice if one can assign dates for \r\nevery event. Unfortunately, in the applications we are consid\u0002ering, this is not a valid assumption. Many events simply \r\ncannot be assigned a precise date. There are methods of geno \r\neralizing this scheme to include ranges of dates in which the \r\nevent must occur, but even this scheme cannot capture some \r\nrelative temporal information. For instance, the fact that two \r\nevents, A and B, did not happen at the same time cannot be \r\nrepresented using fuzzy dates for A and B. Either we must \r\ndecide that A was before B, or B was before A, or we must \r\nassign date ranges that allow A and B to overlap. This prob\u0002lem becomes even more severe if we are dealing with time \r\nintervals rather than time points. We then need fuzzy date \r\nranges for both ends of the interval plus a range for the \r\nminimum and maximum duration of the interval. \r\nThe next scheme is to represent temporal information us\u0002ing before/after chains. This approach allows us to capture \r\nrelative temporal information quite directly. This technique \r\nhas been used successfully in many systems (e.g., [4, 13]). As \r\nthe amount of temporal information grows, however, it suffers \r\nfrom either difficult search problems (searching long chains) \r\nor space problems (if all possible relationships are precom\u0002puted). This problem can be alleviated somewhat by using a \r\nnotion of reference intervals [13], which will be discussed in \r\ndetail later. Note that a fact such as \"events A and B are \r\ndisjoint\" cannot be captured in such systems unless disjunc\u0002tions can be represented. The approach discussed in this pa\u0002per can be viewed as an extension of this type of approach \r\nthat overcomes many of its difficulties. \r\nFinally, there is a wide range of work in formal models of \r\ntime. The work in philosophy is excellently summarized in a \r\ntextbook by Rescher and Urrquhart [16]. Notable formal \r\nmodels in artificial intelligence include the situation calculus \r\n[14], which motivates much of the state space based work in \r\nproblem solving, and the more recent work by McDermott \r\n[15]. In the situation calculus, knowledge is represented as a \r\nseries of situations, each being a description of the world at an \r\ninstantaneous point of time. Actions and events are functions \r\nfrom one situation to another. This theory is viable only in \r\ndomains where only one event can occur at a time. Also, \r\nthere is no concept of an event taking time; the transforma\u0002tion between the situations cannot be reasoned about or de\u0002composed. The situation calculus has the reverse notion of \r\npersistence: a fact that is true at one instance needs to be \r\nexplicitly reproven to be true at succeeding instants. \r\nMost of the work in philosophy, and both the situation \r\ncalculus and the work by McDermott, are essentially point\u0002based theories. Time intervals can be constructed out of \r\npoints, but points are the foundation of the reasoning system. \r\nThis approach will be challenged in the upcoming section. \r\nOne other formal approach, currently under development, \r\nthat is compatible with an interval-based temporal representa\u0002November 1983 Volume 26 Number 11 Communications of the ACM 833 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/2e5aeff6-234a-475c-a720-83428f8af0b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=306e45f2783c6fd4af0d43976a3ce5ceb9a1814cfab505a1eb3e82703cfa264e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1215
      },
      {
        "segments": [
          {
            "segment_id": "2e5aeff6-234a-475c-a720-83428f8af0b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nthe amount of computation involved when adding a fact can \r\nbe controlled in a predictable manner. This representation is \r\ndesigned explicitly to deal with the problem that much of our \r\ntemporal knowledge is relative, and hence cannot be de\u0002scribed by a date (or even a \"fuzzy\" date). \r\nWe start with a survey of current techniques for modeling \r\ntime, and point out various problems that need to be ado \r\ndressed. After a discussion of the relative merits of interval\u0002based systems versus point-based systems in Section 3, a sim\u0002ple interval-based deduction technique based on constraint \r\npropagation is introduced in Section 4. This scheme is then \r\naugmented in Section 5 with reference intervals, and exam\u0002ples in three different domains are presented. In the final \r\nsections of the paper, extensions to the basic system are pro\u0002posed in some detail. These would extend the representation \r\nto include reasoning about the duration of intervals, reasoning \r\nabout dates when they are available, and reasoning about the \r\nfuture given knowledge of what is true at the present. \r\nThe system as described in Section 5 has been imple\u0002mented and is being used in a variety of research projects \r\nwhich are briefly described in Section 6. Of the extensions, \r\nthe duration reasoner is fully implemented and incorporated \r\ninto the system, whereas the date reasoner has been designed \r\nbut not implemented. \r\n2. BACKGROUND \r\nBefore we consider some previous approaches to temporal \r\nrepresentation, let us summarize some important characteris\u0002tics that are relevant to our work: \r\n• The representation should allow significant imprecision. \r\nMuch temporal knowledge is strictly relative (e.g., A is \r\nbefore B) and has little relation to absolute dates. \r\n• The representation should allow uncertainty of informa\u0002tion. Often, the exact relationship between two times is \r\nnot known, but some contraints on how they could be \r\nrelated are known. \r\n• The representation should allow one to vary the grain of \r\nreasoning. For example, when modeling knowledge of \r\nhistory, one may only need to consider time in terms of \r\ndays, or even years. When modeling knowledge of com\u0002puter design, one may need to consider times on the \r\norder of nanoseconds or less. \r\n• The model should support persistence. It should facili\u0002tate default reasoning of the type, \"If I parked my car in \r\nlot A this morning, it should still be there now,\" even \r\nthough proof is not possible (the car may have been \r\ntowed or stolen). \r\nThis does not exhaust all the issues, and others will come \r\nup as they become relevant. It provides us with a starting \r\ncriteria, however, for examining previous approaches. Pre\u0002vious work can be divided roughly into four categories: state \r\nspace approaches, date line systems, before/after chaining, \r\nand formal models. \r\nState space approaches (e.g., [7, 17]) provide a crude sense \r\nof time that is useful in simple problem-solving tasks. A state \r\nis a description of the world (i.e., a database of facts) at an \r\ninstantaneous point in time. Actions are modeled in such \r\nsystems as functions mapping between states. For example, if \r\nan action occurs that causes P to become true and causes fact \r\nQ to be no longer true, its effect is simulated by simply adding \r\nfact P to the current state and deleting fact Q. If the previous \r\nstates are retained, we have a representation of time as a \r\nseries of databases describing the world in successive states. In \r\ngeneral, however, it is too expensive to maintain all the pre\u0002vious states, so most systems only maintain the present state. \r\nWhile this technique is useful in some applications, it does \r\nnot address many of the issues that concern us. Note that \r\nsuch systems do provide a notion of persistence, however. \r\nOnce a fact is asserted, it remains true until it is explicitly \r\ndeleted. \r\nIn datebase systems (e.g., [4, 5, 12, 13]), each fact is indexed \r\nby a date. A date is a representation of a time such that \r\nthe temporal ordering between two dates can be computed by \r\nfairly simple operations. For example, we could use the inte\u0002gers as dates, and then temporal ordering could be computed \r\nusing a simple numeric comparison. Of course, more compli\u0002cated schemes based on calendar dates and times are typi\u0002cally more useful. Because of the nice computational proper\u0002ties, this is the approach of choice if one can assign dates for \r\nevery event. Unfortunately, in the applications we are consid\u0002ering, this is not a valid assumption. Many events simply \r\ncannot be assigned a precise date. There are methods of geno \r\neralizing this scheme to include ranges of dates in which the \r\nevent must occur, but even this scheme cannot capture some \r\nrelative temporal information. For instance, the fact that two \r\nevents, A and B, did not happen at the same time cannot be \r\nrepresented using fuzzy dates for A and B. Either we must \r\ndecide that A was before B, or B was before A, or we must \r\nassign date ranges that allow A and B to overlap. This prob\u0002lem becomes even more severe if we are dealing with time \r\nintervals rather than time points. We then need fuzzy date \r\nranges for both ends of the interval plus a range for the \r\nminimum and maximum duration of the interval. \r\nThe next scheme is to represent temporal information us\u0002ing before/after chains. This approach allows us to capture \r\nrelative temporal information quite directly. This technique \r\nhas been used successfully in many systems (e.g., [4, 13]). As \r\nthe amount of temporal information grows, however, it suffers \r\nfrom either difficult search problems (searching long chains) \r\nor space problems (if all possible relationships are precom\u0002puted). This problem can be alleviated somewhat by using a \r\nnotion of reference intervals [13], which will be discussed in \r\ndetail later. Note that a fact such as \"events A and B are \r\ndisjoint\" cannot be captured in such systems unless disjunc\u0002tions can be represented. The approach discussed in this pa\u0002per can be viewed as an extension of this type of approach \r\nthat overcomes many of its difficulties. \r\nFinally, there is a wide range of work in formal models of \r\ntime. The work in philosophy is excellently summarized in a \r\ntextbook by Rescher and Urrquhart [16]. Notable formal \r\nmodels in artificial intelligence include the situation calculus \r\n[14], which motivates much of the state space based work in \r\nproblem solving, and the more recent work by McDermott \r\n[15]. In the situation calculus, knowledge is represented as a \r\nseries of situations, each being a description of the world at an \r\ninstantaneous point of time. Actions and events are functions \r\nfrom one situation to another. This theory is viable only in \r\ndomains where only one event can occur at a time. Also, \r\nthere is no concept of an event taking time; the transforma\u0002tion between the situations cannot be reasoned about or de\u0002composed. The situation calculus has the reverse notion of \r\npersistence: a fact that is true at one instance needs to be \r\nexplicitly reproven to be true at succeeding instants. \r\nMost of the work in philosophy, and both the situation \r\ncalculus and the work by McDermott, are essentially point\u0002based theories. Time intervals can be constructed out of \r\npoints, but points are the foundation of the reasoning system. \r\nThis approach will be challenged in the upcoming section. \r\nOne other formal approach, currently under development, \r\nthat is compatible with an interval-based temporal representa\u0002November 1983 Volume 26 Number 11 Communications of the ACM 833 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/2e5aeff6-234a-475c-a720-83428f8af0b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=306e45f2783c6fd4af0d43976a3ce5ceb9a1814cfab505a1eb3e82703cfa264e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1215
      },
      {
        "segments": [
          {
            "segment_id": "e616cf0d-9a19-4be2-bb11-14f040cb753e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\ntion is found in the Naive Physics work of Hayes [10, 11]. He \r\nproposes the notion of a history, which is a contiguous block \r\nof space-time upon which reasoning can be organized. By \r\nviewing each temporal interval as one dimension of a history, \r\nthis work can be seen as describing a reasoning mechanism \r\nfor the temporal component of Naive Physics. \r\n3. TIME POINTS VS. TIME INTERVALS \r\nIn English, we can refer to times as points or as intervals. \r\nThus we can say the sentences: \r\nWe found the letter at twelve noon. \r\nWe found the letter yesterday. \r\nIn the first, \"at twelve noon\" appears to refer to a precise point \r\nin time at which the finding event occurred (or was occur\u0002ring). In the second, \"yesterday\" refers to an interval in which \r\nthe finding event occurred. \r\nOf course, these two examples both refer to a date system \r\nwhere we are capable of some temporal precision. In general, \r\nthough, the references to temporal relations in English are \r\nboth implicit and vague. In particular, the majority of tem\u0002poral references are implicitly introduced by tense and by the \r\ndescription of how events are related to other events. Thus \r\nwe have \r\nWe found the letter while John was away. \r\nWe found the letter after we made the decision. \r\nThese sentences introduce temporal relations between the \r\ntimes (intervals) at which the events occurred. In the first \r\nsentence, the temporal connective \"while\" indicates that the \r\ntime when the find event occurred is during the time when \r\nJohn was away. The tense indicates that John being away \r\noccurred in the past (i.e., before now). \r\nAlthough some events appear to be instantaneous (e.g., one \r\nmight argue that the event \"finding the letter\" is instanta\u0002neous), it also appears that such events could be decomposed \r\nif we examine them more closely. For example, the \"finding \r\nthe letter\" might be composed of \"looking at spot X where the \r\nletter was\" and \"realizing that it was the letter you were \r\nlooking at.\" Similarly, we might further decompose the \"real\u0002izing that it was the letter\" into a series of inferences that the \r\nagent made. There seems to be a strong intuition that, given \r\nan event, we can always \"turn up the magnification\" and look \r\nat its structure. This has certainly been the experience so far \r\nin physics. Since the only times we consider will be times of \r\nevents, it appears that we can always decompose times into \r\nsubparts. Thus the formal notion of a time point, which \r\nwould not be decomposable, is not useful. An informal notion \r\nof time points as very small intervals, however, can be useful \r\nand will be discussed later. \r\nThere are examples which provide counterintuitive results \r\nif we allow zero-width time points. For instance, consider the \r\nsituation where a light is turned on. To describe the world \r\nchanging we need to have an interval of time during which \r\nthe light was off, followed by an interval during which it was \r\non. The question arises as to whether these intervals are open \r\nor closed. If they are open, then there exists a time (point) \r\nbetween the two where the light is neither on nor off. Such a \r\nsituation would provide serious semantic difficulties in a tem\u0002poral logic. On the other hand, if intervals are closed, then \r\nthere is a time point at which the light is both on and off. \r\nThis presents even more semantic difficulties than the former \r\ncase. One solution to this would be to adopt a convention that \r\nintervals are closed in their lower end and open on their \r\nupper end. The intervals could then meet as required, but \r\neach interval would have only one endpoint. The artificiality \r\nof this solution merely emphasizes that a model of time based \r\non points on the real line does not correspond to our intuitive \r\nnotion of time. As a consequence, we shall develop a repre\u0002sentation that takes temporal intervals as primitive. \r\nIf we allowed time points, intervals could be represented by \r\nmodeling their endpoints (e.g., [4]) as follows: Assuming a \r\nmodel consisting of a fully ordered set of points of time, an \r\ninterval is an ordered pair of points with the first point less \r\nthan the second. We then can define the relations in Figure 1 \r\nbetween intervals, assuming for any interval t, the lesser end\u0002point is denoted by t- and the greater by t+. \r\nWe could implement intervals with this approach, even \r\ngiven the above argument about time points, as long as we \r\nassume for an interval t that t- < t+, and each assertion \r\nmade is in a form corresponding to one of the interval rela\u0002tions. There are reasons why this is still inconvenient, how\u0002ever. In particular, the representation is too uniform and does \r\nnot facilitate structuring the knowledge in a way which is \r\nconvenient for typical temporal reasoning tasks. To see this, \r\nconsider the importance of the during relation. Temporal \r\nknowledge is often of the form \r\nevent E' occurred during event E. \r\nA key fact used in testing whether some condition P holds \r\nduring an interval t is that if t is during an interval T, and P \r\nholds during T, then P holds during t. Thus during relation\u0002ships can be used to define a hierarchy of intervals in which \r\npropositions can be \"inherited.\" \r\nFurthermore, such a during hierarchy allows reasoning \r\nprocesses to be localized so that irrelevant facts are never \r\nconsidered. For instance, if one is concerned with what is true \r\n\"today,\" one need consider only those intervals that are dur- \r\n•ng \"today,\" or above \"today\" in the during hierarchy. If a fact \r\nis indexed by an interval wholly contained by an interval \r\nrepresenting \"yesterday,\" then it cannot affect what is true \r\nnow. It is not clear how to take advantage of these properties \r\nusing the point-based representation above. \r\n4. MAINTAINING TEMPORAL RELATIONS \r\n4.1. The Basic Algorithm \r\nThe inference technique described in this section is an at\u0002tempt to characterize the inferences about time that appear to \r\nbe made automatically or effortlessly during a dialogue, story \r\ncomprehension, or simple problem-solving. Thus it should \r\nprovide us with enough temporal reasoning to participate in \r\nthese tasks. It does not, however, need to be able to account \r\nfor arbitrarily complex chains of reasoning that could be \r\ndone, say, when solving a puzzle involving time. \r\nWe saw above five relations that can hold between inter\u0002vals. Further subdividing the during relation, however, pro\u0002Interval Relation Equivalent Relations on Endpoints \r\nt<s t+ < s\u0002t=s (t- = s-) & (t+ : s+) \r\ntoverlapss (t- < s-) & (t+ > s-) & (t+ < s+) \r\nt meets s t+ = s\u0002t durings ((t- > s-) & (t+ =(s+)) or \r\n((t- >= s-) & (t+ < s+)) \r\nFIGURE 1. Interval Relation Defined by Endpoints. \r\n834 Communicatimls of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/e616cf0d-9a19-4be2-bb11-14f040cb753e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec801ecffe08f32901182eff787b1e8fb63427601a98952972707704ddc93985",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1128
      },
      {
        "segments": [
          {
            "segment_id": "e616cf0d-9a19-4be2-bb11-14f040cb753e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\ntion is found in the Naive Physics work of Hayes [10, 11]. He \r\nproposes the notion of a history, which is a contiguous block \r\nof space-time upon which reasoning can be organized. By \r\nviewing each temporal interval as one dimension of a history, \r\nthis work can be seen as describing a reasoning mechanism \r\nfor the temporal component of Naive Physics. \r\n3. TIME POINTS VS. TIME INTERVALS \r\nIn English, we can refer to times as points or as intervals. \r\nThus we can say the sentences: \r\nWe found the letter at twelve noon. \r\nWe found the letter yesterday. \r\nIn the first, \"at twelve noon\" appears to refer to a precise point \r\nin time at which the finding event occurred (or was occur\u0002ring). In the second, \"yesterday\" refers to an interval in which \r\nthe finding event occurred. \r\nOf course, these two examples both refer to a date system \r\nwhere we are capable of some temporal precision. In general, \r\nthough, the references to temporal relations in English are \r\nboth implicit and vague. In particular, the majority of tem\u0002poral references are implicitly introduced by tense and by the \r\ndescription of how events are related to other events. Thus \r\nwe have \r\nWe found the letter while John was away. \r\nWe found the letter after we made the decision. \r\nThese sentences introduce temporal relations between the \r\ntimes (intervals) at which the events occurred. In the first \r\nsentence, the temporal connective \"while\" indicates that the \r\ntime when the find event occurred is during the time when \r\nJohn was away. The tense indicates that John being away \r\noccurred in the past (i.e., before now). \r\nAlthough some events appear to be instantaneous (e.g., one \r\nmight argue that the event \"finding the letter\" is instanta\u0002neous), it also appears that such events could be decomposed \r\nif we examine them more closely. For example, the \"finding \r\nthe letter\" might be composed of \"looking at spot X where the \r\nletter was\" and \"realizing that it was the letter you were \r\nlooking at.\" Similarly, we might further decompose the \"real\u0002izing that it was the letter\" into a series of inferences that the \r\nagent made. There seems to be a strong intuition that, given \r\nan event, we can always \"turn up the magnification\" and look \r\nat its structure. This has certainly been the experience so far \r\nin physics. Since the only times we consider will be times of \r\nevents, it appears that we can always decompose times into \r\nsubparts. Thus the formal notion of a time point, which \r\nwould not be decomposable, is not useful. An informal notion \r\nof time points as very small intervals, however, can be useful \r\nand will be discussed later. \r\nThere are examples which provide counterintuitive results \r\nif we allow zero-width time points. For instance, consider the \r\nsituation where a light is turned on. To describe the world \r\nchanging we need to have an interval of time during which \r\nthe light was off, followed by an interval during which it was \r\non. The question arises as to whether these intervals are open \r\nor closed. If they are open, then there exists a time (point) \r\nbetween the two where the light is neither on nor off. Such a \r\nsituation would provide serious semantic difficulties in a tem\u0002poral logic. On the other hand, if intervals are closed, then \r\nthere is a time point at which the light is both on and off. \r\nThis presents even more semantic difficulties than the former \r\ncase. One solution to this would be to adopt a convention that \r\nintervals are closed in their lower end and open on their \r\nupper end. The intervals could then meet as required, but \r\neach interval would have only one endpoint. The artificiality \r\nof this solution merely emphasizes that a model of time based \r\non points on the real line does not correspond to our intuitive \r\nnotion of time. As a consequence, we shall develop a repre\u0002sentation that takes temporal intervals as primitive. \r\nIf we allowed time points, intervals could be represented by \r\nmodeling their endpoints (e.g., [4]) as follows: Assuming a \r\nmodel consisting of a fully ordered set of points of time, an \r\ninterval is an ordered pair of points with the first point less \r\nthan the second. We then can define the relations in Figure 1 \r\nbetween intervals, assuming for any interval t, the lesser end\u0002point is denoted by t- and the greater by t+. \r\nWe could implement intervals with this approach, even \r\ngiven the above argument about time points, as long as we \r\nassume for an interval t that t- < t+, and each assertion \r\nmade is in a form corresponding to one of the interval rela\u0002tions. There are reasons why this is still inconvenient, how\u0002ever. In particular, the representation is too uniform and does \r\nnot facilitate structuring the knowledge in a way which is \r\nconvenient for typical temporal reasoning tasks. To see this, \r\nconsider the importance of the during relation. Temporal \r\nknowledge is often of the form \r\nevent E' occurred during event E. \r\nA key fact used in testing whether some condition P holds \r\nduring an interval t is that if t is during an interval T, and P \r\nholds during T, then P holds during t. Thus during relation\u0002ships can be used to define a hierarchy of intervals in which \r\npropositions can be \"inherited.\" \r\nFurthermore, such a during hierarchy allows reasoning \r\nprocesses to be localized so that irrelevant facts are never \r\nconsidered. For instance, if one is concerned with what is true \r\n\"today,\" one need consider only those intervals that are dur- \r\n•ng \"today,\" or above \"today\" in the during hierarchy. If a fact \r\nis indexed by an interval wholly contained by an interval \r\nrepresenting \"yesterday,\" then it cannot affect what is true \r\nnow. It is not clear how to take advantage of these properties \r\nusing the point-based representation above. \r\n4. MAINTAINING TEMPORAL RELATIONS \r\n4.1. The Basic Algorithm \r\nThe inference technique described in this section is an at\u0002tempt to characterize the inferences about time that appear to \r\nbe made automatically or effortlessly during a dialogue, story \r\ncomprehension, or simple problem-solving. Thus it should \r\nprovide us with enough temporal reasoning to participate in \r\nthese tasks. It does not, however, need to be able to account \r\nfor arbitrarily complex chains of reasoning that could be \r\ndone, say, when solving a puzzle involving time. \r\nWe saw above five relations that can hold between inter\u0002vals. Further subdividing the during relation, however, pro\u0002Interval Relation Equivalent Relations on Endpoints \r\nt<s t+ < s\u0002t=s (t- = s-) & (t+ : s+) \r\ntoverlapss (t- < s-) & (t+ > s-) & (t+ < s+) \r\nt meets s t+ = s\u0002t durings ((t- > s-) & (t+ =(s+)) or \r\n((t- >= s-) & (t+ < s+)) \r\nFIGURE 1. Interval Relation Defined by Endpoints. \r\n834 Communicatimls of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/e616cf0d-9a19-4be2-bb11-14f040cb753e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec801ecffe08f32901182eff787b1e8fb63427601a98952972707704ddc93985",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1128
      },
      {
        "segments": [
          {
            "segment_id": "47ff926f-ead5-43d5-a8af-bbd835c05a47",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nvides a better computational model? Considering the inverses \r\nof these relations, there are a total of thirteen ways in which \r\nan ordered pair of intervals can be related. These are shown \r\nin Figure 2. \r\nSometimes it is convenient to collapse the three during \r\nrelations (d, s, f) into one relationship called dur, and the \r\nthree containment relations (di, si, fi) into one relationship \r\ncalled con. After a quick inspection, it is easy to see that these \r\nthirteen relationships can be used to express any relationship \r\nthat can hold between two intervals. \r\nThe relationships between intervals are maintained in a \r\nnetwork where the nodes represent individual intervals. Each \r\narc is labeled to indicate the possible relationship between the \r\ntwo intervals represented by its nodes. In cases where there is \r\nuncertainty about the relationship, all possible cases are en\u0002tered on the arc. Note that since the thirteen possible relation\u0002ships are mutually exclusive, there is no ambiguity in this \r\nnotation. Figure 3 contains some examples of the notation. \r\nThroughout, let Ni be the node representing interval i. Notice \r\nthat the third set of conditions describes disjoint intervals. \r\nThroughout this paper, both the above notations will be \r\nused for the sake of readability. In general, if the arc asserts \r\nmore than one possible relationship, the network form will be \r\nused, and in the case where only one relationship is possible, \r\nthe relation form will be used. \r\nFor the present, we shall assume that the network always \r\nmaintains complete information about how its intervals could \r\nbe related. When a new interval relation is entered, all conse\u0002quences are computed. This is done by computing the transi\u0002tive closure of the temporal relations as follows: the new fact \r\nadds a constraint about how its two intervals could be related, \r\nwhich may in turn introduce new constraints between other \r\nintervals through the transitivity rules governing the temporal \r\nrelationships. For instance, if the fact that i is during j is \r\nadded, and j is before k, then it is inferred that i must be \r\nbefore k. This new fact is then added to the network in an \r\nidentical fashion, possibly introducing further constraints on \r\nthe relationship between other intervals. The transitivity rela\u0002tions are summarized in Figure 4. \r\nThe precise algorithm is as follows: assume for any tem\u0002peral relation names rl and r2 that T(rl, r2) is the entry in \r\nthe transitivity table in Figure 4. Let R1 and R2 be arc labels, \r\nassume the usual set operations (N for intersection, U for \r\nunion, C for proper subset), and let e be the empty set. Then \r\nconstraints (R 1, R2) is the transitivity function for lists of rela\u0002tion names (i.e., arc labels), and is defined by: \r\nConstraints (R1, R2 ) \r\nC~--e; \r\nFor each rl in R1 \r\nFor each r2 in R2 \r\nC ~ C U T(rl, r2); \r\nReturn C; \r\nAssume we have a queue data structure named ToDo with \r\nthe appropriate queue operations defined. For any two inter\u0002vals i, j, let N(i, j) be the relations on the arc between i and j \r\nin the network, and let R(i, j) be the new relation between i \r\nand j to be added to the network. Then we have the follow\u0002ing algorithm for updating the temporal network: \r\nTo Add R(i, I') \r\nAdd (i, j) to queue ToDo; \r\nWhile ToDo is not empty do \r\n1 This fact was pointed out to me by Marc Vilain and was first utilized in his \r\nsystem [18]. \r\nRelation Symbol Symbol for \r\nInverse \r\nX before Y < > \r\nX equal Y = = \r\nX meets Y m mi \r\nX overlaps Y o oi \r\nX during Y d di \r\nX starts Y s si \r\nX finishes Y f fi \r\nPictoral \r\nExample \r\nXXX YYY \r\nXXX \r\nYYY \r\nXXXYYY \r\nXXX \r\nYYY \r\nXXX \r\nYYYYYY \r\nXXX \r\nYYYYY \r\nXXX \r\nYYYYY \r\nFIGURE 2. The Thirteen Possible Relationships. \r\nRelation Network Representation \r\n1. i duringj N i --(d)~ Nj \r\n2. i during j or N i --(< d di)--, Nj \r\ni before j or \r\nj during i \r\n3. (i<j) or(i>j)or N i --(< > m mi)--, Nj \r\ni meets j or \r\nj meets 1 \r\nFIGURE 3. Representing Knowledge of Temporal Relations \r\nin a Network. \r\nbegin \r\nGet next (i, j) from queue ToDo; \r\nN(i, i) ~ R(i, 1); \r\nFor each node k such that Comparable(k, j) do \r\nbegin \r\nR(k, j) ~-- N(k, l] N Constraints(N(k, i), R(i, j)) \r\nIf R(k, i) C N(k, i) \r\nthen add (k, i) to ToDo; \r\nend \r\nFor each node k such that Comparable(i, k) do \r\nbegin \r\nR(i, k) ~-- N(i, k) N Constraints(R(/, j), N( j, k)) \r\nIf R(i, k) C N(k, i) \r\nthen add (i, k) to ToDo; \r\nend \r\nend; \r\nWe have used the predicate Comparable(i, j) above, which \r\nwill be defined in Section 5. For the present, we can assume \r\nit always returns true for any pair of nodes. \r\n4.2. An Example \r\nConsider a simple example of this algorithm in operation. \r\nAssume we are given the facts: \r\nS overlaps or meets L \r\nS is before, meets, is met by, or after R. \r\nNovember 1983 Volume 26 Number 11 Communications of the ACM 835 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/47ff926f-ead5-43d5-a8af-bbd835c05a47.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=983ffbaafff53eacdbbd887fad06d9d4561cb287bab38ddd85028641e5d75d4d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 842
      },
      {
        "segments": [
          {
            "segment_id": "47ff926f-ead5-43d5-a8af-bbd835c05a47",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nvides a better computational model? Considering the inverses \r\nof these relations, there are a total of thirteen ways in which \r\nan ordered pair of intervals can be related. These are shown \r\nin Figure 2. \r\nSometimes it is convenient to collapse the three during \r\nrelations (d, s, f) into one relationship called dur, and the \r\nthree containment relations (di, si, fi) into one relationship \r\ncalled con. After a quick inspection, it is easy to see that these \r\nthirteen relationships can be used to express any relationship \r\nthat can hold between two intervals. \r\nThe relationships between intervals are maintained in a \r\nnetwork where the nodes represent individual intervals. Each \r\narc is labeled to indicate the possible relationship between the \r\ntwo intervals represented by its nodes. In cases where there is \r\nuncertainty about the relationship, all possible cases are en\u0002tered on the arc. Note that since the thirteen possible relation\u0002ships are mutually exclusive, there is no ambiguity in this \r\nnotation. Figure 3 contains some examples of the notation. \r\nThroughout, let Ni be the node representing interval i. Notice \r\nthat the third set of conditions describes disjoint intervals. \r\nThroughout this paper, both the above notations will be \r\nused for the sake of readability. In general, if the arc asserts \r\nmore than one possible relationship, the network form will be \r\nused, and in the case where only one relationship is possible, \r\nthe relation form will be used. \r\nFor the present, we shall assume that the network always \r\nmaintains complete information about how its intervals could \r\nbe related. When a new interval relation is entered, all conse\u0002quences are computed. This is done by computing the transi\u0002tive closure of the temporal relations as follows: the new fact \r\nadds a constraint about how its two intervals could be related, \r\nwhich may in turn introduce new constraints between other \r\nintervals through the transitivity rules governing the temporal \r\nrelationships. For instance, if the fact that i is during j is \r\nadded, and j is before k, then it is inferred that i must be \r\nbefore k. This new fact is then added to the network in an \r\nidentical fashion, possibly introducing further constraints on \r\nthe relationship between other intervals. The transitivity rela\u0002tions are summarized in Figure 4. \r\nThe precise algorithm is as follows: assume for any tem\u0002peral relation names rl and r2 that T(rl, r2) is the entry in \r\nthe transitivity table in Figure 4. Let R1 and R2 be arc labels, \r\nassume the usual set operations (N for intersection, U for \r\nunion, C for proper subset), and let e be the empty set. Then \r\nconstraints (R 1, R2) is the transitivity function for lists of rela\u0002tion names (i.e., arc labels), and is defined by: \r\nConstraints (R1, R2 ) \r\nC~--e; \r\nFor each rl in R1 \r\nFor each r2 in R2 \r\nC ~ C U T(rl, r2); \r\nReturn C; \r\nAssume we have a queue data structure named ToDo with \r\nthe appropriate queue operations defined. For any two inter\u0002vals i, j, let N(i, j) be the relations on the arc between i and j \r\nin the network, and let R(i, j) be the new relation between i \r\nand j to be added to the network. Then we have the follow\u0002ing algorithm for updating the temporal network: \r\nTo Add R(i, I') \r\nAdd (i, j) to queue ToDo; \r\nWhile ToDo is not empty do \r\n1 This fact was pointed out to me by Marc Vilain and was first utilized in his \r\nsystem [18]. \r\nRelation Symbol Symbol for \r\nInverse \r\nX before Y < > \r\nX equal Y = = \r\nX meets Y m mi \r\nX overlaps Y o oi \r\nX during Y d di \r\nX starts Y s si \r\nX finishes Y f fi \r\nPictoral \r\nExample \r\nXXX YYY \r\nXXX \r\nYYY \r\nXXXYYY \r\nXXX \r\nYYY \r\nXXX \r\nYYYYYY \r\nXXX \r\nYYYYY \r\nXXX \r\nYYYYY \r\nFIGURE 2. The Thirteen Possible Relationships. \r\nRelation Network Representation \r\n1. i duringj N i --(d)~ Nj \r\n2. i during j or N i --(< d di)--, Nj \r\ni before j or \r\nj during i \r\n3. (i<j) or(i>j)or N i --(< > m mi)--, Nj \r\ni meets j or \r\nj meets 1 \r\nFIGURE 3. Representing Knowledge of Temporal Relations \r\nin a Network. \r\nbegin \r\nGet next (i, j) from queue ToDo; \r\nN(i, i) ~ R(i, 1); \r\nFor each node k such that Comparable(k, j) do \r\nbegin \r\nR(k, j) ~-- N(k, l] N Constraints(N(k, i), R(i, j)) \r\nIf R(k, i) C N(k, i) \r\nthen add (k, i) to ToDo; \r\nend \r\nFor each node k such that Comparable(i, k) do \r\nbegin \r\nR(i, k) ~-- N(i, k) N Constraints(R(/, j), N( j, k)) \r\nIf R(i, k) C N(k, i) \r\nthen add (i, k) to ToDo; \r\nend \r\nend; \r\nWe have used the predicate Comparable(i, j) above, which \r\nwill be defined in Section 5. For the present, we can assume \r\nit always returns true for any pair of nodes. \r\n4.2. An Example \r\nConsider a simple example of this algorithm in operation. \r\nAssume we are given the facts: \r\nS overlaps or meets L \r\nS is before, meets, is met by, or after R. \r\nNovember 1983 Volume 26 Number 11 Communications of the ACM 835 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/47ff926f-ead5-43d5-a8af-bbd835c05a47.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=983ffbaafff53eacdbbd887fad06d9d4561cb287bab38ddd85028641e5d75d4d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 842
      },
      {
        "segments": [
          {
            "segment_id": "cdcd391b-9a66-4d95-b698-c0df853e342b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH COJffRIBUllONS \r\nB r2 C < > d di o oi m mi s si f fi \r\nArl B \r\n\"before\" \r\n< \r\n< \r\n\"after\" no \r\n> info \r\n\"during\" \r\nd \r\nno <o < < <o < <o < \r\ninfo m d m d m d \r\nS S S \r\n> > oi \r\nmi d \r\nf \r\n< > d \r\n\"contains\" < o > oi o oi \r\ndi m di di mi dur \r\nfi si con \r\n< \"overlaps\" \r\n0 \r\n\"over- < o \r\nlapped-by\" m di \r\noi fi \r\n< \"meets\" \r\nm \r\n\"met-by\" < o \r\nmi m di \r\nfi \r\n< \"starts\" \r\nS \r\n\"started by\" < o \r\nsi m di \r\nfi \r\n< \"finishes\" \r\nf \r\n\"finished - by\" \r\nfi \r\n< \r\n> > oi > > oi > > oi > \r\nmid mi d mid \r\nf f f \r\nno < o > oi < > d > oi \r\ninfo m d mi d mid \r\ns f f \r\ndi o di oi di o di oi di di fi di \r\nfi si fi si o \r\n> oi o < o < o oi < oi \r\ndi mi d m di o dur di \r\nsi s fi m con si \r\ndi \r\nfi \r\n0 \r\n> oi > oi o oi > o > oi oi \r\nd mi di dur oi di d > \r\nf si con mi fi f mi \r\nI = \r\n> oi o < < o < f \r\nmi di d d fi \r\nsi s s = \r\nm \r\n> oi > oi > s > d \r\nd d si f \r\nf f = oi \r\n< \r\n> d < o < o oi < mi s \r\nmdi m df \r\nfi \r\n> oi di o oi o mi s si \r\nd f di fi di fi = \r\n> d > oi o > oi m > d \r\nmi di d mi \r\nsi s \r\n> oi o di o oi m si oi \r\nmi di d di si di \r\nsi s \r\nm \r\n> \r\ns si \r\nsi \r\n> oi \r\nmi \r\ndi \r\n<0 \r\nmd \r\nS \r\n> \r\nd \r\ndi si \r\noi \r\nd \r\nS \r\n0 \r\noi \r\nmi \r\noi \r\nf fi \r\n< \r\n> \r\n<0 \r\nmd \r\nS \r\ndi \r\n< \r\n0 \r\nm \r\noi \r\ndi \r\nsi \r\n< \r\nmi \r\n<m \r\n0 \r\ndi \r\nf fi \r\nFIGURE 4. The Transitivity Table for the Twelve Temporal Relations (omittin 9 \"=\"). \r\n836 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/cdcd391b-9a66-4d95-b698-c0df853e342b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=34c0306c24fec9ac4f7c773c44c2cb3e2c9ce4a60980c5ddd89b809113bb7eef",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 385
      },
      {
        "segments": [
          {
            "segment_id": "021f13a6-a309-45f4-a0e1-2eee41b5ba3e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONnUBUnONS \r\nThese facts might be derived from a story such as the follow\u0002ing: \r\nJohn was not in the room when I touched the switch to \r\nturn on the light. \r\nwhere we let S be the time of touching the switch, L be the \r\ntime the light was on, and R be the time that John was in the \r\nroom. The network storing this information is \r\nR ~---(< mmi >)-- S - -(om)----~ L. \r\nWhen the second fact is added, the algorithm computes a \r\nconstraint between L and R (via S) by calling the function \r\nConstraints with its two arguments, R1 and R2, set to {oimi} \r\nand {(mmi)I, respectively. Note that we obtained the inverse \r\nof the arc from S to L simply by taking the inverse of each \r\nlabel. Constraints uses the transitivity table for each pair of \r\nlabels and returns the union of all the answers. Since \r\nT(oi, <) = (< omdifi) \r\nT(oi, m) = (odifi) \r\nT(oi, mi) = (>) \r\nr(oi, >) = (>) \r\nT(mi, <) = (< omdifi) \r\nT(mi, m) = (ssi =) \r\nT(mi, mi) = (>) \r\nT(mi, >) = (>) \r\nwe compute (< > omdi s sift =) as the constraint between L \r\nand R and thus obtain the network \r\nR ~--(< mmi >)- - S - -(om)--~ L \r\n1' I \r\n- - -(< > ooimdi s sift =) ..... \r\nLet us consider what happens now when we add the fact \r\nL overlaps, starts, or is during R \r\nThis fact might arise from a continuation of the above story \r\nsuch as \r\nBut John was in the room later while the light went out \r\nTaking the intersection of this constraint with the previously \r\nknown constraint between L and R to eliminate any impossi\u0002ble relationships gives \r\nL - -(os)---~ R \r\nTo add this constraint, we need to propagate its effects \r\nthrough the network. A new constraint between S and R can \r\nbe calculated using the path: \r\nS - -(om)--~ L - -(os)--~ R \r\nFrom the transitivity tables, we find: \r\nT(o,o) =(<om) \r\nT(o, s) = (o) \r\nT(m, o) = (<) \r\nT(m, s) = (m) \r\nThus the inferred constraint between S and R is \r\nS - -(< om)--~ R. \r\nIntersecting this with our previous constraint between S and \r\nR yields \r\nS - -(< m)---~ R. \r\nWith respect to the example story, this is equivalent to infer\u0002ring that John entered the room (i.e., R started) either after I \r\ntouched the switch or at the same time that I finished touch\u0002ing the switch. Thus the new network is: \r\nR <--(< m)-- S --(om)--~ L \r\n't I \r\n.......... (o s) ........ \r\nOf couse, if there were other nodes in the network, there \r\nwould be other constraints derived from this new informa\u0002tion. Thus, if we added a new interval D, say with the con\u0002straint D - -(d)--~ S, we would infer the following new rela\u0002tionships as well: \r\nD - -(<)--~ R \r\nD - -(< o m d s)---~ L. \r\n4.3. Analysis \r\nA nice property of this algorithm is that it only continues to \r\noperate as long as it is producing new further constrained \r\nrelationships between intervals. Since there are at most thir\u0002teen possible relationships that could hold between two inter\u0002vals, there are at most thirteen steps that could modify this \r\nrelationship. Thus for a fixed number of nodes N, the upper \r\nlimit on the number of modifications that can be made, irre\u0002spective of how many constraints are added to the network, is \r\n13 × the number of binary relations between N nodes, which \r\nis: \r\n(N- 1)(N- 2) 13x \r\n2 \r\nThus, in practice, if we add approximately the same number \r\nof constraints as we have nodes, the average amount of work \r\nfor each addition is essentially linear (i.e., N additions take \r\nO(N 2) time; one addition on average takes O(N) time). \r\nThe major problem with this algorithm is the space re\u0002quirement. It requires O(N 2) space for N temporal intervals. \r\nMethods for controlling the propagation, saving time and \r\nspace, will be discussed in the next section. \r\nIt should be noted that this algorithm, while it does not \r\ngenerate inconsistencies, does not detect all inconsistencies in \r\nits input. In fact, it only guarantees consistency between three \r\nnode subnetworks. There are networks that can be added \r\nwhich appear consistent by viewing any three nodes, but for \r\nwhich there is no consistent overall labeling. The network \r\nshown in Figure 5 is consistent if we consider any three \r\nnodes; however, there is no overall labeling of the network. 2 \r\nTo see this, if we assign the relationship between A and C, \r\nwhich could be f or fi according to this network, to either f \r\nalone, or fi alone, we would arrive at an inconsistency. In \r\nother words, there is no consistent labeling with A - -( f)--~ C, \r\nor with A - -( fi)--~ C, even though the algorithm accepts A \r\n- -( f fi)~ C. \r\nTo ensure total consistency, one would have to consider \r\nconstraints between three arcs, between four arcs, etc. While \r\nthis can be done using techniques outlined in Freuder [9], the \r\ncomputational complexity of the algorithm is exponential. In \r\npractice, we have not encountered problems from this defi\u0002ciency in our applications of the model. We can verify the \r\nconsistency of any subnetwork, if desired, by a simple back\u0002tracking search through the alternative arc labelings until we \r\n2 This network is due to Henry Kautz, personal communication. \r\nNovember1983 Volume26 Number 11 Communications of the ACM 837 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/021f13a6-a309-45f4-a0e1-2eee41b5ba3e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=18b6dfaf1e2d2696cddb9cc692cfaafc338771b9ac9383929dd1de2e9784ee2e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 900
      },
      {
        "segments": [
          {
            "segment_id": "021f13a6-a309-45f4-a0e1-2eee41b5ba3e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONnUBUnONS \r\nThese facts might be derived from a story such as the follow\u0002ing: \r\nJohn was not in the room when I touched the switch to \r\nturn on the light. \r\nwhere we let S be the time of touching the switch, L be the \r\ntime the light was on, and R be the time that John was in the \r\nroom. The network storing this information is \r\nR ~---(< mmi >)-- S - -(om)----~ L. \r\nWhen the second fact is added, the algorithm computes a \r\nconstraint between L and R (via S) by calling the function \r\nConstraints with its two arguments, R1 and R2, set to {oimi} \r\nand {(mmi)I, respectively. Note that we obtained the inverse \r\nof the arc from S to L simply by taking the inverse of each \r\nlabel. Constraints uses the transitivity table for each pair of \r\nlabels and returns the union of all the answers. Since \r\nT(oi, <) = (< omdifi) \r\nT(oi, m) = (odifi) \r\nT(oi, mi) = (>) \r\nr(oi, >) = (>) \r\nT(mi, <) = (< omdifi) \r\nT(mi, m) = (ssi =) \r\nT(mi, mi) = (>) \r\nT(mi, >) = (>) \r\nwe compute (< > omdi s sift =) as the constraint between L \r\nand R and thus obtain the network \r\nR ~--(< mmi >)- - S - -(om)--~ L \r\n1' I \r\n- - -(< > ooimdi s sift =) ..... \r\nLet us consider what happens now when we add the fact \r\nL overlaps, starts, or is during R \r\nThis fact might arise from a continuation of the above story \r\nsuch as \r\nBut John was in the room later while the light went out \r\nTaking the intersection of this constraint with the previously \r\nknown constraint between L and R to eliminate any impossi\u0002ble relationships gives \r\nL - -(os)---~ R \r\nTo add this constraint, we need to propagate its effects \r\nthrough the network. A new constraint between S and R can \r\nbe calculated using the path: \r\nS - -(om)--~ L - -(os)--~ R \r\nFrom the transitivity tables, we find: \r\nT(o,o) =(<om) \r\nT(o, s) = (o) \r\nT(m, o) = (<) \r\nT(m, s) = (m) \r\nThus the inferred constraint between S and R is \r\nS - -(< om)--~ R. \r\nIntersecting this with our previous constraint between S and \r\nR yields \r\nS - -(< m)---~ R. \r\nWith respect to the example story, this is equivalent to infer\u0002ring that John entered the room (i.e., R started) either after I \r\ntouched the switch or at the same time that I finished touch\u0002ing the switch. Thus the new network is: \r\nR <--(< m)-- S --(om)--~ L \r\n't I \r\n.......... (o s) ........ \r\nOf couse, if there were other nodes in the network, there \r\nwould be other constraints derived from this new informa\u0002tion. Thus, if we added a new interval D, say with the con\u0002straint D - -(d)--~ S, we would infer the following new rela\u0002tionships as well: \r\nD - -(<)--~ R \r\nD - -(< o m d s)---~ L. \r\n4.3. Analysis \r\nA nice property of this algorithm is that it only continues to \r\noperate as long as it is producing new further constrained \r\nrelationships between intervals. Since there are at most thir\u0002teen possible relationships that could hold between two inter\u0002vals, there are at most thirteen steps that could modify this \r\nrelationship. Thus for a fixed number of nodes N, the upper \r\nlimit on the number of modifications that can be made, irre\u0002spective of how many constraints are added to the network, is \r\n13 × the number of binary relations between N nodes, which \r\nis: \r\n(N- 1)(N- 2) 13x \r\n2 \r\nThus, in practice, if we add approximately the same number \r\nof constraints as we have nodes, the average amount of work \r\nfor each addition is essentially linear (i.e., N additions take \r\nO(N 2) time; one addition on average takes O(N) time). \r\nThe major problem with this algorithm is the space re\u0002quirement. It requires O(N 2) space for N temporal intervals. \r\nMethods for controlling the propagation, saving time and \r\nspace, will be discussed in the next section. \r\nIt should be noted that this algorithm, while it does not \r\ngenerate inconsistencies, does not detect all inconsistencies in \r\nits input. In fact, it only guarantees consistency between three \r\nnode subnetworks. There are networks that can be added \r\nwhich appear consistent by viewing any three nodes, but for \r\nwhich there is no consistent overall labeling. The network \r\nshown in Figure 5 is consistent if we consider any three \r\nnodes; however, there is no overall labeling of the network. 2 \r\nTo see this, if we assign the relationship between A and C, \r\nwhich could be f or fi according to this network, to either f \r\nalone, or fi alone, we would arrive at an inconsistency. In \r\nother words, there is no consistent labeling with A - -( f)--~ C, \r\nor with A - -( fi)--~ C, even though the algorithm accepts A \r\n- -( f fi)~ C. \r\nTo ensure total consistency, one would have to consider \r\nconstraints between three arcs, between four arcs, etc. While \r\nthis can be done using techniques outlined in Freuder [9], the \r\ncomputational complexity of the algorithm is exponential. In \r\npractice, we have not encountered problems from this defi\u0002ciency in our applications of the model. We can verify the \r\nconsistency of any subnetwork, if desired, by a simple back\u0002tracking search through the alternative arc labelings until we \r\n2 This network is due to Henry Kautz, personal communication. \r\nNovember1983 Volume26 Number 11 Communications of the ACM 837 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/021f13a6-a309-45f4-a0e1-2eee41b5ba3e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=18b6dfaf1e2d2696cddb9cc692cfaafc338771b9ac9383929dd1de2e9784ee2e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 900
      },
      {
        "segments": [
          {
            "segment_id": "599aa441-41b7-4fc2-a02a-494c42be56d3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\ns \r\nD \r\nffi \r\n....~ C .~,,v \r\nm \r\nFIGURE 5. An Inconsistent Labeling. \r\narrive at a labeling for the whole subnetwork in which every \r\narc has only one label. \r\n5. CONTROI.I.ING PROPAGATION: REFERENCE \r\nINTERVALS \r\nIn order to reduce the space requirements of the representa\u0002tion without greatly affecting the inferential power of the \r\nmechanism, we introduce reference intervals. Formally, a ref\u0002erence interval is simply another interval in the system, but it \r\nis endowed with a special property that affects the computa\u0002tion. Reference intervals are used to group together clusters of \r\nintervals for which the temporal constraints between each \r\npair of intervals in the cluster is fully computed. Such a \r\ncluster is related to the rest of the intervals in the system only \r\nindirectly via the reference interval. \r\n5.1. Using Reference Intervals \r\nEvery interval may designate one or more reference intervals \r\n(i.e., node clusters to which it belongs). These will be listed in \r\nparentheses after the interval name. Thus the node names \r\nII(R1) \r\nI2(R1, R2) \r\ndescribe an interval named I1 that has a reference interval \r\nR1, and an interval named I2 that has two reference intervals \r\nR1 and R2. Since I2 has two reference intervals, it will be \r\nfully connected to two clusters. An illustration of the connect\u0002edness of such a network is formed in Figure 6. \r\nThe algorithm to add relations using reference intervals is \r\nidentical to the previous addition algorithm except that the \r\ncomparability condition is no longer universally true. For any \r\nnode N, let Refs(N) return the set of reference intervals for N. \r\nFor any two nodes K and J, Comparable(K, J) is true if \r\n1) Refs(K) A Refs(J) is not null, that is, they share a reference \r\ninterval; or \r\n2) K c Refs(J); or \r\n3) J c Refs(K). \r\nSince reference intervals are simply intervals themselves, \r\nthey may in turn have their own reference intervals, possibly \r\ndefining a hierarchy of clusters. In most of the useful applica\u0002tions that we have seen, these hierarchies are typically tree\u0002like, as depicted in Figure 7. \r\nIf two intervals are not explicitly related in the network, a \r\nrelationship can be retrieved by finding a path between them \r\nthrough the reference intervals by searching up the reference \r\nhierarchy until a path (or all paths) between the two nodes \r\nare found. Then, by simply applying the transitivity relation\u0002ships along the path, a relationship between the two nodes \r\ncan be inferred. If one is careful about structuring the refer\u0002ence hierarchy, this can be done with little loss of information \r\nfrom the original complete propagation scheme. \r\nTo find a relationship between two nodes I and ], where \r\nN(i, j) represents the network relation between nodes i and j \r\nas in Section 4.1, we use the algorithm: \r\nIf N(I, J) exists \r\nthen return N(I, J) \r\nelse do \r\nPaths := Find-Paths(I, J) \r\nFor each path in Paths do \r\nR := R CI Constrain-along-path(path) \r\nreturn R; \r\nend; \r\nThe function Find-Paths does a straightforward graph \r\nsearch for a path between the two nodes with the restriction \r\nthat each step of the path must be between a node and one of \r\nits reference intervals except for the one case where a direct \r\nconnection is found. Thus, a path is of the general form \r\nnl, n2, . . . , nk, nk+l, • • • , nm \r\nwhere all of the following hold: \r\n- - for all i from I to k - 1, ni+l is a reference interval for ni; \r\n-- nk and nk+l are connected explicitly; \r\n- - for all i from k + 1 to m - 1, ni is a reference interval for \r\nn~+l; \r\n! 1 (RI) 17(R2) \r\n/ I \\ /1\\ 4 :R14,,. /I21R 'R21 6(R2) \r\nI3(R1) I5(R2) \r\nFIGURE 6. The Connectness of a Network with \r\nTwo Reference Intervals. \r\nR2(R1) \r\nR3(R2) ~ R4(R2) /\\ \r\n1 1(R3) 12(R3) 14(R4)-I 5(R4) \r\nR1 \r\nR5(R1) \r\n/\\ \r\nZ , \r\nFIGURE 7. A Tree-Like Hierarchy Based on Reference Intervals. \r\n838 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/599aa441-41b7-4fc2-a02a-494c42be56d3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9a5a23a16a79752778d306483f5a136a85e71601c06a8faac061e07374e43576",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 656
      },
      {
        "segments": [
          {
            "segment_id": "599aa441-41b7-4fc2-a02a-494c42be56d3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\ns \r\nD \r\nffi \r\n....~ C .~,,v \r\nm \r\nFIGURE 5. An Inconsistent Labeling. \r\narrive at a labeling for the whole subnetwork in which every \r\narc has only one label. \r\n5. CONTROI.I.ING PROPAGATION: REFERENCE \r\nINTERVALS \r\nIn order to reduce the space requirements of the representa\u0002tion without greatly affecting the inferential power of the \r\nmechanism, we introduce reference intervals. Formally, a ref\u0002erence interval is simply another interval in the system, but it \r\nis endowed with a special property that affects the computa\u0002tion. Reference intervals are used to group together clusters of \r\nintervals for which the temporal constraints between each \r\npair of intervals in the cluster is fully computed. Such a \r\ncluster is related to the rest of the intervals in the system only \r\nindirectly via the reference interval. \r\n5.1. Using Reference Intervals \r\nEvery interval may designate one or more reference intervals \r\n(i.e., node clusters to which it belongs). These will be listed in \r\nparentheses after the interval name. Thus the node names \r\nII(R1) \r\nI2(R1, R2) \r\ndescribe an interval named I1 that has a reference interval \r\nR1, and an interval named I2 that has two reference intervals \r\nR1 and R2. Since I2 has two reference intervals, it will be \r\nfully connected to two clusters. An illustration of the connect\u0002edness of such a network is formed in Figure 6. \r\nThe algorithm to add relations using reference intervals is \r\nidentical to the previous addition algorithm except that the \r\ncomparability condition is no longer universally true. For any \r\nnode N, let Refs(N) return the set of reference intervals for N. \r\nFor any two nodes K and J, Comparable(K, J) is true if \r\n1) Refs(K) A Refs(J) is not null, that is, they share a reference \r\ninterval; or \r\n2) K c Refs(J); or \r\n3) J c Refs(K). \r\nSince reference intervals are simply intervals themselves, \r\nthey may in turn have their own reference intervals, possibly \r\ndefining a hierarchy of clusters. In most of the useful applica\u0002tions that we have seen, these hierarchies are typically tree\u0002like, as depicted in Figure 7. \r\nIf two intervals are not explicitly related in the network, a \r\nrelationship can be retrieved by finding a path between them \r\nthrough the reference intervals by searching up the reference \r\nhierarchy until a path (or all paths) between the two nodes \r\nare found. Then, by simply applying the transitivity relation\u0002ships along the path, a relationship between the two nodes \r\ncan be inferred. If one is careful about structuring the refer\u0002ence hierarchy, this can be done with little loss of information \r\nfrom the original complete propagation scheme. \r\nTo find a relationship between two nodes I and ], where \r\nN(i, j) represents the network relation between nodes i and j \r\nas in Section 4.1, we use the algorithm: \r\nIf N(I, J) exists \r\nthen return N(I, J) \r\nelse do \r\nPaths := Find-Paths(I, J) \r\nFor each path in Paths do \r\nR := R CI Constrain-along-path(path) \r\nreturn R; \r\nend; \r\nThe function Find-Paths does a straightforward graph \r\nsearch for a path between the two nodes with the restriction \r\nthat each step of the path must be between a node and one of \r\nits reference intervals except for the one case where a direct \r\nconnection is found. Thus, a path is of the general form \r\nnl, n2, . . . , nk, nk+l, • • • , nm \r\nwhere all of the following hold: \r\n- - for all i from I to k - 1, ni+l is a reference interval for ni; \r\n-- nk and nk+l are connected explicitly; \r\n- - for all i from k + 1 to m - 1, ni is a reference interval for \r\nn~+l; \r\n! 1 (RI) 17(R2) \r\n/ I \\ /1\\ 4 :R14,,. /I21R 'R21 6(R2) \r\nI3(R1) I5(R2) \r\nFIGURE 6. The Connectness of a Network with \r\nTwo Reference Intervals. \r\nR2(R1) \r\nR3(R2) ~ R4(R2) /\\ \r\n1 1(R3) 12(R3) 14(R4)-I 5(R4) \r\nR1 \r\nR5(R1) \r\n/\\ \r\nZ , \r\nFIGURE 7. A Tree-Like Hierarchy Based on Reference Intervals. \r\n838 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/599aa441-41b7-4fc2-a02a-494c42be56d3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9a5a23a16a79752778d306483f5a136a85e71601c06a8faac061e07374e43576",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 656
      },
      {
        "segments": [
          {
            "segment_id": "2e033eeb-ad09-4a9e-85d1-2a83f8dc258d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nLIFE \r\n< d \r\nPRESCHOOL(LIFE) ~ PREGRAD(LIFE) ~POSTGRAD(LIFE) \r\nd POSTGRAOI \r\nPRIM(PREGRAD) ~ SECOND(PREGRAD) ~ UNIV(PREGRAD) \r\nCHESS(PRIM) WlN(UNIV) \r\nFIGURE 8. A Typical Reference Hierarchy \r\nfor a History of a Person. \r\nThe function Constrain-along-path simply takes a path and \r\ncomputes the transitivity constraints along it. Thus if a path \r\nconsisted of the nodes nl, n2, n3 ..... nm, we compute the \r\nrelation between nl and nm as follows: \r\nR := N(nl, n2) \r\nR := Constraints(R, N(nz, n3)) \r\nR := Constraints(R, N(n3, n4)) \r\nR := Constraints(R, N(nm-~, nm)) \r\nwhere Constraints was defined in Section 4.1. \r\n5.2. Examples \r\nThere are no restrictions imposed by the system on the use of \r\nreference intervals. Their organization is left up to the system \r\ndesigner. Certain principles of organization, however, are par\u0002ticularly useful in designing systems that remain efficient in \r\nretrieval, and yet capture the required knowledge. The most \r\nobvious of these is a consequence of the path search algo\u0002rithm in the previous section: the more tree-like the reference \r\nhierarchy, the more efficient the retrieval process. The others \r\nconsidered in this section exploit characteristics of the tem\u0002poral knowledge being stored. \r\nWith domains that capture historical information, it is best \r\nto choose the reference intervals to correspond to key events \r\nthat naturally divide the facts in the domain. Thus, if model\u0002ing facts about the history of a particular person, key events \r\nmight be their birth, their first going to school, their gradua\u0002tion from university, etc. Kahn and Gorry [13] introduced \r\nsuch a notion of reference events in their system. Other times \r\nin their system were explicitly related to these reference \r\nevents (i.e., points). In our system, the intervals between such \r\nkey events would become the reference intervals. Other time \r\nintervals would be stored in the cluster(s) identified by the \r\nreference intervals that contain them. Thus, we could have a \r\nseries of reference intervals for the time from birth to starting \r\nschool (PRESCHOOL), during school (PREGRAD), and after \r\ngraduation (POSTGRAD). In addition, certain reference inter\u0002vals could be further decomposed. For example, PREGRAD \r\ncould be divided into primary and secondary school (PRIM \r\nand SECOND) and the time at university (UNIV). The times \r\nof the rest of the events would be stored with respect to this \r\nreference hierarchy. Figure 8 depicts this set of facts including \r\nits reference hierarchy, plus intervals such as the time spent \r\nlearning chess (CHESS), the time the person won the state \r\nlottery (WIN), and the time of the first job (JOB). If an event \r\nextended over two reference intervals, then it would be \r\nstored with respect to both. For example, if learning to play \r\nchess occurred during primary and secondary school, the in\u0002terval CHESS would have two reference intervals, namely, \r\nPRIM and SECOND. \r\nWe can now trace the retrieval algorithm for this set of \r\nfacts. Let us find the relationship between CHESS and WIN. \r\nThere is no explicit relationship between the intervals, so we \r\nmust search up the reference hierarchy. Only one path is \r\nfound, namely: \r\nCHESS(PRIM)- -(d)---~ PRIM(PREGRAD) - -(<)-. \r\nUNIV(PREGRAD) - -(di)--~ WIN(UNIV) \r\nApplying the transitivity relations along the first path, we \r\ninfer first that \r\nCHESS before UNIV \r\nand then \r\nCHESS before WIN. \r\nThe fact that CHESS is before JOB can be inferred similarly \r\nfrom the path \r\nCHESS- -(d)--> PRIM - -(s)--, PREGRAD - -(m)--~ \r\nPOSTGRAD - -(di)--> JOB. \r\nConsider another domain, namely, that of representing in\u0002formation about processes or actions. Such knowledge is re\u0002quired for problem-solving systems that are used to guide the \r\nactivity of a robot. Each process can be described as a partial \r\nsequence of subprocesses. Such a decomposition is not de\u0002scribed in absolute temporal terms (i.e., using dates), but by \r\nthe subprocess's relation to its containing process. Thus a \r\nnatural reference hierarchy can be constructed mirroring the \r\nprocess hierarchy. For example, consider a process P consist\u0002ing of a sequence of steps P1, P2, and P3 and another process \r\nQ consisting of subprocesses Q1 and Q2 occurring in any \r\norder, but not at the same time. Furthermore, let Q2 be \r\ndecomposed into two subprocesses Q21 and Q22, each occur\u0002ring simultaneously. To simulate a world in which process P \r\nbegins before Q begins, we can construct the reference hier\u0002archy in Figure 9. With this organization we can infer rela\u0002tionships between subprocesses of Q and subprocesses of P in \r\nthe same manner as above. As long as the decomposition of \r\nNovember1983 Volume26 Number 11 Communications of the ACM 839 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/2e033eeb-ad09-4a9e-85d1-2a83f8dc258d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9644a86f684f5f0eeaf9f4ca900bfcd095112bda118cbe3af8cc6c9a5be799df",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 726
      },
      {
        "segments": [
          {
            "segment_id": "2e033eeb-ad09-4a9e-85d1-2a83f8dc258d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nLIFE \r\n< d \r\nPRESCHOOL(LIFE) ~ PREGRAD(LIFE) ~POSTGRAD(LIFE) \r\nd POSTGRAOI \r\nPRIM(PREGRAD) ~ SECOND(PREGRAD) ~ UNIV(PREGRAD) \r\nCHESS(PRIM) WlN(UNIV) \r\nFIGURE 8. A Typical Reference Hierarchy \r\nfor a History of a Person. \r\nThe function Constrain-along-path simply takes a path and \r\ncomputes the transitivity constraints along it. Thus if a path \r\nconsisted of the nodes nl, n2, n3 ..... nm, we compute the \r\nrelation between nl and nm as follows: \r\nR := N(nl, n2) \r\nR := Constraints(R, N(nz, n3)) \r\nR := Constraints(R, N(n3, n4)) \r\nR := Constraints(R, N(nm-~, nm)) \r\nwhere Constraints was defined in Section 4.1. \r\n5.2. Examples \r\nThere are no restrictions imposed by the system on the use of \r\nreference intervals. Their organization is left up to the system \r\ndesigner. Certain principles of organization, however, are par\u0002ticularly useful in designing systems that remain efficient in \r\nretrieval, and yet capture the required knowledge. The most \r\nobvious of these is a consequence of the path search algo\u0002rithm in the previous section: the more tree-like the reference \r\nhierarchy, the more efficient the retrieval process. The others \r\nconsidered in this section exploit characteristics of the tem\u0002poral knowledge being stored. \r\nWith domains that capture historical information, it is best \r\nto choose the reference intervals to correspond to key events \r\nthat naturally divide the facts in the domain. Thus, if model\u0002ing facts about the history of a particular person, key events \r\nmight be their birth, their first going to school, their gradua\u0002tion from university, etc. Kahn and Gorry [13] introduced \r\nsuch a notion of reference events in their system. Other times \r\nin their system were explicitly related to these reference \r\nevents (i.e., points). In our system, the intervals between such \r\nkey events would become the reference intervals. Other time \r\nintervals would be stored in the cluster(s) identified by the \r\nreference intervals that contain them. Thus, we could have a \r\nseries of reference intervals for the time from birth to starting \r\nschool (PRESCHOOL), during school (PREGRAD), and after \r\ngraduation (POSTGRAD). In addition, certain reference inter\u0002vals could be further decomposed. For example, PREGRAD \r\ncould be divided into primary and secondary school (PRIM \r\nand SECOND) and the time at university (UNIV). The times \r\nof the rest of the events would be stored with respect to this \r\nreference hierarchy. Figure 8 depicts this set of facts including \r\nits reference hierarchy, plus intervals such as the time spent \r\nlearning chess (CHESS), the time the person won the state \r\nlottery (WIN), and the time of the first job (JOB). If an event \r\nextended over two reference intervals, then it would be \r\nstored with respect to both. For example, if learning to play \r\nchess occurred during primary and secondary school, the in\u0002terval CHESS would have two reference intervals, namely, \r\nPRIM and SECOND. \r\nWe can now trace the retrieval algorithm for this set of \r\nfacts. Let us find the relationship between CHESS and WIN. \r\nThere is no explicit relationship between the intervals, so we \r\nmust search up the reference hierarchy. Only one path is \r\nfound, namely: \r\nCHESS(PRIM)- -(d)---~ PRIM(PREGRAD) - -(<)-. \r\nUNIV(PREGRAD) - -(di)--~ WIN(UNIV) \r\nApplying the transitivity relations along the first path, we \r\ninfer first that \r\nCHESS before UNIV \r\nand then \r\nCHESS before WIN. \r\nThe fact that CHESS is before JOB can be inferred similarly \r\nfrom the path \r\nCHESS- -(d)--> PRIM - -(s)--, PREGRAD - -(m)--~ \r\nPOSTGRAD - -(di)--> JOB. \r\nConsider another domain, namely, that of representing in\u0002formation about processes or actions. Such knowledge is re\u0002quired for problem-solving systems that are used to guide the \r\nactivity of a robot. Each process can be described as a partial \r\nsequence of subprocesses. Such a decomposition is not de\u0002scribed in absolute temporal terms (i.e., using dates), but by \r\nthe subprocess's relation to its containing process. Thus a \r\nnatural reference hierarchy can be constructed mirroring the \r\nprocess hierarchy. For example, consider a process P consist\u0002ing of a sequence of steps P1, P2, and P3 and another process \r\nQ consisting of subprocesses Q1 and Q2 occurring in any \r\norder, but not at the same time. Furthermore, let Q2 be \r\ndecomposed into two subprocesses Q21 and Q22, each occur\u0002ring simultaneously. To simulate a world in which process P \r\nbegins before Q begins, we can construct the reference hier\u0002archy in Figure 9. With this organization we can infer rela\u0002tionships between subprocesses of Q and subprocesses of P in \r\nthe same manner as above. As long as the decomposition of \r\nNovember1983 Volume26 Number 11 Communications of the ACM 839 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/2e033eeb-ad09-4a9e-85d1-2a83f8dc258d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9644a86f684f5f0eeaf9f4ca900bfcd095112bda118cbe3af8cc6c9a5be799df",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 726
      },
      {
        "segments": [
          {
            "segment_id": "f6651c5a-7153-4190-b6cb-423c3f3bc852",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTPJBUTIONS \r\n(<m o) Q(x) ~ P(x) \r\nQ1 (Q) > Q2(Q) P1 (p).i.-p2(p)~ P3(P) \r\ne Q21 (Q2) ~ 12122(1212) \r\nFIGURE 9. A Reference Hierarchy Mirror\u0002ing a Process Hierarchy. \r\nprocesses or actions can be done independently (such as in \r\nthe NOAH system [17]), this organization will capture all the \r\nrelevant temporal knowledge. \r\nMore interesting cases arise when there may be interac\u0002tions among subprocesses. For instance, we might want to add \r\nthat Q1 must occur before Q21. Note that, in adding Q1 \r\nbefore Q21, we can infer a new relationship between Q1 and \r\nQ2 from the path \r\nQI(Q) - -(<)--~ Q21(Q2) - -(e)--~ Q2(Q) \r\nbecause Q1 and Q2 share the reference interval Q. It does not \r\nmatter that Q21 does not share a reference interval with Q1. \r\nIn more complicated cases, we will find relationships between \r\nsubprocesses such that an important relationship between the \r\nprocesses containing the subprocesses will not be inferred \r\nbecause they do not share a reference interval. For instance, if \r\nwe learn that Q2 overlaps P1, adding this will not cause the \r\nrelationship between Q and P to be constrained to simply the \r\noverlaps relation even though that would be a consequence in \r\nthe system without reference intervals. There is no path con\u0002sisting of two arcs from Q to P that is affected by adding Q2 \r\noverlaps P1. \r\nTo allow this inference, we need to reorganize the refer\u0002ence hierarchy. For example, we could, when adding a rela\u0002tion between two noncompatible nodes, expand one of the \r\nnode's reference intervals with the other node's reference \r\nintervals. In this scheme, to add Q2 ovedaps P1, we would \r\nfirst add P to Q2's reference interval list. Then adding the \r\nrelation will allow the appropriate changes. In particular, \r\namong others, we would infer that \r\nQ2(Q, P) - -(o)--~ P(X) \r\nfrom the path \r\nQ2(Q, P) - -(o)-+ PI(P) - -(s)-+ P(X), \r\nand then infer \r\nQ(X) - -(o)--~ P(X) \r\nfrom the path \r\nQ(X) - -(di)-+ Q2(Q, P) - -(o)--, P(X) \r\nand the previous constraints between Q and P. The final state \r\nof the processes after these two additions is summarized in \r\nFigure 10. \r\nManipulating the reference hierarchies as in this example \r\ncan be effective if used sparingly. With overuse, such tricks \r\ntend to \"flatten out\" the reference hierarchy as more intervals \r\nbecome explicitly related. In domains where such interactions \r\nare rare compared with the pure decompositional interac\u0002tions, it can be very effective. \r\n5.3. Representing the Present Moment \r\nThe technique of reference interval hierarchies provides a \r\nsimple solution to the problem of representing the present \r\nmoment. In many applications, such as natural language proc\u0002essing and process modeling, the present is constantly moving \r\ninto the future. Thus a representation of NOW must allow for \r\nfrequent updating without involving large-scale reorganization \r\nof the database each time. \r\nSuppose we have a database in which all assertions are \r\nindexed by the temporal interval over which they hold. As \r\ntime passes, we are interested in monitoring what is true at \r\nthe present time, as well as in the past and future. The \r\nmethod suggested here is to represent NOW as a variable that, \r\nat any specific time, is bound to an interval in the database. \r\nTo update NOW, we simply reassign the variable to a new \r\ninterval that is after the previous interval representing the \r\npresent moment. The key observation is that while the pre\u0002sent is continually changing, most of the world description is \r\nremaining the same. We can exploit this fact by using refer\u0002FIGURE 10. The Process Knowledge \r\nAfter Two Updates. \r\no \r\nQ(x) ~ P(x) \r\nd d o s d < f \r\nQ1 (Q) -..~ Q2 (QP) --i,- P1 (P) --~,.- P2 (P) > P3(P) \r\nt \r\nQ21 (Q2) ~ Q22(A2) \r\n840 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/f6651c5a-7153-4190-b6cb-423c3f3bc852.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f9a01d998f35f036079f1f9b04ce929a2e7c5f802a3bfb0e3be964341106508",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 620
      },
      {
        "segments": [
          {
            "segment_id": "f6651c5a-7153-4190-b6cb-423c3f3bc852",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTPJBUTIONS \r\n(<m o) Q(x) ~ P(x) \r\nQ1 (Q) > Q2(Q) P1 (p).i.-p2(p)~ P3(P) \r\ne Q21 (Q2) ~ 12122(1212) \r\nFIGURE 9. A Reference Hierarchy Mirror\u0002ing a Process Hierarchy. \r\nprocesses or actions can be done independently (such as in \r\nthe NOAH system [17]), this organization will capture all the \r\nrelevant temporal knowledge. \r\nMore interesting cases arise when there may be interac\u0002tions among subprocesses. For instance, we might want to add \r\nthat Q1 must occur before Q21. Note that, in adding Q1 \r\nbefore Q21, we can infer a new relationship between Q1 and \r\nQ2 from the path \r\nQI(Q) - -(<)--~ Q21(Q2) - -(e)--~ Q2(Q) \r\nbecause Q1 and Q2 share the reference interval Q. It does not \r\nmatter that Q21 does not share a reference interval with Q1. \r\nIn more complicated cases, we will find relationships between \r\nsubprocesses such that an important relationship between the \r\nprocesses containing the subprocesses will not be inferred \r\nbecause they do not share a reference interval. For instance, if \r\nwe learn that Q2 overlaps P1, adding this will not cause the \r\nrelationship between Q and P to be constrained to simply the \r\noverlaps relation even though that would be a consequence in \r\nthe system without reference intervals. There is no path con\u0002sisting of two arcs from Q to P that is affected by adding Q2 \r\noverlaps P1. \r\nTo allow this inference, we need to reorganize the refer\u0002ence hierarchy. For example, we could, when adding a rela\u0002tion between two noncompatible nodes, expand one of the \r\nnode's reference intervals with the other node's reference \r\nintervals. In this scheme, to add Q2 ovedaps P1, we would \r\nfirst add P to Q2's reference interval list. Then adding the \r\nrelation will allow the appropriate changes. In particular, \r\namong others, we would infer that \r\nQ2(Q, P) - -(o)--~ P(X) \r\nfrom the path \r\nQ2(Q, P) - -(o)-+ PI(P) - -(s)-+ P(X), \r\nand then infer \r\nQ(X) - -(o)--~ P(X) \r\nfrom the path \r\nQ(X) - -(di)-+ Q2(Q, P) - -(o)--, P(X) \r\nand the previous constraints between Q and P. The final state \r\nof the processes after these two additions is summarized in \r\nFigure 10. \r\nManipulating the reference hierarchies as in this example \r\ncan be effective if used sparingly. With overuse, such tricks \r\ntend to \"flatten out\" the reference hierarchy as more intervals \r\nbecome explicitly related. In domains where such interactions \r\nare rare compared with the pure decompositional interac\u0002tions, it can be very effective. \r\n5.3. Representing the Present Moment \r\nThe technique of reference interval hierarchies provides a \r\nsimple solution to the problem of representing the present \r\nmoment. In many applications, such as natural language proc\u0002essing and process modeling, the present is constantly moving \r\ninto the future. Thus a representation of NOW must allow for \r\nfrequent updating without involving large-scale reorganization \r\nof the database each time. \r\nSuppose we have a database in which all assertions are \r\nindexed by the temporal interval over which they hold. As \r\ntime passes, we are interested in monitoring what is true at \r\nthe present time, as well as in the past and future. The \r\nmethod suggested here is to represent NOW as a variable that, \r\nat any specific time, is bound to an interval in the database. \r\nTo update NOW, we simply reassign the variable to a new \r\ninterval that is after the previous interval representing the \r\npresent moment. The key observation is that while the pre\u0002sent is continually changing, most of the world description is \r\nremaining the same. We can exploit this fact by using refer\u0002FIGURE 10. The Process Knowledge \r\nAfter Two Updates. \r\no \r\nQ(x) ~ P(x) \r\nd d o s d < f \r\nQ1 (Q) -..~ Q2 (QP) --i,- P1 (P) --~,.- P2 (P) > P3(P) \r\nt \r\nQ21 (Q2) ~ Q22(A2) \r\n840 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/f6651c5a-7153-4190-b6cb-423c3f3bc852.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f9a01d998f35f036079f1f9b04ce929a2e7c5f802a3bfb0e3be964341106508",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 620
      },
      {
        "segments": [
          {
            "segment_id": "7974447c-fdde-407c-b815-41ea5c4ff02d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBImONS \r\nence intervals to control the inferences resulting from updat\u0002ing NOW. \r\nFor example, let NOW be interval N1, which is during its \r\nreference interval R1. An example state of the database \r\nwould be \r\nNI(R1) during R1 \r\nR1 before I1, R1 after I2, R1 during I3 \r\nFrom this we can infer easily that the present (i.e., N1) is \r\nduring 13, before I1, and after 12. If NOW then is updated \r\n(slightly), N2 can be defined as the new NOW using the same \r\nreference interval by adding the facts \r\nN2(R1) during R1, N2(R1) after NI(R1) \r\nThus, NOW has been updated but most of the relations in the \r\ndatabase have been unaffected, for the effects of N2 will only \r\npropagate to intervals referenced by R1. The reference inter\u0002val R1 has \"protected\" the rest of the database from a minor \r\nchange in the present moment. \r\nOf course, eventually NOW will cease to be during R1 and \r\na new reference interval will be needed. This will involve a \r\nmore major update to the database, but the amount of work \r\ncan be reduced if R1 itself has a reference interval that \"pro\u0002tects\" much of the database from it. \r\nThus we need a hierarchy of reference intervals, each con\u0002taining the present moment. This hierarchy could be designed \r\nto mirror the set of English terms that can be used to refer to \r\nthe present. For example, in English we can refer to the exact \r\nmoment of an utterance (e.g., at a race, the starter may say \r\n\"Go now!\"), as well as to larger intervals such as \"this morn\u0002ing,\" \"today,\" and \"this year.\" We can also refer to more \r\nevent-oriented intervals such as \"during this lecture\" and \r\n\"while at this bar.\" These are the types of intervals that \r\nshould be maintained in the hierarchy representing the pre\u0002sent. Furthermore, these intervals typically have well defined \r\nstarting and termination points. Thus it is reasonable to as\u0002sume that the temporal database will receive explicit notifica\u0002tion when one of them ceases to contain the present. This \r\nallows the following important assumption: \r\nWhen updating the NOW interval, unless otherwise stated, \r\nits relationship to its reference interval(s) remains constant. \r\nWhen one of the reference intervals in the hierarchy ceases \r\nto contain the present moment, a new reference interval is \r\nselected. (This new interval should usually be provided by \r\nthe user.) This update is done in the identical fashion as \r\ndescribed above with NOW. In particular, the relationship \r\nwith the higher-level reference interval remains constant. A \r\nnew NOW interval, below the new reference interval in the \r\nhierarchy, must be introduced. For example, the beginning of \r\na new day would make much of the old hierarchy part of the \r\npast (i.e., \"yesterday\"). \r\nWhile many intervals will be generated by this succession \r\nof intervals for NOW, many of them can be garbage collected \r\nwhen the reference intervals are updated. In particular, any \r\ninterval that is not used to index any events or facts may be \r\nremoved from the database. In a system modeling a natural \r\nlanguage dialogue, a large number of these intervals would be \r\nused only to index the time of an utterance: These generally \r\ncan be deleted without harm. \r\n6. DISCUSSION \r\nThe temporal representation described is notable in that it is \r\nboth expressive and computationally feasible. In particular, it \r\ndoes not insist that all events occur in a known fixed order, as \r\nin the state space approach, and its allows disjunctive knowl\u0002edge, such as that event A occurred either before or after \r\nevent B, not expressible in date-based systems or simple sys\u0002tems based on before/after chaining. It is not as expressive as \r\na full temporal logic (such as that of McDermott [15]), but \r\nthese systems do not currently have viable implementations. \r\nThis balance between expressive power and computational \r\nefficiency is achieved by the restricted form of disjunctions \r\nallowed in the system. One can only assert disjunctive infor\u0002mation about the relationship of two intervals. In other words, \r\nwe can assert that A is before or meets B, but not that (A \r\nmeets B) or (C before D). This limited form of disjunction is \r\nideal for the constraint propagation algorithm. \r\nThe system has been implemented and is being used in a \r\nvariety of applications. Both FRANZ LISP [8] and INTERLISP \r\nversions are running on a VAX 11/780 under UNIX. The \r\nsystem presently also includes the duration reasoner de\u0002scribed below. It is currently being used in research in repre\u0002senting actions, events, and interactions that arise in natural \r\nlanguage dialogues [1]. We are also using the representation as \r\na world model for research in automatic problem-solving sys\u0002tems [3]. Such systems have long been constrained by their \r\ninadequate temporal models. \r\nVilain [18] has implemented a version of this system \r\nwhich, at the cost of greater space requirements, can perform \r\nconsistency maintenance. In other words, in his system, when \r\nan inconsistency is found, the set of facts that caused the \r\ninconsistency can be identified. This system also explicitly \r\nallows time points in the representation and has a larger \r\ntransitivity table, including all interval/point and point/point \r\ninteractions. This violates the semantics of the interval repre\u0002sentation, and so has not been adopted in our present system. \r\nLet us consider why we would like time points, however. \r\nThey seem to be referred to in English. We can, for instance, \r\ntalk about the beginning and ending of events. There is no \r\nreason to assume, however, that these \"endpoints\" are truly \r\nzero-width points rather than intervals small enough so that \r\nthey appear to be instantaneous. What this suggests is that \r\nthere might be a minimum duration e, such that all intervals \r\nof duration less than e would be viewed as points. This would \r\nsimplify our reasoning about such times for we would not \r\nhave to worry about the possibility of two such intervals \r\noverlapping. It would be assumed either that these small in\u0002tervals are equal or that one is before the other. \r\nBut this minimum size cannot be fixed in advance. A histo\u0002rian, for instance, may be happy to consider days as points, \r\nwhereas the computer engineer, when reasoning about a logic \r\ncircuit, would consider a day to be an eternity. Thus the \r\ninterval size, where it is appropriate to simplify reasoning by \r\nassuming point-like times, varies with the reasoning task. \r\n7. FUTURE RESEARCH AND EXTENSIONS \r\nThere are many areas in which this system is being extended. \r\nIn particular, an interface to a duration reasoner has been \r\nincorporated into the system, and a system for reasoning \r\nabout dates will be implemented in the near future. Finally, \r\nwe are investigating reasoning systems that depend on the \r\nnotion of persistence. \r\n7.1. Duration Reasoning \r\nWe have designed a duration reasoning system based on the \r\nsame principles as the interval relation reasoner described \r\nabove. In particular, it is designed to allow relative informa\u0002tion (e.g., interval A took longer than interval B) as well as \r\nrepresenting uncertainty. The reasoner is again based on con\u0002November 1983 Volume 26 Number 11 Communications of the ACM 841 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/7974447c-fdde-407c-b815-41ea5c4ff02d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2e7f71d917be26e3d9fbb57b89c4993138225a0be1201578f9a4f6a4192b911c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1153
      },
      {
        "segments": [
          {
            "segment_id": "7974447c-fdde-407c-b815-41ea5c4ff02d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBImONS \r\nence intervals to control the inferences resulting from updat\u0002ing NOW. \r\nFor example, let NOW be interval N1, which is during its \r\nreference interval R1. An example state of the database \r\nwould be \r\nNI(R1) during R1 \r\nR1 before I1, R1 after I2, R1 during I3 \r\nFrom this we can infer easily that the present (i.e., N1) is \r\nduring 13, before I1, and after 12. If NOW then is updated \r\n(slightly), N2 can be defined as the new NOW using the same \r\nreference interval by adding the facts \r\nN2(R1) during R1, N2(R1) after NI(R1) \r\nThus, NOW has been updated but most of the relations in the \r\ndatabase have been unaffected, for the effects of N2 will only \r\npropagate to intervals referenced by R1. The reference inter\u0002val R1 has \"protected\" the rest of the database from a minor \r\nchange in the present moment. \r\nOf course, eventually NOW will cease to be during R1 and \r\na new reference interval will be needed. This will involve a \r\nmore major update to the database, but the amount of work \r\ncan be reduced if R1 itself has a reference interval that \"pro\u0002tects\" much of the database from it. \r\nThus we need a hierarchy of reference intervals, each con\u0002taining the present moment. This hierarchy could be designed \r\nto mirror the set of English terms that can be used to refer to \r\nthe present. For example, in English we can refer to the exact \r\nmoment of an utterance (e.g., at a race, the starter may say \r\n\"Go now!\"), as well as to larger intervals such as \"this morn\u0002ing,\" \"today,\" and \"this year.\" We can also refer to more \r\nevent-oriented intervals such as \"during this lecture\" and \r\n\"while at this bar.\" These are the types of intervals that \r\nshould be maintained in the hierarchy representing the pre\u0002sent. Furthermore, these intervals typically have well defined \r\nstarting and termination points. Thus it is reasonable to as\u0002sume that the temporal database will receive explicit notifica\u0002tion when one of them ceases to contain the present. This \r\nallows the following important assumption: \r\nWhen updating the NOW interval, unless otherwise stated, \r\nits relationship to its reference interval(s) remains constant. \r\nWhen one of the reference intervals in the hierarchy ceases \r\nto contain the present moment, a new reference interval is \r\nselected. (This new interval should usually be provided by \r\nthe user.) This update is done in the identical fashion as \r\ndescribed above with NOW. In particular, the relationship \r\nwith the higher-level reference interval remains constant. A \r\nnew NOW interval, below the new reference interval in the \r\nhierarchy, must be introduced. For example, the beginning of \r\na new day would make much of the old hierarchy part of the \r\npast (i.e., \"yesterday\"). \r\nWhile many intervals will be generated by this succession \r\nof intervals for NOW, many of them can be garbage collected \r\nwhen the reference intervals are updated. In particular, any \r\ninterval that is not used to index any events or facts may be \r\nremoved from the database. In a system modeling a natural \r\nlanguage dialogue, a large number of these intervals would be \r\nused only to index the time of an utterance: These generally \r\ncan be deleted without harm. \r\n6. DISCUSSION \r\nThe temporal representation described is notable in that it is \r\nboth expressive and computationally feasible. In particular, it \r\ndoes not insist that all events occur in a known fixed order, as \r\nin the state space approach, and its allows disjunctive knowl\u0002edge, such as that event A occurred either before or after \r\nevent B, not expressible in date-based systems or simple sys\u0002tems based on before/after chaining. It is not as expressive as \r\na full temporal logic (such as that of McDermott [15]), but \r\nthese systems do not currently have viable implementations. \r\nThis balance between expressive power and computational \r\nefficiency is achieved by the restricted form of disjunctions \r\nallowed in the system. One can only assert disjunctive infor\u0002mation about the relationship of two intervals. In other words, \r\nwe can assert that A is before or meets B, but not that (A \r\nmeets B) or (C before D). This limited form of disjunction is \r\nideal for the constraint propagation algorithm. \r\nThe system has been implemented and is being used in a \r\nvariety of applications. Both FRANZ LISP [8] and INTERLISP \r\nversions are running on a VAX 11/780 under UNIX. The \r\nsystem presently also includes the duration reasoner de\u0002scribed below. It is currently being used in research in repre\u0002senting actions, events, and interactions that arise in natural \r\nlanguage dialogues [1]. We are also using the representation as \r\na world model for research in automatic problem-solving sys\u0002tems [3]. Such systems have long been constrained by their \r\ninadequate temporal models. \r\nVilain [18] has implemented a version of this system \r\nwhich, at the cost of greater space requirements, can perform \r\nconsistency maintenance. In other words, in his system, when \r\nan inconsistency is found, the set of facts that caused the \r\ninconsistency can be identified. This system also explicitly \r\nallows time points in the representation and has a larger \r\ntransitivity table, including all interval/point and point/point \r\ninteractions. This violates the semantics of the interval repre\u0002sentation, and so has not been adopted in our present system. \r\nLet us consider why we would like time points, however. \r\nThey seem to be referred to in English. We can, for instance, \r\ntalk about the beginning and ending of events. There is no \r\nreason to assume, however, that these \"endpoints\" are truly \r\nzero-width points rather than intervals small enough so that \r\nthey appear to be instantaneous. What this suggests is that \r\nthere might be a minimum duration e, such that all intervals \r\nof duration less than e would be viewed as points. This would \r\nsimplify our reasoning about such times for we would not \r\nhave to worry about the possibility of two such intervals \r\noverlapping. It would be assumed either that these small in\u0002tervals are equal or that one is before the other. \r\nBut this minimum size cannot be fixed in advance. A histo\u0002rian, for instance, may be happy to consider days as points, \r\nwhereas the computer engineer, when reasoning about a logic \r\ncircuit, would consider a day to be an eternity. Thus the \r\ninterval size, where it is appropriate to simplify reasoning by \r\nassuming point-like times, varies with the reasoning task. \r\n7. FUTURE RESEARCH AND EXTENSIONS \r\nThere are many areas in which this system is being extended. \r\nIn particular, an interface to a duration reasoner has been \r\nincorporated into the system, and a system for reasoning \r\nabout dates will be implemented in the near future. Finally, \r\nwe are investigating reasoning systems that depend on the \r\nnotion of persistence. \r\n7.1. Duration Reasoning \r\nWe have designed a duration reasoning system based on the \r\nsame principles as the interval relation reasoner described \r\nabove. In particular, it is designed to allow relative informa\u0002tion (e.g., interval A took longer than interval B) as well as \r\nrepresenting uncertainty. The reasoner is again based on con\u0002November 1983 Volume 26 Number 11 Communications of the ACM 841 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/7974447c-fdde-407c-b815-41ea5c4ff02d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2e7f71d917be26e3d9fbb57b89c4993138225a0be1201578f9a4f6a4192b911c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1153
      },
      {
        "segments": [
          {
            "segment_id": "b9f8004d-73f7-4918-a07f-ad5b1484e528",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nstraint propagation and a notion of reference durations can be \r\ndefined. \r\nVery briefly, the duration relationship between two inter\u0002vals is expressed by outlining a range that includes the multi\u0002plicative factor which the duration of the first would be mul\u0002tiplied by to get the duration of the second. For example, the \r\nfact that the duration of A is less than the duration of B, \r\nexpressed as dur(A) < dur(B), is represented by the relation \r\nA - -(0(1))--) B. In other words, dur(A) >= 0*dur(B) and \r\ndur(A) < l*dur(B). The parentheses about the factor I indi\u0002cate an open endpoint; thus the durations of A and B could \r\nnot be equal. Both the upper and lower duration limits may \r\nbe open or closed. \r\nDuration information is encoded in a network orthogonal to \r\nthe relationship network. Propagation across two duration re\u0002strictions is accomplished simply by multiplying the respec\u0002tive upper and lower duration limits. For example, if we have \r\nthe facts \r\ndur(A) <= dur(B) \r\ndur(C) <= dur(B) \r\ndur(B) < 2*dur(C) \r\nwhich in network form would be \r\nA --(01)--~ B --(1(2))--) C \r\nwe derive the relation \r\nA - -(0(2))--~ C. \r\nThe duration reasoner and the interval reasoner are not \r\nindependent of each other, however. They constrain each \r\nother by rules such as the following: \r\nIf I --(dsf)--~ J then dur(I) < dur(J). \r\nUsing this rule, constraints introduced in one network may \r\nintroduce constraints in the other. In many examples, the \r\nnetworks may exchange information back and forth multiple \r\ntimes before the propagation terminates. \r\nReference durations correspond to the notion of scales, or \r\ncommon units. Constraints do not propagate through a refer\u0002ence duration. Thus, if the duration HOUR is a reference \r\nduration, and we add that dur(A) is between 1 and 2 hours, \r\nand dur(B) is less than one half an hour, no relation between \r\ndur(A) and dur(B) will be inferred. It will be derived at re\u0002trieval time via the reference duration HOUR. Further details \r\non the duration reasoner can be found in [2]. \r\n7.2. Date Lines \r\nHaving considered the maintenance of relative temporal in_for\u0002mation in detail, we now consider how to exploit date infor\u0002mation when available. Let a date line be any representation \r\nconsisting of a fully ordered set of values taken to correspond \r\nto times. A date line corresponding to a simple calendar could \r\nbe defined as follows: \r\nvalues: ordered triples of integers, representing year, month \r\n(1-12), and day (1-31) (for example, (50 3 25) represents \r\nMarch 25, 1950) \r\ncomparison operation: orders triples in the obvious manner \r\n(for example, (50 3 25) < (75 1 1)) \r\nWith date lines, the comparison operation between two times \r\non the same date line is relatively inexpensive compared to \r\nsearching the network of temporal relations. \r\nDate line information could be incorporated into the pre\u0002sent system by allowing any interval in the network to have \r\ndate line information associated with it which identifies the \r\ndating system and dates associated with its start and end. The \r\nname of the date line is necessary to identify the operations \r\nfor comparing values. A new interval, added with date line \r\ninformation specified, may affect the relationship to its refer\u0002ence interval and to the other intervals in its \"reference \r\nclass.\" For example, if two intervals are dated by the same \r\ndate line, and have date values specified, those values can be \r\nused to calculate the exact relation between the intervals. If \r\nthis relation is more specific than the information stored in \r\nthe relational network, the network is updated and its effects \r\npropagated as usual. \r\nWhen retrieving a relationship between two intervals dated \r\nby the same date line, the date information should be consid\u0002ered first before applying the usual network retrieval mecha\u0002nism. Sometimes, however, the date line information will not \r\nbe specific enough to pinpoint a specific relationship, and a \r\nnetwork search will still be necessary. It may occur that one \r\nof the intervals being considered is dated but the other is not. \r\nIn this case, the date information may be used only if a \r\nrelationship can be found between the nondated interval and \r\nanother interval dated by the same date line. In general, this \r\nmay be too expensive to consider. A specific case that could \r\nbe very useful, however, occurs when a reference interval \r\ninvolved in the search is dated by the appropriate date line. \r\nWe can then compare the two dated intervals to obtain a \r\nrelationship, which can be propagated back to the nondated \r\ninterval. \r\nA useful date line for dialogue systems is the time-of-day \r\nline. A reasonable implementation of this might have the \r\nbasic duration of one minute, and have values consisting of \r\nan hour-minute pair. If the system were given access to a \r\nclock, this date line could be used extensively in the NOW \r\nhierarchy. Of course, the relative time database is still re-, \r\nquired to store the facts that are acquired during the dialogue \r\nas facts typically hold for much longer than the time that they \r\nare being talked about. \r\nIf the system does not have such easy access to an internal \r\nclock, it may still get time-of-day information occasionally \r\nduring a dialogue. In this case, some of the NOW intervals \r\nwill map onto the time-of-day line, while others will only be \r\nrelated to it by some relation (e.g., after 10 o'clock). In such a \r\nscheme, a new reference interval for the NOW interval would \r\nbe created each time a precise time-of-day value was identi\u0002fied. For example, if the system learns that it is presently 10 \r\no'clock, it can create an \"after 10 o'clock\" reference interval in \r\nwhich the NOW intervals will be contained until the next \r\nspecific time is acquired. Whether such a technique is feasible \r\nrequires further search. \r\n7.3. Persistence of Intervals \r\nThe last requirement described in the introduction was that \r\nthe representation should facilitate plausible inferences of the \r\nform \"if fact P is true now, it will remain true until noticed \r\notherwise.\" Most of the issues concerning this fall outside the \r\nrange of this paper, as this system only knows about time \r\nintervals. However, a simple trick using this representation \r\nmakes inferences of the above form easy to implement. \r\nTypically, when a new fact is learned, its exact extent in \r\ntime is not known. For instance, when I parked by car in the \r\nparking lot this morning I knew its location. Sitting at my \r\ndesk now, I assume it is still there, though I have no proof of \r\nthat fact. In general, I assume it will remain where it is until I \r\npick it up. Thus, although I do not know the extent of the \r\ninterval in which my car is parked, I want to be able to \r\nassume that this fact holds later in the day. The temporal \r\nrepresentation is already based on the observation that most \r\ntime intervals do not have precisely defined limits. If we \r\n842 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/b9f8004d-73f7-4918-a07f-ad5b1484e528.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=86da31fdf7f69ddac3f4dd779319990924d919953c42568afadd6ff556e8b41b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1143
      },
      {
        "segments": [
          {
            "segment_id": "b9f8004d-73f7-4918-a07f-ad5b1484e528",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nstraint propagation and a notion of reference durations can be \r\ndefined. \r\nVery briefly, the duration relationship between two inter\u0002vals is expressed by outlining a range that includes the multi\u0002plicative factor which the duration of the first would be mul\u0002tiplied by to get the duration of the second. For example, the \r\nfact that the duration of A is less than the duration of B, \r\nexpressed as dur(A) < dur(B), is represented by the relation \r\nA - -(0(1))--) B. In other words, dur(A) >= 0*dur(B) and \r\ndur(A) < l*dur(B). The parentheses about the factor I indi\u0002cate an open endpoint; thus the durations of A and B could \r\nnot be equal. Both the upper and lower duration limits may \r\nbe open or closed. \r\nDuration information is encoded in a network orthogonal to \r\nthe relationship network. Propagation across two duration re\u0002strictions is accomplished simply by multiplying the respec\u0002tive upper and lower duration limits. For example, if we have \r\nthe facts \r\ndur(A) <= dur(B) \r\ndur(C) <= dur(B) \r\ndur(B) < 2*dur(C) \r\nwhich in network form would be \r\nA --(01)--~ B --(1(2))--) C \r\nwe derive the relation \r\nA - -(0(2))--~ C. \r\nThe duration reasoner and the interval reasoner are not \r\nindependent of each other, however. They constrain each \r\nother by rules such as the following: \r\nIf I --(dsf)--~ J then dur(I) < dur(J). \r\nUsing this rule, constraints introduced in one network may \r\nintroduce constraints in the other. In many examples, the \r\nnetworks may exchange information back and forth multiple \r\ntimes before the propagation terminates. \r\nReference durations correspond to the notion of scales, or \r\ncommon units. Constraints do not propagate through a refer\u0002ence duration. Thus, if the duration HOUR is a reference \r\nduration, and we add that dur(A) is between 1 and 2 hours, \r\nand dur(B) is less than one half an hour, no relation between \r\ndur(A) and dur(B) will be inferred. It will be derived at re\u0002trieval time via the reference duration HOUR. Further details \r\non the duration reasoner can be found in [2]. \r\n7.2. Date Lines \r\nHaving considered the maintenance of relative temporal in_for\u0002mation in detail, we now consider how to exploit date infor\u0002mation when available. Let a date line be any representation \r\nconsisting of a fully ordered set of values taken to correspond \r\nto times. A date line corresponding to a simple calendar could \r\nbe defined as follows: \r\nvalues: ordered triples of integers, representing year, month \r\n(1-12), and day (1-31) (for example, (50 3 25) represents \r\nMarch 25, 1950) \r\ncomparison operation: orders triples in the obvious manner \r\n(for example, (50 3 25) < (75 1 1)) \r\nWith date lines, the comparison operation between two times \r\non the same date line is relatively inexpensive compared to \r\nsearching the network of temporal relations. \r\nDate line information could be incorporated into the pre\u0002sent system by allowing any interval in the network to have \r\ndate line information associated with it which identifies the \r\ndating system and dates associated with its start and end. The \r\nname of the date line is necessary to identify the operations \r\nfor comparing values. A new interval, added with date line \r\ninformation specified, may affect the relationship to its refer\u0002ence interval and to the other intervals in its \"reference \r\nclass.\" For example, if two intervals are dated by the same \r\ndate line, and have date values specified, those values can be \r\nused to calculate the exact relation between the intervals. If \r\nthis relation is more specific than the information stored in \r\nthe relational network, the network is updated and its effects \r\npropagated as usual. \r\nWhen retrieving a relationship between two intervals dated \r\nby the same date line, the date information should be consid\u0002ered first before applying the usual network retrieval mecha\u0002nism. Sometimes, however, the date line information will not \r\nbe specific enough to pinpoint a specific relationship, and a \r\nnetwork search will still be necessary. It may occur that one \r\nof the intervals being considered is dated but the other is not. \r\nIn this case, the date information may be used only if a \r\nrelationship can be found between the nondated interval and \r\nanother interval dated by the same date line. In general, this \r\nmay be too expensive to consider. A specific case that could \r\nbe very useful, however, occurs when a reference interval \r\ninvolved in the search is dated by the appropriate date line. \r\nWe can then compare the two dated intervals to obtain a \r\nrelationship, which can be propagated back to the nondated \r\ninterval. \r\nA useful date line for dialogue systems is the time-of-day \r\nline. A reasonable implementation of this might have the \r\nbasic duration of one minute, and have values consisting of \r\nan hour-minute pair. If the system were given access to a \r\nclock, this date line could be used extensively in the NOW \r\nhierarchy. Of course, the relative time database is still re-, \r\nquired to store the facts that are acquired during the dialogue \r\nas facts typically hold for much longer than the time that they \r\nare being talked about. \r\nIf the system does not have such easy access to an internal \r\nclock, it may still get time-of-day information occasionally \r\nduring a dialogue. In this case, some of the NOW intervals \r\nwill map onto the time-of-day line, while others will only be \r\nrelated to it by some relation (e.g., after 10 o'clock). In such a \r\nscheme, a new reference interval for the NOW interval would \r\nbe created each time a precise time-of-day value was identi\u0002fied. For example, if the system learns that it is presently 10 \r\no'clock, it can create an \"after 10 o'clock\" reference interval in \r\nwhich the NOW intervals will be contained until the next \r\nspecific time is acquired. Whether such a technique is feasible \r\nrequires further search. \r\n7.3. Persistence of Intervals \r\nThe last requirement described in the introduction was that \r\nthe representation should facilitate plausible inferences of the \r\nform \"if fact P is true now, it will remain true until noticed \r\notherwise.\" Most of the issues concerning this fall outside the \r\nrange of this paper, as this system only knows about time \r\nintervals. However, a simple trick using this representation \r\nmakes inferences of the above form easy to implement. \r\nTypically, when a new fact is learned, its exact extent in \r\ntime is not known. For instance, when I parked by car in the \r\nparking lot this morning I knew its location. Sitting at my \r\ndesk now, I assume it is still there, though I have no proof of \r\nthat fact. In general, I assume it will remain where it is until I \r\npick it up. Thus, although I do not know the extent of the \r\ninterval in which my car is parked, I want to be able to \r\nassume that this fact holds later in the day. The temporal \r\nrepresentation is already based on the observation that most \r\ntime intervals do not have precisely defined limits. If we \r\n842 Communications of the ACM November 1983 Volume 26 Number 11 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/b9f8004d-73f7-4918-a07f-ad5b1484e528.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=86da31fdf7f69ddac3f4dd779319990924d919953c42568afadd6ff556e8b41b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1143
      },
      {
        "segments": [
          {
            "segment_id": "d5443d5e-152d-4666-a2b5-59a80218493b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nallow the user to specify that some intervals should be as\u0002sumed to extend as far as possible given the constraints, then \r\nwe can use such intervals to index facts that are assumed to \r\npersist until discovered otherwise. \r\nThus, if we let a fact P be indexed by a persistent interval \r\nTp, then testing P later during an interval t will succeed (by \r\nassumption) if it is possible that t is during Tp. Checking \r\nwhether relationships between intervals are possible is easy, \r\nsince the representation explicitly maintains this information. \r\nFor example, let Tp represent the interval in which my car \r\nis in the parking lot. I know that Tp is met by Tarrive, where \r\nTarrive is the time that I arrived at school today. Then, if \r\nNOW is represented as interval Tnow, where Tnow after \r\nTarrive, we can test if my car is on the parking lot. Since it is \r\nthere during Tp, we are interested in whether it is possible \r\nthat Tnow is during Tp. The known constraints allow us to \r\ninfer the following: \r\nTp met by Tarrive, Tarrive before Tnow \r\n=> Tp - -(< odim)--~ Tnow \r\nThus it is possible that Tnow is during Tp, since it is possible \r\nthat Tp contains (\"di\") Tnow. So the test succeeds. \r\nOf course, if it is later learned that the car was found to be \r\nmissing during time interval Tmiss, then Tp is constrained to \r\nbe before Tmiss (even though it is still persistent). If Tnow is \r\nthen after or during Tmiss, then it is not possible any longer \r\nthat Tnow is during Tp. \r\nManaging a system such as this is a difficult problem that \r\nrequires some form of truth maintenance (e.g., see [6]). These \r\nissues, however, are independent of the temporal representa\u0002tion. All that is shown here is that the necessary temporal \r\ncalculations are easily done within this framework. \r\nAn interesting technique suggested by the above may sim\u0002plify much of the computation required for truth mainte\u0002nance for this type of assumption. In particular, let us assume \r\nthat P holds during interval Tp, where Tp is a persistent \r\ninterval. Furthermore, assume that for any time, P implies Q. \r\nThen if we test P at time t, and find it is true by assumption, \r\nso we can infer Q during time t. However, if we index Q by \r\nTp rather than by t, then we still can use the fact that Q is \r\ntrue during t (by assumption), but if we ever discover further \r\nconstraints on Tp that then eliminate the possibility that t is \r\nduring Tp, then both P and Q will cease to be true (by \r\nassumption) during t. Thus, by indexing all the consequences \r\nof P by the same interval, Tp, we can revise our beliefs about \r\nP and all its consequences simply by adding constraints about \r\nTp. While this idea obviously requires further investigation, it \r\nappears that it may allow a large class of assumption-based \r\nbelief revision to be performed easily. \r\n8. SUMMARY \r\nWe have described a system for reasoning about temporal \r\nintervals that is both expressive and computationally effec\u0002tive. The representation captures the temporal hierarchy im\u0002plicit in many domains by using a hierarchy of reference \r\nintervals, which precisely control the amount of deduction \r\nperformed automatically by the system. This approach is par\u0002tially useful in domains where temporal information is impre\u0002cise and relative, and techniques such as dating are not possi\u0002ble. \r\nAclmowledgments. Many people have provided significant \r\nhelp during the design and development of this work. In \r\nparticular, I would like to thank Marc Vilain and Henry \r\nKautz for work on developing and extending the system. \r\nI have also received many valuable criticisms from Alan \r\nFrisch, Pat Hayes, Hans Koomen, Drew McDermott, Candy \r\nSidner, and the referees. Finally, I would like to thank Peggy \r\nMeeker for preparing the manuscript, and Irene Allen and \r\nHenry Kautz for the valuable editorial criticism on the final \r\ndraft. \r\nREFERENCES \r\n1. Allen, J. F., Frisch, A. M., and Litman, D. J. ARGOT: The Rochester \r\ndialogue system, Proc. Nat. Conf. on Artificial Intelligence, AAAI 82, \r\nPittsburgh, Pa., Aug. 1982. \r\n2. Allen, J. F., and Kautz, H. A. \"A model of naive temporal reasoning,\" \r\nto appear in J. R. Hobbs and R. Moore (Ed}., Contributions in Artificial \r\nIntelligence, Vol. 1, Ablex Pub. Co., Norwood, N.J., 1983. \r\n3. Allen, J. F., and Koomen, l- A. Planning using a temporal world \r\nmodel. Submitted to 8th Int. Joint Conf. Artificial Intelligence, Aug. \r\n1983. \r\n4. Bruce, B. C. A model for temporal references and its application in a \r\nquestion answering program. Artificial Intelligence 3 (1972), 1-25. \r\n5. Bubenko, J. A., Jr. Information modeling in the context of system \r\ndevelopment. Proc. IFIP Congress 80, Oct. 1980, North-Holland, Am\u0002sterdam. \r\n6. Doyle, J. A truth maintenance system. Artificial Intelligence 12, 3, \r\n(Nov. 1979), 231-272. \r\n7. Fikes, R. E., and Nilsson, N. J. STRIPS: A new approach to the appli\u0002cation of theorem proving to problem solving. Artificial Intelligence 2, \r\n(1971), 189-205. \r\n8. Foderaro, J. K. The FRANZ LISP Manual. Dept. of Computer Science, \r\nU. of California, Berkeley, 1980. \r\n9. Freuder, E. C. A sufficient condition for backtrack-flee search. J. \r\nACM 29, 1 (Jan. 1982), 24-32. \r\n10. Hayes, P. J. The Naive Physics manifesto. In Expert Systems, D. Mi\u0002chie (Ed.), Edinburgh U. Press, 1979. \r\n11. Hayes, P. J. Naive Physics I: Ontology for liquids. Working Paper 63, \r\nlnstitut pour les Etudes Semantiques et Cognitives, Geneva, 1978. \r\n12. Hendrix, G. G. Modeling simultaneous actions and continuous proc\u0002esses, Artificial Intelligence 4, 3 (1973), 145-180. \r\n13. Kahn, K. M., and Gorry, A. G. Mechanizing temporal knowledge. \r\nArtificial Intelligence 9, 2 (1977). 87-108. \r\n14. McCarthy, J., and Hayes, P. Some philosophical problems from the \r\nstandpoint of artificial intelligence. Machine Intelligence 4, Edinburgh \r\nU. Press, 1969. \r\n15. McDermott, D. A temporal logic for reasoning about processes and \r\nplans. Cognitive Science 6, (1982), 101-155. \r\n16. Rescher, N., and Urquhart, A. Temporal Logic. Springer-Verlag, New \r\nYork, 1971. \r\n17. Sacerdoti, E. D. A Structure for Plans and Behavior. Elsevier North\u0002Holland, New York, 1977. \r\n18. Vilain, M. A system for reasoning about time. Proc. AAAI 82, Pitts\u0002burgh, Pa., Aug. 1982. \r\nCR Categories and Subject Descriptors: 1.2.4 [Knowledge Representa\u0002tion Formalisms and Methods]: Representations--time, temporal repre\u0002sentation; 1.2.3 [Deduction and Theorem Proving]: Deduction--constraint \r\npropagation, temporal reasoning; H.3.3 [Information Search and Re\u0002trieval]: Clustering, Retrieval Methods \r\nGeneral Terms: Algorithms \r\nAdditional Key Words and Phrases: temporal interval, interval rea\u0002soning, interval representation. \r\nReceived 12/81; revised 3/83: accepted 5/83 \r\nNovember1983 Volume26 Number11 Communications of the ACM 843 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/d5443d5e-152d-4666-a2b5-59a80218493b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=705fa9362c6c2da2cb8f5ab04453aac344ee517dfab9a29b28542802f9d4c685",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1067
      },
      {
        "segments": [
          {
            "segment_id": "d5443d5e-152d-4666-a2b5-59a80218493b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "RESEARCH CONTRIBUTIONS \r\nallow the user to specify that some intervals should be as\u0002sumed to extend as far as possible given the constraints, then \r\nwe can use such intervals to index facts that are assumed to \r\npersist until discovered otherwise. \r\nThus, if we let a fact P be indexed by a persistent interval \r\nTp, then testing P later during an interval t will succeed (by \r\nassumption) if it is possible that t is during Tp. Checking \r\nwhether relationships between intervals are possible is easy, \r\nsince the representation explicitly maintains this information. \r\nFor example, let Tp represent the interval in which my car \r\nis in the parking lot. I know that Tp is met by Tarrive, where \r\nTarrive is the time that I arrived at school today. Then, if \r\nNOW is represented as interval Tnow, where Tnow after \r\nTarrive, we can test if my car is on the parking lot. Since it is \r\nthere during Tp, we are interested in whether it is possible \r\nthat Tnow is during Tp. The known constraints allow us to \r\ninfer the following: \r\nTp met by Tarrive, Tarrive before Tnow \r\n=> Tp - -(< odim)--~ Tnow \r\nThus it is possible that Tnow is during Tp, since it is possible \r\nthat Tp contains (\"di\") Tnow. So the test succeeds. \r\nOf course, if it is later learned that the car was found to be \r\nmissing during time interval Tmiss, then Tp is constrained to \r\nbe before Tmiss (even though it is still persistent). If Tnow is \r\nthen after or during Tmiss, then it is not possible any longer \r\nthat Tnow is during Tp. \r\nManaging a system such as this is a difficult problem that \r\nrequires some form of truth maintenance (e.g., see [6]). These \r\nissues, however, are independent of the temporal representa\u0002tion. All that is shown here is that the necessary temporal \r\ncalculations are easily done within this framework. \r\nAn interesting technique suggested by the above may sim\u0002plify much of the computation required for truth mainte\u0002nance for this type of assumption. In particular, let us assume \r\nthat P holds during interval Tp, where Tp is a persistent \r\ninterval. Furthermore, assume that for any time, P implies Q. \r\nThen if we test P at time t, and find it is true by assumption, \r\nso we can infer Q during time t. However, if we index Q by \r\nTp rather than by t, then we still can use the fact that Q is \r\ntrue during t (by assumption), but if we ever discover further \r\nconstraints on Tp that then eliminate the possibility that t is \r\nduring Tp, then both P and Q will cease to be true (by \r\nassumption) during t. Thus, by indexing all the consequences \r\nof P by the same interval, Tp, we can revise our beliefs about \r\nP and all its consequences simply by adding constraints about \r\nTp. While this idea obviously requires further investigation, it \r\nappears that it may allow a large class of assumption-based \r\nbelief revision to be performed easily. \r\n8. SUMMARY \r\nWe have described a system for reasoning about temporal \r\nintervals that is both expressive and computationally effec\u0002tive. The representation captures the temporal hierarchy im\u0002plicit in many domains by using a hierarchy of reference \r\nintervals, which precisely control the amount of deduction \r\nperformed automatically by the system. This approach is par\u0002tially useful in domains where temporal information is impre\u0002cise and relative, and techniques such as dating are not possi\u0002ble. \r\nAclmowledgments. Many people have provided significant \r\nhelp during the design and development of this work. In \r\nparticular, I would like to thank Marc Vilain and Henry \r\nKautz for work on developing and extending the system. \r\nI have also received many valuable criticisms from Alan \r\nFrisch, Pat Hayes, Hans Koomen, Drew McDermott, Candy \r\nSidner, and the referees. Finally, I would like to thank Peggy \r\nMeeker for preparing the manuscript, and Irene Allen and \r\nHenry Kautz for the valuable editorial criticism on the final \r\ndraft. \r\nREFERENCES \r\n1. Allen, J. F., Frisch, A. M., and Litman, D. J. ARGOT: The Rochester \r\ndialogue system, Proc. Nat. Conf. on Artificial Intelligence, AAAI 82, \r\nPittsburgh, Pa., Aug. 1982. \r\n2. Allen, J. F., and Kautz, H. A. \"A model of naive temporal reasoning,\" \r\nto appear in J. R. Hobbs and R. Moore (Ed}., Contributions in Artificial \r\nIntelligence, Vol. 1, Ablex Pub. Co., Norwood, N.J., 1983. \r\n3. Allen, J. F., and Koomen, l- A. Planning using a temporal world \r\nmodel. Submitted to 8th Int. Joint Conf. Artificial Intelligence, Aug. \r\n1983. \r\n4. Bruce, B. C. A model for temporal references and its application in a \r\nquestion answering program. Artificial Intelligence 3 (1972), 1-25. \r\n5. Bubenko, J. A., Jr. Information modeling in the context of system \r\ndevelopment. Proc. IFIP Congress 80, Oct. 1980, North-Holland, Am\u0002sterdam. \r\n6. Doyle, J. A truth maintenance system. Artificial Intelligence 12, 3, \r\n(Nov. 1979), 231-272. \r\n7. Fikes, R. E., and Nilsson, N. J. STRIPS: A new approach to the appli\u0002cation of theorem proving to problem solving. Artificial Intelligence 2, \r\n(1971), 189-205. \r\n8. Foderaro, J. K. The FRANZ LISP Manual. Dept. of Computer Science, \r\nU. of California, Berkeley, 1980. \r\n9. Freuder, E. C. A sufficient condition for backtrack-flee search. J. \r\nACM 29, 1 (Jan. 1982), 24-32. \r\n10. Hayes, P. J. The Naive Physics manifesto. In Expert Systems, D. Mi\u0002chie (Ed.), Edinburgh U. Press, 1979. \r\n11. Hayes, P. J. Naive Physics I: Ontology for liquids. Working Paper 63, \r\nlnstitut pour les Etudes Semantiques et Cognitives, Geneva, 1978. \r\n12. Hendrix, G. G. Modeling simultaneous actions and continuous proc\u0002esses, Artificial Intelligence 4, 3 (1973), 145-180. \r\n13. Kahn, K. M., and Gorry, A. G. Mechanizing temporal knowledge. \r\nArtificial Intelligence 9, 2 (1977). 87-108. \r\n14. McCarthy, J., and Hayes, P. Some philosophical problems from the \r\nstandpoint of artificial intelligence. Machine Intelligence 4, Edinburgh \r\nU. Press, 1969. \r\n15. McDermott, D. A temporal logic for reasoning about processes and \r\nplans. Cognitive Science 6, (1982), 101-155. \r\n16. Rescher, N., and Urquhart, A. Temporal Logic. Springer-Verlag, New \r\nYork, 1971. \r\n17. Sacerdoti, E. D. A Structure for Plans and Behavior. Elsevier North\u0002Holland, New York, 1977. \r\n18. Vilain, M. A system for reasoning about time. Proc. AAAI 82, Pitts\u0002burgh, Pa., Aug. 1982. \r\nCR Categories and Subject Descriptors: 1.2.4 [Knowledge Representa\u0002tion Formalisms and Methods]: Representations--time, temporal repre\u0002sentation; 1.2.3 [Deduction and Theorem Proving]: Deduction--constraint \r\npropagation, temporal reasoning; H.3.3 [Information Search and Re\u0002trieval]: Clustering, Retrieval Methods \r\nGeneral Terms: Algorithms \r\nAdditional Key Words and Phrases: temporal interval, interval rea\u0002soning, interval representation. \r\nReceived 12/81; revised 3/83: accepted 5/83 \r\nNovember1983 Volume26 Number11 Communications of the ACM 843 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e486b275-1bc0-49c3-ae9c-0f8b7a10216a/images/d5443d5e-152d-4666-a2b5-59a80218493b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041904Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=705fa9362c6c2da2cb8f5ab04453aac344ee517dfab9a29b28542802f9d4c685",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1067
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Maintaining Knowledge about Temporal Intervals\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "James F. Allen\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "November 1983"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "The text does not explicitly mention any specific location."
        }
      ]
    }
  }
}