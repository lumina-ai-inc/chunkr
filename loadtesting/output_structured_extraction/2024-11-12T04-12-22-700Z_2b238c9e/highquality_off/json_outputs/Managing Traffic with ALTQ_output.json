{
  "file_name": "Managing Traffic with ALTQ.pdf",
  "task_id": "201f6150-af06-4240-8a35-8dbcfd72ecd2",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "e880b905-2378-46c1-a4f7-1c21a0e756e7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "THE ADVANCED COMPUTING SYSTEMS ASSOCIATION\r\nThe following paper was originally published in the\r\nProceedings of the FREENIX Track:\r\n1999 USENIX Annual Technical Conference\r\nMonterey, California, USA, June 6–11, 1999\r\nManaging Traffic with ALTQ\r\nKenjiro Cho\r\nSony Computer Science Laboratories, Inc., Tokyo\r\n© 1999 by The USENIX Association\r\nAll Rights Reserved\r\nRights to individual papers remain with the author or the author's employer. Permission is granted for noncommercial\r\nreproduction of the work for educational or research purposes. This copyright notice must be included in the reproduced paper.\r\nUSENIX acknowledges all trademarks herein.\r\nFor more information about the USENIX Association:\r\nPhone: 1 510 528 8649 FAX: 1 510 548 5738\r\nEmail: office@usenix.org WWW: http://www.usenix.org",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/e880b905-2378-46c1-a4f7-1c21a0e756e7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1bd810fb042f8d8338a771a778249ff2614281ff0d804af75474b99691ef87d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 112
      },
      {
        "segments": [
          {
            "segment_id": "20c1fb19-775a-4762-a90d-89eb8270337d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Managing Traffic with ALTQ\r\nKenjiro Cho\r\nSony Computer Science Laboratories, Inc.\r\nTokyo, Japan 1410022\r\nkjc@csl.sony.co.jp\r\nAbstract\r\nALTQ is a package for traffic management. ALTQ\r\nincludes a queueing framework and several advanced\r\nqueueing disciplines such as CBQ, RED, WFQ and RIO.\r\nALTQ also supports RSVP and diffserv. ALTQ can be\r\nconfigured in a variety of ways for both research and op\u0002eration. However, it requires understanding of the tech\u0002nologies to set up things correctly. In this paper, I sum\u0002marize the design trade-offs, the available technologies\r\nand their limitations, and how they can be applied to typ\u0002ical network settings.\r\n1 Queueing Basics\r\nEssentially, every traffic management scheme involves\r\nqueue management. A large number of queueing dis\u0002ciplines have been proposed to date in order to meet con\u0002tradictory requirements such as fairness, protection, per\u0002formance bounds, ease of implementation or administra\u0002tion.\r\n1.1 Queueing Components\r\nFigure 1 illustrates queueing related functional blocks on\r\na router. Each functional block could be needed to build\r\na certain service but is not always required for other ser\u0002vices. In fact, most routers currently in use do not have\r\nall the functional blocks.\r\nPackets arrive at one interface of the router (ingress\r\ninterface), and then, are forwarded to another interface\r\n(egress interface). A router could have functional blocks\r\nin the ingress interface to police incoming packets but\r\nthe main functional blocks reside in the egress interface.\r\nThe function of each block is described below.\r\nClassifier Packet classifiers categorizes packets based\r\non the content of some portion of the packet header.\r\n(e.g., addresses and port numbers). Packets match\u0002ing some specified rule are classified for further pro\u0002cessing.\r\nMeters Traffic meters measure the properties of a traf\u0002fic stream (e.g., bandwidth, packet counts). The\r\nmeasured characteristics are stored as flow state and\r\nused by other functions.\r\nMarkers Packet markers set a particular value to some\r\nportion of the packet header. The written values\r\ncould be a priority, congestion information, an ap\u0002plication type, or other types of information.\r\nDroppers Droppers discard some or all of the packets\r\nin a traffic stream in order to limit the queue length,\r\nor as an implicit congestion notification.\r\nQueues Queues are finite buffers to store backlogged\r\npackets. A queueing discipline could have multiple\r\nqueues for different traffic classes.\r\nSchedulers Schedulers select a packet to transmit from\r\nthe backlogged packets in the queue.\r\nShapers Shapers delay some or all of the packets in a\r\ntraffic stream in order to limit the peak rate of the\r\nstream. A shaper usually has a finite-size buffer, and\r\npackets may be discarded if there is not sufficient\r\nbuffer space to hold the delayed packets.\r\nA queueing discipline is, in general, defined as a set of\r\nthe functional blocks at the egress interface, and usually\r\nconsists of a specific queue structure, a scheduling mech\u0002anism and a dropper mechanism. However, the func\u0002tional blocks described here are conceptual and a wide\r\nvariety of combinations are possible.\r\n1.2 Queueing Disciplines\r\nBandwidth allocation is one of the most important goals\r\nof a queueing discipline. Fair or preferential band\u0002width allocation can be achieved by using an appropriate\r\nqueueing discipline. The same mechanism also isolates\r\na misbehaving flow, and thus, protects other traffic.\r\n1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/20c1fb19-775a-4762-a90d-89eb8270337d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2a763abae288df157620abc573b4180d2da8713a7222977a8f89d011059a9e75",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 521
      },
      {
        "segments": [
          {
            "segment_id": "20c1fb19-775a-4762-a90d-89eb8270337d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Managing Traffic with ALTQ\r\nKenjiro Cho\r\nSony Computer Science Laboratories, Inc.\r\nTokyo, Japan 1410022\r\nkjc@csl.sony.co.jp\r\nAbstract\r\nALTQ is a package for traffic management. ALTQ\r\nincludes a queueing framework and several advanced\r\nqueueing disciplines such as CBQ, RED, WFQ and RIO.\r\nALTQ also supports RSVP and diffserv. ALTQ can be\r\nconfigured in a variety of ways for both research and op\u0002eration. However, it requires understanding of the tech\u0002nologies to set up things correctly. In this paper, I sum\u0002marize the design trade-offs, the available technologies\r\nand their limitations, and how they can be applied to typ\u0002ical network settings.\r\n1 Queueing Basics\r\nEssentially, every traffic management scheme involves\r\nqueue management. A large number of queueing dis\u0002ciplines have been proposed to date in order to meet con\u0002tradictory requirements such as fairness, protection, per\u0002formance bounds, ease of implementation or administra\u0002tion.\r\n1.1 Queueing Components\r\nFigure 1 illustrates queueing related functional blocks on\r\na router. Each functional block could be needed to build\r\na certain service but is not always required for other ser\u0002vices. In fact, most routers currently in use do not have\r\nall the functional blocks.\r\nPackets arrive at one interface of the router (ingress\r\ninterface), and then, are forwarded to another interface\r\n(egress interface). A router could have functional blocks\r\nin the ingress interface to police incoming packets but\r\nthe main functional blocks reside in the egress interface.\r\nThe function of each block is described below.\r\nClassifier Packet classifiers categorizes packets based\r\non the content of some portion of the packet header.\r\n(e.g., addresses and port numbers). Packets match\u0002ing some specified rule are classified for further pro\u0002cessing.\r\nMeters Traffic meters measure the properties of a traf\u0002fic stream (e.g., bandwidth, packet counts). The\r\nmeasured characteristics are stored as flow state and\r\nused by other functions.\r\nMarkers Packet markers set a particular value to some\r\nportion of the packet header. The written values\r\ncould be a priority, congestion information, an ap\u0002plication type, or other types of information.\r\nDroppers Droppers discard some or all of the packets\r\nin a traffic stream in order to limit the queue length,\r\nor as an implicit congestion notification.\r\nQueues Queues are finite buffers to store backlogged\r\npackets. A queueing discipline could have multiple\r\nqueues for different traffic classes.\r\nSchedulers Schedulers select a packet to transmit from\r\nthe backlogged packets in the queue.\r\nShapers Shapers delay some or all of the packets in a\r\ntraffic stream in order to limit the peak rate of the\r\nstream. A shaper usually has a finite-size buffer, and\r\npackets may be discarded if there is not sufficient\r\nbuffer space to hold the delayed packets.\r\nA queueing discipline is, in general, defined as a set of\r\nthe functional blocks at the egress interface, and usually\r\nconsists of a specific queue structure, a scheduling mech\u0002anism and a dropper mechanism. However, the func\u0002tional blocks described here are conceptual and a wide\r\nvariety of combinations are possible.\r\n1.2 Queueing Disciplines\r\nBandwidth allocation is one of the most important goals\r\nof a queueing discipline. Fair or preferential band\u0002width allocation can be achieved by using an appropriate\r\nqueueing discipline. The same mechanism also isolates\r\na misbehaving flow, and thus, protects other traffic.\r\n1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/20c1fb19-775a-4762-a90d-89eb8270337d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2a763abae288df157620abc573b4180d2da8713a7222977a8f89d011059a9e75",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 521
      },
      {
        "segments": [
          {
            "segment_id": "aae9bcbc-87a7-4faf-9f34-ef56ed337851",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "classifier\r\nqueues\r\nshaper\r\ndropper\r\nmarker\r\nmeter\r\ndropper\r\nmarker\r\nscheduler forwarding\r\ningress interface egress interface\r\nclassifier\r\nFigure 1: Queueing Architecture\r\nAnother important goal is to control delay and jitter\r\nthat are critical to emerging real-time applications. It\r\nis possible to bound the delay and jitter of a flow by\r\nreserving the necessary network resources. Admission\r\ncontrol is required to decide whether requested resources\r\ncan be allocated. It is also needed to regulate the rate of\r\nthe reserved flow by means of shaping. The incoming\r\nrate should be less than the reserved rate to avoid delay\r\ncaused by the flow’s own traffic. A leaky bucket is a\r\nsimple shaper mechanism with a finite buffer size. An\u0002other popular shaper mechanism is a token bucket that al\u0002lows small bursts with a configurable burst size. The to\u0002ken bucket can accommodate traffic streams with bursty\r\ncharacteristics so it is more suitable for the current Inter\u0002net traffic.\r\nYet another goal of a queueing discipline is congestion\r\navoidance. TCP considers packet loss as a sign of con\u0002gestion. A router can notify TCP of congestion implicitly\r\nby intentionally dropping a packet.\r\nThe following list describes representative queueing\r\ndisciplines.\r\nFIFO The simplest possible queueing discipline is\r\nFIFO (First-In-First-Out) that has only a single\r\nqueue and a simple drop-tail dropper.\r\nPQ PQ (Priority Queueing) has multiple queues associ\u0002ated with different priorities. A queue with a higher\r\npriority is always served first. Priority queueing is\r\nthe simplest form of preferential queueing. How\u0002ever, low priority traffic easily starves unless there\r\nis a mechanism to regulate high priority traffic.\r\nWFQ WFQ (Weighted Fair Queueing) [11, 4, 8] is a dis\u0002cipline that assigns an independent queue for each\r\nflow. WFQ can provide fair bandwidth allocation in\r\ntimes of congestion, and protects a flow from other\r\nflows. A weight can be assigned to each queue to\r\ngive a different proportion of the network capacity.\r\nSFQ SFQ (Stochastic Fairness Queueing) [10] is an ap\u0002proximation of WFQ. WFQ is difficult to imple\u0002ment because a large number of queues are required\r\nas the number of flows increases. In SFQ, a hash\r\nfunction is used to map a flow to one of a fixed set\r\nof queues, and thus, it is possible for two different\r\nflows to be mapped into the same queue.\r\nCBQ CBQ (Class Based Queueing) [7] achieves both\r\npartitioning and sharing of link bandwidth by hier\u0002archically structured classes. Each class has its own\r\nqueue and is assigned its share of bandwidth. CBQ\r\nis non-work conserving and can regulate bandwidth\r\nuse of a class. A child class can be configured to\r\nborrow bandwidth from its parent class as long as\r\nexcess bandwidth is available.\r\nRED RED (Random Early Detection) [6, 2] is a dropper\r\nmechanism that exercises packet dropping stochas\u0002tically according to the average queue length. RED\r\navoids traffic synchronization in which many TCPs\r\nlose packets at one time [5]. Also, RED makes\r\nTCPs keep the queue length short. RED is fair in\r\nthe sense that packets are dropped from flows with\r\na probability proportional to their buffer occupation.\r\nSince RED does not require per-flow state, it is con\u0002sidered scalable and suitable for backbone routers.\r\n1.3 Issues in Queueing\r\nAlthough there are a large number of mechanisms avail\u0002able for traffic management, there is no single mecha\u0002nism that satisfies a wide range of requirements. There\u0002fore, it is important to use appropriate mechanisms suit\u0002able for a purpose.\r\nIn addition, a mechanism can have quite different ef\u0002fects depending on how it is used. For example, WFQ for\r\nbest effort traffic can provide fair bandwidth allocation.\r\nA certain portion of the link capacity can be reserved by\r\nconfiguring the weight and the classifier of WFQ. Fur\u0002ther, the delay can be bounded by adding a token bucket\r\nto the traffic source.\r\nFurthermore, it is not easy to combine different mech\u0002anisms in a coherent manner because different mecha\u0002nisms are independently developed to meet the require\u0002ments of specific applications.\r\n2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/aae9bcbc-87a7-4faf-9f34-ef56ed337851.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=33455b576827c006736d4ed6651638b95d750ee2b44344ea09aded21546ce0a4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 645
      },
      {
        "segments": [
          {
            "segment_id": "aae9bcbc-87a7-4faf-9f34-ef56ed337851",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "classifier\r\nqueues\r\nshaper\r\ndropper\r\nmarker\r\nmeter\r\ndropper\r\nmarker\r\nscheduler forwarding\r\ningress interface egress interface\r\nclassifier\r\nFigure 1: Queueing Architecture\r\nAnother important goal is to control delay and jitter\r\nthat are critical to emerging real-time applications. It\r\nis possible to bound the delay and jitter of a flow by\r\nreserving the necessary network resources. Admission\r\ncontrol is required to decide whether requested resources\r\ncan be allocated. It is also needed to regulate the rate of\r\nthe reserved flow by means of shaping. The incoming\r\nrate should be less than the reserved rate to avoid delay\r\ncaused by the flow’s own traffic. A leaky bucket is a\r\nsimple shaper mechanism with a finite buffer size. An\u0002other popular shaper mechanism is a token bucket that al\u0002lows small bursts with a configurable burst size. The to\u0002ken bucket can accommodate traffic streams with bursty\r\ncharacteristics so it is more suitable for the current Inter\u0002net traffic.\r\nYet another goal of a queueing discipline is congestion\r\navoidance. TCP considers packet loss as a sign of con\u0002gestion. A router can notify TCP of congestion implicitly\r\nby intentionally dropping a packet.\r\nThe following list describes representative queueing\r\ndisciplines.\r\nFIFO The simplest possible queueing discipline is\r\nFIFO (First-In-First-Out) that has only a single\r\nqueue and a simple drop-tail dropper.\r\nPQ PQ (Priority Queueing) has multiple queues associ\u0002ated with different priorities. A queue with a higher\r\npriority is always served first. Priority queueing is\r\nthe simplest form of preferential queueing. How\u0002ever, low priority traffic easily starves unless there\r\nis a mechanism to regulate high priority traffic.\r\nWFQ WFQ (Weighted Fair Queueing) [11, 4, 8] is a dis\u0002cipline that assigns an independent queue for each\r\nflow. WFQ can provide fair bandwidth allocation in\r\ntimes of congestion, and protects a flow from other\r\nflows. A weight can be assigned to each queue to\r\ngive a different proportion of the network capacity.\r\nSFQ SFQ (Stochastic Fairness Queueing) [10] is an ap\u0002proximation of WFQ. WFQ is difficult to imple\u0002ment because a large number of queues are required\r\nas the number of flows increases. In SFQ, a hash\r\nfunction is used to map a flow to one of a fixed set\r\nof queues, and thus, it is possible for two different\r\nflows to be mapped into the same queue.\r\nCBQ CBQ (Class Based Queueing) [7] achieves both\r\npartitioning and sharing of link bandwidth by hier\u0002archically structured classes. Each class has its own\r\nqueue and is assigned its share of bandwidth. CBQ\r\nis non-work conserving and can regulate bandwidth\r\nuse of a class. A child class can be configured to\r\nborrow bandwidth from its parent class as long as\r\nexcess bandwidth is available.\r\nRED RED (Random Early Detection) [6, 2] is a dropper\r\nmechanism that exercises packet dropping stochas\u0002tically according to the average queue length. RED\r\navoids traffic synchronization in which many TCPs\r\nlose packets at one time [5]. Also, RED makes\r\nTCPs keep the queue length short. RED is fair in\r\nthe sense that packets are dropped from flows with\r\na probability proportional to their buffer occupation.\r\nSince RED does not require per-flow state, it is con\u0002sidered scalable and suitable for backbone routers.\r\n1.3 Issues in Queueing\r\nAlthough there are a large number of mechanisms avail\u0002able for traffic management, there is no single mecha\u0002nism that satisfies a wide range of requirements. There\u0002fore, it is important to use appropriate mechanisms suit\u0002able for a purpose.\r\nIn addition, a mechanism can have quite different ef\u0002fects depending on how it is used. For example, WFQ for\r\nbest effort traffic can provide fair bandwidth allocation.\r\nA certain portion of the link capacity can be reserved by\r\nconfiguring the weight and the classifier of WFQ. Fur\u0002ther, the delay can be bounded by adding a token bucket\r\nto the traffic source.\r\nFurthermore, it is not easy to combine different mech\u0002anisms in a coherent manner because different mecha\u0002nisms are independently developed to meet the require\u0002ments of specific applications.\r\n2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/aae9bcbc-87a7-4faf-9f34-ef56ed337851.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=33455b576827c006736d4ed6651638b95d750ee2b44344ea09aded21546ce0a4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 645
      },
      {
        "segments": [
          {
            "segment_id": "a4aeeaed-5462-4b75-8475-0219f37bd489",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "The issues in designing queueing disciplines are de\u0002scribed below.\r\nOverhead Most of the functional blocks are located in\r\nthe packet forwarding path, and thus, adds some\r\noverhead to forwarding performance. A queueing\r\ndiscipline should require only a few simple opera\u0002tions to forward a packet in order to scale to a high\u0002speed network. It is also preferable to be easily im\u0002plemented in hardware.\r\nFlow Definition A flow is a unit that a classifier iden\u0002tifies packets in a traffic stream. A flow can be a\r\nmicro flow such as a single TCP session, or some\r\ntype of aggregated flow.\r\nPackets belonging to the same micro flow should be\r\nplaced in the same queue in order to avoid packet re\u0002ordering. Although TCP and other transport mech\u0002anisms can handle out-of-order packets, frequent\r\nout-of-order packets will considerably damage the\r\ntransport performance.\r\nClassifier Design The design of an efficient classifier is\r\nstill an area of active research. A scalable algorithm\r\nis required as the number of filters or the number\r\nof active flows increases. Efficient handling of wild\r\ncard filters is difficult because it needs to find a best\r\nmatch for multiple fields.\r\nClassifiers are required not only by queueing but\r\nalso by firewall, layer 4 forwarding, and traffic mon\u0002itoring. Classifiers should be designed to be shared\r\nby other components.\r\nTo identify traffic types by port numbers, a classi\u0002fier needs to check the transport header (e.g., TCP,\r\nUDP). However, port based classification is not\r\nalways possible if a packet is fragmented or en\u0002crypted. Although IP fragments will decrease by\r\nthe Path MTU Discovery, encrypted packets will be\r\ncommon with the widespread use of secure shells\r\nand IPsec.\r\nRequired States A queueing discipline needs to keep\r\nsome state for each traffic class. The size of a state\r\nand the total number of states have a great impact\r\nto the scalability of a queueing discipline. It is\r\nbelieved that per-flow queueing is preferable for a\r\nsmall network or at an edge of a backbone but only\r\naggregated-flow queueing is possible within a back\u0002bone network.\r\nA related issue is how long a flow state is main\u0002tained. A queueing discipline could keep only the\r\nstates of flows that have packets in the queue. On\r\nthe other hand, a discipline would need information\r\nfor a longer period to enforce a longer term rule.\r\nFairness Fairness is an important property to handle\r\nbest effort traffic. However, there are different def\u0002initions of fairness and different targets for whom\r\nfairness is defined. Local fairness at a router does\r\nnot necessarily lead to global fairness. Besides, net\u0002work traffic is dynamic and constantly changing so\r\nthat static fairness does not necessarily lead to fair\u0002ness in a larger time scale.\r\nNon-work Conserving Queues A work-conserving\r\ndiscipline is idle only when there is no packet\r\nawaiting service. A non-work conserving disci\u0002pline, on the other hand, can delay packets in the\r\nqueue; it can be considered as a form of a shaper.\r\nA non-work conserving queue is more complex to\r\nimplement but is able to limit the peak rate, reduce\r\njitters, and provide tighter performance bounds.\r\nStatistical Guarantee Performance guarantee can be\r\neither deterministic or statistic. In general, deter\u0002ministic guarantee requires a much larger fraction\r\nof the resources to be reserved than statistical guar\u0002antee. In practice, deterministic guarantee is dif\u0002ficult to implement because computer communica\u0002tion involves many mechanisms that do not have\r\ntight bounds.\r\n2 Traffic Management\r\nThere are people arguing that there are no need for QoS\r\ncontrol since bandwidth will be cheap and abundant in\r\nthe future. However, traffic management is not a choice\r\nbetween QoS and non-QoS but a wide rage of spectrum.\r\nFor example, at one extreme, every single packet could\r\nbe precisely controlled at every router. At the other ex\u0002treme, packets could be transferred even without flow\r\ncontrol. However, both approaches are too expensive to\r\nrealize and to manage so that they have no practical im\u0002portance.\r\nFor a properly provisioned network, queue manage\u0002ment could be considered as a precaution in case of con\u0002gestion. It also works as a protective measure against\r\nmisbehaving flows, misconfiguration, or misprovision\u0002ing. The effect of active queue management will not be\r\nso visible for such a properly provisioned network. How\u0002ever, it will virtually shift the starting point of congestion\r\nso that the effect is similar to increasing the link capacity.\r\nTraffic management needs a good balance between\r\ncontrolling and provisioning at each level and among dif\u0002ferent levels. It is important to find a balance point that is\r\ncost-effective as well as administratively easy to manage.\r\n2.1 Time Scale of Traffic Management\r\nTraffic management consists of a diverse set of mecha\u0002nisms and policies. Traffic management includes pric\u00023",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/a4aeeaed-5462-4b75-8475-0219f37bd489.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=df985410dc4906f909582caea93d188251e4dc7c8f140c46a1c5a5e961f630b9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "a4aeeaed-5462-4b75-8475-0219f37bd489",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "The issues in designing queueing disciplines are de\u0002scribed below.\r\nOverhead Most of the functional blocks are located in\r\nthe packet forwarding path, and thus, adds some\r\noverhead to forwarding performance. A queueing\r\ndiscipline should require only a few simple opera\u0002tions to forward a packet in order to scale to a high\u0002speed network. It is also preferable to be easily im\u0002plemented in hardware.\r\nFlow Definition A flow is a unit that a classifier iden\u0002tifies packets in a traffic stream. A flow can be a\r\nmicro flow such as a single TCP session, or some\r\ntype of aggregated flow.\r\nPackets belonging to the same micro flow should be\r\nplaced in the same queue in order to avoid packet re\u0002ordering. Although TCP and other transport mech\u0002anisms can handle out-of-order packets, frequent\r\nout-of-order packets will considerably damage the\r\ntransport performance.\r\nClassifier Design The design of an efficient classifier is\r\nstill an area of active research. A scalable algorithm\r\nis required as the number of filters or the number\r\nof active flows increases. Efficient handling of wild\r\ncard filters is difficult because it needs to find a best\r\nmatch for multiple fields.\r\nClassifiers are required not only by queueing but\r\nalso by firewall, layer 4 forwarding, and traffic mon\u0002itoring. Classifiers should be designed to be shared\r\nby other components.\r\nTo identify traffic types by port numbers, a classi\u0002fier needs to check the transport header (e.g., TCP,\r\nUDP). However, port based classification is not\r\nalways possible if a packet is fragmented or en\u0002crypted. Although IP fragments will decrease by\r\nthe Path MTU Discovery, encrypted packets will be\r\ncommon with the widespread use of secure shells\r\nand IPsec.\r\nRequired States A queueing discipline needs to keep\r\nsome state for each traffic class. The size of a state\r\nand the total number of states have a great impact\r\nto the scalability of a queueing discipline. It is\r\nbelieved that per-flow queueing is preferable for a\r\nsmall network or at an edge of a backbone but only\r\naggregated-flow queueing is possible within a back\u0002bone network.\r\nA related issue is how long a flow state is main\u0002tained. A queueing discipline could keep only the\r\nstates of flows that have packets in the queue. On\r\nthe other hand, a discipline would need information\r\nfor a longer period to enforce a longer term rule.\r\nFairness Fairness is an important property to handle\r\nbest effort traffic. However, there are different def\u0002initions of fairness and different targets for whom\r\nfairness is defined. Local fairness at a router does\r\nnot necessarily lead to global fairness. Besides, net\u0002work traffic is dynamic and constantly changing so\r\nthat static fairness does not necessarily lead to fair\u0002ness in a larger time scale.\r\nNon-work Conserving Queues A work-conserving\r\ndiscipline is idle only when there is no packet\r\nawaiting service. A non-work conserving disci\u0002pline, on the other hand, can delay packets in the\r\nqueue; it can be considered as a form of a shaper.\r\nA non-work conserving queue is more complex to\r\nimplement but is able to limit the peak rate, reduce\r\njitters, and provide tighter performance bounds.\r\nStatistical Guarantee Performance guarantee can be\r\neither deterministic or statistic. In general, deter\u0002ministic guarantee requires a much larger fraction\r\nof the resources to be reserved than statistical guar\u0002antee. In practice, deterministic guarantee is dif\u0002ficult to implement because computer communica\u0002tion involves many mechanisms that do not have\r\ntight bounds.\r\n2 Traffic Management\r\nThere are people arguing that there are no need for QoS\r\ncontrol since bandwidth will be cheap and abundant in\r\nthe future. However, traffic management is not a choice\r\nbetween QoS and non-QoS but a wide rage of spectrum.\r\nFor example, at one extreme, every single packet could\r\nbe precisely controlled at every router. At the other ex\u0002treme, packets could be transferred even without flow\r\ncontrol. However, both approaches are too expensive to\r\nrealize and to manage so that they have no practical im\u0002portance.\r\nFor a properly provisioned network, queue manage\u0002ment could be considered as a precaution in case of con\u0002gestion. It also works as a protective measure against\r\nmisbehaving flows, misconfiguration, or misprovision\u0002ing. The effect of active queue management will not be\r\nso visible for such a properly provisioned network. How\u0002ever, it will virtually shift the starting point of congestion\r\nso that the effect is similar to increasing the link capacity.\r\nTraffic management needs a good balance between\r\ncontrolling and provisioning at each level and among dif\u0002ferent levels. It is important to find a balance point that is\r\ncost-effective as well as administratively easy to manage.\r\n2.1 Time Scale of Traffic Management\r\nTraffic management consists of a diverse set of mecha\u0002nisms and policies. Traffic management includes pric\u00023",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/a4aeeaed-5462-4b75-8475-0219f37bd489.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=df985410dc4906f909582caea93d188251e4dc7c8f140c46a1c5a5e961f630b9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "1afe8251-fcbf-497d-8fc3-548d47bb35ba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "ing, capacity planning, end-to-end flow control, packet\r\nscheduling, and other factors. These cover different time\r\nscales and complement one another.\r\nThe time scale of queueing is a packet transmission\r\ntime. Queueing is effective to manage short bursts of\r\npackets. End-to-end flow control in turn manages the rate\r\nof a flow in a larger time scale. An important role of end\u0002to-end flow control is to keep the size of packet bursts\r\nsmall enough to be manageable by queueing. To this end,\r\nlarge capacity itself is of no use for managing bursts in\r\nthe packet level time scale. On the contrary, widening\r\ngap in link speed makes bursts larger and larger so that\r\nit makes managing traffic more important, especially at\r\nbandwidth gap points.\r\n2.2 Controlling Bottleneck Link\r\nTypically, bottleneck points are entries of WAN connec\u0002tions and they are the source of packet loss and delay.\r\nQueue management is most effective at those points.\r\nCongestion is often caused by a small number of bulk\r\ndata sessions (e.g., web images, ftp) so that isolating such\r\nsessions from other types of traffic will significantly im\u0002prove network performance. It also serves as a protective\r\nmeasure. On the other hand, RED will substantially im\u0002prove the performance of cooperative TCP sessions.\r\nThere are network administrators trying to keep the\r\nlink utilization as high as possible. However, queueing\r\ntheory tells us that the system performance drastically\r\ndrops if the link utilization becomes close to 100%. It is\r\na phenomenon that a queue is no longer able to absorb\r\nfluctuations in packet arrivals. Ideally, the link capacity\r\nshould be provisioned so that the average link utilization\r\nis under a certain point, say 80%.\r\nA difficulty in deploying queue management is that\r\nqueueing manages only outgoing traffic and the benefi\u0002ciaries are on the other side of a link. Queueing is not\r\nappropriate for managing incoming traffic because the\r\nqueue is almost always empty at the exit of a bottleneck.\r\nIn order to manage incoming traffic, queue management\r\nshould be placed at the other end of the WAN link but\r\nmost organizations do not have control over it.\r\n2.3 Queueing Delay\r\nNetwork engineers tend to focus on the forwarding per\u0002formance. That is, how many packets can be forwarded\r\nper second, or how long it takes to forward a single\r\npacket. However, once the forwarding overhead be\u0002comes less than a packet transmission time, the through\u0002put reaches the wire speed by a pipeline effect. Although\r\nfurther cutting down the overhead improves the delay, it\r\nhas no effect if the queue is not empty.\r\nOn the other hand, queueing delay (waiting time in the\r\nqueue) is by orders of magnitude larger than the forward\u0002ing delay. It implies that, if there is a bottleneck, high\u0002Table 1: Queueing Overhead Comparison\r\nFIFO FIFOQ RED WFQ CBQ CBQ\r\n+RED\r\n(usec) 0.0 0.14 1.62 1.95 10.72 11.97\r\nspeed forwarding does not improve the delay because\r\nmost of the delay comes from queueing delay. Thus, we\r\nshould pay closer attention to queueing delay, once the\r\nthroughput reaches the wire speed.\r\n2.4 Impact of Link Speed\r\nIt is important to understand how the effects and the over\u0002heads of queueing are related to the link speed. To illus\u0002trate the issues involved, Figure 2 plots packet transmis\u0002sion time and queueing delay on varying link speed in\r\nlog-log scale. min delay and packet delay show the re\u0002quired time to transmit a packet at the wire speed with\r\nthe packet size of 64 bytes and 1500 bytes, respectively.\r\nThese are the minimum time required to forward a packet\r\nby a store-and-forward method. worst delay shows the\r\nworst case queueing delay when the queue is full, as\u0002suming that the maximum queue length is 50 (the de\u0002fault value in BSD UNIX) and all packets are 1500-byte\r\nlong. On the other hand, Table 1 shows the per-packet\r\noverhead of different queueing disciplines measured on\r\na PentiumPro 200MHz machine [3].\r\nThe per-packet overhead of queueing is independent\r\nof link speed. By a simplistic analysis, queueing over\u0002head would be negligible if the per-packet overhead is\r\nless than min delay, and could be acceptable if the per\u0002packet overhead is less than packet delay. The overhead\r\nof CBQ is 10usec. It would be negligible up to 40Mbps\r\nand acceptable even at 1Gbps. The overhead of RED is\r\n1.6usec. It would be negligible up to 300Mbps.\r\nOn the other hand, the delay requirement of an appli\u0002cation is also independent of link speed. If an interac\u0002tive telnet session needs the latency to be less than 300\r\nmsec, preferential scheduling is required for link speed\r\nless than 1.5Mbps. If a voice stream needs the latency to\r\nbe less than 30 msec, preferential scheduling is required\r\nfor link speed less than 20Mbps.\r\nAlthough there are other performance factors and the\r\nanalysis is simplistic, it illustrates the effects of the link\r\nspeed on queueing. In summary, queueing does not\r\nhave significant overhead for commonly used link speed.\r\nPreferential scheduling improves interactive response on\r\na slow link, and improves real-time traffic on a medium\r\nspeed link.\r\n2.5 Building Services\r\nSo far, we have looked at the behavior of a single router.\r\nAn end-to-end service quality can be obtained by con\u00024",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/1afe8251-fcbf-497d-8fc3-548d47bb35ba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d4f2ebc3265465ebcc9b22d06a486c58d14ee00546af9f1cfaf10be07361e4fe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 852
      },
      {
        "segments": [
          {
            "segment_id": "1afe8251-fcbf-497d-8fc3-548d47bb35ba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "ing, capacity planning, end-to-end flow control, packet\r\nscheduling, and other factors. These cover different time\r\nscales and complement one another.\r\nThe time scale of queueing is a packet transmission\r\ntime. Queueing is effective to manage short bursts of\r\npackets. End-to-end flow control in turn manages the rate\r\nof a flow in a larger time scale. An important role of end\u0002to-end flow control is to keep the size of packet bursts\r\nsmall enough to be manageable by queueing. To this end,\r\nlarge capacity itself is of no use for managing bursts in\r\nthe packet level time scale. On the contrary, widening\r\ngap in link speed makes bursts larger and larger so that\r\nit makes managing traffic more important, especially at\r\nbandwidth gap points.\r\n2.2 Controlling Bottleneck Link\r\nTypically, bottleneck points are entries of WAN connec\u0002tions and they are the source of packet loss and delay.\r\nQueue management is most effective at those points.\r\nCongestion is often caused by a small number of bulk\r\ndata sessions (e.g., web images, ftp) so that isolating such\r\nsessions from other types of traffic will significantly im\u0002prove network performance. It also serves as a protective\r\nmeasure. On the other hand, RED will substantially im\u0002prove the performance of cooperative TCP sessions.\r\nThere are network administrators trying to keep the\r\nlink utilization as high as possible. However, queueing\r\ntheory tells us that the system performance drastically\r\ndrops if the link utilization becomes close to 100%. It is\r\na phenomenon that a queue is no longer able to absorb\r\nfluctuations in packet arrivals. Ideally, the link capacity\r\nshould be provisioned so that the average link utilization\r\nis under a certain point, say 80%.\r\nA difficulty in deploying queue management is that\r\nqueueing manages only outgoing traffic and the benefi\u0002ciaries are on the other side of a link. Queueing is not\r\nappropriate for managing incoming traffic because the\r\nqueue is almost always empty at the exit of a bottleneck.\r\nIn order to manage incoming traffic, queue management\r\nshould be placed at the other end of the WAN link but\r\nmost organizations do not have control over it.\r\n2.3 Queueing Delay\r\nNetwork engineers tend to focus on the forwarding per\u0002formance. That is, how many packets can be forwarded\r\nper second, or how long it takes to forward a single\r\npacket. However, once the forwarding overhead be\u0002comes less than a packet transmission time, the through\u0002put reaches the wire speed by a pipeline effect. Although\r\nfurther cutting down the overhead improves the delay, it\r\nhas no effect if the queue is not empty.\r\nOn the other hand, queueing delay (waiting time in the\r\nqueue) is by orders of magnitude larger than the forward\u0002ing delay. It implies that, if there is a bottleneck, high\u0002Table 1: Queueing Overhead Comparison\r\nFIFO FIFOQ RED WFQ CBQ CBQ\r\n+RED\r\n(usec) 0.0 0.14 1.62 1.95 10.72 11.97\r\nspeed forwarding does not improve the delay because\r\nmost of the delay comes from queueing delay. Thus, we\r\nshould pay closer attention to queueing delay, once the\r\nthroughput reaches the wire speed.\r\n2.4 Impact of Link Speed\r\nIt is important to understand how the effects and the over\u0002heads of queueing are related to the link speed. To illus\u0002trate the issues involved, Figure 2 plots packet transmis\u0002sion time and queueing delay on varying link speed in\r\nlog-log scale. min delay and packet delay show the re\u0002quired time to transmit a packet at the wire speed with\r\nthe packet size of 64 bytes and 1500 bytes, respectively.\r\nThese are the minimum time required to forward a packet\r\nby a store-and-forward method. worst delay shows the\r\nworst case queueing delay when the queue is full, as\u0002suming that the maximum queue length is 50 (the de\u0002fault value in BSD UNIX) and all packets are 1500-byte\r\nlong. On the other hand, Table 1 shows the per-packet\r\noverhead of different queueing disciplines measured on\r\na PentiumPro 200MHz machine [3].\r\nThe per-packet overhead of queueing is independent\r\nof link speed. By a simplistic analysis, queueing over\u0002head would be negligible if the per-packet overhead is\r\nless than min delay, and could be acceptable if the per\u0002packet overhead is less than packet delay. The overhead\r\nof CBQ is 10usec. It would be negligible up to 40Mbps\r\nand acceptable even at 1Gbps. The overhead of RED is\r\n1.6usec. It would be negligible up to 300Mbps.\r\nOn the other hand, the delay requirement of an appli\u0002cation is also independent of link speed. If an interac\u0002tive telnet session needs the latency to be less than 300\r\nmsec, preferential scheduling is required for link speed\r\nless than 1.5Mbps. If a voice stream needs the latency to\r\nbe less than 30 msec, preferential scheduling is required\r\nfor link speed less than 20Mbps.\r\nAlthough there are other performance factors and the\r\nanalysis is simplistic, it illustrates the effects of the link\r\nspeed on queueing. In summary, queueing does not\r\nhave significant overhead for commonly used link speed.\r\nPreferential scheduling improves interactive response on\r\na slow link, and improves real-time traffic on a medium\r\nspeed link.\r\n2.5 Building Services\r\nSo far, we have looked at the behavior of a single router.\r\nAn end-to-end service quality can be obtained by con\u00024",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/1afe8251-fcbf-497d-8fc3-548d47bb35ba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d4f2ebc3265465ebcc9b22d06a486c58d14ee00546af9f1cfaf10be07361e4fe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 852
      },
      {
        "segments": [
          {
            "segment_id": "982f50f7-9aac-42da-9008-358b0425daa8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "10K 100K 1M 10M 100M 1G\r\n1usec\r\n1msec\r\n1sec\r\n10ms\r\n100ms\r\n10sec\r\n100usec\r\n10usec\r\nworst delay\r\npacket delay\r\nmin delay\r\ntelnet delay limit\r\nvoice delay limit\r\nkernel timer\r\nCBQ overhad\r\nT1 Ethernet FastEther\r\nRED overhad\r\nTime\r\nLink Speed (bps)\r\nFigure 2: Queueing and Link Speed\r\ncatenating router behaviors along the communication\r\npath. For example, a traffic stream from user A to user\r\nB can be controlled such a way that the average rate is\r\n1Mbps, the peak rate is 3Mbps and the packet delay is\r\nless than 1msec.\r\nHowever, to make useful services, a network as a\r\nwhole should be properly configured in a consistent way.\r\nIn order to guarantee a service quality, it is necessary to\r\nconfigure all routers along the path and control all in\u0002coming traffic to these routers.\r\nThe diffserv working group at IETF is trying to es\u0002tablish a framework for various types of differentiated\r\nservices [1]. In the diffserv model, a network that sup\u0002ports a common set of services is called “DS domain”. A\r\nDS domain should be built in such a way that all incom\u0002ing packets are policed at the boundary. Incoming pack\u0002ets are classified, measured and marked according to the\r\nuser contract. These boundary actions are called “traf\u0002fic conditioning”. Inside a DS domain, internal routers\r\n(called DS interior nodes) perform preferential packet\r\nscheduling using only the packet header field (DS field)\r\nthat has been marked at the boundary.\r\nTraffic management mechanisms can be simpler in a\r\nclosed network that can police all incoming traffic at\r\nthe network boundary. For example, a simple priority\r\nqueueing discipline can provide a premium service if the\r\namount of incoming premium traffic is limited to a small\r\nfraction of the capacity. On the other hand, most current\r\nIP networks do not follow such a closed network model\r\nso that no firm assumption can be made about incoming\r\ntraffic.\r\n3 ALTQ\r\nALTQ [3] is a framework for FreeBSD that introduces a\r\nvariety of queueing disciplines. ALTQ provides a plat\u0002form for traffic management related research. ALTQ\r\nalso makes active queue management available for op\u0002erational experience.\r\n3.1 Design\r\nThe basic design of ALTQ is quite simple; the queue\u0002ing interface is designed as a switch to a set of queueing\r\ndisciplines as shown in Figure 3. To implement ALTQ,\r\nseveral fields are added to struct ifnet. The added fields\r\nare a discipline type, a common state field, a pointer to\r\na discipline specific state, and pointers to discipline spe\u0002cific enqueue/dequeue functions.\r\nThe implementation policy of ALTQ is to make min\u0002imal changes to the existing code. The current kernel,\r\nhowever, does not have queueing abstraction enough to\r\nimplement various types of queueing disciplines. As a\r\nresult, there are many parts of the kernel code that as\u0002sume FIFO queueing and the ifqueue structure.\r\nEspecially, it is problematic that many drivers directly\r\nuse the ifqueue structure, if snd, in the ifnet structure.\r\nThese drivers must be modified but it is not easy to mod\u0002ify all the existing drivers. Therefore, we took an ap\u0002proach that allows both modified drivers and unmodified\r\ndrivers to coexist so that we can modify only the drivers\r\nwe need, and incrementally add supported drivers.\r\n5",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/982f50f7-9aac-42da-9008-358b0425daa8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1cd0596bf5bef2921b2d25ebdbd21d82fd44410aaf88ba817e8731794be72fd4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 523
      },
      {
        "segments": [
          {
            "segment_id": "982f50f7-9aac-42da-9008-358b0425daa8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "10K 100K 1M 10M 100M 1G\r\n1usec\r\n1msec\r\n1sec\r\n10ms\r\n100ms\r\n10sec\r\n100usec\r\n10usec\r\nworst delay\r\npacket delay\r\nmin delay\r\ntelnet delay limit\r\nvoice delay limit\r\nkernel timer\r\nCBQ overhad\r\nT1 Ethernet FastEther\r\nRED overhad\r\nTime\r\nLink Speed (bps)\r\nFigure 2: Queueing and Link Speed\r\ncatenating router behaviors along the communication\r\npath. For example, a traffic stream from user A to user\r\nB can be controlled such a way that the average rate is\r\n1Mbps, the peak rate is 3Mbps and the packet delay is\r\nless than 1msec.\r\nHowever, to make useful services, a network as a\r\nwhole should be properly configured in a consistent way.\r\nIn order to guarantee a service quality, it is necessary to\r\nconfigure all routers along the path and control all in\u0002coming traffic to these routers.\r\nThe diffserv working group at IETF is trying to es\u0002tablish a framework for various types of differentiated\r\nservices [1]. In the diffserv model, a network that sup\u0002ports a common set of services is called “DS domain”. A\r\nDS domain should be built in such a way that all incom\u0002ing packets are policed at the boundary. Incoming pack\u0002ets are classified, measured and marked according to the\r\nuser contract. These boundary actions are called “traf\u0002fic conditioning”. Inside a DS domain, internal routers\r\n(called DS interior nodes) perform preferential packet\r\nscheduling using only the packet header field (DS field)\r\nthat has been marked at the boundary.\r\nTraffic management mechanisms can be simpler in a\r\nclosed network that can police all incoming traffic at\r\nthe network boundary. For example, a simple priority\r\nqueueing discipline can provide a premium service if the\r\namount of incoming premium traffic is limited to a small\r\nfraction of the capacity. On the other hand, most current\r\nIP networks do not follow such a closed network model\r\nso that no firm assumption can be made about incoming\r\ntraffic.\r\n3 ALTQ\r\nALTQ [3] is a framework for FreeBSD that introduces a\r\nvariety of queueing disciplines. ALTQ provides a plat\u0002form for traffic management related research. ALTQ\r\nalso makes active queue management available for op\u0002erational experience.\r\n3.1 Design\r\nThe basic design of ALTQ is quite simple; the queue\u0002ing interface is designed as a switch to a set of queueing\r\ndisciplines as shown in Figure 3. To implement ALTQ,\r\nseveral fields are added to struct ifnet. The added fields\r\nare a discipline type, a common state field, a pointer to\r\na discipline specific state, and pointers to discipline spe\u0002cific enqueue/dequeue functions.\r\nThe implementation policy of ALTQ is to make min\u0002imal changes to the existing code. The current kernel,\r\nhowever, does not have queueing abstraction enough to\r\nimplement various types of queueing disciplines. As a\r\nresult, there are many parts of the kernel code that as\u0002sume FIFO queueing and the ifqueue structure.\r\nEspecially, it is problematic that many drivers directly\r\nuse the ifqueue structure, if snd, in the ifnet structure.\r\nThese drivers must be modified but it is not easy to mod\u0002ify all the existing drivers. Therefore, we took an ap\u0002proach that allows both modified drivers and unmodified\r\ndrivers to coexist so that we can modify only the drivers\r\nwe need, and incrementally add supported drivers.\r\n5",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/982f50f7-9aac-42da-9008-358b0425daa8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1cd0596bf5bef2921b2d25ebdbd21d82fd44410aaf88ba817e8731794be72fd4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 523
      },
      {
        "segments": [
          {
            "segment_id": "0134210a-cbfb-438f-a37f-926eeba45643",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "ip_output\r\nif_output\r\nif_start\r\nif_snd alternative\r\ndiscipline 1\r\nalternative\r\ndiscipline 2\r\naltq_enqueue\r\naltq_dequeue\r\nIF_ENQUEUE\r\nIF_DEQUEUE\r\nFigure 3: Alternate Queueing Architecture\r\n3.1.1 Queueing Operations\r\nIn ALTQ, queueing disciplines have a common set of\r\nqueue operations. Other parts of the kernel code manipu\u0002late a queue through 4 queueing operations; enqueue, de\u0002queue, peek and flush. Drivers are modified to use only\r\nthese operations, and not to refer to the ifqueue structure.\r\nThe enqueue operation is responsible not only for\r\nqueueing a packet but also for other functions such as\r\nclassifier and dropper that are required to enqueue a\r\npacket.\r\nThe dequeue operation returns the next packet to\r\nsend. The main role of the dequeue operation is packet\r\nscheduling.\r\nThe peek operation is similar to the dequeue operation\r\nbut it does not remove the packet from the queue. The\r\npeek operation can be used by a driver to see if there\r\nis enough buffer space or DMA descriptors for the next\r\npacket. ALTQ does not have a prepend operation since\r\nprepending a packet does not make sense if a discipline\r\nhas multiple queues. Therefore, a driver should use a\r\npeek-and-dequeue policy if necessary.\r\nThe flush operation is used to empty the queue since\r\nnon-work conserving queues cannot be emptied by a\r\ndequeue-loop.\r\n3.1.2 Discipline Operations\r\nQueueing disciplines are controlled by ioctl system calls\r\nvia a queueing device (e.g., /dev/cbq). ALTQ is defined\r\nas a character device and each queueing discipline is de\u0002fined as a minor device of ALTQ.\r\nThere are 4 common operations to handle queueing\r\ndisciplines; attach, detach, enable, and disable. The at\u0002tach operation sets a queueing discipline to the specified\r\ninterface. An interface can have one queueing discipline\r\nattached at a time. The attached discipline is not ac\u0002tivated until the enable operation is performed. When\r\nthe alternative queueing is disabled or closed, the system\r\nfalls back to the original FIFO queueing.\r\nOther than these operations, each queueing discipline\r\nusually needs discipline specific settings, which are also\r\ndone via discipline specific ioctls.\r\n3.2 Using ALTQ\r\nALTQ implements several queueing disciplines includ\u0002ing CBQ, WFQ, RED, ECN, and RIO. For managing an\r\noperational network, CBQ will be the most appropriate\r\ndiscipline. CBQ is flexible to meet a wide range of re\u0002quirements and the implementation is stable and well\r\ntested. Moreover, the CBQ implementation also inte\u0002grates RED so that RED can be enabled for each CBQ\r\nclass. The detailed mechanism of CBQ can be found\r\nelsewhere [7, 12, 3].\r\nThere are implementation issues when using ALTQ\r\nfor different link speeds. These issues are described be\u0002low.\r\n3.2.1 Effect of Timer Resolution\r\nShapers are usually realized using timers, and thus, the\r\nresolution of a shaper is limited by the kernel timer res\u0002olution. The kernel timer resolution is 10msec in most\r\nUNIX systems. This implies that traffic becomes bursty\r\nif the packet transmission time of the link is less than\r\nthe kernel timer resolution. On 10Mbps Ethernet, a 1500\r\nbyte packet takes 1.2msec so that 8 packets can be sent\r\nduring a timer interval. 100Mbps FastEthernet is prob\u0002lematic since more than 80 packets can be sent during a\r\ntimer interval. Therefore, it is desirable to use a higher\r\nresolution for the kernel timer. Current PCs seem to have\r\nlittle overhead even if the timer resolution is increased by\r\na factor of 10.\r\nCBQ employs a more elaborate scheme to limit band\u0002width but it also has constraints from the timer resolu\u0002tion. In CBQ, an overlimit class is suspended until the\r\nstate becomes underlimit again. A suspended class can\r\nbe resumed from transmission complete interrupts but it\r\nrelies on a timeout in case that the class is not resumed\r\nfrom interrupts. CBQ also limits the number of back-to\u0002back packets by a variable maxburst. In the worst case\r\nscenario in which resuming is done only from timeouts,\r\nbandwidth of a class is limited by the timer resolution\r\nand maxburst. The default value of maxburst is 16; the\r\nvalue is selected to achieve 9.6Mbps on Ethernet with\r\nthe default timer resolution. However, it is only 1/10 of\r\nthe link capacity for FastEthernet. It is desirable to use a\r\nhigher timer resolution for FastEthernet; 1 msec resolu\u0002tion achieves 96Mbps.\r\nNote that the timer resolution affects only non-work\r\nconserving disciplines. Work-conserving disciplines do\r\n6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/0134210a-cbfb-438f-a37f-926eeba45643.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=720de204690c2a6993e09c7e437ec8149d89091a09996407c54e20f9f223c7cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 698
      },
      {
        "segments": [
          {
            "segment_id": "0134210a-cbfb-438f-a37f-926eeba45643",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "ip_output\r\nif_output\r\nif_start\r\nif_snd alternative\r\ndiscipline 1\r\nalternative\r\ndiscipline 2\r\naltq_enqueue\r\naltq_dequeue\r\nIF_ENQUEUE\r\nIF_DEQUEUE\r\nFigure 3: Alternate Queueing Architecture\r\n3.1.1 Queueing Operations\r\nIn ALTQ, queueing disciplines have a common set of\r\nqueue operations. Other parts of the kernel code manipu\u0002late a queue through 4 queueing operations; enqueue, de\u0002queue, peek and flush. Drivers are modified to use only\r\nthese operations, and not to refer to the ifqueue structure.\r\nThe enqueue operation is responsible not only for\r\nqueueing a packet but also for other functions such as\r\nclassifier and dropper that are required to enqueue a\r\npacket.\r\nThe dequeue operation returns the next packet to\r\nsend. The main role of the dequeue operation is packet\r\nscheduling.\r\nThe peek operation is similar to the dequeue operation\r\nbut it does not remove the packet from the queue. The\r\npeek operation can be used by a driver to see if there\r\nis enough buffer space or DMA descriptors for the next\r\npacket. ALTQ does not have a prepend operation since\r\nprepending a packet does not make sense if a discipline\r\nhas multiple queues. Therefore, a driver should use a\r\npeek-and-dequeue policy if necessary.\r\nThe flush operation is used to empty the queue since\r\nnon-work conserving queues cannot be emptied by a\r\ndequeue-loop.\r\n3.1.2 Discipline Operations\r\nQueueing disciplines are controlled by ioctl system calls\r\nvia a queueing device (e.g., /dev/cbq). ALTQ is defined\r\nas a character device and each queueing discipline is de\u0002fined as a minor device of ALTQ.\r\nThere are 4 common operations to handle queueing\r\ndisciplines; attach, detach, enable, and disable. The at\u0002tach operation sets a queueing discipline to the specified\r\ninterface. An interface can have one queueing discipline\r\nattached at a time. The attached discipline is not ac\u0002tivated until the enable operation is performed. When\r\nthe alternative queueing is disabled or closed, the system\r\nfalls back to the original FIFO queueing.\r\nOther than these operations, each queueing discipline\r\nusually needs discipline specific settings, which are also\r\ndone via discipline specific ioctls.\r\n3.2 Using ALTQ\r\nALTQ implements several queueing disciplines includ\u0002ing CBQ, WFQ, RED, ECN, and RIO. For managing an\r\noperational network, CBQ will be the most appropriate\r\ndiscipline. CBQ is flexible to meet a wide range of re\u0002quirements and the implementation is stable and well\r\ntested. Moreover, the CBQ implementation also inte\u0002grates RED so that RED can be enabled for each CBQ\r\nclass. The detailed mechanism of CBQ can be found\r\nelsewhere [7, 12, 3].\r\nThere are implementation issues when using ALTQ\r\nfor different link speeds. These issues are described be\u0002low.\r\n3.2.1 Effect of Timer Resolution\r\nShapers are usually realized using timers, and thus, the\r\nresolution of a shaper is limited by the kernel timer res\u0002olution. The kernel timer resolution is 10msec in most\r\nUNIX systems. This implies that traffic becomes bursty\r\nif the packet transmission time of the link is less than\r\nthe kernel timer resolution. On 10Mbps Ethernet, a 1500\r\nbyte packet takes 1.2msec so that 8 packets can be sent\r\nduring a timer interval. 100Mbps FastEthernet is prob\u0002lematic since more than 80 packets can be sent during a\r\ntimer interval. Therefore, it is desirable to use a higher\r\nresolution for the kernel timer. Current PCs seem to have\r\nlittle overhead even if the timer resolution is increased by\r\na factor of 10.\r\nCBQ employs a more elaborate scheme to limit band\u0002width but it also has constraints from the timer resolu\u0002tion. In CBQ, an overlimit class is suspended until the\r\nstate becomes underlimit again. A suspended class can\r\nbe resumed from transmission complete interrupts but it\r\nrelies on a timeout in case that the class is not resumed\r\nfrom interrupts. CBQ also limits the number of back-to\u0002back packets by a variable maxburst. In the worst case\r\nscenario in which resuming is done only from timeouts,\r\nbandwidth of a class is limited by the timer resolution\r\nand maxburst. The default value of maxburst is 16; the\r\nvalue is selected to achieve 9.6Mbps on Ethernet with\r\nthe default timer resolution. However, it is only 1/10 of\r\nthe link capacity for FastEthernet. It is desirable to use a\r\nhigher timer resolution for FastEthernet; 1 msec resolu\u0002tion achieves 96Mbps.\r\nNote that the timer resolution affects only non-work\r\nconserving disciplines. Work-conserving disciplines do\r\n6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/0134210a-cbfb-438f-a37f-926eeba45643.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=720de204690c2a6993e09c7e437ec8149d89091a09996407c54e20f9f223c7cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 698
      },
      {
        "segments": [
          {
            "segment_id": "f0612291-c346-4bcb-bc9b-51d2a71149a8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "not need timers since packets are sent from transmission\r\ncomplete interrupts.\r\n3.2.2 Difference in Network Cards\r\nSome cards generate interrupts every time a packet is\r\ntransmitted, and some generate interrupts only when the\r\nbuffer becomes empty. It is generally believed that a\r\nsmart network card should reduce interrupts to allevi\u0002ate CPU burden. However, a queueing discipline could\r\nhave finer grained control with frequent interrupts; it is\r\na trade-off between CPU control and CPU load. There\r\nis an interesting report that CBQ works much better with\r\nan old NE2000 card that interrupts a lot and has small\r\nbuffers.\r\n3.2.3 Device Buffers\r\nThere is a similar trade-off in setting the buffer size in\r\na network card. When delay is a concern on a slow\r\nlink, large buffers in network cards could adversely af\u0002fect queueing. For example, if a network card for a\r\n128Kbps link has a 16KB buffer, the buffer can hold 1\r\nsecond worth of packets. The device buffer has an ef\u0002fect of inserting another FIFO queue beneath a queueing\r\ndiscipline. This problem is invisible under FIFO but it\r\nbecomes apparent when preferential scheduling is used.\r\nThe transmission buffer size should be set to the min\u0002imum amount that is required to fill up the link. Al\u0002though it is not easy to automatically detect the appro\u0002priate buffer size, it seems that many drivers set an ex\u0002cessive buffer size.\r\n3.3 Availability\r\nA public release of ALTQ for FreeBSD, the source\r\ncode along with additional information, can be found at\r\nhttp://www.csl.sony.co.jp/person/kjc/software.html.\r\n4 Related Work\r\n4.1 Dummynet\r\nDummynet [9] is another popular mechanism available\r\nfor FreeBSD to limit bandwidth. Dummynet is originally\r\ndesigned to emulate a link with varying bandwidth and\r\ndelay, and realized as a set of 2-level shapers; the first\r\nlevel shaper enforces the bandwidth limit, and the second\r\nlevel shaper enforces the specified delay.\r\nDummynet has several advantages over ALTQ. Dum\u0002mynet is implemented solely in the IP layer so that it is\r\ndevice independent and no modification is necessary to\r\ndrivers. Because dummynet is a set of software shapers,\r\ndummynet can be used both on the input path and on the\r\noutput path. In addition, the classifier of dummynet is in\u0002tegrated into ipfw (the firewall mechanism of FreeBSD)\r\nso that it can be configured as part of firewall rules. Dum\u0002mynet also works with the Ethernet bridging mechanism.\r\nOn the other hand, there are disadvantages. The shaper\r\nmechanism is realized solely by the kernel timer so that\r\nthe shaper resolution is limited to the kernel timer res\u0002olution as described in Section 3.2.1. Although ALTQ\r\nshares the same limitation, ALTQ can take advantage of\r\ntransmission complete interrupts. Dummynet currently\r\ndoes not have a mechanism for packet scheduling nor ac\u0002tive buffer management. Dummynet does not work with\r\nthe fastforwarding mechanism that bypasses the normal\r\nIP forwarding path.\r\nIn summary, dummynet is good for simple bandwidth\r\nlimiting on moderate (Ethernet class) link speed, and it\r\nis easy to configure. There are great demands for band\u0002width control that fall into this category.\r\n4.2 Linux Traffic Control\r\nLinux has a traffic control (TC) framework since version\r\n2.1. The implemented queueing disciplines include CSZ,\r\nPQ, CBQ, RED and SFQ.\r\nLinux TC is similar to ALTQ in a number of ways.\r\nThe Linux TC framework has a switch of queueing dis\u0002ciplines and defines a set of queue operations. One minor\r\ndifference found in the queue operations is that Linux TC\r\ndefines “requeue” (prepend) instead of “peek”. Linux TC\r\nemploys a dequeue-and-requeue policy while ALTQ em\u0002ploys a peek-and-dequeue policy.\r\nThe architectural differences come from the kernel ar\u0002chitecture. That is, Linux has a network device layer and\r\nits sk buff has rich fields.\r\nLinux has a common network device layer that han\u0002dles link type specific processing and acts as an upper\r\nhalf of a driver. Queueing is done within this device layer\r\nso that TC requires changes only in this layer.\r\nIn BSD UNIX, there is no common code path between\r\nthe network layer and network device drivers. Opera\u0002tions are performed only through struct ifnet. As a result,\r\nthe ALTQ support is scattered in if output and if start.\r\nNote that it is not only ALTQ but also BPF and ether\u0002net bridging need supporting code in device drivers. In\r\nLinux, they are also supported in the common network\r\ndevice layer.\r\nLinux’s sk buff has many fields and have almost all\r\ninformation about a packet. A classifier can easily access\r\nnetwork layer or transport layer information.\r\nOn the other hand, mbuf of BSD UNIX carries no in\u0002formation about a packet. Though this design is good for\r\nenforcing network stack layering, a classifier needs to ex\u0002tract information from a packet itself by parsing headers.\r\nThese architectural differences illustrate the difference\r\nin their design philosophy. The network code of BSD\r\nUNIX has been successful with this minimalist approach.\r\n7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/f0612291-c346-4bcb-bc9b-51d2a71149a8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=63d2718b38b1af7ff0dce462f4c1eac84b471c8cc7a3824b854d80ec76b5cea4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 794
      },
      {
        "segments": [
          {
            "segment_id": "f0612291-c346-4bcb-bc9b-51d2a71149a8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "not need timers since packets are sent from transmission\r\ncomplete interrupts.\r\n3.2.2 Difference in Network Cards\r\nSome cards generate interrupts every time a packet is\r\ntransmitted, and some generate interrupts only when the\r\nbuffer becomes empty. It is generally believed that a\r\nsmart network card should reduce interrupts to allevi\u0002ate CPU burden. However, a queueing discipline could\r\nhave finer grained control with frequent interrupts; it is\r\na trade-off between CPU control and CPU load. There\r\nis an interesting report that CBQ works much better with\r\nan old NE2000 card that interrupts a lot and has small\r\nbuffers.\r\n3.2.3 Device Buffers\r\nThere is a similar trade-off in setting the buffer size in\r\na network card. When delay is a concern on a slow\r\nlink, large buffers in network cards could adversely af\u0002fect queueing. For example, if a network card for a\r\n128Kbps link has a 16KB buffer, the buffer can hold 1\r\nsecond worth of packets. The device buffer has an ef\u0002fect of inserting another FIFO queue beneath a queueing\r\ndiscipline. This problem is invisible under FIFO but it\r\nbecomes apparent when preferential scheduling is used.\r\nThe transmission buffer size should be set to the min\u0002imum amount that is required to fill up the link. Al\u0002though it is not easy to automatically detect the appro\u0002priate buffer size, it seems that many drivers set an ex\u0002cessive buffer size.\r\n3.3 Availability\r\nA public release of ALTQ for FreeBSD, the source\r\ncode along with additional information, can be found at\r\nhttp://www.csl.sony.co.jp/person/kjc/software.html.\r\n4 Related Work\r\n4.1 Dummynet\r\nDummynet [9] is another popular mechanism available\r\nfor FreeBSD to limit bandwidth. Dummynet is originally\r\ndesigned to emulate a link with varying bandwidth and\r\ndelay, and realized as a set of 2-level shapers; the first\r\nlevel shaper enforces the bandwidth limit, and the second\r\nlevel shaper enforces the specified delay.\r\nDummynet has several advantages over ALTQ. Dum\u0002mynet is implemented solely in the IP layer so that it is\r\ndevice independent and no modification is necessary to\r\ndrivers. Because dummynet is a set of software shapers,\r\ndummynet can be used both on the input path and on the\r\noutput path. In addition, the classifier of dummynet is in\u0002tegrated into ipfw (the firewall mechanism of FreeBSD)\r\nso that it can be configured as part of firewall rules. Dum\u0002mynet also works with the Ethernet bridging mechanism.\r\nOn the other hand, there are disadvantages. The shaper\r\nmechanism is realized solely by the kernel timer so that\r\nthe shaper resolution is limited to the kernel timer res\u0002olution as described in Section 3.2.1. Although ALTQ\r\nshares the same limitation, ALTQ can take advantage of\r\ntransmission complete interrupts. Dummynet currently\r\ndoes not have a mechanism for packet scheduling nor ac\u0002tive buffer management. Dummynet does not work with\r\nthe fastforwarding mechanism that bypasses the normal\r\nIP forwarding path.\r\nIn summary, dummynet is good for simple bandwidth\r\nlimiting on moderate (Ethernet class) link speed, and it\r\nis easy to configure. There are great demands for band\u0002width control that fall into this category.\r\n4.2 Linux Traffic Control\r\nLinux has a traffic control (TC) framework since version\r\n2.1. The implemented queueing disciplines include CSZ,\r\nPQ, CBQ, RED and SFQ.\r\nLinux TC is similar to ALTQ in a number of ways.\r\nThe Linux TC framework has a switch of queueing dis\u0002ciplines and defines a set of queue operations. One minor\r\ndifference found in the queue operations is that Linux TC\r\ndefines “requeue” (prepend) instead of “peek”. Linux TC\r\nemploys a dequeue-and-requeue policy while ALTQ em\u0002ploys a peek-and-dequeue policy.\r\nThe architectural differences come from the kernel ar\u0002chitecture. That is, Linux has a network device layer and\r\nits sk buff has rich fields.\r\nLinux has a common network device layer that han\u0002dles link type specific processing and acts as an upper\r\nhalf of a driver. Queueing is done within this device layer\r\nso that TC requires changes only in this layer.\r\nIn BSD UNIX, there is no common code path between\r\nthe network layer and network device drivers. Opera\u0002tions are performed only through struct ifnet. As a result,\r\nthe ALTQ support is scattered in if output and if start.\r\nNote that it is not only ALTQ but also BPF and ether\u0002net bridging need supporting code in device drivers. In\r\nLinux, they are also supported in the common network\r\ndevice layer.\r\nLinux’s sk buff has many fields and have almost all\r\ninformation about a packet. A classifier can easily access\r\nnetwork layer or transport layer information.\r\nOn the other hand, mbuf of BSD UNIX carries no in\u0002formation about a packet. Though this design is good for\r\nenforcing network stack layering, a classifier needs to ex\u0002tract information from a packet itself by parsing headers.\r\nThese architectural differences illustrate the difference\r\nin their design philosophy. The network code of BSD\r\nUNIX has been successful with this minimalist approach.\r\n7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/f0612291-c346-4bcb-bc9b-51d2a71149a8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=63d2718b38b1af7ff0dce462f4c1eac84b471c8cc7a3824b854d80ec76b5cea4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 794
      },
      {
        "segments": [
          {
            "segment_id": "4d26c12c-27e5-4960-a7f4-f1b23f494d5d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "However, BSD UNIX might need to redesign the cur\u0002rent abstraction in the future. An abstracted network de\u0002vice will make extensions easier and keep drivers sim\u0002pler. There are other possible extensions to the interface\r\nlevel such as sub-interfaces for VLAN and virtual inter\u0002faces for multi-link. Also, various optimizations will be\r\npossible if packet information can be tagged to mbuf.\r\n5 Conclusion\r\nThere are increasing demands and expectations for net\u0002work traffic management. Although a variety of tech\u0002nologies are available, there is no single mechanism that\r\nsatisfies a wide range of requirements. It is important to\r\nunderstand advantages and limitations of different mech\u0002anisms.\r\nIt is also important to understand the system bottle\u0002neck for different link speeds. With a network ranging\r\nfrom a slow modem to a high-speed fiber, the system bot\u0002tleneck shifts one place to another. The requirements for\r\nthe hardware and the system configuration also change.\r\nThe behaviors of single queueing disciplines are well\r\nunderstood but interaction of different mechanisms, es\u0002pecially in operational settings, needs more study and\r\nexperience. We hope ALTQ will be of use to gain ex\u0002perience in the field.\r\nReferences\r\n[1] S. Blake, D. Black, M. Carlson, E. Davies,\r\nZ. Wang, and W. Weiss. An architecture for differ\u0002entiated services. RFC 2475, Internet Engineering\r\nTask Force, December 1998.\r\n[2] B. Braden, D. Clark, J. Crowcroft, B. Davie,\r\nS. Deering, D. Estrin, S. Floyd, V. Jacob\u0002son, G. Minshall, C. Partridge, K. L. Peterson,\r\nS. Shenker Ramakrishnan, J. Wroclawski, and\r\nL. Zhang. Recommendations on queue manage\u0002ment and congestion avoidance in the internet.\r\nRFC 2309, Internet Engineering Task Force, April\r\n1998.\r\n[3] Kenjiro Cho. A Framework for Alternate Queue\u0002ing: Towards Traffic Management by PC-UNIX\r\nBased Routers. In USENIX 1998 Annual Techni\u0002cal Conference, pages 247–258, June 1998.\r\n[4] Alan Demers, Srinivasan Keshav, and Scott\r\nShenker. Analysis and simulation of a fair queue\u0002ing algorithm. In Proceedings of SIGCOMM ’89\r\nSymposium, pages 1–12, Austin, Texas, September\r\n1989.\r\n[5] S. Floyd and V. Jacobson. Traffic phase effects in\r\npacket-switched gateways. Computer Comunica\u0002tion Review, 21(2):26–42, April 1991.\r\n[6] Sally Floyd and Van Jacobson. Random early\r\ndetection gateways for congestion avoidance.\r\nIEEE/ACM Transaction on Networking, 1(4):397–\r\n413, August 1993. Also available from http://www.\r\naciri.org/floyd/papers.html.\r\n[7] Sally Floyd and Van Jacobson. Link-sharing and\r\nresource management models for packet networks.\r\nIEEE/ACM Transactions on Networking, 3(4), Au\u0002gust 1995. Also available from http://www.aciri.\r\norg/floyd/papers.html.\r\n[8] Srinivasan Keshav. On the efficient implementation\r\nof fair queueing. Internetworking: Research and\r\nExperience, 2:157–173, September 1991.\r\n[9] Rizzo L. Dummynet: A simple approach to the\r\nevaluation of network protocols. Computer Comu\u0002nication Review, 27(1):31–41, April 1997. Also\r\navailable from http://www.iet.unipi.it/\u0018luigi/.\r\n[10] P. E. McKenney. Stochastic fairness queueing. In\r\nProceedings of INFOCOM, San Francisco, Califor\u0002nia, June 1990.\r\n[11] John Nagle. On packet switches with infinite stor\u0002age. IEEE Trans. on Comm., 35(4), April 1987.\r\n[12] Ian Wakeman, Atanu Ghosh, Jon Crowcroft, Van\r\nJacobson, and Sally Floyd. Implementing real-time\r\npacket forwarding policies using streams. In Pro\u0002ceedings of USENIX ’95, pages 71–82, New Or\u0002leans, Louisiana, January 1995.\r\n8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/201f6150-af06-4240-8a35-8dbcfd72ecd2/images/4d26c12c-27e5-4960-a7f4-f1b23f494d5d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041931Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a15e04c5faff7544dc3e3b3e9b261bf0ebe66d389a00e348c8821283b8190aa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 485
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Managing Traffic with ALTQ\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "Kenjiro Cho\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "June 6–11, 1999\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "Monterey, California, USA\n"
        }
      ]
    }
  }
}