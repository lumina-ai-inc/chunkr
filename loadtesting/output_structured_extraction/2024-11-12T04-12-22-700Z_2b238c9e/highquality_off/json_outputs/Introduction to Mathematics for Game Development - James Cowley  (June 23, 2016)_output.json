{
  "file_name": "Introduction to Mathematics for Game Development - James Cowley  (June 23, 2016).pdf",
  "task_id": "6052d57a-acf0-4fdf-a2bf-2fb877fc6de9",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "fe46044d-c304-4d1f-a13c-d54a9c252aa4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Introduction to Mathematics for Game Development.\r\nJames Cowley\r\n(Dated: June 23, 2016)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/fe46044d-c304-4d1f-a13c-d54a9c252aa4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9860085325e33d3430745948f2f7826ea2bc5faef8a3ef0ec82b02a240267c3a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4aa94fa7-160f-42ab-bc1c-2d76997f264f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "2\r\nI. INTRODUCTION\r\nThis article is intended as an introduction to all the basic mathematical concepts you will need\r\nto understand for game development. It will make the assumption that you are someone who\r\nmaybe was never particularly good at maths, or who took maths classes so long ago that you can\r\nbarely remember them. Basically, I will not assume much prior knowledge of mathematics.\r\nThis guide obviously has it’s limitations; I will not be going into massive depth on any of these\r\nsubjects, or treating them with a high degree of rigour. So if you want to get some more details on\r\nany of the topics introduced here, I’ll be providing a reference list at the end.\r\nI’ll wrap up this section with a little bit about myself. I am currently studying physics at\r\nuniversity, in my third year, so maths is like a second language to me (I’m not very good at learning\r\nactual languages, though, unfortunately). I want to go into full-time game development once I\r\ngraduate, so I’ve been programming in my spare time, and there are a lot of cases where I have\r\ncome across other devs saying “I wish I understood matrices” or “what the hell is a quaternion?”.\r\nSo I decided to make this in the hopes that it would help someone out at some point.\r\nNow, on to the meat of the article.\r\nII. TRIGONOMETRY\r\nI’m sure many of you have traumatic memories of high school trigonometry lessons. That is\r\nfair enough, but trig lies at the heart of a large amount of game development, and maths as a whole.\r\nSo you are going to have to take this bull by the horns at some point. I will try to cover it in as\r\nnice a way as possible, though.\r\nFirstly: what is trigonometry? Well, it ultimately stems from the study of geometry, specifically\r\ntriangles. The overall idea is to relate angles to distances and vice versa. There are many different\r\ntrigonometric quantities, but there are six that you need to know about: sin, cos, tan, arcsin,\r\narccos, and arctan. They may sound very intimidating, but in reality they are pretty simple, if you\r\nhave a diagram to help, that is. If you turn your attention to Figure 1, you will see a construction\r\ncalled the “unit circle”. The word “unit” is one that crops up all the time in maths; it basically\r\nmeans “length = 1”. So the unit circle is a circle with a radius of one. Specifically “THE” unit\r\ncircle is the circle with radius one, and centred at the origin of whatever coordinate system you are\r\ndealing with.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/4aa94fa7-160f-42ab-bc1c-2d76997f264f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a4668c6fd663d13715a45271e608bd7768b059627cfebf819bbc99185d033c0f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 452
      },
      {
        "segments": [
          {
            "segment_id": "1c950db8-687c-403e-a2c8-8562cceb1d6c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "3\r\nFIG. 1. The unit circle for trigonometry.\r\nLet us take a look at that triangle marked on the figure. You can see the sides are marked “O”,\r\n“H” and “A”. These stand for “Opposite”, “Hypotenuse” and “Adjacent”. So the “opposite” side\r\nis opposite the angle θ, the “adjacent” side is next to it, and the “hypotenuse” is the longest side.\r\nYou may recall being taught in school the “SOH CAH TOA” mnemonic. That is simply a way to\r\nremember the following relations:\r\nsin(θ) = LO\r\nLH\r\n, cos(θ) = LA\r\nLH\r\n, tan(θ) = LO\r\nLA\r\n. (1)\r\nwhere LA, LO, LH are the lengths of each side of the triangle. If you bear these in mind, and\r\nthen look back at the unit circle, you will see that I have marked the y-axis as “sin” and the x-axis\r\nas “cos”. This is because the y coordinate of a point P on the circle is equal to the sin of the angle\r\nθ; this is easy to see, if you remember that the hypotenuse here is the radius of the circle, which is\r\njust 1.\r\nYou will also notice a line marked “tan”. Tan is the short name for “tangent”; a tangent is a\r\nline which joins a curve (in this case our unit circle) at one point only (in this case, (1, 0)). So if\r\nsin(θ) is the y coordinate of the point P on the circumference, and cos(θ) is the x coordinate, then\r\nwhat is tan(θ)? Well, that is the y coordinate of the point at which our line touches the tangent",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/1c950db8-687c-403e-a2c8-8562cceb1d6c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7bf84a417f8e9ab35f5564424b3acbe8ab56de3935e58dbac11ca02472fd94a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 265
      },
      {
        "segments": [
          {
            "segment_id": "f4ea0ab5-84cc-46a9-92c9-1600083b81bb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "4\r\n(note we’ll have to continue the line past the unit circle’s edge). Now the unit circle is not great\r\nfor finding the exact values of trig functions (except in special cases, such as θ = 90 degrees), but\r\ncan come in handy for estimation, and can also give you an intuitive understanding of why some\r\nthings occur in trigonometry. For example, if you have a quick look, you will note that if we let\r\nθ = 90 degrees, then sin(θ) = 1,cos(θ) = 0, but you will also notice that no matter how far we\r\ncontinue our line out, it will never touch the tangent line. so tan(θ) = ∞.\r\nSo, let us have an example: say you have an angle of 30 degrees and an adjacent side of length\r\n3 metres. What is the length of the hypotenuse? First, which of the three trig relations involves the\r\nhypotenuse and the adjacent? That would be cos. So the relation for cos is\r\ncos(θ) = LA\r\nLH\r\n(2)\r\nand we want to get LH. So we multiply both sides by LH:\r\nLHcos(θ) = LA, (3)\r\nthen divide both sides by cos(θ), to get LH on its own:\r\nLH =\r\nLA\r\ncos(θ)\r\n(4)\r\nand there we have it. We have the unknown (LH) in terms of known quantities. Plop these into\r\na calculator and we obtain 3.46 m (to 3 significant figures).\r\nThis is all well and good; but if you recall the start of this section, I mentioned six trig quantities.\r\nWhere do the “arc”s come in? Well, you may have noticed we have only dealt with finding a length,\r\ngiven a length and an angle. What if we want to find an angle, given two lengths? This is where\r\nthe arc quantities come into play. Arcsin is the “inverse” of the ‘sin function, and similarly for the\r\nother arcs. What does this mean, though? It means that arcsin “undoes” the action of sin. This\r\nwill be better illustrated with an example. Say we want to find the angle between the hypotenuse\r\nand the adjacent sides of a triangle. So we want arccos (remember SOH CAH TOA). Let us work\r\nthrough this step by step:\r\ncos(θ) = LA\r\nLH\r\n. (5)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/f4ea0ab5-84cc-46a9-92c9-1600083b81bb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=30ffb056504bd6d96cec818407bf988e3ee675a8d554a845fda11eae774082b6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "f45ffcb2-b27d-47af-a8c2-995a39298c4d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "5\r\nWe want just θ, so we want to undo the cos. So we apply arccos:\r\narccos(cos(θ)) = arccos(\r\nLA\r\nLH\r\n). (6)\r\nRemember that arccos removes the cos, so we just get θ on the left-hand side:\r\nθ = arccos(\r\nLA\r\nLH\r\n). (7)\r\nAnd then, again, the right-hand side is something you can do on a calculator (or in code, e.g.\r\nthe acos function in C/C++).\r\nNow, any discussion of angles is incomplete without discussing “radians”. The radian is a unit\r\nof angle, just like degrees, except far more useful in mathematics, physics, programming, and\r\neverything really. The basic low-down is that there are 2π radians in a circle, just as there are\r\n360 degrees in a circle. So to convert from degrees to radians, you divide by 180, then multiply\r\nby π. So, for example, 90 degrees is the same as π\r\n2\r\nradians. Radians are handy because a lot of\r\nmathematical results are neatest, or only work, in radians. So radians are good to know. Also,\r\nsome maths functions, e.g. in C and C++, only take radians as arguments, so you can get all the\r\nwrong results if you try using degrees. My advice is to use radians always, unless you have a\r\nspecific reason not to.\r\nAnd that is pretty much it for trigonometry. What do I think you should put emphasis on\r\nlearning? The unit circle, SOH CAH TOA, and radians. Learn those and you’re set. Note that\r\ntrigonometry goes a whole lot deeper than this, with the hyperbolic functions sinh, cosh, tanh\r\nand so on, but you are very unlikely to need them in game development.\r\nIII. CALCULUS\r\nCalculus is a key part of game programming, especially in physics programming. I am going\r\nto limit this to differential calculus, and you can research integral calculus on your own if you\r\nwish/need to.\r\nDifferential calculus is the study of rates. If you are familiar with gradients in geometry, then\r\nfinding the gradient of a line is simple differential calculus. You find the change in y, divide it\r\nby the change in x, and that is your gradient. But what if you have a curve? No straight lines\r\nthere. This is where you use differentiation. With a curve, we approximate it by assuming that the\r\ncurve is made up of an infinite number of infinitesimally small straight lines. Then we say that",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/f45ffcb2-b27d-47af-a8c2-995a39298c4d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=002528e62ef8116322e4e08f1027d9bdaf1f5d24c80188c205f9fa0a88ed2718",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 397
      },
      {
        "segments": [
          {
            "segment_id": "584bc879-e2c0-4b67-af30-04763a036a63",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "6\r\nthe gradient of the curve at a given point is the gradient of the straight line at that point. But how\r\ndo we work this out practically? Well, say we have a curve described by the equation (this is a\r\nparabola, if you are interested; parabolae come into play with projectiles such as balls or bullets):\r\ny = ax2, (8)\r\nwhere a is some constant. To differentiate this, we take the power of x (2 in this case) down,\r\nand multiply it with the a, then take one away from the power. That is,\r\ndy\r\ndx = 2ax1 = 2ax. (9)\r\nIn general:\r\nd\r\ndx(axn\r\n) = naxn−1. (10)\r\nwhere d\r\ndx is the “derivative with respect to x”. It’s as simple as that. From this, you can also\r\nsee how to reverse a differentiation, which is called “integration”. I’ll leave that as an exercise for\r\nthe reader.\r\nThat is pretty much all you need to know about calculus to be starting off with. There is a lot\r\nmore you can look into, and what you need to know will be dependent on what sort of things you\r\nwant to do. I urge you to look into integral calculus at least.\r\nIV. IMAGINARY NUMBERS\r\nImaginary numbers may sound very abstract, but they have many real-world uses, and under\u0002standing them is crucial to understanding quaternions (which we’ll be dealing with later), so I shall\r\ngive a quick introduction here.\r\nThe “imaginary unit”, i, is defined as\r\ni =\r\n√\r\n−1. (11)\r\nA “complex number” is a number which has an imaginary part and a real part. An imaginary\r\nnumber is usually denoted by z. So\r\nz = x + iy, (12)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/584bc879-e2c0-4b67-af30-04763a036a63.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdb9d0a9e4655e1d3d289ceb5f5b15571e9a0b2066b000ecef02095651e00734",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 281
      },
      {
        "segments": [
          {
            "segment_id": "fb15ab38-d793-4a5f-97cc-61541b7fa208",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "7\r\nwith x being the real component and y the imaginary component. To picture the complex\r\nnumbers, you can imagine the usual “real” number line, going from −∞ to ∞. Then, we add a\r\nsecond line at right-angles to that, to give us the “complex plane”, where the y-axis is the imaginary\r\naxis. In this plane, we represent the complex number z by a point with coordinates (x, y).\r\nIf you go back to the unit circle, you can see that we can represent a point in 2D space as a\r\ncombination of a sin and a cos term. This can be readily applied to complex numbers, to give us\r\nanother representation:\r\nz = |z|(cos(θ) + isin(θ)), (13)\r\nwhere |z| is the “magnitude” of z, i.e. the “length” of z, with\r\n|z| =\r\np\r\nx\r\n2 + y2\r\n. (14)\r\nThe sin, cos representation is called “Euler’s formula”, and provides a very nice geometric\r\ninterpretation of complex numbers. The final representation you will want to know is the complex\r\nexponential notation. I assume you are somewhat aware of the number e? If you are not, then it\r\nsuffices to say that e has the remarkable quality of being its own derivative:\r\nd\r\ndx(e\r\nx\r\n) = e\r\nx\r\n. (15)\r\nIn the realm of complex numbers, e has another use:\r\nz = x + iy = |z|e\r\niθ\r\n. (16)\r\nThis has an obvious advantage when dealing with differentiation, as differentiating an expo\u0002nential is pretty easy.\r\nThis is pretty much all you will need to know for game development, usually. However, if you\r\nare interested, do check out the internet for some really interesting information.\r\nV. VECTORS\r\nNow we get to the nitty-gritty of what game dev deals with.\r\nVectors are a type of mathematical object which have a size, or “magnitude”, and a direction.\r\nCompare that to normal numbers, which are called “scalars”. Those just have a size, and no",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/fb15ab38-d793-4a5f-97cc-61541b7fa208.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19014d60a00b5649f55228ad3e126a214da37b5a14ccac4ef2c67fe8a02b87c4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 321
      },
      {
        "segments": [
          {
            "segment_id": "da1ebba3-76a6-4adc-ad09-6c373028a020",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "8\r\ndirection. The difference is best seen in an example: temperature is a scalar; it makes no sense to\r\nsay “it is 15 degrees Celsius in the westerly direction”. An example of a vector is displacement,\r\nbasically the combination of the distance to something, and the direction to it (e.g. “To get to\r\nthat hill, walk 3 kilometres North-West”).\r\nVectors are represented mathematically in terms of components:\r\n~u = (x, y, z) = x~i + y~j + z\r\n~k (17)\r\nwhere x, y and z are the components of the vector ~u. ~i, ~j and ~k are the so-called “unit vectors”\r\n(there’s the word “unit” again). These are basically vectors with magnitude 1, pointing in the x,\r\nyand z directions respectively. These are strictly necessary because the (x, y, z) representation is\r\nambiguous; the x could mean x metres to the left, x metres to the slightly-left-and-behind-you, or\r\nsomething else entirely. The unit vectors tell you specifically which direction each component is\r\ngoing in.\r\nA. Basic Vector Arithmetic\r\nAdding and subtracting vectors is easy; you just go “component-wise”, i.e. adding the x com\u0002ponents, adding the ys and so on. You can also multiply and divide vectors by scalars; again we\r\ndo this component-wise, so 2~u = (2x, 2y, 2z). However, multiplying two vectors together is more\r\ncomplicated, as there are two ways in which we can do so: the dot (or “scalar”) product and the\r\ncross (“vector”) product.\r\nB. Dot Product\r\nAlso known as the scalar product, the result of this is a scalar. It basically tells us “how much”\r\nof vector ~u is pointing in the direction of ~v. You can think of this as “projecting” ~u onto ~v. How do\r\nwe calculate this? All we do is multiply the x components, the y components and z components,\r\nthen add the results together. Simple.\r\nBut where do we actually use this in game development? Well, we use it all over the goddamn\r\nplace, but two simple example are: you can use it to easily tell if two vectors are perpendicular\r\n(“orthogonal”) to each other; if they are, their dot product will be zero (which is easy to see if you",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/da1ebba3-76a6-4adc-ad09-6c373028a020.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8de9338a9daa8c28a398c6bebad1f4d61b6c2dda7ad076d19627270e8ae506a8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 361
      },
      {
        "segments": [
          {
            "segment_id": "8cb06e74-b026-4b74-a228-62821188454b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "9\r\nconsider the projection of one onto the other). Another simple way the dot product can be used is\r\nin calculating the magnitude of a vector. The magnitude of a three-dimensional vector is given by\r\n|~v| =\r\np\r\nx\r\n2 + y2 + z2\r\n. (18)\r\nNow, you could calculate that manually, but the better way to do it is to take the dot product\r\nof the vector with itself, and square-root that. This is better for two main reasons: firstly, it better\r\nrepresents the actual mathematical basis. The magnitude of a vector is strictly defined as\r\n|~v|\r\n2 = ~v · ~v. (19)\r\nSo using this method just better shows the underlying maths. The other main advantage is that\r\nit gives self-consistency. Ideally, when you are implementing maths in a program, you want it to\r\nbe self-consistent. For example (a simple one), you might want to define comparison operators !=\r\nand ==. Now, you could implement them completely separately, but the better way is to define\r\none in terms of the other. This means that if you do something wrong in programming the first,\r\nyou will at least get consistent results in the second; != will still return the opposite of ==, even if\r\n== returns the wrong result.\r\nI’ll finish this subsection off with a little bit of pseudocode illustrating how to do the dot prod\u0002uct, and how to use it in finding the magnitude of a vector:\r\nfunction Dot(Vector u , Vector v)\r\n{\r\nr e t u r n (u . x ∗ v . x + u . y ∗ v . y) ;\r\n}\r\nfunction Magnitude(Vector u)\r\n{\r\nr e t u r n (sqrt(Dot(u , u) ) ) ;\r\n}\r\nC. Cross Product\r\nThis is more complicated. This method is also referred to as the “vector product”, because it\r\nreturns (shock!) a vector. If the dot product may be thought of as the projection of one vector",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/8cb06e74-b026-4b74-a228-62821188454b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=67601804ba40db504213659b9abe456d40ce811b2bdc2f13245d4f2dc36f1271",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 324
      },
      {
        "segments": [
          {
            "segment_id": "aceb2b71-23ce-4c93-a168-ab0566f1510b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "10\r\nonto another, we can picture the cross product as being how much of the first vector is pointing\r\nperpendicular to the other. It returns a vector at right-angles to both the input vectors; this is very\r\nuseful throughout physics and game dev. But before we get to uses, let’s see how to calculate it.\r\nThere are two ways I use to remember how to do this: the first is more simple, while the second\r\nis more mathematically “rigorous”, as it were. The first method is to imagine a circular route with\r\n“x” at the twelve ‘o’ clock position, “y” at four and “z” at eight. Then imagine arrows going from\r\nx → y → z → x. In order to find the x component of the result, you multiply along the arrows to\r\nget to the x (so you go y times z) and then subtract back along the arrows (subtract z of the first\r\nvector times y of the second vector) and so on. This gets you\r\n~v × ~u = (vyuz − vzuy)~i + (vzux − vxuz)~j + (vxuy − vyux)\r\n~k. (20)\r\nThe other method for remembering it uses the determinant of a matrix, which I won’t go into\r\nhere.\r\nSo that is the cross product. Unwieldy, but mad useful. How do we use it in practice? One\r\nuse is in coordinate systems. A coordinate system is basically how you define your space; where\r\nthe origin (0, 0, 0) is, what direction is up, left, forward, and how you split your space up (you\r\ncan use the Cartesian grid style that you’ll be used to, which is a square/cubic grid, or you could\r\nuse polar coordinates of various sorts, which rely more on angles). Now for a coordinate space to\r\nwork, you need 3 (in 3D; 2 in 2D) orthogonal vectors. See where I’m going with this? If we define\r\nwhere up and left are, we can find the forward direction using the cross-product. This is handy\r\nas it reduces the memory footprint of our program (in a 3D engine each object needs a different\r\ncoordinate system, so reducing the number of vectors stored per coordinate system even by one\r\nis really helpful). We don’t mind the extra calculation, because memory tends to be slower these\r\ndays than computation.\r\nThe other major use is in rotational mechanics. For example, the vector torque on an object is\r\ngiven by the cross product between the force applied and the vector location at which the force is\r\napplied:\r\n~Γ = ~r × F . ~ (21)\r\nLet us again have a code snippet showing how we calculate our cross product:",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/aceb2b71-23ce-4c93-a168-ab0566f1510b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2eb6c53c2b3f8dd95bae0e4143a72f10bbab2f4b36a210a1206843d132ef830f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 441
      },
      {
        "segments": [
          {
            "segment_id": "e76950c2-77f5-43ca-ae3c-84ee5a3c0755",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "11\r\nfunction Cross(vector u , Vector v)\r\n{\r\nresX = (u . y ∗ v . z − u . z ∗ v . y) ;\r\nresY = (u . z ∗ v . x − u . x ∗ v . z) ;\r\nresZ = (u . x ∗ v . y − u . y ∗ v . x) ;\r\nr e t u r n Vector(resX , resY , resZ) ;\r\n}\r\nVI. MATRICES\r\nThis is where things really start to ramp up. We will start with the question: what is a matrix?\r\nWell, a matrix is an array of values which are related in some way. We can represent a vector in\r\nmatrix form, as either a row or a column. The main use of matrices is in what are called “linear\r\nsystems of equations”. That will sound mighty daunting, but basically it is a way of referring to a\r\nset of equations which are all simultaneously true, and which are coupled in some way (i.e. both\r\nequation 1 and equation 2 will have the variables x and y in them). This makes it difficult/impos\u0002sible to separate the equations from one another, so you have to treat them as a single system. In\r\npretty much any game development scenario, you will only be dealing with square matrices i.e.\r\nones with the same number of rows as columns).\r\nSo let’s look at a simple matrix:\r\n\r\n\r\nA B\r\nC D\r\n\r\n (22)\r\nSo this is what we call a “2 × 2” matrix. The 2 × 2 is called the dimension of the matrix; two\r\nrows, two columns. Another thing to note is how we denote the different “elements”: we number\r\nthem left-to-right and top-to-bottom, so that A is element 1,1 and C is element 2,1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/e76950c2-77f5-43ca-ae3c-84ee5a3c0755.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=63fc4ced3cab2f1f16610b0e8337b1d0b962217178d16eb2b1738071266fb383",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 301
      },
      {
        "segments": [
          {
            "segment_id": "2abb850b-8b48-4090-9028-fb1ee7c28900",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "12\r\nA. Vectors as Matrices\r\nWe have seen that vectors are essentially three related values. This sounds like our definition\r\nof a matrix, doesn’t it? Turns out that we can write a vector in matrix form, either as a column\r\n\r\n\r\nx\r\ny\r\nz\r\n\r\n\r\n(23)\r\nor as a row\r\n(xyz). (24)\r\nThis is important, as it allows us to multiply matrices and vectors together, which is the key to\r\ngraphics programming, for example.\r\nB. Matrix Arithmetic\r\n1. Addition and Subtraction\r\nAdding matrices is simple you just add corresponding elements:\r\n\r\n\r\nA B\r\nC D\r\n\r\n +\r\n\r\n\r\nE F\r\nG H\r\n\r\n =\r\n\r\n\r\nA + E B + F\r\nC + G D + H\r\n\r\n (25)\r\nSubtraction, of course, follows the same pattern.\r\n2. Multiplication\r\nMultiplying a matrix by a scalar (just a number) is simple; just multiply each element in the\r\nmatrix by the scalar.\r\nMultiplying two matrices is a little more complicated. The short explanation is that you mul\u0002tiply the rows of the first with the columns of the second matrix. Let’s illustrate this with an\r\nexample:\r\n\r\n\r\nA B\r\nC D\r\n\r\n ×\r\n\r\n\r\nE F\r\nG H\r\n\r\n =\r\n\r\n\r\nAE + BG AF + BH\r\nCE + DG CF + DH\r\n\r\n (26)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/2abb850b-8b48-4090-9028-fb1ee7c28900.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bd1d5bb67fe0af9a92c061079acfdb4eecb4413a48e16654e0737f7ec6f78a50",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7b69e2a1-1c38-481e-a22d-2c297c6be913",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "13\r\nNote that this means that you can only multiply two matrices whose “inner” dimensions match.\r\nSo a 3 × 3 multiplied by a 3 × 2 works (the 3 on the right of the first matches with the 3 on the left\r\nof the second) but not the other way round. So the order of multiplication matters! This is very\r\nimportant. Very. This rule for the dimensions is something you must account for if you wish to\r\nmake your own matrix implementation.\r\nHere is some pseudocode for multiplying matrices:\r\nfunction MatrixMultiply(Matrix a , Matrix b)\r\n{\r\ni f (a . columns . count != b . rows . count)\r\n{\r\nError(Cannot multiply the matrices ! ) ;\r\n}\r\ne l s e\r\n{\r\nloop(a . rows)\r\n{\r\nloop(a . columns)\r\n{\r\nresult . elements[i ] [ j] += a . elements[i ] [ j] ∗ b . elements[j ] [ i ] ;\r\n}\r\n}\r\n}\r\n}\r\nFinally, we’ll look at multiplying vectors and matrices. If we represent our vector as a row or\r\na column, we can literally treat it identically to any other matrix. Note that this means that you\r\nhave to put thought into whether your vectors will be stored as columns or as rows, because that\r\nwill affect how you lay out your matrices. If you have row (1 × 3) vectors, then if you want to\r\nmultiply them with, say, a 3 × 3 transformation matrix, then you have to put the vector in front of\r\nthe matrix when multiplying them. But if you are representing the vectors as columns (3 × 1) then\r\nyou “post-multiply” the matrix by the vector (i.e. you put the vector after the matrix).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/7b69e2a1-1c38-481e-a22d-2c297c6be913.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=617091ec1bd5d48f03a5eec6be79c9e6b324bde58e7b0e41f23de55ba50c1919",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 510
      },
      {
        "segments": [
          {
            "segment_id": "64338dc9-6139-47dc-8dea-229b1e6d4193",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "14\r\nC. Important Definitions\r\n1. Cofactors\r\nThe “cofactor” of the i, j element of a matrix is the determinant (see later) of the smaller matrix\r\nformed by the elements not on row i or column j, multiplied by (−1)i+j. If we have a matrix\r\nM =\r\n\r\n\r\nA B C\r\nD E F\r\nG H I\r\n\r\n\r\n(27)\r\nand we refer to the i, j element as mij and the i, j cofactor as Mij , then\r\nM11 = (−1)2det\r\n\r\n\r\nE F\r\nH I\r\n\r\n (28)\r\n2. Determinant\r\nThe determinant of a (square) matrix is a very important quantity. It is defined as the sum of\r\neach element along a single row or column (e.g. along the top row) multiplied by the corresponding\r\ncofactor, i.e. the sum of mijM ij. The determinant of our 2 × 2 matrix is just AD − BC.\r\n3. Transpose\r\nThe transpose of a matrix is the matrix when reflected along the top-left-to-bottom-right (“lead\u0002ing”) diagonal. So the transpose of the matrix M from earlier is\r\nMT =\r\n\r\n\r\nA D G\r\nB E H\r\nC F I\r\n\r\n\r\n. (29)\r\n4. Inverse\r\nWhen you want to “divide” by a matrix, what you do is you multiply by its inverse. We denote\r\nthe inverse of a matrix M−1\r\n. You may ask why, why the power of minus one? Well, this follows",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/64338dc9-6139-47dc-8dea-229b1e6d4193.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c37f897d1a8953747c8df4a1f1c34658b61375c68030b4898f3adaf54867b31a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8b6f956d-9d91-47ac-8cc7-8cd7a932d7ec",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "15\r\nfrom the fact that dividing by x to some power is the same as multiplying by x to the negative of\r\nthat power. That is, y\r\nxa = yx−a\r\n.\r\nThe inverse is calculated by forming a matrix of the cofactors:\r\n\r\n\r\nM11 M12 M13\r\nM21 M22 M23\r\nM31 M32 M33\r\n\r\n\r\n. (30)\r\ntaking the transpose of that, then multiplying that by 1\r\ndet(M)\r\n.\r\nD. In Practice\r\nThe main case in which you’ll use matrices for game development is graphics programming.\r\nThis is a very extensive topic which I won’t cover fully here, but I will give an example. The\r\nexample is the transformation matrices used for rendering.\r\nYou will somehow generate a couple of matrices when rendering: the first is the model matrix,\r\nwhich describes the position and rotation of the object relative to the global coordinate system, and\r\nthe second is the view matrix, which describes how to go from the global coordinate system to the\r\ncamera’s coordinate system. You will then have a projection matrix which transforms a position\r\nin the camera space to a screen position.\r\nBut how do you use these to work out where to render a vertex of your model? Well, you take\r\nthe vector position of that vertex and then multiply that by the model, view and projection matrices\r\nin turn:\r\nfunction RenderVertex(Vector vertPosition)\r\n{\r\nscreenCoord = projection ∗ view ∗ model ∗ vertPosition ;\r\nRender(screenCoord) ;\r\n}\r\nVII. QUATERNIONS\r\nWe’ve come a long way, and now we face what is probably the most difficult part of this article,\r\nconceptually, but is actually not too bad if you are content with just knowing the equations and",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/8b6f956d-9d91-47ac-8cc7-8cd7a932d7ec.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e3d032be4c04e922b73d8de9e746abfc916a71910a51351bdaf1c40e3cf3a4f8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 512
      },
      {
        "segments": [
          {
            "segment_id": "bc63563f-fcd5-47b4-91e4-6c0df2b05142",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "16\r\nnot needing any in-depth understanding. Quaternions. Those dreaded things which are like black\r\nmagic.\r\nFirst: what is a quaternion? I won’t give a full answer, but suffice it to say that they are like\r\na 4-element vector. Why do we use them? Well, unit quaternions (quaternions with a magnitude\r\n- a “size” - of one) are handy for representing rotations. This is due to the fact that they avoid\r\nthe dreaded gimbal lock. Gimbal lock occurs when you use “Euler angles” (a method where you\r\nrepresent a rotation as a series of rotations about the x, y, and z axes) and try to “pitch up” beyond\r\n90 degrees. What happens is that you basically have two of the rotation axes “collapsing” onto\r\neach other so that a rotation about either one is identical to a rotation about the other. This means\r\nyou lose the ability to rotate in one of the directions (referred to as losing a “degree of freedom”).\r\nWhich is bad.\r\nQuaternions fix this. They are not subject to gimbal lock. Which is great. So what you do is\r\nyou represent rotations as quaternions internally in the belly of your engine, and then expose a\r\nmore easily-understood Euler angle rotation system to the user, so the user can put in Euler angle\r\nrotations, then you convert those to quaternions in the bowels of your engine in order to prevent\r\ngimbal lock.\r\nThe quaternion for a rotation θ about some axis ~a is:\r\nq =\r\n\u0010\r\n~asin\u0010θ\r\n2\r\n\u0011\r\n, cos\u0010θ\r\n2\r\n\u0011\u0011. (31)\r\nWe can refer to that vector bit at the start as ~qv, and the cosine part as qs (s for scalar).\r\nWe define the inverse of a unit quaternion as\r\nq\r\n−1 = (−~qv, qs). (32)\r\nSo let us apply this to rotating a vector: our vector will be called ~u. To rotate ~u by a quaternion\r\nq, we do\r\n~v = q~uq−1. (33)\r\nFinally, we may want to do one quaternion rotation after another (called “concatenating”), so\r\nhow do we do that? Well, we just do\r\n~v = q3q2q1~uq−1\r\n1\r\nq\r\n−1\r\n2\r\nq\r\n−1\r\n3\r\n. (34)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/bc63563f-fcd5-47b4-91e4-6c0df2b05142.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4bcb4279487b7d10bc24cc34cc698ae489f6b24ecb51f11f7bba52b79c23c941",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 355
      },
      {
        "segments": [
          {
            "segment_id": "aac9adac-eddb-4560-a1a2-836e50dfe7d1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "17\r\nbut how do we multiply quaternions together? Well we use what’s called the Grassman product:\r\npq =\r\n\u0002\r\n(ps ~qv + qs ~pv + ~ps × ~qv, psqs − pv · qv)\r\n\u0003\r\n(35)\r\nNote how the first bit with the cross product generates the vector part of the result, and the\r\nsecond bit with the dot product generates the scalar part of the result.\r\nVIII. CLOSING REMARKS\r\nThank you for sticking with this all the way through, and I hope you learned a lot! Now you\r\nshould be able to understand most of the maths you will encounter in game development, which is\r\ngreat, because understanding something means you can use it so much better.\r\nIX. FURTHER READING\r\nA good intro to vectors and matrices, with a view towards graphics programming in particular.\r\nA cool introduction to trigonometry, by making a little game.\r\nA good, more in-depth look at quaternions.\r\nA primer on linear algebra for game dev.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6052d57a-acf0-4fdf-a2bf-2fb877fc6de9/images/aac9adac-eddb-4560-a1a2-836e50dfe7d1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041845Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e84507bd35d6729d2f8436684a33eb9769802fbfffa30962b0fb83ecd2d738da",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 160
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Introduction to Mathematics for Game Development.\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "James Cowley"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "\"June 23, 2016\"\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "\"Introduction to Mathematics for Game Development\"\n"
        }
      ]
    }
  }
}