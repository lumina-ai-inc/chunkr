{
  "file_name": "K - A Rewriting-Based Framework for Computations (rosu-2007-tr-c).pdf",
  "task_id": "451fa1bf-8626-47d7-931d-e09277312ff4",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "ade15ffc-c7d4-492c-81b5-c7d6db20f123",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "K: A Rewriting-Based Framework for Computations\r\n— Preliminary version —\r\nGrigore Rosu\r\nDepartment of Computer Science\r\nUniversity of Illinois at Urbana-Champaign\r\nContents\r\n1 Introduction 3\r\n2 Term Rewriting and Rewriting Logic in a Nutshell 9\r\n3 K in a Nutshell 14\r\n3.1 K Configurations: Nested Multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\r\n3.2 K Computations: y-Separated Nested Lists of Tasks . . . . . . . . . . . . . . . . . . . . . . . 16\r\n3.3 K Heating/Cooling and Strictness Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\r\n3.4 K Semantic Sentences: Equations and Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\r\n3.5 K Specialized Notation: Attributes, Contexts, Angle Brackets . . . . . . . . . . . . . . . . . . 23\r\n4 Defining “Idealized” Programming Languages in K 24\r\n4.1 Defining Turing Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\r\n4.2 Defining Lambda-Calculi in K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\r\n4.3 Defining a Simple Imperative Language in K . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\r\n4.4 Defining Milner’s CCS in K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\r\n4.5 Defining Milner’s π-Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\r\n4.6 Defining Hoare’s CSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.7 Defining Cardelli’s Ambient Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.8 Defining Agha’s Actors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.9 Defining Milner’s EXP Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.10 Defining Robinson’s Unification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\r\n4.11 Defining Milner’s W Polymorphic Type Inferencer . . . . . . . . . . . . . . . . . . . . . . . . 38\r\n4.12 Defining Plotkin’s PCF language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\r\n5 Comparing K With Other Formalisms 43\r\n5.1 Structural Operational Semantics (SOS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\r\n5.1.1 SOS as a Methodological Fragment of Rewriting Logic . . . . . . . . . . . . . . . . . . 46\r\n5.1.2 SOS as a Methodological Fragment of K . . . . . . . . . . . . . . . . . . . . . . . . . . 47\r\n5.2 Big-Step Operational Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\r\n5.2.1 Big-Step Semantics as a Methodological Fragment of Rewriting Logic . . . . . . . . . 50\r\n5.2.2 Big-Step Semantics as a Methodological Fragment of K . . . . . . . . . . . . . . . . . 51\r\n5.3 Modular Structural Operational Semantics (MSOS) . . . . . . . . . . . . . . . . . . . . . . . 51\r\n5.4 Context Reduction: Reduction Semantics with Evaluation Contexts . . . . . . . . . . . . . . 58\r\n5.4.1 Evaluation Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\r\n5.4.2 The Characteristic Context Reduction Rule . . . . . . . . . . . . . . . . . . . . . . . . 60\r\n5.4.3 From One to Many Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\r\n1\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/ade15ffc-c7d4-492c-81b5-c7d6db20f123.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0685d327cb635932f9b019d16eb649118270b318aea742ceb0bab9ea44182100",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1079
      },
      {
        "segments": [
          {
            "segment_id": "ade15ffc-c7d4-492c-81b5-c7d6db20f123",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "K: A Rewriting-Based Framework for Computations\r\n— Preliminary version —\r\nGrigore Rosu\r\nDepartment of Computer Science\r\nUniversity of Illinois at Urbana-Champaign\r\nContents\r\n1 Introduction 3\r\n2 Term Rewriting and Rewriting Logic in a Nutshell 9\r\n3 K in a Nutshell 14\r\n3.1 K Configurations: Nested Multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\r\n3.2 K Computations: y-Separated Nested Lists of Tasks . . . . . . . . . . . . . . . . . . . . . . . 16\r\n3.3 K Heating/Cooling and Strictness Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\r\n3.4 K Semantic Sentences: Equations and Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\r\n3.5 K Specialized Notation: Attributes, Contexts, Angle Brackets . . . . . . . . . . . . . . . . . . 23\r\n4 Defining “Idealized” Programming Languages in K 24\r\n4.1 Defining Turing Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\r\n4.2 Defining Lambda-Calculi in K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\r\n4.3 Defining a Simple Imperative Language in K . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\r\n4.4 Defining Milner’s CCS in K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\r\n4.5 Defining Milner’s π-Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\r\n4.6 Defining Hoare’s CSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.7 Defining Cardelli’s Ambient Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.8 Defining Agha’s Actors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.9 Defining Milner’s EXP Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\r\n4.10 Defining Robinson’s Unification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\r\n4.11 Defining Milner’s W Polymorphic Type Inferencer . . . . . . . . . . . . . . . . . . . . . . . . 38\r\n4.12 Defining Plotkin’s PCF language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\r\n5 Comparing K With Other Formalisms 43\r\n5.1 Structural Operational Semantics (SOS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\r\n5.1.1 SOS as a Methodological Fragment of Rewriting Logic . . . . . . . . . . . . . . . . . . 46\r\n5.1.2 SOS as a Methodological Fragment of K . . . . . . . . . . . . . . . . . . . . . . . . . . 47\r\n5.2 Big-Step Operational Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\r\n5.2.1 Big-Step Semantics as a Methodological Fragment of Rewriting Logic . . . . . . . . . 50\r\n5.2.2 Big-Step Semantics as a Methodological Fragment of K . . . . . . . . . . . . . . . . . 51\r\n5.3 Modular Structural Operational Semantics (MSOS) . . . . . . . . . . . . . . . . . . . . . . . 51\r\n5.4 Context Reduction: Reduction Semantics with Evaluation Contexts . . . . . . . . . . . . . . 58\r\n5.4.1 Evaluation Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\r\n5.4.2 The Characteristic Context Reduction Rule . . . . . . . . . . . . . . . . . . . . . . . . 60\r\n5.4.3 From One to Many Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\r\n1\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/ade15ffc-c7d4-492c-81b5-c7d6db20f123.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0685d327cb635932f9b019d16eb649118270b318aea742ceb0bab9ea44182100",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1079
      },
      {
        "segments": [
          {
            "segment_id": "73aeaa0d-8fae-43db-8b5f-1c684a1b76ab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.4 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\r\n5.4.5 Context Reduction as a Methodological Fragment of Rewriting Logic . . . . . . . . . . 66\r\n5.4.6 Context Reduction as a Methodological Fragment of K . . . . . . . . . . . . . . . . . . 74\r\n5.4.7 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n5.5 Abstract State Machines and the SECD Machine . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n5.6 The Chemical Abstract Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n6 The K-CHALLENGE Language 77\r\nA On K Computation Adequacy 91\r\nB Defining SILF in K 97\r\nB.1 Untyped SILF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\r\nB.2 Type Checking SILF Dynamically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\r\nB.3 Type Checking SILF Statically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\r\nC Defining FUN in K 105\r\nC.1 Untyped FUN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\r\nC.2 Untyped FUN Extended with Call-By-Name and Call-By-Need . . . . . . . . . . . . . . . . . 108\r\nC.3 Polymorphic FUN with Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\r\nD Defining SKOOL in K 112\r\nD.1 Untyped SKOOL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\r\nD.2 Type Checking SKOOL Dynamically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\r\nD.3 Type Checking SKOOL Statically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\r\nE K for the Maude User 116\r\nE.1 Using Plain Maude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\r\nE.2 Using Maude’s Meta-Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\r\nE.3 Comparing the Plain and Meta Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\r\nF The K Prelude 124\r\nAbstract\r\nK is a definitional framework based on term rewriting, in which programming languages, calculi,\r\nas well as type systems or formal analysis tools can be defined making use of special list and/or set\r\nstructures, called cells, which can be potentially nested. In addition to cells, K definitions contain\r\nequations capturing structural equivalences that do not count as computational steps, and rewrite rules\r\ncapturing computational steps or irreversible transitions. Rewrite rules in K are unconditional, i.e., they\r\nneed no computational premises (they are rule schemata and may have ordinary side conditions, though),\r\nand they are context-insensitive, so in K rewrite rules apply concurrently as soon as they match, without\r\nany contextual delay or restrictions.\r\nThe distinctive feature of K compared to other term rewriting approaches in general and to rewriting\r\nlogic in particular, is that K allows rewrite rules to apply concurrently even in cases when they overlap,\r\nprovided that they do not change the overlapped portion of the term. This allows for truly concurrent\r\nsemantics to programming languages and calculi. For example, two threads that read the same location\r\nof memory can do that concurrently, even though the corresponding rules overlap on the store location\r\nbeing read. The distinctive feature of K compared to other frameworks for true concurrency, like chemical\r\nabstract machines (Chams) or membrane systems (P-systems), is that equations and rewrite rules can\r\nmatch across multiple cells and thus perform changes many places at the same time, in one step.\r\nK provides special support for list cells that carry “computational meaning”, called computations.\r\nComputations are special “y”-separated lists “T1 y T2 y · · · y Tn” comprising computational\r\ntasks, thought of as having to be “processed” sequentially. Computation (structural) equations or heat\u0002ing/cooling equations, which technically are ordinary equations but which practically tend to have a\r\n2\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/73aeaa0d-8fae-43db-8b5f-1c684a1b76ab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e31e50e49c9ff270559b5aa2d8c44cc8892e484b7b77bb17965b1ec16496fdbe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1058
      },
      {
        "segments": [
          {
            "segment_id": "73aeaa0d-8fae-43db-8b5f-1c684a1b76ab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.4 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\r\n5.4.5 Context Reduction as a Methodological Fragment of Rewriting Logic . . . . . . . . . . 66\r\n5.4.6 Context Reduction as a Methodological Fragment of K . . . . . . . . . . . . . . . . . . 74\r\n5.4.7 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n5.5 Abstract State Machines and the SECD Machine . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n5.6 The Chemical Abstract Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74\r\n6 The K-CHALLENGE Language 77\r\nA On K Computation Adequacy 91\r\nB Defining SILF in K 97\r\nB.1 Untyped SILF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\r\nB.2 Type Checking SILF Dynamically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\r\nB.3 Type Checking SILF Statically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\r\nC Defining FUN in K 105\r\nC.1 Untyped FUN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\r\nC.2 Untyped FUN Extended with Call-By-Name and Call-By-Need . . . . . . . . . . . . . . . . . 108\r\nC.3 Polymorphic FUN with Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\r\nD Defining SKOOL in K 112\r\nD.1 Untyped SKOOL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\r\nD.2 Type Checking SKOOL Dynamically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\r\nD.3 Type Checking SKOOL Statically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\r\nE K for the Maude User 116\r\nE.1 Using Plain Maude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\r\nE.2 Using Maude’s Meta-Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\r\nE.3 Comparing the Plain and Meta Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\r\nF The K Prelude 124\r\nAbstract\r\nK is a definitional framework based on term rewriting, in which programming languages, calculi,\r\nas well as type systems or formal analysis tools can be defined making use of special list and/or set\r\nstructures, called cells, which can be potentially nested. In addition to cells, K definitions contain\r\nequations capturing structural equivalences that do not count as computational steps, and rewrite rules\r\ncapturing computational steps or irreversible transitions. Rewrite rules in K are unconditional, i.e., they\r\nneed no computational premises (they are rule schemata and may have ordinary side conditions, though),\r\nand they are context-insensitive, so in K rewrite rules apply concurrently as soon as they match, without\r\nany contextual delay or restrictions.\r\nThe distinctive feature of K compared to other term rewriting approaches in general and to rewriting\r\nlogic in particular, is that K allows rewrite rules to apply concurrently even in cases when they overlap,\r\nprovided that they do not change the overlapped portion of the term. This allows for truly concurrent\r\nsemantics to programming languages and calculi. For example, two threads that read the same location\r\nof memory can do that concurrently, even though the corresponding rules overlap on the store location\r\nbeing read. The distinctive feature of K compared to other frameworks for true concurrency, like chemical\r\nabstract machines (Chams) or membrane systems (P-systems), is that equations and rewrite rules can\r\nmatch across multiple cells and thus perform changes many places at the same time, in one step.\r\nK provides special support for list cells that carry “computational meaning”, called computations.\r\nComputations are special “y”-separated lists “T1 y T2 y · · · y Tn” comprising computational\r\ntasks, thought of as having to be “processed” sequentially. Computation (structural) equations or heat\u0002ing/cooling equations, which technically are ordinary equations but which practically tend to have a\r\n2\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/73aeaa0d-8fae-43db-8b5f-1c684a1b76ab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e31e50e49c9ff270559b5aa2d8c44cc8892e484b7b77bb17965b1ec16496fdbe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1058
      },
      {
        "segments": [
          {
            "segment_id": "e694cc93-9171-4abd-b44e-5cfe4ca227c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "special “computational” intuition (reason for which we use the “equality” symbol “\n “ instead of “=”\r\nfor them), allow to regard computations (finitely) many different, but completely equivalent ways. For ex\u0002ample, in a language with an addition operation whose arguments can be evaluated in non-deterministic\r\norder, a computation a1 + a2 may also be regarded as a1 y \u0003 + a2, with the intuition “schedule a1\r\nfor processing and freeze a2 in freezer \u0003 + ”, but also as a2 y a1 + \u0003. Computations can be handled\r\nlike any other terms in a rewriting environment, that is, they can be matched, moved from one place\r\nto another in the original term, modified, or even deleted. A term may contain an arbitrary number of\r\ncomputations, so K can be naturally used to define concurrent languages or calculi. Structural equations\r\ncan rearrange computations, so that rewrite rules can match and apply. Equations and rules can apply\r\nanywhere, in particular in the middle of computations, not only at their top. However, rules correspond\u0002ing to inherently sequential operations (such as reads/writes of variables in the same thread) must be\r\ndesigned with care, to ensure that they are applied only at the top of computations.\r\nK achieves, in one uniform framework, the benefits of both Chams and reduction semantics with\r\nevaluation contexts (context reduction), at the same time avoiding what may be called the “rigidity\r\nto chemistry” of the former and the “rigidity to syntax” of the latter. Any Cham and any context\r\nreduction definition can be captured in K with minimal (in our view zero) representational distance. K\r\ncan support concurrent language definitions with either an interleaving or a true concurrency semantics.\r\nK definitions can be efficiently executed on existing rewrite engines, thus providing “interpreters for free”\r\ndirectly from formal language definitions. Additionally, general-purpose formal analysis techniques and\r\ntools developed for rewrite logic, such as state space exploration for safety violations or model-checking,\r\ngive us corresponding techniques and tools for the defined languages, at no additional development cost.\r\n1 Introduction\r\nThis paper is an informal introduction to K, a rewriting-based language definitional framework. By saying\r\nthat K is a “rewriting-based” framework, in contrast to a “reduction-based” one, we mean that in K rules can\r\nbe applied concurrently and unrestricted by context, following the basic intuitions and operational/semantical\r\nstrengths of Meseguer’s rewriting logic [20]. K was first introduced by the author in an algebraic form in the\r\nlecture notes of a programming language design course at the University of Illinois at Urbana-Champaign\r\nin Fall 2003 [32], as a means to define executable concurrent languages in rewriting logic using the Maude\r\nexecutable specification system [9]. A more formal, detailed algebraic description of K can be found in [33].\r\nThe major purpose of this report is to explain K using a non-algebraic, intuitive and conventional notation\r\nbased on context-free grammars enriched with structural equivalences and rewrite rules, as opposed to\r\nalgebraic signatures, algebraic specifications and rewriting logic theories. The reason for doing so is that we\r\nstrongly believe that K can also be useful to the working programming language or calculi designer who may\r\nnot like, may not be familiar with, or simply may not want to use the algebraic notation. An additional\r\npurpose for stripping K of its algebraic armor is to reflect the important fact that K is more than “a technique\r\nto implement interpreters in Maude”; it is a language definitional style, like structural operational semantics\r\n(SOS) [31], modular SOS (MSOS) [29], reduction semantics with evaluation contexts (context reduction)\r\n[11], or the chemical abstract machine (Cham) [5].\r\nFigure 1 shows definitions of a simple imperative language and of some λ-calculi using both context\r\nreduction and K. For a fair comparison on the imperative language, we assumed that both definitions\r\ninitiate the evaluation of a program p by wrapping it into double square brackets, JpK; then each definition\r\ntakes that and initiates the configuration in its own way. The syntax of the simple imperative language is:\r\nName ::= standard identifiers\r\nVal ::= Int\r\nAExp ::= Name | Val | AExp + AExp\r\nBExp ::= true | false | AExp ≤ AExp | BExp and BExp | not BExp\r\nStmt ::= Name := AExp | Stmt; Stmt | if BExp then Stmt else Stmt | while BExp do Stmt | halt AExp\r\nPgm ::= AExp | Stmt; AExp\r\nTo make it more interesting, we assumed that + is strict but evaluates its arguments non-deterministically\r\n(i.e., it may interleave execution steps in its argument expressions), that ≤ is strict from left to right\r\n3\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e694cc93-9171-4abd-b44e-5cfe4ca227c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5933c115d28a4d336ded776f8b7e33577b1ea4ed0a3a34320d9836e4157e8467",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 773
      },
      {
        "segments": [
          {
            "segment_id": "e694cc93-9171-4abd-b44e-5cfe4ca227c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "special “computational” intuition (reason for which we use the “equality” symbol “\n “ instead of “=”\r\nfor them), allow to regard computations (finitely) many different, but completely equivalent ways. For ex\u0002ample, in a language with an addition operation whose arguments can be evaluated in non-deterministic\r\norder, a computation a1 + a2 may also be regarded as a1 y \u0003 + a2, with the intuition “schedule a1\r\nfor processing and freeze a2 in freezer \u0003 + ”, but also as a2 y a1 + \u0003. Computations can be handled\r\nlike any other terms in a rewriting environment, that is, they can be matched, moved from one place\r\nto another in the original term, modified, or even deleted. A term may contain an arbitrary number of\r\ncomputations, so K can be naturally used to define concurrent languages or calculi. Structural equations\r\ncan rearrange computations, so that rewrite rules can match and apply. Equations and rules can apply\r\nanywhere, in particular in the middle of computations, not only at their top. However, rules correspond\u0002ing to inherently sequential operations (such as reads/writes of variables in the same thread) must be\r\ndesigned with care, to ensure that they are applied only at the top of computations.\r\nK achieves, in one uniform framework, the benefits of both Chams and reduction semantics with\r\nevaluation contexts (context reduction), at the same time avoiding what may be called the “rigidity\r\nto chemistry” of the former and the “rigidity to syntax” of the latter. Any Cham and any context\r\nreduction definition can be captured in K with minimal (in our view zero) representational distance. K\r\ncan support concurrent language definitions with either an interleaving or a true concurrency semantics.\r\nK definitions can be efficiently executed on existing rewrite engines, thus providing “interpreters for free”\r\ndirectly from formal language definitions. Additionally, general-purpose formal analysis techniques and\r\ntools developed for rewrite logic, such as state space exploration for safety violations or model-checking,\r\ngive us corresponding techniques and tools for the defined languages, at no additional development cost.\r\n1 Introduction\r\nThis paper is an informal introduction to K, a rewriting-based language definitional framework. By saying\r\nthat K is a “rewriting-based” framework, in contrast to a “reduction-based” one, we mean that in K rules can\r\nbe applied concurrently and unrestricted by context, following the basic intuitions and operational/semantical\r\nstrengths of Meseguer’s rewriting logic [20]. K was first introduced by the author in an algebraic form in the\r\nlecture notes of a programming language design course at the University of Illinois at Urbana-Champaign\r\nin Fall 2003 [32], as a means to define executable concurrent languages in rewriting logic using the Maude\r\nexecutable specification system [9]. A more formal, detailed algebraic description of K can be found in [33].\r\nThe major purpose of this report is to explain K using a non-algebraic, intuitive and conventional notation\r\nbased on context-free grammars enriched with structural equivalences and rewrite rules, as opposed to\r\nalgebraic signatures, algebraic specifications and rewriting logic theories. The reason for doing so is that we\r\nstrongly believe that K can also be useful to the working programming language or calculi designer who may\r\nnot like, may not be familiar with, or simply may not want to use the algebraic notation. An additional\r\npurpose for stripping K of its algebraic armor is to reflect the important fact that K is more than “a technique\r\nto implement interpreters in Maude”; it is a language definitional style, like structural operational semantics\r\n(SOS) [31], modular SOS (MSOS) [29], reduction semantics with evaluation contexts (context reduction)\r\n[11], or the chemical abstract machine (Cham) [5].\r\nFigure 1 shows definitions of a simple imperative language and of some λ-calculi using both context\r\nreduction and K. For a fair comparison on the imperative language, we assumed that both definitions\r\ninitiate the evaluation of a program p by wrapping it into double square brackets, JpK; then each definition\r\ntakes that and initiates the configuration in its own way. The syntax of the simple imperative language is:\r\nName ::= standard identifiers\r\nVal ::= Int\r\nAExp ::= Name | Val | AExp + AExp\r\nBExp ::= true | false | AExp ≤ AExp | BExp and BExp | not BExp\r\nStmt ::= Name := AExp | Stmt; Stmt | if BExp then Stmt else Stmt | while BExp do Stmt | halt AExp\r\nPgm ::= AExp | Stmt; AExp\r\nTo make it more interesting, we assumed that + is strict but evaluates its arguments non-deterministically\r\n(i.e., it may interleave execution steps in its argument expressions), that ≤ is strict from left to right\r\n3\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e694cc93-9171-4abd-b44e-5cfe4ca227c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5933c115d28a4d336ded776f8b7e33577b1ea4ed0a3a34320d9836e4157e8467",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 773
      },
      {
        "segments": [
          {
            "segment_id": "7a792e87-e31e-43a3-bbb5-b6f62b76136f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction K\r\nA simple imperative language\r\nConfiguration and initialization KResult ::= Val\r\nK ::= KResult | List·\r\ny[K]\r\nConfig ::= Int | JPgmK | JPgm, StateK Config ::= Int | JKK | LKMk | LStateMstate | LSet[Config]M>\r\nJpK → Jp, ∅K JpK = LLpMk L∅MstateM>\r\nJv, σK → v h|LvMk|i> = v\r\nCxt ::= \u0003 | JCxt, StateK\r\nVariable lookup\r\nJc, σK[x] → Jc, σK[σ[x]] L x\r\nσ[x]\r\n|ikLσMstate\r\nOperators\r\nCxt ::= ... | Cxt + AExp AExp + AExp [strict extends +Int]\r\nCxt ::= ... | AExp + Cxt\r\ni1 + i2 → i1 +Int i2\r\nCxt ::= ... | Cxt ≤ AExp AExp ≤ AExp [seqstrict extends ≤Int]\r\nCxt ::= ... | Int ≤ Cxt\r\ni1 ≤ i2 → i1 ≤Int i2\r\nCxt ::= ... | not Cxt not BExp [strict extends notBool ]\r\nnot b → notBool b\r\nCxt ::= ... | Cxt and BExp BExp and BExp [strict(1)]\r\ntrue and b → b true and b → b\r\nfalse and b → false false and b → false\r\nStatements\r\nStmt ::= ... | skip\r\nCxt ::= ... | Name := Cxt Name := AExp [strict(2)]\r\nJc, σK[x := v] → Jc, σ[v/x]K[skip] Lx := v\r\n·\r\n|ikL σ\r\nσ[v/x]\r\nMstate\r\nCxt ::= ... | Cxt; Stmt k1; k2 \n k1 y k2\r\nskip; s → s\r\nCxt ::= ... | if Cxt then Stmt else Stmt if BExp then Stmt else Stmt [strict(1)]\r\nif true then s1 else s2 → s1 if true then s1 else s2 → s1\r\nif false then s1 else s2 → s2 if false then s1 else s2 → s2\r\nwhile b do s → if b then (s;while b do s) else skip Lwhile b do s|ik = Lif b then (s;while b do s) else ·|ik\r\nCxt ::= ... | halt Cxt halt AExp [strict]\r\nc[halt i] → i Lhalt i|ik → LiMk\r\nPrograms\r\nCxt ::= ... | Cxt; AExp\r\nskip; a → a\r\nλ-calculus\r\nCxt ::= λName.Cxt | Cxt Exp | Exp Cxt\r\n(λx.e) e\r\n0 → e[e0/x] (λx.e) e0 → e[e0/x]\r\nCall-by-value λ-calculus\r\nVal ::= λName.Exp Val ::= λName.Exp\r\nCxt ::= Cxt Exp | Exp Cxt Exp Exp [strict]\r\n(λx.e) v → e[v/x] L(λx.e) v|ik → Le[v/x]|ik\r\nCall-by-name λ-calculus\r\nCxt ::= Cxt Exp Exp Exp [strict(1)]\r\n(λx.e) e\r\n0 → e[e0/x] L(λx.e) e0\r\n|ik → Le[e\r\n0/x]|ik\r\nFigure 1: A simple imperative language and λ-calculi defined using evaluation contexts and K (p ∈ Pgm,\r\nv ∈ Val, c ∈ Cxt, x ∈ Name, σ ∈ State, i, i1, i2 ∈ Int, b ∈ Bool, s, s1, s2 ∈ Stmt, a ∈ AExp; e, e0 ∈ Exp)\r\n4\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/7a792e87-e31e-43a3-bbb5-b6f62b76136f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=371d9bb30223fd94f29aa07376b8be8f7e1b7f7813b457e11c83a17c0a48b394",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 455
      },
      {
        "segments": [
          {
            "segment_id": "b8910024-e922-4e7e-b9c8-3a6dad8dd76a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "(it first evaluates its first argument completely then its second), and that and shortcuts (it evaluates its\r\nfirst argument and it continues to evaluate the second only if the first is true). Only arithmetic expressions\r\ncan be assigned, so in particular variables can take only integer values. Programs consist of a statement\r\nfollowed by an arithmetic expression, so they can only evaluate to an integer value. Halt also halts programs\r\nonly with integer values. Booleans can be introduced in programs only as results of comparisons and can be\r\nused in conditionals and loops. This language is admittedly trivial and limited, but it serves our purpose\r\nof introducing K by comparison with context reduction. This language will be non-trivially modified and\r\nextended in Section 6. Note that even though we had to rewrite the syntactic constructs in the K definition in\r\nFigure 1 in order to augment them with strictness attributes1, the K definition was still more compact than\r\nthe context reduction one. For the sake of completeness, in both definitions we also included declarations of\r\ndefault items that appear in almost any language definition and so deserve to be implicit to the framework,\r\nsuch as the “\u0003” in context reduction, and the configuration constructs LKMk and LSet[Config]M>, respectively,\r\nin K. In general, K definitions tend to be more compact than their equivalent context reduction definitions;\r\nthat holds true especially for more complex definitions of languages. As discussed in Section 5.4.6, context\r\nreduction definitions can be automatically converted into equivalent K definitions. However, K has several\r\nother advantages over context reduction that may make one consider using K directly at its full strength,\r\ninstead of adopting a methodological fragment of it.\r\nSince K makes use only of standard, context-insensitive term rewriting modulo equations, it can be\r\nexecuted on rewrite engines like Maude almost as is. Nevertheless, the relationship between K and Maude is\r\nlike that between SOS, or any of the above-mentioned styles, and Maude (or ML, or Scheme, or Haskell, etc.):\r\nMaude can be used as a means to execute and analyze K language definitions. The interested reader is referred\r\nto [36] for a detailed discussion on how the various language definitional styles can be faithfully embedded\r\nin rewriting logic and then executed using systems like Maude, or even more conventional programming\r\nlanguages. The basic idea of these faithful embeddings is that a language definition in any of these styles,\r\nsay L, can be regarded as a rewrite logic theory, say RL, in such a way that there is a one-to-one computational\r\nequivalence between reductions using L and rewrites using RL. Note that this is significantly stronger than\r\nencoding, or implementing, a framework into another framework: RL is L, not an encoding of it, the only\r\ndifference between the two being insignificant notational/syntactic conventions. This is totally different from\r\nencoding L on a Turing machine or in a λ-calculus, for example, because such encodings would not preserve\r\nthe intended computational granularity of L’s reductions (if correct, they would only preserve the “relational\r\nbehavior” of L: whatever is reduced with L can also be reduced, in any number of steps, with its encodings).\r\nOne can naturally ask the following question then:\r\nWhat is the need for yet another language definitional framework that can be embedded in rewriting\r\nlogic, K in this case, if rewriting logic is already so powerful?\r\nUnfortunately, in spite of its definitional strength as a computational logic framework, rewriting logic does\r\nnot give, and does not intend to give, the programming language designer any recipe on how to define a\r\nlanguage. It essentially only suggests the following: however one wants to formally define a programming\r\nlanguage or calculus, one can probably also do it in rewriting logic following the same intuitions and style.\r\nTherefore, rewriting logic can be regarded as a meta-framework that supports definitions of programming\r\nlanguages and calculi among many other things, providing the language designer with a means to execute\r\nand formally analyze languages in a generic way, but only after the language is already defined. The following\r\nimportant question remains largely open to the working programming language designer, and not only:\r\nIs there any language definitional framework that, at the same time,\r\n1. Gives a strong intuition, even precise recipes, on how to define a language?\r\n2. Same for language-related definitions, such as type checkers, type inferencers, abstract in\u0002terpreters, safety policy or domain-specific checkers, etc.?\r\n1\r\nIn standalone K definitions, the language syntax is annotated with K attributes when the syntax is defined, not as part of\r\nthe semantics as we did in Figure 1.\r\n5\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b8910024-e922-4e7e-b9c8-3a6dad8dd76a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4bd132a278eb4d7c811fc4fd5163f233554ecaecf045ea2384cc93e3cbfa431f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 777
      },
      {
        "segments": [
          {
            "segment_id": "b8910024-e922-4e7e-b9c8-3a6dad8dd76a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "(it first evaluates its first argument completely then its second), and that and shortcuts (it evaluates its\r\nfirst argument and it continues to evaluate the second only if the first is true). Only arithmetic expressions\r\ncan be assigned, so in particular variables can take only integer values. Programs consist of a statement\r\nfollowed by an arithmetic expression, so they can only evaluate to an integer value. Halt also halts programs\r\nonly with integer values. Booleans can be introduced in programs only as results of comparisons and can be\r\nused in conditionals and loops. This language is admittedly trivial and limited, but it serves our purpose\r\nof introducing K by comparison with context reduction. This language will be non-trivially modified and\r\nextended in Section 6. Note that even though we had to rewrite the syntactic constructs in the K definition in\r\nFigure 1 in order to augment them with strictness attributes1, the K definition was still more compact than\r\nthe context reduction one. For the sake of completeness, in both definitions we also included declarations of\r\ndefault items that appear in almost any language definition and so deserve to be implicit to the framework,\r\nsuch as the “\u0003” in context reduction, and the configuration constructs LKMk and LSet[Config]M>, respectively,\r\nin K. In general, K definitions tend to be more compact than their equivalent context reduction definitions;\r\nthat holds true especially for more complex definitions of languages. As discussed in Section 5.4.6, context\r\nreduction definitions can be automatically converted into equivalent K definitions. However, K has several\r\nother advantages over context reduction that may make one consider using K directly at its full strength,\r\ninstead of adopting a methodological fragment of it.\r\nSince K makes use only of standard, context-insensitive term rewriting modulo equations, it can be\r\nexecuted on rewrite engines like Maude almost as is. Nevertheless, the relationship between K and Maude is\r\nlike that between SOS, or any of the above-mentioned styles, and Maude (or ML, or Scheme, or Haskell, etc.):\r\nMaude can be used as a means to execute and analyze K language definitions. The interested reader is referred\r\nto [36] for a detailed discussion on how the various language definitional styles can be faithfully embedded\r\nin rewriting logic and then executed using systems like Maude, or even more conventional programming\r\nlanguages. The basic idea of these faithful embeddings is that a language definition in any of these styles,\r\nsay L, can be regarded as a rewrite logic theory, say RL, in such a way that there is a one-to-one computational\r\nequivalence between reductions using L and rewrites using RL. Note that this is significantly stronger than\r\nencoding, or implementing, a framework into another framework: RL is L, not an encoding of it, the only\r\ndifference between the two being insignificant notational/syntactic conventions. This is totally different from\r\nencoding L on a Turing machine or in a λ-calculus, for example, because such encodings would not preserve\r\nthe intended computational granularity of L’s reductions (if correct, they would only preserve the “relational\r\nbehavior” of L: whatever is reduced with L can also be reduced, in any number of steps, with its encodings).\r\nOne can naturally ask the following question then:\r\nWhat is the need for yet another language definitional framework that can be embedded in rewriting\r\nlogic, K in this case, if rewriting logic is already so powerful?\r\nUnfortunately, in spite of its definitional strength as a computational logic framework, rewriting logic does\r\nnot give, and does not intend to give, the programming language designer any recipe on how to define a\r\nlanguage. It essentially only suggests the following: however one wants to formally define a programming\r\nlanguage or calculus, one can probably also do it in rewriting logic following the same intuitions and style.\r\nTherefore, rewriting logic can be regarded as a meta-framework that supports definitions of programming\r\nlanguages and calculi among many other things, providing the language designer with a means to execute\r\nand formally analyze languages in a generic way, but only after the language is already defined. The following\r\nimportant question remains largely open to the working programming language designer, and not only:\r\nIs there any language definitional framework that, at the same time,\r\n1. Gives a strong intuition, even precise recipes, on how to define a language?\r\n2. Same for language-related definitions, such as type checkers, type inferencers, abstract in\u0002terpreters, safety policy or domain-specific checkers, etc.?\r\n1\r\nIn standalone K definitions, the language syntax is annotated with K attributes when the syntax is defined, not as part of\r\nthe semantics as we did in Figure 1.\r\n5\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b8910024-e922-4e7e-b9c8-3a6dad8dd76a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4bd132a278eb4d7c811fc4fd5163f233554ecaecf045ea2384cc93e3cbfa431f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 777
      },
      {
        "segments": [
          {
            "segment_id": "dbd5cbd5-8ed8-43a7-8e58-8789bf228d45",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "3. Can define arbitrarily complex language features, including, obviously, all those found in\r\nexisting languages, capturing also their intended computational granularity?\r\n4. Is modular, that is, adding new features to a language does not require modifying existing\r\ndefinitions of unrelated features? Modularity is crucial for scalability and reuse.\r\n5. Is generic, that is, not tied to any particular programming language or paradigm?\r\n6. Supports naturally non-determinism and concurrency?\r\n7. Is executable, so one can “test” language or formal analyzer definitions, as if one already\r\nhad an interpreter or a compiler for one’s language? Efficient executability of language\r\ndefinitions may even eliminate the need for interpreters or compilers.\r\n8. Has state-exploration capabilities, including exhaustive behavior analysis (e.g., finite-state\r\nmodel-checking), when one’s language is non-deterministic or/and concurrent?\r\n9. Has a formal semantics, so one can also carry out proofs about programs? A fix-point, or\r\nan initial model, semantics is necessary if proofs by induction are desired.\r\nWe believe that the list above contains a minimal set of desirable features that an ideal language defini\u0002tional framework should have. Unfortunately, the current practice is to take the above desired features one\r\nat a time, temporarily or permanently declaring the others as “something else”. We next list how, in our\r\nview, current practices and language definitional styles fail to satisfy the above-mentioned requirements.\r\n1. To formally capture one’s intuition about a language feature to be defined, one may use a big-step or a\r\nsmall-step SOS reduction semantics, with or without evaluation contexts, typically on paper, without\r\nany machine support. Sometimes this so-called “formal” process is pushed to extreme in what regards\r\nits informality, in the sense that one can see definitions of some language features using one definitional\r\nstyle and of other features using another definitional style, without ever proving that the two definitional\r\nstyles can co-exist in the claimed form for the particular language under consideration. For example,\r\none may use a big-step SOS to give semantics to a code-self-generation extension of Java, while using\r\na small-step SOS to define the concurrency semantics of Java. However, once one has concurrency\r\nand shared memory, one cannot have a big-step SOS definition of almost anything. An ideal language\r\ndefinitional framework should provide a uniform, compact and rigorous way to modularly define various\r\nlanguage features, avoiding the need to define different language features following different styles.\r\n2. To define a type system or a (domain-specific or not) safety policy for a language, one may follow\r\na big-step-like definitional style, or even simply provide an algorithm to serve as a formal definition.\r\nWhile this appears to be, and in many cases indeed is acceptable, there can be a significant “formal\r\ngap” between the actual language semantic definition and its type system or safety policy regarded as\r\nmathematical objects, because in order to carry out proofs relating the two one needs one common\r\nformal ground. In practice, one typically ends up “encoding” the two in yet another framework,\r\nclaimed to be “richer”, and then carry out the proofs within that framework. But how can one make\r\nsure that the encodings are correct? Do they serve as alternative definitions for that sole purpose? An\r\nideal definitional framework should have all the benefits of the “richer” framework, at no additional\r\nnotational or logical complexity, yet capturing the complete meaning of the defined constructs. In\r\nother words, in an ideal framework one should define a language as a mathematical object, say L,\r\nand a type system or other abstract interpretation of it as another mathematical object over the same\r\nformalism, say L\r\n0\r\n, and then carry out proofs relating L and L\r\n0 using the provided proof system of\r\nthe definitional framework. L, L\r\n0\r\n, as well as other related definitions, should be readable and easy to\r\nunderstand enough so that one does not feel the drive to give alternative, more intuitive definitions\r\nusing a more informal notation or framework.\r\n3. Some popular language definitional frameworks are incapable of defining even existing language features.\r\nIn our view, the fact that a particular language feature is supported in some existing language serves as\r\nthe strongest argument that that feature may be desirable, so an ideal language definitional framework\r\n6\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dbd5cbd5-8ed8-43a7-8e58-8789bf228d45.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d64f516ac144a10c0b8052a207f2964bbbb61a371a02d2e1f51d484f3d636054",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 713
      },
      {
        "segments": [
          {
            "segment_id": "dbd5cbd5-8ed8-43a7-8e58-8789bf228d45",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "3. Can define arbitrarily complex language features, including, obviously, all those found in\r\nexisting languages, capturing also their intended computational granularity?\r\n4. Is modular, that is, adding new features to a language does not require modifying existing\r\ndefinitions of unrelated features? Modularity is crucial for scalability and reuse.\r\n5. Is generic, that is, not tied to any particular programming language or paradigm?\r\n6. Supports naturally non-determinism and concurrency?\r\n7. Is executable, so one can “test” language or formal analyzer definitions, as if one already\r\nhad an interpreter or a compiler for one’s language? Efficient executability of language\r\ndefinitions may even eliminate the need for interpreters or compilers.\r\n8. Has state-exploration capabilities, including exhaustive behavior analysis (e.g., finite-state\r\nmodel-checking), when one’s language is non-deterministic or/and concurrent?\r\n9. Has a formal semantics, so one can also carry out proofs about programs? A fix-point, or\r\nan initial model, semantics is necessary if proofs by induction are desired.\r\nWe believe that the list above contains a minimal set of desirable features that an ideal language defini\u0002tional framework should have. Unfortunately, the current practice is to take the above desired features one\r\nat a time, temporarily or permanently declaring the others as “something else”. We next list how, in our\r\nview, current practices and language definitional styles fail to satisfy the above-mentioned requirements.\r\n1. To formally capture one’s intuition about a language feature to be defined, one may use a big-step or a\r\nsmall-step SOS reduction semantics, with or without evaluation contexts, typically on paper, without\r\nany machine support. Sometimes this so-called “formal” process is pushed to extreme in what regards\r\nits informality, in the sense that one can see definitions of some language features using one definitional\r\nstyle and of other features using another definitional style, without ever proving that the two definitional\r\nstyles can co-exist in the claimed form for the particular language under consideration. For example,\r\none may use a big-step SOS to give semantics to a code-self-generation extension of Java, while using\r\na small-step SOS to define the concurrency semantics of Java. However, once one has concurrency\r\nand shared memory, one cannot have a big-step SOS definition of almost anything. An ideal language\r\ndefinitional framework should provide a uniform, compact and rigorous way to modularly define various\r\nlanguage features, avoiding the need to define different language features following different styles.\r\n2. To define a type system or a (domain-specific or not) safety policy for a language, one may follow\r\na big-step-like definitional style, or even simply provide an algorithm to serve as a formal definition.\r\nWhile this appears to be, and in many cases indeed is acceptable, there can be a significant “formal\r\ngap” between the actual language semantic definition and its type system or safety policy regarded as\r\nmathematical objects, because in order to carry out proofs relating the two one needs one common\r\nformal ground. In practice, one typically ends up “encoding” the two in yet another framework,\r\nclaimed to be “richer”, and then carry out the proofs within that framework. But how can one make\r\nsure that the encodings are correct? Do they serve as alternative definitions for that sole purpose? An\r\nideal definitional framework should have all the benefits of the “richer” framework, at no additional\r\nnotational or logical complexity, yet capturing the complete meaning of the defined constructs. In\r\nother words, in an ideal framework one should define a language as a mathematical object, say L,\r\nand a type system or other abstract interpretation of it as another mathematical object over the same\r\nformalism, say L\r\n0\r\n, and then carry out proofs relating L and L\r\n0 using the provided proof system of\r\nthe definitional framework. L, L\r\n0\r\n, as well as other related definitions, should be readable and easy to\r\nunderstand enough so that one does not feel the drive to give alternative, more intuitive definitions\r\nusing a more informal notation or framework.\r\n3. Some popular language definitional frameworks are incapable of defining even existing language features.\r\nIn our view, the fact that a particular language feature is supported in some existing language serves as\r\nthe strongest argument that that feature may be desirable, so an ideal language definitional framework\r\n6\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dbd5cbd5-8ed8-43a7-8e58-8789bf228d45.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d64f516ac144a10c0b8052a207f2964bbbb61a371a02d2e1f51d484f3d636054",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 713
      },
      {
        "segments": [
          {
            "segment_id": "2205c72d-fa00-4731-9c99-30403a111f6f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "must simply support it; in other words, one cannot argue against the usefulness of that feature just\r\nbecause one’s favorite definitional framework does not support it. For example, since in standard SOS\r\ndefinitions (not including reduction semantics with evaluation contexts) the “control flow” information\r\nof a program is captured within the structure of the “proof”, and since proof derivations are not first\r\nclass objects in these formalisms, it makes it very hard, virtually almost impossible in these formalisms\r\nto define complex control intensive language constructs like, e.g., call-with-current-continuation (callcc).\r\nAnother important example showing that conventional definitional frameworks fail to properly support\r\nexisting common language features is concurrency: most frameworks enforce an interleaving semantics,\r\nwhich may not necessarily always be desired. Concurrency is further discussed in item 5 below. Some\r\nframeworks provide a “well-chosen” set of constructs, shown to be theoretically sufficient to define any\r\ncomputable function or algorithm, and then propose encodings of other language features into the set\r\nof basic ones; examples in this category are Turing machines or the plethora of (typed or untyped)\r\nλ-calculi, or π-calculi, etc. While these basic constructs yield interesting and meaningful idealized\r\nprogramming languages, using them to encode other language features is, in our view, inappropriate.\r\nIndeed, encodings hide the intended computational granularity of the defined language constructs; for\r\nexample, a variable lookup intended to be a one-step operation in one’s language should take precisely\r\none step in an ideal framework (not hundreds/thousands of steps as in a Turing machine or lambda\r\ncalculus encoding, not even two steps: first get location, then get value).\r\n4. As Mosses pointed out in [29], SOS is non-modular. Even in the original notes on SOS [31], Plotkin\r\nhad to modify the definition of simple arithmetic expressions three times as his initial language evolved\r\n[29]. Even more frustratingly, to add an innocent abrupt termination statement to a language defined\r\nusing SOS, say a halt, one would need to more than double the total number of rules: each language\r\nconstruct needs to be allowed to “propagate” the halting signal potentially generated by its arguments.\r\nAlso, as one needs to add more items into configurations to support new language features, in SOS\r\none needs to change again every rule to include the new items; note that there are no less than\r\n7 + n ∗ 10 configuration items, where n is the number of threads, in the configuration of KOOL (which\r\nis a comparatively simple language) as shown in Figure 2. It can easily become very annoying and\r\nerror prone to modify a large portion of unrelated existing definitions when adding a new feature. A\r\nlanguage designer may be unwilling to add a new feature or improve the definition of an existing one,\r\njust because of the large number of required changes. Informal writing conventions are sometimes\r\nadopted to circumvent the non-modularity of SOS. For example, in the definition of Standard ML [27],\r\nMilner and his collaborators propose a “store convention” to avoid having to mention the store in every\r\nrule, and an “exception convention” to avoid having to double the number of rules for the sole purpose\r\nof supporting exceptions. As rightfully noticed by Mosses [29], such conventions are not only adhoc\r\nand language specific, but may also lead to erroneous definitions. Mosses’ Modular SOS [29] (MSOS)\r\nbrings modularity to SOS in a formal and elegant way, by grouping the non-syntactic configuration\r\nitems into transition labels, and allowing rules to mention only those items of interest from each label.\r\nAs discussed in Section 5.3, MSOS still inherits all the remaining limitations of SOS.\r\n5. A non-generic framework, i.e., one building upon a particular programming language or paradigm, may\r\nbe hard or impossible to use at its full strength when defining a language that crosses the boundaries of\r\nthe underlying language or paradigm. For example, a framework enforcing object or thread communi\u0002cation via explicit send and receive messages may require artificial encodings of languages that opt for\r\na different communication approach (e.g., shared memory), while a framework enforcing static typing\r\nof programs in the defined language may be inconvenient for defining dynamically typed or untyped\r\nlanguages. In general, a framework providing and enforcing particular ways to define certain types of\r\nlanguage features would lack genericity. Within an ideal framework, one can and should develop and\r\nadopt methodologies for defining certain types of languages or language features, but these should not\r\nbe enforced. This genericity requirement is derived from the observation that today’s programming\r\nlanguages are so diverse and based on orthogonal, sometimes even conflicting paradigms, that, regard\u0002less of how much we believe in the superiority of a particular language paradigm, be it object-oriented,\r\n7\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/2205c72d-fa00-4731-9c99-30403a111f6f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e2cfe67678520523240c686f1cd00587304a29618f8d4a4c9c1e225b27355482",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 789
      },
      {
        "segments": [
          {
            "segment_id": "2205c72d-fa00-4731-9c99-30403a111f6f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "must simply support it; in other words, one cannot argue against the usefulness of that feature just\r\nbecause one’s favorite definitional framework does not support it. For example, since in standard SOS\r\ndefinitions (not including reduction semantics with evaluation contexts) the “control flow” information\r\nof a program is captured within the structure of the “proof”, and since proof derivations are not first\r\nclass objects in these formalisms, it makes it very hard, virtually almost impossible in these formalisms\r\nto define complex control intensive language constructs like, e.g., call-with-current-continuation (callcc).\r\nAnother important example showing that conventional definitional frameworks fail to properly support\r\nexisting common language features is concurrency: most frameworks enforce an interleaving semantics,\r\nwhich may not necessarily always be desired. Concurrency is further discussed in item 5 below. Some\r\nframeworks provide a “well-chosen” set of constructs, shown to be theoretically sufficient to define any\r\ncomputable function or algorithm, and then propose encodings of other language features into the set\r\nof basic ones; examples in this category are Turing machines or the plethora of (typed or untyped)\r\nλ-calculi, or π-calculi, etc. While these basic constructs yield interesting and meaningful idealized\r\nprogramming languages, using them to encode other language features is, in our view, inappropriate.\r\nIndeed, encodings hide the intended computational granularity of the defined language constructs; for\r\nexample, a variable lookup intended to be a one-step operation in one’s language should take precisely\r\none step in an ideal framework (not hundreds/thousands of steps as in a Turing machine or lambda\r\ncalculus encoding, not even two steps: first get location, then get value).\r\n4. As Mosses pointed out in [29], SOS is non-modular. Even in the original notes on SOS [31], Plotkin\r\nhad to modify the definition of simple arithmetic expressions three times as his initial language evolved\r\n[29]. Even more frustratingly, to add an innocent abrupt termination statement to a language defined\r\nusing SOS, say a halt, one would need to more than double the total number of rules: each language\r\nconstruct needs to be allowed to “propagate” the halting signal potentially generated by its arguments.\r\nAlso, as one needs to add more items into configurations to support new language features, in SOS\r\none needs to change again every rule to include the new items; note that there are no less than\r\n7 + n ∗ 10 configuration items, where n is the number of threads, in the configuration of KOOL (which\r\nis a comparatively simple language) as shown in Figure 2. It can easily become very annoying and\r\nerror prone to modify a large portion of unrelated existing definitions when adding a new feature. A\r\nlanguage designer may be unwilling to add a new feature or improve the definition of an existing one,\r\njust because of the large number of required changes. Informal writing conventions are sometimes\r\nadopted to circumvent the non-modularity of SOS. For example, in the definition of Standard ML [27],\r\nMilner and his collaborators propose a “store convention” to avoid having to mention the store in every\r\nrule, and an “exception convention” to avoid having to double the number of rules for the sole purpose\r\nof supporting exceptions. As rightfully noticed by Mosses [29], such conventions are not only adhoc\r\nand language specific, but may also lead to erroneous definitions. Mosses’ Modular SOS [29] (MSOS)\r\nbrings modularity to SOS in a formal and elegant way, by grouping the non-syntactic configuration\r\nitems into transition labels, and allowing rules to mention only those items of interest from each label.\r\nAs discussed in Section 5.3, MSOS still inherits all the remaining limitations of SOS.\r\n5. A non-generic framework, i.e., one building upon a particular programming language or paradigm, may\r\nbe hard or impossible to use at its full strength when defining a language that crosses the boundaries of\r\nthe underlying language or paradigm. For example, a framework enforcing object or thread communi\u0002cation via explicit send and receive messages may require artificial encodings of languages that opt for\r\na different communication approach (e.g., shared memory), while a framework enforcing static typing\r\nof programs in the defined language may be inconvenient for defining dynamically typed or untyped\r\nlanguages. In general, a framework providing and enforcing particular ways to define certain types of\r\nlanguage features would lack genericity. Within an ideal framework, one can and should develop and\r\nadopt methodologies for defining certain types of languages or language features, but these should not\r\nbe enforced. This genericity requirement is derived from the observation that today’s programming\r\nlanguages are so diverse and based on orthogonal, sometimes even conflicting paradigms, that, regard\u0002less of how much we believe in the superiority of a particular language paradigm, be it object-oriented,\r\n7\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/2205c72d-fa00-4731-9c99-30403a111f6f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e2cfe67678520523240c686f1cd00587304a29618f8d4a4c9c1e225b27355482",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 789
      },
      {
        "segments": [
          {
            "segment_id": "b21db099-1e67-43c3-bec6-256cd3997f12",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "functional or logical, a commitment to any existing paradigm would significantly diminish the strengths\r\nof a language definitional framework.\r\n6. By inherently enforcing an interleaving semantics for concurrency, existing reduction semantics defini\u0002tions (including ones based on evaluation contexts) can only capture a projection of concurrency (when\r\none’s goal is to define a truly concurrent language), namely its resulting non-determinism. Proponents\r\nof existing reduction semantics approaches may argue that the resulting non-deterministic behavior of\r\na concurrent system is all what matters, while proponents of true concurrency may argue that a frame\u0002work which does not support naturally concurrent actions, i.e., actions that take place at the same\r\ntime, is not a framework for concurrency. We do not intend to discuss the important and debatable\r\ndistinctions between non-determinism and interleaving vs. true concurrency here. The fact that there\r\nare language designers who desire an interleaving semantics while others who desire a true concurrency\r\nsemantics for their language is strong evidence that an ideal language definitional framework should\r\nsimply support both, preferably with no additional settings of the framework, but rather via particular\r\ndefinitional methodologies within the framework.\r\n7. Most existing language definitional frameworks are, or until relatively recently were, lacking tool sup\u0002port for executability. Without the capability to execute language definitions, it is virtually impossible\r\nto debug or develop large and complex language definitions in a reasonable period of time. The common\r\npractice today is still to have a paper definition of a language using one’s desired formalism, and then\r\nto implement an interpreter for the defined language following in principle the paper definition. This\r\napproach, besides the inconvenience of having to define the language twice, guarantees little to nothing\r\nabout the appropriateness of the formal, paper definition. Compare this approach to an approach\r\nwhere there is no gap between the formal definition and its implementation as an interpreter. While\r\nany definition is by definition correct, one gets significantly more confidence in the appropriateness of\r\na language definition, and is less reluctant to change it, when one is able to run it as is on tens or\r\nhundreds of programs. Recently, executability engines have been proposed both for MSOS (the MSOS\r\ntool, implemented by Braga and collaborators in Maude [7]) and for reduction semantics with evalua\u0002tion contexts (the PLT Redex tool, implemented by Findler and his collaborators in Scheme [19]). A\r\nframework providing efficient support for executability of formal language definitions may eliminate en\u0002tirely the need to implement interpreters, or type checkers or type inferencers, for a language, because\r\none can use directly the formal definition for that purpose.\r\n8. While executability of language definitions is indispensable when designing non-trivial languages, one\r\nneeds richer tool support when the language is concurrent. Indeed, it may be that one’s definition is\r\nappropriate for particular thread or process interleavings (e.g., when blocks are executed atomically),\r\nbut that it has unexpected behaviors for other interleavings. Moreover, somewhat related to the\r\ndesired computational granularity of language constructs mentioned in item 3 above, one may wish to\r\nexhaustively investigate all possible interleavings or executions of a particular concurrent program, to\r\nmake sure that no undesired behaviors are present and no desired behaviors are excluded. Moreover,\r\nwhen the state space of the analyzed program is large, manual analysis of behaviors may not be feasible;\r\ntherefore, model-checking and/or safety property analyses are also desirable as intrinsic components\r\nof an ideal language definitional framework.\r\n9. To prove properties about programs in a defined programming language, or properties about the pro\u0002gramming language itself, as also mentioned in item 2 above, the current practice is to encode/redefine\r\nthe language semantics in a “richer” framework, such as a theorem prover, and then carry out the\r\ndesired proofs there. Redefining the semantics of a fully fledged programming language in a different\r\nformalism is a highly nontrivial, error prone and tedious task, possibly taking months; automated\r\ntranslations may be possible when the original definition of the language is itself formal, though one\r\nwould need to validate the translator. In addition to the “formal gap” mentioned in item 2 due to the\r\ntranslation itself, this process of redefining the language is simply inconvenient. An ideal language def\u0002initional framework should allow one to have, for each language, “one definition serving all purposes”,\r\n8\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b21db099-1e67-43c3-bec6-256cd3997f12.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bf180b9aa7e78fe1fb55856faf70276728be03cc686eba2f3af59ee2b15e26c7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 719
      },
      {
        "segments": [
          {
            "segment_id": "b21db099-1e67-43c3-bec6-256cd3997f12",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "functional or logical, a commitment to any existing paradigm would significantly diminish the strengths\r\nof a language definitional framework.\r\n6. By inherently enforcing an interleaving semantics for concurrency, existing reduction semantics defini\u0002tions (including ones based on evaluation contexts) can only capture a projection of concurrency (when\r\none’s goal is to define a truly concurrent language), namely its resulting non-determinism. Proponents\r\nof existing reduction semantics approaches may argue that the resulting non-deterministic behavior of\r\na concurrent system is all what matters, while proponents of true concurrency may argue that a frame\u0002work which does not support naturally concurrent actions, i.e., actions that take place at the same\r\ntime, is not a framework for concurrency. We do not intend to discuss the important and debatable\r\ndistinctions between non-determinism and interleaving vs. true concurrency here. The fact that there\r\nare language designers who desire an interleaving semantics while others who desire a true concurrency\r\nsemantics for their language is strong evidence that an ideal language definitional framework should\r\nsimply support both, preferably with no additional settings of the framework, but rather via particular\r\ndefinitional methodologies within the framework.\r\n7. Most existing language definitional frameworks are, or until relatively recently were, lacking tool sup\u0002port for executability. Without the capability to execute language definitions, it is virtually impossible\r\nto debug or develop large and complex language definitions in a reasonable period of time. The common\r\npractice today is still to have a paper definition of a language using one’s desired formalism, and then\r\nto implement an interpreter for the defined language following in principle the paper definition. This\r\napproach, besides the inconvenience of having to define the language twice, guarantees little to nothing\r\nabout the appropriateness of the formal, paper definition. Compare this approach to an approach\r\nwhere there is no gap between the formal definition and its implementation as an interpreter. While\r\nany definition is by definition correct, one gets significantly more confidence in the appropriateness of\r\na language definition, and is less reluctant to change it, when one is able to run it as is on tens or\r\nhundreds of programs. Recently, executability engines have been proposed both for MSOS (the MSOS\r\ntool, implemented by Braga and collaborators in Maude [7]) and for reduction semantics with evalua\u0002tion contexts (the PLT Redex tool, implemented by Findler and his collaborators in Scheme [19]). A\r\nframework providing efficient support for executability of formal language definitions may eliminate en\u0002tirely the need to implement interpreters, or type checkers or type inferencers, for a language, because\r\none can use directly the formal definition for that purpose.\r\n8. While executability of language definitions is indispensable when designing non-trivial languages, one\r\nneeds richer tool support when the language is concurrent. Indeed, it may be that one’s definition is\r\nappropriate for particular thread or process interleavings (e.g., when blocks are executed atomically),\r\nbut that it has unexpected behaviors for other interleavings. Moreover, somewhat related to the\r\ndesired computational granularity of language constructs mentioned in item 3 above, one may wish to\r\nexhaustively investigate all possible interleavings or executions of a particular concurrent program, to\r\nmake sure that no undesired behaviors are present and no desired behaviors are excluded. Moreover,\r\nwhen the state space of the analyzed program is large, manual analysis of behaviors may not be feasible;\r\ntherefore, model-checking and/or safety property analyses are also desirable as intrinsic components\r\nof an ideal language definitional framework.\r\n9. To prove properties about programs in a defined programming language, or properties about the pro\u0002gramming language itself, as also mentioned in item 2 above, the current practice is to encode/redefine\r\nthe language semantics in a “richer” framework, such as a theorem prover, and then carry out the\r\ndesired proofs there. Redefining the semantics of a fully fledged programming language in a different\r\nformalism is a highly nontrivial, error prone and tedious task, possibly taking months; automated\r\ntranslations may be possible when the original definition of the language is itself formal, though one\r\nwould need to validate the translator. In addition to the “formal gap” mentioned in item 2 due to the\r\ntranslation itself, this process of redefining the language is simply inconvenient. An ideal language def\u0002initional framework should allow one to have, for each language, “one definition serving all purposes”,\r\n8\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b21db099-1e67-43c3-bec6-256cd3997f12.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bf180b9aa7e78fe1fb55856faf70276728be03cc686eba2f3af59ee2b15e26c7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 719
      },
      {
        "segments": [
          {
            "segment_id": "990561e8-15f8-4089-b823-1b96511b85d9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "including all those mentioned above. Most likely, proofs about programs or programming languages\r\nwill need induction. In order for induction to be a valid proof principle, either it needs to be hardwired\r\nas one or more proof rules in the framework when the framework is proof-theoretical, or the framework\r\nmust posses a fixed-point or an initial model semantics when it is model-theoretical.\r\nThere are additional desirable, yet of a more subjective nature and thus harder to quantify, requirements\r\nof an ideal language definitional framework. For example, it should be simple and easy to understand, teach\r\nand use by mainstream enthusiastic language designers, not only by language experts —in particular, an\r\nideal framework should not require its users to have advanced concepts of category theory, logics, or type\r\ntheory, in order to use it. Also, it should have good data representation capabilities and should allow proofs of\r\ntheorems about programming languages that are easy to comprehend. Additionally, a framework providing\r\nsupport for parsing programs directly in the desired language syntax may be desirable to one requiring the\r\nimplementation of an additional, external to the definitional setting, parser.\r\nThe nine requirements above are nevertheless ambitious. Some proponents of existing language defini\u0002tional frameworks may argue that their favorite framework has these properties; however, a careful analysis\r\nof existing language definitional frameworks reveals that they actually fail to satisfy some, sometimes many,\r\nof these ideal features (we discuss several such frameworks and their limitations in Section ??). Others\r\nmay argue that their favorite framework has some of the properties above, the “important ones”, declaring\r\nthe other properties either “not interesting” or “something else”. For example, one may say that what\r\nis important in one’s framework is to get a dynamic semantics of a language, but its (model-theoretical)\r\nalgebraic denotational semantics, proving properties about programs, model checking, etc., are “something\r\nelse” and therefore are allowed to need a different “encoding” of the language. Our position is that an ideal\r\nlanguage definitional framework should not compromise any of the nine requirements above. Whether K\r\nsatisfies all the requirements above or not is, and probably should always be, open. What we can mention\r\nwith regards to this aspect, though, is that K was motivated and stimulated by the observation that the\r\nexisting language definitional frameworks fail to fully satisfy these minimal requirements; consequently, K’s\r\ndesign and development was conducted aiming explicitly to fulfill all nine requirements discussed above.\r\nK’s actual merit is in addressing the first four requirements in our list above, namely it proposes a scalable,\r\nmodular and comprehensive formal approach to define programming languages and language-related features\r\nand analyses. While the first four requirements are specific to programming languages, the remaining five,\r\nnamely genericity, support for concurrency, executability, formal analysis and formal semantics, transcend the\r\ndomain of programming languages. Indeed, the latter are desired features of system specification formalisms\r\nin general, an area of great interest to many researchers and, consequently, with a variety of approaches,\r\nmethods, techniques and supporting tools. K’s current approach is to avoid proposing a new general purpose\r\nsystem specification formalism, with a new semantics and with tool support developed from scratch (in other\r\nwords, to avoid “reinventing the wheel”), but instead to build upon the vast existing theoretical and tool\r\ninfrastructure of rewriting logic [20, 9]. This decision more than paid off. For example, we can carry out\r\nproofs about language definitions and corresponding type systems using the existing proof machinery of\r\nrewriting logic (see Section ??). Also, our definition of a polymorphic type inferencer in K using Maude\r\n(see Section ??) significantly outperforms the current type inferencer of SML and slightly that of Haskell,\r\nwhile slightly under-performs that of OCAML. Experiments performed with the K definition of Java 1.4\r\nusing Maude’s builtin model checker, that translates into a model-checker for Java “for free”, outperforms\r\nstate-of-the art model checkers developed specifically for Java, such as Java PathFinder [10].\r\nIn this report, syntax is defined using only conventional and familiar context-free grammars, extended\r\nwith lists and sets in a natural way. K is formally defined avoiding the algebraic notation, but its intuitions\r\nare borrowed from rewriting logic, an inherently algebraic meta-framework.\r\n2 Term Rewriting and Rewriting Logic in a Nutshell\r\nTerm rewriting is a standard computational model supported by many systems and languages. Meseguer’s\r\nrewriting logic [20], not to be confused with term rewriting, organizes term rewriting modulo equations as\r\n9\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/990561e8-15f8-4089-b823-1b96511b85d9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=88e4b6703424b89b5f84aff0e0c191b52eab3af7f87e44b7c684294f8284057c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 745
      },
      {
        "segments": [
          {
            "segment_id": "990561e8-15f8-4089-b823-1b96511b85d9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "including all those mentioned above. Most likely, proofs about programs or programming languages\r\nwill need induction. In order for induction to be a valid proof principle, either it needs to be hardwired\r\nas one or more proof rules in the framework when the framework is proof-theoretical, or the framework\r\nmust posses a fixed-point or an initial model semantics when it is model-theoretical.\r\nThere are additional desirable, yet of a more subjective nature and thus harder to quantify, requirements\r\nof an ideal language definitional framework. For example, it should be simple and easy to understand, teach\r\nand use by mainstream enthusiastic language designers, not only by language experts —in particular, an\r\nideal framework should not require its users to have advanced concepts of category theory, logics, or type\r\ntheory, in order to use it. Also, it should have good data representation capabilities and should allow proofs of\r\ntheorems about programming languages that are easy to comprehend. Additionally, a framework providing\r\nsupport for parsing programs directly in the desired language syntax may be desirable to one requiring the\r\nimplementation of an additional, external to the definitional setting, parser.\r\nThe nine requirements above are nevertheless ambitious. Some proponents of existing language defini\u0002tional frameworks may argue that their favorite framework has these properties; however, a careful analysis\r\nof existing language definitional frameworks reveals that they actually fail to satisfy some, sometimes many,\r\nof these ideal features (we discuss several such frameworks and their limitations in Section ??). Others\r\nmay argue that their favorite framework has some of the properties above, the “important ones”, declaring\r\nthe other properties either “not interesting” or “something else”. For example, one may say that what\r\nis important in one’s framework is to get a dynamic semantics of a language, but its (model-theoretical)\r\nalgebraic denotational semantics, proving properties about programs, model checking, etc., are “something\r\nelse” and therefore are allowed to need a different “encoding” of the language. Our position is that an ideal\r\nlanguage definitional framework should not compromise any of the nine requirements above. Whether K\r\nsatisfies all the requirements above or not is, and probably should always be, open. What we can mention\r\nwith regards to this aspect, though, is that K was motivated and stimulated by the observation that the\r\nexisting language definitional frameworks fail to fully satisfy these minimal requirements; consequently, K’s\r\ndesign and development was conducted aiming explicitly to fulfill all nine requirements discussed above.\r\nK’s actual merit is in addressing the first four requirements in our list above, namely it proposes a scalable,\r\nmodular and comprehensive formal approach to define programming languages and language-related features\r\nand analyses. While the first four requirements are specific to programming languages, the remaining five,\r\nnamely genericity, support for concurrency, executability, formal analysis and formal semantics, transcend the\r\ndomain of programming languages. Indeed, the latter are desired features of system specification formalisms\r\nin general, an area of great interest to many researchers and, consequently, with a variety of approaches,\r\nmethods, techniques and supporting tools. K’s current approach is to avoid proposing a new general purpose\r\nsystem specification formalism, with a new semantics and with tool support developed from scratch (in other\r\nwords, to avoid “reinventing the wheel”), but instead to build upon the vast existing theoretical and tool\r\ninfrastructure of rewriting logic [20, 9]. This decision more than paid off. For example, we can carry out\r\nproofs about language definitions and corresponding type systems using the existing proof machinery of\r\nrewriting logic (see Section ??). Also, our definition of a polymorphic type inferencer in K using Maude\r\n(see Section ??) significantly outperforms the current type inferencer of SML and slightly that of Haskell,\r\nwhile slightly under-performs that of OCAML. Experiments performed with the K definition of Java 1.4\r\nusing Maude’s builtin model checker, that translates into a model-checker for Java “for free”, outperforms\r\nstate-of-the art model checkers developed specifically for Java, such as Java PathFinder [10].\r\nIn this report, syntax is defined using only conventional and familiar context-free grammars, extended\r\nwith lists and sets in a natural way. K is formally defined avoiding the algebraic notation, but its intuitions\r\nare borrowed from rewriting logic, an inherently algebraic meta-framework.\r\n2 Term Rewriting and Rewriting Logic in a Nutshell\r\nTerm rewriting is a standard computational model supported by many systems and languages. Meseguer’s\r\nrewriting logic [20], not to be confused with term rewriting, organizes term rewriting modulo equations as\r\n9\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/990561e8-15f8-4089-b823-1b96511b85d9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=88e4b6703424b89b5f84aff0e0c191b52eab3af7f87e44b7c684294f8284057c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 745
      },
      {
        "segments": [
          {
            "segment_id": "b0ac597d-8e76-4525-ae9d-8f2881549270",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "a logic with a complete proof system and initial model semantics. Meseguer and Rosu’s rewriting logic\r\nsemantics (RLS) [22, 23] aims at making rewriting logic a foundation for programming language semantics\r\nand analysis that unifies operational and algebraic denotational semantics.\r\nA term rewrite system (TRS) consists of a set of uninterpreted operations, possibly over different syntactic\r\ncategories, or sorts, and a set of rewrite rules of the form l → r, where l and r are terms possibly containing\r\nvariables with possibly multiple occurrences. Term rewriting is a method of computation that works by\r\nprogressively changing (rewriting) a term, using a TRS. A rule can apply to the entire term being rewritten\r\nor to a subterm of the term. First, a match within the current term is found. This is done by finding a\r\nsubstitution, θ, from variables to terms such that the left-hand side of the rule, l, matches part or all of\r\nthe current term when the variables in l are replaced according to the substitution. The matched subterm\r\nis then replaced by the result of applying the substitution to the right-hand side of the rule, r. Thus, the\r\npart of the current term matching θ(l) is replaced by θ(r). The rewriting process continues as long as it is\r\npossible to find a subterm, rule, and substitution such that θ(l) matches the subterm. When no matching\r\nsubterms are found, the rewriting process terminates, with the final term, a normal form, being the result\r\nof the computation. One of the distinctive features of term rewriting, implicit in the discussion above, is\r\nthat, unlike in reduction-based operational semantics, rules apply in a context insensitive manner; in other\r\nwords, the larger context in which a rule is matched does not influence the applicability of the rewrite rule.\r\nRewriting, like other methods of computation, can continue forever. The following is a rewrite definition of\r\na factorial language construct in a hypothetical calculator language:\r\nExp ::= N at | Exp ∗ Exp | Exp − Exp | ... | Exp !\r\n0! → 1\r\nn! → n ∗ (n − 1)!, when n ≥ 1\r\nThere are a large number of term rewriting engines, including ASF [38], Elan [6], Maude [9], OBJ\r\n[12], Stratego [39], and others, some of which are capable of executing several million rewrites per second.\r\nRewriting is also a fundamental part of many existing functional languages and theorem provers. One of the\r\nmajor points of this paper is that rewriting logic definitions of languages or language features, if executed\r\non efficient rewrite engines, can be as performant or even outperform implementations of interpreters or\r\nother tools in conventional programming languages. This point can be quickly reflected even on the simple\r\ncalculator language above. For example, in our experiments executing the definition above, the factorial of\r\n50,000, a number of 213,237 digits, was “calculated” in 18.620 seconds by Maude and in 19.280 and 16.770\r\nseconds by the programming languages ML and Scheme, respectively. While for this particular example one\r\nmay say that the quality of large integers libraries plays the major role, we obtained similar results for many\r\nother experiments, some of them mentioned below and in the rest of the paper.\r\nIn contrast to term rewriting, which is just a method of computation, rewriting logic is a computational\r\nlogic proposed by Meseguer [20] as a unified logic for (true) concurrency, which builds upon equational logic\r\nby extending it with rewrite rules. In equational logic, a number of sorts (types) and equations are defined,\r\nspecifying which terms are equal. Equal terms are members of the same equivalence class. In other words,\r\nequal terms are regarded as being identical; in particular, equations can be soundly applied either from\r\nleft-to-right or from right-to-left when reasoning about equational or rewrite logic theories. Rewriting logic\r\nadds rules to equational logic, thought of as irreversible transitions: a rewrite theory is an equational theory\r\nextended with rewrite rules, where equations can be applied in any direction, while rules can only be applied\r\nfrom left-to-right. In other words, a rewrite logic theory consists of:\r\n• Syntax, consisting of sorts (syntactic categories) and operators on them, that can be used to define\r\nwell-formed “uninterpreted” terms; as already mentioned, we prefer to use equivalent CFGs to define\r\nsyntax in this paper;\r\n• Equations, defining structural identities on terms: equal terms can be substituted for each other unre\u0002stricted anywhere. Intuitively, equal terms are the same thing represented differently, the same way π,\r\n3.1459..., or the circumference of a circle of diameter 1 are the same thing; and\r\n• Rewrite rules, defining irreversible transitions between terms.\r\n10\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b0ac597d-8e76-4525-ae9d-8f2881549270.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5111c071e97bef732c566792697b0af50ac3a0d386c74fafcc03a32c0a9333b5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 781
      },
      {
        "segments": [
          {
            "segment_id": "b0ac597d-8e76-4525-ae9d-8f2881549270",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "a logic with a complete proof system and initial model semantics. Meseguer and Rosu’s rewriting logic\r\nsemantics (RLS) [22, 23] aims at making rewriting logic a foundation for programming language semantics\r\nand analysis that unifies operational and algebraic denotational semantics.\r\nA term rewrite system (TRS) consists of a set of uninterpreted operations, possibly over different syntactic\r\ncategories, or sorts, and a set of rewrite rules of the form l → r, where l and r are terms possibly containing\r\nvariables with possibly multiple occurrences. Term rewriting is a method of computation that works by\r\nprogressively changing (rewriting) a term, using a TRS. A rule can apply to the entire term being rewritten\r\nor to a subterm of the term. First, a match within the current term is found. This is done by finding a\r\nsubstitution, θ, from variables to terms such that the left-hand side of the rule, l, matches part or all of\r\nthe current term when the variables in l are replaced according to the substitution. The matched subterm\r\nis then replaced by the result of applying the substitution to the right-hand side of the rule, r. Thus, the\r\npart of the current term matching θ(l) is replaced by θ(r). The rewriting process continues as long as it is\r\npossible to find a subterm, rule, and substitution such that θ(l) matches the subterm. When no matching\r\nsubterms are found, the rewriting process terminates, with the final term, a normal form, being the result\r\nof the computation. One of the distinctive features of term rewriting, implicit in the discussion above, is\r\nthat, unlike in reduction-based operational semantics, rules apply in a context insensitive manner; in other\r\nwords, the larger context in which a rule is matched does not influence the applicability of the rewrite rule.\r\nRewriting, like other methods of computation, can continue forever. The following is a rewrite definition of\r\na factorial language construct in a hypothetical calculator language:\r\nExp ::= N at | Exp ∗ Exp | Exp − Exp | ... | Exp !\r\n0! → 1\r\nn! → n ∗ (n − 1)!, when n ≥ 1\r\nThere are a large number of term rewriting engines, including ASF [38], Elan [6], Maude [9], OBJ\r\n[12], Stratego [39], and others, some of which are capable of executing several million rewrites per second.\r\nRewriting is also a fundamental part of many existing functional languages and theorem provers. One of the\r\nmajor points of this paper is that rewriting logic definitions of languages or language features, if executed\r\non efficient rewrite engines, can be as performant or even outperform implementations of interpreters or\r\nother tools in conventional programming languages. This point can be quickly reflected even on the simple\r\ncalculator language above. For example, in our experiments executing the definition above, the factorial of\r\n50,000, a number of 213,237 digits, was “calculated” in 18.620 seconds by Maude and in 19.280 and 16.770\r\nseconds by the programming languages ML and Scheme, respectively. While for this particular example one\r\nmay say that the quality of large integers libraries plays the major role, we obtained similar results for many\r\nother experiments, some of them mentioned below and in the rest of the paper.\r\nIn contrast to term rewriting, which is just a method of computation, rewriting logic is a computational\r\nlogic proposed by Meseguer [20] as a unified logic for (true) concurrency, which builds upon equational logic\r\nby extending it with rewrite rules. In equational logic, a number of sorts (types) and equations are defined,\r\nspecifying which terms are equal. Equal terms are members of the same equivalence class. In other words,\r\nequal terms are regarded as being identical; in particular, equations can be soundly applied either from\r\nleft-to-right or from right-to-left when reasoning about equational or rewrite logic theories. Rewriting logic\r\nadds rules to equational logic, thought of as irreversible transitions: a rewrite theory is an equational theory\r\nextended with rewrite rules, where equations can be applied in any direction, while rules can only be applied\r\nfrom left-to-right. In other words, a rewrite logic theory consists of:\r\n• Syntax, consisting of sorts (syntactic categories) and operators on them, that can be used to define\r\nwell-formed “uninterpreted” terms; as already mentioned, we prefer to use equivalent CFGs to define\r\nsyntax in this paper;\r\n• Equations, defining structural identities on terms: equal terms can be substituted for each other unre\u0002stricted anywhere. Intuitively, equal terms are the same thing represented differently, the same way π,\r\n3.1459..., or the circumference of a circle of diameter 1 are the same thing; and\r\n• Rewrite rules, defining irreversible transitions between terms.\r\n10\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b0ac597d-8e76-4525-ae9d-8f2881549270.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5111c071e97bef732c566792697b0af50ac3a0d386c74fafcc03a32c0a9333b5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 781
      },
      {
        "segments": [
          {
            "segment_id": "59444d97-e163-4d48-8dbe-ff6c9e0bc224",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "In this paper, we define languages and/or language features as rewrite logic theories: the syntax of the rewrit\u0002ing logic theory captures the syntax of the language possibly extended with auxiliary operators needed for\r\nsemantic reasons, the equations capture structural rearrangements or equivalences of the program configura\u0002tion of computation structures and thus carry no computational meaning, while rules capture the intended\r\ncomputational steps and can apply in parallel (provided that they do not overlap).\r\nBoth equations and rules can be parametric in rewriting logic, in the sense that they can contain variables\r\nthat act as placeholders for subterms that match them. To avoid defining the details of rewriting logic,\r\nincluding substitutions and matching, in this paper by a “parametric” equation or rule we mean a recursively\r\nenumerable set of equations or rules, one per each parameter instance that satisfies the side conditions.\r\nIn other words, equations and rules in this paper are regarded as schematas (when executing them on\r\nrewrite engines, one may need to capture side conditions using conditions in rules and/or equations). Unlike\r\nin reduction semantics with evaluation contexts [11], there are no context restrictions on applications of\r\nequations and/or rules (extensions of rewriting logic have been proposed recently allowing some forms of\r\ncontext-sensitivity, but we are not going to use those). This allows for rewriting logic to serve as a very simple\r\nand elegant foundation for concurrency, because rules and equations can indeed be applied concurrently.\r\nRewriting logic admits a complete proof system and an initial model semantics [20] that makes inductive\r\nproofs rigorous and valid. The intuition for why rewriting logic is a unified logic for concurrency comes\r\nfrom two observations: (1) the rewriting process is inherently parallel, in the sense that non-overlapping\r\nparts of a term can be rewritten concurrently, and thus fits well with current trends in concurrent system\r\narchitecture; and (2) as shown in [20, 18], many other models of concurrent computation can be represented\r\nwithin rewriting logic, capturing faithfully the intended true or interleaved concurrency of each model.\r\nRewriting logic is connected to term rewriting in that the latter can be used to “execute” theories in\r\nthe former. Indeed, most of the equations l = r can be transformed into term rewriting rules l → r, thus\r\nproviding a means to taking a rewriting logic theory, together with an initial term, and “executing” it\r\nusing the underlying TRS. Some of the TRS steps therefore correspond to equations, so can be viewed as\r\n“structural transformations” rather than “computational steps”. Any of the existing rewrite engines can\r\nbe used for this purpose. It is important, though, not to confuse orientation of equations for executability\r\npurposes with rewrite rules in rewriting logic! As mentioned above, the actual semantics of a rewrite logic\r\ntheory is that rewrite rules can apply concurrently on equivalence classes of terms obtained modulo all the\r\nequations! Not all equations can be oriented into rewrite rules for execution purposes; for example, an\r\nequation stating commutativity (C) of a binary operator cannot be regarded as a rewrite rule, because it\r\nwould lead to non-termination; similarly, equations for associativity (A) or even ones defining identities, or\r\nunits, of binary operators (I) may not always be desired to be regarded as (irreversible) rewrite rules. For\r\nthat reason, some rewrite engines provide support for rewriting modulo special equations such as A, C, I.\r\nAn associative binary operator on a sort S can also be regarded as a list construct for S, an AI one as a\r\nlist with empty-list construct, while an ACI one as a multiset construct; to obtain a set, one also needs to\r\nadd an explicit idempotency equation in addition to the ACI equations. Since lists and (multi-)sets admit\r\nstraightforward equational definitions in rewriting logic, from here on in this paper, we assume lists and\r\n(multi-)sets over any sort whenever needed; for a sort Sort, List[Sort] denotes comma-separated lists of terms\r\nof sort Sort, and Set[Sort] denotes white space separated (multi-)sets of terms of sort Sort. For all these\r\nstructures, we use “·” as unit (nil, empty, etc.). If one wants a different list or set separator, then one writes\r\nit as a subscript, while if one wants a different unit then one writes it as a superscript. For clarity, we take\r\nthe liberty to occasionally mention as subscripts and/or superscripts even the default constructs and units\r\nfor lists and sets. For example, List·\r\ny[K] stays for y-separated lists of terms of sort K. We also assume,\r\nwhenever needed, product sorts; these are written conventionally (S1 × S2) and are also easy to define in\r\nrewriting logic.\r\nWe next show some examples of rewrite theories modulo equations (modulo A and AI, and modulo\r\nAC and ACI). First, let us consider two simple examples, showing also how intuitively rewriting logic and\r\nconcurrency fit together. Suppose that one would like to define (comma-separated) sorted lists of integers.\r\nThen all one needs to do is to add the following “bubble sort” rule (to the AI equations for lists):\r\ni, j → j, i when i > j\r\n11\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/59444d97-e163-4d48-8dbe-ff6c9e0bc224.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1e88b04bba4c814c074916566a01ce03f76e5772292ba8febf5799eeada8661e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 856
      },
      {
        "segments": [
          {
            "segment_id": "59444d97-e163-4d48-8dbe-ff6c9e0bc224",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "In this paper, we define languages and/or language features as rewrite logic theories: the syntax of the rewrit\u0002ing logic theory captures the syntax of the language possibly extended with auxiliary operators needed for\r\nsemantic reasons, the equations capture structural rearrangements or equivalences of the program configura\u0002tion of computation structures and thus carry no computational meaning, while rules capture the intended\r\ncomputational steps and can apply in parallel (provided that they do not overlap).\r\nBoth equations and rules can be parametric in rewriting logic, in the sense that they can contain variables\r\nthat act as placeholders for subterms that match them. To avoid defining the details of rewriting logic,\r\nincluding substitutions and matching, in this paper by a “parametric” equation or rule we mean a recursively\r\nenumerable set of equations or rules, one per each parameter instance that satisfies the side conditions.\r\nIn other words, equations and rules in this paper are regarded as schematas (when executing them on\r\nrewrite engines, one may need to capture side conditions using conditions in rules and/or equations). Unlike\r\nin reduction semantics with evaluation contexts [11], there are no context restrictions on applications of\r\nequations and/or rules (extensions of rewriting logic have been proposed recently allowing some forms of\r\ncontext-sensitivity, but we are not going to use those). This allows for rewriting logic to serve as a very simple\r\nand elegant foundation for concurrency, because rules and equations can indeed be applied concurrently.\r\nRewriting logic admits a complete proof system and an initial model semantics [20] that makes inductive\r\nproofs rigorous and valid. The intuition for why rewriting logic is a unified logic for concurrency comes\r\nfrom two observations: (1) the rewriting process is inherently parallel, in the sense that non-overlapping\r\nparts of a term can be rewritten concurrently, and thus fits well with current trends in concurrent system\r\narchitecture; and (2) as shown in [20, 18], many other models of concurrent computation can be represented\r\nwithin rewriting logic, capturing faithfully the intended true or interleaved concurrency of each model.\r\nRewriting logic is connected to term rewriting in that the latter can be used to “execute” theories in\r\nthe former. Indeed, most of the equations l = r can be transformed into term rewriting rules l → r, thus\r\nproviding a means to taking a rewriting logic theory, together with an initial term, and “executing” it\r\nusing the underlying TRS. Some of the TRS steps therefore correspond to equations, so can be viewed as\r\n“structural transformations” rather than “computational steps”. Any of the existing rewrite engines can\r\nbe used for this purpose. It is important, though, not to confuse orientation of equations for executability\r\npurposes with rewrite rules in rewriting logic! As mentioned above, the actual semantics of a rewrite logic\r\ntheory is that rewrite rules can apply concurrently on equivalence classes of terms obtained modulo all the\r\nequations! Not all equations can be oriented into rewrite rules for execution purposes; for example, an\r\nequation stating commutativity (C) of a binary operator cannot be regarded as a rewrite rule, because it\r\nwould lead to non-termination; similarly, equations for associativity (A) or even ones defining identities, or\r\nunits, of binary operators (I) may not always be desired to be regarded as (irreversible) rewrite rules. For\r\nthat reason, some rewrite engines provide support for rewriting modulo special equations such as A, C, I.\r\nAn associative binary operator on a sort S can also be regarded as a list construct for S, an AI one as a\r\nlist with empty-list construct, while an ACI one as a multiset construct; to obtain a set, one also needs to\r\nadd an explicit idempotency equation in addition to the ACI equations. Since lists and (multi-)sets admit\r\nstraightforward equational definitions in rewriting logic, from here on in this paper, we assume lists and\r\n(multi-)sets over any sort whenever needed; for a sort Sort, List[Sort] denotes comma-separated lists of terms\r\nof sort Sort, and Set[Sort] denotes white space separated (multi-)sets of terms of sort Sort. For all these\r\nstructures, we use “·” as unit (nil, empty, etc.). If one wants a different list or set separator, then one writes\r\nit as a subscript, while if one wants a different unit then one writes it as a superscript. For clarity, we take\r\nthe liberty to occasionally mention as subscripts and/or superscripts even the default constructs and units\r\nfor lists and sets. For example, List·\r\ny[K] stays for y-separated lists of terms of sort K. We also assume,\r\nwhenever needed, product sorts; these are written conventionally (S1 × S2) and are also easy to define in\r\nrewriting logic.\r\nWe next show some examples of rewrite theories modulo equations (modulo A and AI, and modulo\r\nAC and ACI). First, let us consider two simple examples, showing also how intuitively rewriting logic and\r\nconcurrency fit together. Suppose that one would like to define (comma-separated) sorted lists of integers.\r\nThen all one needs to do is to add the following “bubble sort” rule (to the AI equations for lists):\r\ni, j → j, i when i > j\r\n11\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/59444d97-e163-4d48-8dbe-ff6c9e0bc224.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1e88b04bba4c814c074916566a01ce03f76e5772292ba8febf5799eeada8661e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 856
      },
      {
        "segments": [
          {
            "segment_id": "9466a39b-182a-4e3e-86c9-8e51895816c3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "Here is an example of a nine-step rewriting logic derivation in the one-rule rewrite theory above (underlined\r\nsubterms are redexes where the rule applies in the corresponding step):\r\n7, 6, 5, 4, 3, 2, 1 → 6, 7, 4, 5, 3, 1, 2 → 6, 4, 7, 3, 5, 1, 2 → 4, 6, 3, 7, 5, 1, 2 → 4, 3, 6, 7, 1, 5, 2 →\r\n3, 4, 6, 1, 7, 2, 5 → 3, 4, 1, 6, 2, 7, 5 → 3, 1, 4, 2, 6, 5, 7 → 1, 3, 2, 4, 5, 6, 7 → 1, 2, 3, 4, 5, 6, 7\r\nNote that the rewrite rule is allowed to apply concurrently, but that it is not enforced to apply everywhere\r\nit can; for example, the rule was purposely not applied on the subterm “5, 1” in the third step above. Also,\r\nnote that many applications of the associativity equation for “ , ” were necessary in order to structurally\r\nchange the term so that the rewrite rule could match and apply (sometimes multiple times). Note also that\r\nthe applications of rules is non-deterministic and that one rule application choice may “disable” one or more\r\nother potential rule applications; for example, in the first step above one could have chosen the redex “6, 5”,\r\nwhich would have disabled the redexes “7, 6” and “5, 4”. This “disabling” is, of course, just an informal\r\nway of saying that equations (such as associativity) can be applied many different and sometimes exclusive\r\nways in order for the rules to match. It is obvious that the resulting rewrite system terminates (modulo AI),\r\nbecause the number of misplaced numbers decreases at each application of the rule, concurrent or not. It\r\nis also obvious that the normal-form lists are sorted, so the one-rule rewrite system above gives a correct\r\nsorting algorithm. What may be less obvious is that, when executed on a parallel rewrite engine with plenty\r\nof cores, this trivial rewrite system gives a parallel algorithm that can sort in worst-case linear time.\r\nConsider now a simple game. A group of children get a large bag (an ACI operator, giving a multiset)\r\nwith black and white balls, as well as arbitrarily many additional balls. Each child can remove two balls\r\nfrom the bag, whenever they want and concurrently, but then immediately put back in the bag a black ball\r\nif both extracted balls had the same color, or a white ball if they had different colors. Other children may\r\ndynamically join the game. We can define this problem as a rewrite theory as follows (b ranges over Ball):\r\nBall ::= ◦ | •\r\nBag ::= Set[Ball]\r\n◦ • → ◦\r\nb b → • where b ∈ {◦, •}\r\nIt is obvious that as far as children keep playing the game it will eventually terminate, because at each\r\nextraction the number of balls decreases by at least one. The rules above can apply concurrently as far as\r\nthere are at least two balls in the bag. What is not immediately obvious is that, despite the high degree of\r\nparallelism in this ACI rewrite system, it is actually confluent: the parity of the white balls does not change.\r\nLet us now consider an extension of the simple calculator language above with “,”-separated lists and\r\nwith “;”-separated lists of lists (let us not worry about typing such programs for now) and with a permutation\r\nconstruct taking a number n and generating the list of permutation lists over the elements {1, 2, ..., n} (here\r\nn, m range over natural numbers, p over “,”-separated lists of natural numbers, and pl over “;”-separated\r\nlists of “,”-separated lists of natural numbers):\r\nExp ::= ... | List,[Exp] | List;[Exp] | perm(Exp) | insert(Exp,Exp) | mapcons(Exp,Exp))\r\nperm(1) → 1\r\nperm(n) → insert(n, perm(n − 1)) when n ≥ 1\r\ninsert(n,(p; pl)) → insert(n, p); insert(n, pl)\r\ninsert(n,(m, p)) → (n, m, p); mapcons(m, insert(n, p))\r\ninsert(n, ·) → n\r\nmapcons(m,(p; pl)) → mapcons(m, p); mapcons(m, pl)\r\nmapcons(m, p) → (m, p)\r\nNote that the “,”-separated lists above have an identity (i.e., it is an AI operator), “·”, while the “;”-separated\r\nones have no identity (only A). Also, note that the second occurrence of “1” in the first rule can and should\r\nbe thought of as a degenerated “;”-separated list of “,”-separated lists; indeed, thanks to matching modulo\r\nidentity (I), the fourth rule also applies when p is · (since (m, p) matches 1 with m = 1 and p = ·). In\r\n12\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9466a39b-182a-4e3e-86c9-8e51895816c3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9cd49d517e63a870552ded6d10f7c3ad593dea84d0f98cc1bf322f667067f06b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 771
      },
      {
        "segments": [
          {
            "segment_id": "9466a39b-182a-4e3e-86c9-8e51895816c3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "Here is an example of a nine-step rewriting logic derivation in the one-rule rewrite theory above (underlined\r\nsubterms are redexes where the rule applies in the corresponding step):\r\n7, 6, 5, 4, 3, 2, 1 → 6, 7, 4, 5, 3, 1, 2 → 6, 4, 7, 3, 5, 1, 2 → 4, 6, 3, 7, 5, 1, 2 → 4, 3, 6, 7, 1, 5, 2 →\r\n3, 4, 6, 1, 7, 2, 5 → 3, 4, 1, 6, 2, 7, 5 → 3, 1, 4, 2, 6, 5, 7 → 1, 3, 2, 4, 5, 6, 7 → 1, 2, 3, 4, 5, 6, 7\r\nNote that the rewrite rule is allowed to apply concurrently, but that it is not enforced to apply everywhere\r\nit can; for example, the rule was purposely not applied on the subterm “5, 1” in the third step above. Also,\r\nnote that many applications of the associativity equation for “ , ” were necessary in order to structurally\r\nchange the term so that the rewrite rule could match and apply (sometimes multiple times). Note also that\r\nthe applications of rules is non-deterministic and that one rule application choice may “disable” one or more\r\nother potential rule applications; for example, in the first step above one could have chosen the redex “6, 5”,\r\nwhich would have disabled the redexes “7, 6” and “5, 4”. This “disabling” is, of course, just an informal\r\nway of saying that equations (such as associativity) can be applied many different and sometimes exclusive\r\nways in order for the rules to match. It is obvious that the resulting rewrite system terminates (modulo AI),\r\nbecause the number of misplaced numbers decreases at each application of the rule, concurrent or not. It\r\nis also obvious that the normal-form lists are sorted, so the one-rule rewrite system above gives a correct\r\nsorting algorithm. What may be less obvious is that, when executed on a parallel rewrite engine with plenty\r\nof cores, this trivial rewrite system gives a parallel algorithm that can sort in worst-case linear time.\r\nConsider now a simple game. A group of children get a large bag (an ACI operator, giving a multiset)\r\nwith black and white balls, as well as arbitrarily many additional balls. Each child can remove two balls\r\nfrom the bag, whenever they want and concurrently, but then immediately put back in the bag a black ball\r\nif both extracted balls had the same color, or a white ball if they had different colors. Other children may\r\ndynamically join the game. We can define this problem as a rewrite theory as follows (b ranges over Ball):\r\nBall ::= ◦ | •\r\nBag ::= Set[Ball]\r\n◦ • → ◦\r\nb b → • where b ∈ {◦, •}\r\nIt is obvious that as far as children keep playing the game it will eventually terminate, because at each\r\nextraction the number of balls decreases by at least one. The rules above can apply concurrently as far as\r\nthere are at least two balls in the bag. What is not immediately obvious is that, despite the high degree of\r\nparallelism in this ACI rewrite system, it is actually confluent: the parity of the white balls does not change.\r\nLet us now consider an extension of the simple calculator language above with “,”-separated lists and\r\nwith “;”-separated lists of lists (let us not worry about typing such programs for now) and with a permutation\r\nconstruct taking a number n and generating the list of permutation lists over the elements {1, 2, ..., n} (here\r\nn, m range over natural numbers, p over “,”-separated lists of natural numbers, and pl over “;”-separated\r\nlists of “,”-separated lists of natural numbers):\r\nExp ::= ... | List,[Exp] | List;[Exp] | perm(Exp) | insert(Exp,Exp) | mapcons(Exp,Exp))\r\nperm(1) → 1\r\nperm(n) → insert(n, perm(n − 1)) when n ≥ 1\r\ninsert(n,(p; pl)) → insert(n, p); insert(n, pl)\r\ninsert(n,(m, p)) → (n, m, p); mapcons(m, insert(n, p))\r\ninsert(n, ·) → n\r\nmapcons(m,(p; pl)) → mapcons(m, p); mapcons(m, pl)\r\nmapcons(m, p) → (m, p)\r\nNote that the “,”-separated lists above have an identity (i.e., it is an AI operator), “·”, while the “;”-separated\r\nones have no identity (only A). Also, note that the second occurrence of “1” in the first rule can and should\r\nbe thought of as a degenerated “;”-separated list of “,”-separated lists; indeed, thanks to matching modulo\r\nidentity (I), the fourth rule also applies when p is · (since (m, p) matches 1 with m = 1 and p = ·). In\r\n12\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9466a39b-182a-4e3e-86c9-8e51895816c3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9cd49d517e63a870552ded6d10f7c3ad593dea84d0f98cc1bf322f667067f06b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 771
      },
      {
        "segments": [
          {
            "segment_id": "81b50066-7a38-4b70-b845-6a93f2c31bc0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "our experiments, the rewrite theory above, when executed in Maude, outperformed best implementations\r\nof permutation generation in ML and Scheme: Maude took 61 seconds to “calculate” permutations of 10,\r\nwhile ML and Scheme took 83 and 92 seconds, respectively. None of these systems were able to calculate\r\npermutations of 11. These simplistic experiments should by no means be considered conclusive; all we are\r\ntrying to say is that the pragmatic, semantics-reluctant language designer, can safely regard the semantic\r\nprogramming language and related definitions in this paper also as efficient implementations, in addition to\r\ntheir conciseness and mathematical rigor.\r\nTo further exemplify the use of ACI operators and corresponding matching, let us now consider an\r\nextension of the simple calculator language above with partial maps (from natural numbers to expressions)\r\ndefined by their graphs (i.e., as sets of pairs (n, e)), as well as update and lookup constructs:\r\nExp ::= ... | Set[Nat × Exp] | Exp[Nat] | Exp[Exp/Nat]\r\ne e = e\r\n([n, e] g)[n] → e\r\n([n, e] g)[e\r\n0/n] → [n, e0\r\n] g\r\ng[e\r\n0/n] → [n, e0\r\n] g when g contains no pair [n, ]\r\nIn the above, we assumed white-space-separated sets and the notation [n, e] for pairs in the product sort\r\nNat × Exp. The equation assures that maps are indeed sets, not multi-sets (note that this set requirement is\r\nnot really necessary in this case, because if one constructs maps only with the provided update interface then\r\none can show that maps contain no duplicate pairs. The first rule shows a first example of ACI matching:\r\nnote that n appears both in the map and as the lookup index, and that g can also be “·”. In theory, many\r\napplications of associativity and commutativity equations may take place in the background to “bring” the\r\npair [n, e] on the first position in the set. In practice, ACI rewrite engines like Maude implement efficient\r\ndata-structures and indexing to perform such matches in essentially logarithmic time (in the size of the set).\r\nWe here did not bother to produce an error if the map was not defined in n; if g has no pair of the form [n, ],\r\nthen the term g[n] is “stuck” and thus can be regarded as a “core dump” error message. On rewrite engines\r\nproviding support for errors, one can define lookup as a potentially error generating operator; for example,\r\nin Maude one would define it to return an element of kind [Exp] instead of sort Exp. The remaining two\r\nrules define the update operation; the first uses again ACI matching, while the second has a side condition.\r\nAs mentioned above, in the theoretical developments of rewriting logic semantics and K in this paper we\r\nassume only unconditional rules and equations, though we adopt common conventions in logics and regard\r\nrules and equations as schematas, so they are allowed to have side conditions.\r\nThe simple calculator language above, with or without its extensions, is rather trivial and therefore cannot\r\nbe used as an argument that rewriting logic can serve as a solid foundation for programming languages.\r\nIndeed, the main problem when defining non-trivial languages is that the applications of reductions needs\r\nto be somehow controlled, to ensure the correct evaluation flow in a program, and, moreover, applications\r\nof rules may need data that is not available locally, such as, e.g., values associated to locations in a shared,\r\ntop-level store. Rewriting logic semantics (RLS), proposed by Meseguer and Rosu [22, 23], builds upon the\r\nstrong belief, supported by extensive empirical evidence, that arbitrarily complex programming languages\r\ncan, in fact, be easily defined as rewriting logic theories. By doing so, one gets essentially “for free” not only\r\nan interpreter and an initial model semantics for the defined language, but also a series of formal analysis\r\ntools obtained as instances of existing tools for rewriting logic.\r\nAs mentioned above, operationally speaking the major difference between conventional reduction seman\u0002tics, with [11] or without [31] evaluation contexts, and rewriting logic semantics is that the former typically\r\nimpose contextual restrictions on applications of reduction steps and the reduction steps happen one at a\r\ntime, while the latter imposes no such restrictions. To avoid undesired applications of rewrite steps, one\r\nhas to follow certain techniques and obey certain methodologies when using rewriting logic. In particular,\r\nas shown in [36], the more conventional language definitional styles (small-step and big-step SOS, reduction\r\nsemantics with evaluation contexts, chemical abstract machines, continuation-based semantics, etc.) can\r\nbe faithfully captured in rewriting logic by appropriate particular uses of its general reduction machinery.\r\nConsequently, one can define a language many different ways in rewriting logic, each with its advantages\r\n13\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/81b50066-7a38-4b70-b845-6a93f2c31bc0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aff3af058e591211c79581a2b18c1e5ab3aad34e82db49f4466f33411e45e8d7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 792
      },
      {
        "segments": [
          {
            "segment_id": "81b50066-7a38-4b70-b845-6a93f2c31bc0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "our experiments, the rewrite theory above, when executed in Maude, outperformed best implementations\r\nof permutation generation in ML and Scheme: Maude took 61 seconds to “calculate” permutations of 10,\r\nwhile ML and Scheme took 83 and 92 seconds, respectively. None of these systems were able to calculate\r\npermutations of 11. These simplistic experiments should by no means be considered conclusive; all we are\r\ntrying to say is that the pragmatic, semantics-reluctant language designer, can safely regard the semantic\r\nprogramming language and related definitions in this paper also as efficient implementations, in addition to\r\ntheir conciseness and mathematical rigor.\r\nTo further exemplify the use of ACI operators and corresponding matching, let us now consider an\r\nextension of the simple calculator language above with partial maps (from natural numbers to expressions)\r\ndefined by their graphs (i.e., as sets of pairs (n, e)), as well as update and lookup constructs:\r\nExp ::= ... | Set[Nat × Exp] | Exp[Nat] | Exp[Exp/Nat]\r\ne e = e\r\n([n, e] g)[n] → e\r\n([n, e] g)[e\r\n0/n] → [n, e0\r\n] g\r\ng[e\r\n0/n] → [n, e0\r\n] g when g contains no pair [n, ]\r\nIn the above, we assumed white-space-separated sets and the notation [n, e] for pairs in the product sort\r\nNat × Exp. The equation assures that maps are indeed sets, not multi-sets (note that this set requirement is\r\nnot really necessary in this case, because if one constructs maps only with the provided update interface then\r\none can show that maps contain no duplicate pairs. The first rule shows a first example of ACI matching:\r\nnote that n appears both in the map and as the lookup index, and that g can also be “·”. In theory, many\r\napplications of associativity and commutativity equations may take place in the background to “bring” the\r\npair [n, e] on the first position in the set. In practice, ACI rewrite engines like Maude implement efficient\r\ndata-structures and indexing to perform such matches in essentially logarithmic time (in the size of the set).\r\nWe here did not bother to produce an error if the map was not defined in n; if g has no pair of the form [n, ],\r\nthen the term g[n] is “stuck” and thus can be regarded as a “core dump” error message. On rewrite engines\r\nproviding support for errors, one can define lookup as a potentially error generating operator; for example,\r\nin Maude one would define it to return an element of kind [Exp] instead of sort Exp. The remaining two\r\nrules define the update operation; the first uses again ACI matching, while the second has a side condition.\r\nAs mentioned above, in the theoretical developments of rewriting logic semantics and K in this paper we\r\nassume only unconditional rules and equations, though we adopt common conventions in logics and regard\r\nrules and equations as schematas, so they are allowed to have side conditions.\r\nThe simple calculator language above, with or without its extensions, is rather trivial and therefore cannot\r\nbe used as an argument that rewriting logic can serve as a solid foundation for programming languages.\r\nIndeed, the main problem when defining non-trivial languages is that the applications of reductions needs\r\nto be somehow controlled, to ensure the correct evaluation flow in a program, and, moreover, applications\r\nof rules may need data that is not available locally, such as, e.g., values associated to locations in a shared,\r\ntop-level store. Rewriting logic semantics (RLS), proposed by Meseguer and Rosu [22, 23], builds upon the\r\nstrong belief, supported by extensive empirical evidence, that arbitrarily complex programming languages\r\ncan, in fact, be easily defined as rewriting logic theories. By doing so, one gets essentially “for free” not only\r\nan interpreter and an initial model semantics for the defined language, but also a series of formal analysis\r\ntools obtained as instances of existing tools for rewriting logic.\r\nAs mentioned above, operationally speaking the major difference between conventional reduction seman\u0002tics, with [11] or without [31] evaluation contexts, and rewriting logic semantics is that the former typically\r\nimpose contextual restrictions on applications of reduction steps and the reduction steps happen one at a\r\ntime, while the latter imposes no such restrictions. To avoid undesired applications of rewrite steps, one\r\nhas to follow certain techniques and obey certain methodologies when using rewriting logic. In particular,\r\nas shown in [36], the more conventional language definitional styles (small-step and big-step SOS, reduction\r\nsemantics with evaluation contexts, chemical abstract machines, continuation-based semantics, etc.) can\r\nbe faithfully captured in rewriting logic by appropriate particular uses of its general reduction machinery.\r\nConsequently, one can define a language many different ways in rewriting logic, each with its advantages\r\n13\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/81b50066-7a38-4b70-b845-6a93f2c31bc0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aff3af058e591211c79581a2b18c1e5ab3aad34e82db49f4466f33411e45e8d7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 792
      },
      {
        "segments": [
          {
            "segment_id": "e23364aa-f4ac-437a-865f-59e27c815c10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "and disadvantages; indeed, the fact that one faithfully captures a small-step SOS definition as a rewrite logic\r\ntheory does not mean that the resulting rewrite theory will give a true concurrency semantics to the original\r\nSOS definition: the adverb “faithfully”, justified by theorems proved in [36], ensures that the corresponding\r\nrewrite theories have exactly the same strengths and limitations as the original definitions.\r\nIn this paper, we discuss the K rewriting logic technique, which was first introduced in the lecture notes\r\nof a programming language design course at the University of Illinois at Urbana-Champaign in Fall 2003\r\n[32], as a means to define executable concurrent languages in rewriting logic using the Maude executable\r\nspecification system [9]. K and its corresponding Maude tool support incrementally improved every year since\r\nthen, as seen in the series of technical reports [33]. The latest of these reports also contains a more formal\r\nand detailed algebraic description of K. K is reminiscent of abstract state machines [13] and continuations\r\n[37], and glosses over language-irrelevant rewriting logic details. Analyzing the various faithful translations\r\nof language definitional styles into rewriting logic discussed in detail in [36], as well as their advantages and\r\ndisadvantages when regarded as rewrite logic theories, we confidently believe that K captures and reflects\r\nbest the strengths of rewriting logic as a semantic framework for programming languages and related features.\r\n3 K in a Nutshell\r\nK is a rewrite-based definitional framework in which programming languages, calculi, as well as type systems\r\nor formal analysis tools can be defined making use of special structures that carry “computational meaning”,\r\ncalled computations. These are special terms “T1 y T2 y · · · y Tn” having a nested list structure comprising\r\n“y”-separated computational tasks that are processed sequentially. Computations are typically derived from\r\nprograms or fragments of programs via a “heating” mechanism; in particular, the original syntax of the\r\nprogramming language is “swallowed” as computation constructors. Computations can be handled like any\r\nother terms in a rewriting environment, that is, they can be matched, moved from one place to another\r\nin the original term, modified, or even deleted. In addition to computations, K definitions also contain\r\nK-sentences: equations capturing structural equivalences and rewrite rules capturing reduction steps (or\r\nirreversible transitions). K-sentences are unconditional, i.e., they need no computational premises (they are\r\nschematas and may have ordinary side conditions, though), and context-insensitive. Therefore, K-sentences\r\nmay apply concurrently as soon as they match, without any delay or restrictions. A term may contain an\r\narbitrary number of computations, so K can be naturally used to define concurrent languages or calculi.\r\nEquations can rearrange computations, so that rewrite rules can match and apply. K definitions can be\r\nefficiently executed on existing rewrite engines, thus providing “interpreters for free” directly from formal\r\nlanguage definitions. Additionally, general-purpose formal analysis techniques and tools developed for rewrite\r\nlogic, such as state space exploration for safety violations or model-checking, give us corresponding techniques\r\nand tools for the defined languages, at no additional development cost.\r\n3.1 K Configurations: Nested Multisets\r\nIn K definitions, the program configuration is represented as a potentially nested “soup” (multiset) of configu\u0002ration item terms, also called configuration cells, representing the current infrastructure needed to process the\r\nremaining program; these may include the current computation (e.g., continuation-like structure), environ\u0002ment, store, remaining input, output, analysis results, bookkeeping information, etc. The set of configuration\r\ncells is not fixed and is typically different from definition to definition. K assumes lists, sets and multisets\r\nover any sort whenever needed, using the notation discussed in Section 2. As discussed in Section 2, lists\r\nand sets admit straightforward equational definitions in rewriting logic (list = associative operator, multiset\r\n= associative and commutative operator, etc.). Formally, configurations have the following structure:\r\nConfigLabel ::= > | k | env | store | ... (descriptive names; first two common, rest differ with language)\r\nConfig ::= LSortMConfigLabel | ...\r\nwhere Sort can be any sort, including set or list sorts such as Set[Sort] or List[Sort], or even Set[Config]\r\nor List[Config]. Many K definitions share the configuration labels > (which stays for “top”) and k (which\r\n14\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e23364aa-f4ac-437a-865f-59e27c815c10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5becbb058975f3a06206f346f676b642d8f785ca5f7a14650da5290102bdd966",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 697
      },
      {
        "segments": [
          {
            "segment_id": "e23364aa-f4ac-437a-865f-59e27c815c10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "and disadvantages; indeed, the fact that one faithfully captures a small-step SOS definition as a rewrite logic\r\ntheory does not mean that the resulting rewrite theory will give a true concurrency semantics to the original\r\nSOS definition: the adverb “faithfully”, justified by theorems proved in [36], ensures that the corresponding\r\nrewrite theories have exactly the same strengths and limitations as the original definitions.\r\nIn this paper, we discuss the K rewriting logic technique, which was first introduced in the lecture notes\r\nof a programming language design course at the University of Illinois at Urbana-Champaign in Fall 2003\r\n[32], as a means to define executable concurrent languages in rewriting logic using the Maude executable\r\nspecification system [9]. K and its corresponding Maude tool support incrementally improved every year since\r\nthen, as seen in the series of technical reports [33]. The latest of these reports also contains a more formal\r\nand detailed algebraic description of K. K is reminiscent of abstract state machines [13] and continuations\r\n[37], and glosses over language-irrelevant rewriting logic details. Analyzing the various faithful translations\r\nof language definitional styles into rewriting logic discussed in detail in [36], as well as their advantages and\r\ndisadvantages when regarded as rewrite logic theories, we confidently believe that K captures and reflects\r\nbest the strengths of rewriting logic as a semantic framework for programming languages and related features.\r\n3 K in a Nutshell\r\nK is a rewrite-based definitional framework in which programming languages, calculi, as well as type systems\r\nor formal analysis tools can be defined making use of special structures that carry “computational meaning”,\r\ncalled computations. These are special terms “T1 y T2 y · · · y Tn” having a nested list structure comprising\r\n“y”-separated computational tasks that are processed sequentially. Computations are typically derived from\r\nprograms or fragments of programs via a “heating” mechanism; in particular, the original syntax of the\r\nprogramming language is “swallowed” as computation constructors. Computations can be handled like any\r\nother terms in a rewriting environment, that is, they can be matched, moved from one place to another\r\nin the original term, modified, or even deleted. In addition to computations, K definitions also contain\r\nK-sentences: equations capturing structural equivalences and rewrite rules capturing reduction steps (or\r\nirreversible transitions). K-sentences are unconditional, i.e., they need no computational premises (they are\r\nschematas and may have ordinary side conditions, though), and context-insensitive. Therefore, K-sentences\r\nmay apply concurrently as soon as they match, without any delay or restrictions. A term may contain an\r\narbitrary number of computations, so K can be naturally used to define concurrent languages or calculi.\r\nEquations can rearrange computations, so that rewrite rules can match and apply. K definitions can be\r\nefficiently executed on existing rewrite engines, thus providing “interpreters for free” directly from formal\r\nlanguage definitions. Additionally, general-purpose formal analysis techniques and tools developed for rewrite\r\nlogic, such as state space exploration for safety violations or model-checking, give us corresponding techniques\r\nand tools for the defined languages, at no additional development cost.\r\n3.1 K Configurations: Nested Multisets\r\nIn K definitions, the program configuration is represented as a potentially nested “soup” (multiset) of configu\u0002ration item terms, also called configuration cells, representing the current infrastructure needed to process the\r\nremaining program; these may include the current computation (e.g., continuation-like structure), environ\u0002ment, store, remaining input, output, analysis results, bookkeeping information, etc. The set of configuration\r\ncells is not fixed and is typically different from definition to definition. K assumes lists, sets and multisets\r\nover any sort whenever needed, using the notation discussed in Section 2. As discussed in Section 2, lists\r\nand sets admit straightforward equational definitions in rewriting logic (list = associative operator, multiset\r\n= associative and commutative operator, etc.). Formally, configurations have the following structure:\r\nConfigLabel ::= > | k | env | store | ... (descriptive names; first two common, rest differ with language)\r\nConfig ::= LSortMConfigLabel | ...\r\nwhere Sort can be any sort, including set or list sorts such as Set[Sort] or List[Sort], or even Set[Config]\r\nor List[Config]. Many K definitions share the configuration labels > (which stays for “top”) and k (which\r\n14\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e23364aa-f4ac-437a-865f-59e27c815c10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5becbb058975f3a06206f346f676b642d8f785ca5f7a14650da5290102bdd966",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 697
      },
      {
        "segments": [
          {
            "segment_id": "04499545-01a1-44b4-9f52-a871fcdb7778",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 2: KOOL configuration “soup”\r\nstays for “computation”). For that reason, in our implementation of K in Maude (see Appendix E), they are\r\nassumed builtin, so that one needs not declare them in each language definition. If in a particular language\r\ndefinition there is only one configuration label, like in the definition of CCS in Section 4.4, then we take the\r\nliberty to drop the label name all together. The configuration labels typically differ with the language or\r\nanalysis technique to be defined in K. A configuration LcMl may also be called a configuration item (or cell)\r\nnamed (or labeled) l; interesting configuration cells are the nested ones, namely those where c ∈ Set[Config].\r\nOne is also allowed to define some language-specific configuration constructs, to more elegantly initialize\r\nand terminate computations. A common such additional configuration construct, also declared as builtin\r\nin our implementation, is JKK, which takes the given program to an initial configuration. An equation\r\ntherefore needs to be given taking such special initializing configuration into an actual configuration cell;\r\nin most definitions, an equation identifies a term of the form JpK with one of the form L...LpMk...M>, for\r\nsome appropriate configuration items replacing the dots. Sometimes one may want to provide more info\r\nthan just a program as part of the initial configuration, for example, an input buffer; then one needs to\r\ndefine appropriate configuration constructs, such as JK, inputK, and give corresponding equations, such as\r\nJp, lK = L...LpMk...LlMin...M>, etc. If one’s goal is to give a dynamic semantics of a language and if p is some\r\nterminating program, then JpK eventually produces (after a series of rewrites) the result of evaluating p; if\r\none’s goal is to analyze p, for example to type check it, then JpK eventually rewrites to the result of the\r\nanalysis, for example a type when p is well-typed or an error term when p is not well-typed.\r\nFigure 2 shows the nested “soup” configuration of KOOL [14, 15, 8], a medium-complexity experimental\r\nobject-oriented language defined by Mark Hills using the K technique in Maude. A simplified variant of\r\nKOOL, called SKOOL, is discussed in Appendix D. We often display the configuration structure graphically\r\nas trees, like above. Non-leaf nodes in the tree represent (multiset) configurations containing as configuration\r\nitems the incoming sub-configurations, each wrapped with a unique configuration label named as indicated\r\non the corresponding edge. For example, in Figure 2, the top-level configuration contains 8 configuration\r\nitems: input and output lists of strings, a store, a thread, a class set, a next available location, a set\r\nof busy locks, and a next available thread id. Each thread configuration contains 7 other configuration\r\nitems: an environment, a control item comprising the various control information data (stacks) needed, a\r\ncurrent object and class that the thread is executing code of, a set of pairs (lock,counter) containing all the\r\nlocks that the thread holds together with their order of multiplicity, a label and a thread id. The control\r\nconfiguration item wraps a configuration of 4 additional items, each a stack containing computations possibly\r\naugmented with other resources: the first contains the main computation (remaining part of the program,\r\n15\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/04499545-01a1-44b4-9f52-a871fcdb7778.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6e0fc24be8f5f99040563cc48ac2c444a7d5390dfdde4412826278ab8ea1677",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 542
      },
      {
        "segments": [
          {
            "segment_id": "04499545-01a1-44b4-9f52-a871fcdb7778",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 2: KOOL configuration “soup”\r\nstays for “computation”). For that reason, in our implementation of K in Maude (see Appendix E), they are\r\nassumed builtin, so that one needs not declare them in each language definition. If in a particular language\r\ndefinition there is only one configuration label, like in the definition of CCS in Section 4.4, then we take the\r\nliberty to drop the label name all together. The configuration labels typically differ with the language or\r\nanalysis technique to be defined in K. A configuration LcMl may also be called a configuration item (or cell)\r\nnamed (or labeled) l; interesting configuration cells are the nested ones, namely those where c ∈ Set[Config].\r\nOne is also allowed to define some language-specific configuration constructs, to more elegantly initialize\r\nand terminate computations. A common such additional configuration construct, also declared as builtin\r\nin our implementation, is JKK, which takes the given program to an initial configuration. An equation\r\ntherefore needs to be given taking such special initializing configuration into an actual configuration cell;\r\nin most definitions, an equation identifies a term of the form JpK with one of the form L...LpMk...M>, for\r\nsome appropriate configuration items replacing the dots. Sometimes one may want to provide more info\r\nthan just a program as part of the initial configuration, for example, an input buffer; then one needs to\r\ndefine appropriate configuration constructs, such as JK, inputK, and give corresponding equations, such as\r\nJp, lK = L...LpMk...LlMin...M>, etc. If one’s goal is to give a dynamic semantics of a language and if p is some\r\nterminating program, then JpK eventually produces (after a series of rewrites) the result of evaluating p; if\r\none’s goal is to analyze p, for example to type check it, then JpK eventually rewrites to the result of the\r\nanalysis, for example a type when p is well-typed or an error term when p is not well-typed.\r\nFigure 2 shows the nested “soup” configuration of KOOL [14, 15, 8], a medium-complexity experimental\r\nobject-oriented language defined by Mark Hills using the K technique in Maude. A simplified variant of\r\nKOOL, called SKOOL, is discussed in Appendix D. We often display the configuration structure graphically\r\nas trees, like above. Non-leaf nodes in the tree represent (multiset) configurations containing as configuration\r\nitems the incoming sub-configurations, each wrapped with a unique configuration label named as indicated\r\non the corresponding edge. For example, in Figure 2, the top-level configuration contains 8 configuration\r\nitems: input and output lists of strings, a store, a thread, a class set, a next available location, a set\r\nof busy locks, and a next available thread id. Each thread configuration contains 7 other configuration\r\nitems: an environment, a control item comprising the various control information data (stacks) needed, a\r\ncurrent object and class that the thread is executing code of, a set of pairs (lock,counter) containing all the\r\nlocks that the thread holds together with their order of multiplicity, a label and a thread id. The control\r\nconfiguration item wraps a configuration of 4 additional items, each a stack containing computations possibly\r\naugmented with other resources: the first contains the main computation (remaining part of the program,\r\n15\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/04499545-01a1-44b4-9f52-a871fcdb7778.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6e0fc24be8f5f99040563cc48ac2c444a7d5390dfdde4412826278ab8ea1677",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 542
      },
      {
        "segments": [
          {
            "segment_id": "c6ec7bef-1728-4249-85a4-f666af46fa48",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "a first-order continuation-like structure), a method stack, an exception stack, and a loop stack (loops can\r\nbreak and continue). Therefore, there are no less than 17 leaf configuration items, each containing important\r\ninformation about the state of the program. Moreover, 10 of them, those within threads, can have multiple\r\ninstances, depending upon the number of threads that are alive at a given moment. Thus, the total number\r\nof leaf configuration items at any given moment is 7+n∗10, where n is the number of threads t that moment.\r\nThe advantage of representing configurations as nested “soups”, is that, like in MSOS [29], subsequent\r\nsemantic equations and rules will only need to mention those configuration items that are needed for those\r\nparticular equations and rules, as opposed to having to mention the entire configuration, whether needed\r\nor not, like in conventional SOS. We can add or remove elements from the configuration multiset as we\r\nlike, only impacting rules that use those particular configuration items. Rules that do not need the changed\r\nconfigurations items do not need to be touched. This is one important aspect of K’s modularity.\r\nThere are two optional conventions/guidelines regarding the use of configurations that help increase the\r\nmodularity of K language definitions. By convention, configuration labels must be distinct in the initial\r\nconfiguration, so that the configurations they wrap can be uniquely identified even when the exact paths\r\nto them are not completely specified. Also, equations and rules are allowed to add new configuration\r\nitem instances (a necessary process when, for example, creating threads) only at the same nesting level as\r\noriginally declared in the nested configuration. These conventions are crucial for K’s context transformation\r\nprocess; essentially, equations and rules in a K definition are unambiguously and automatically modified by\r\ncompleting partial configuration contexts to “fit” the current configuration. This optional process, explained\r\nin detail in [33], gives an additional degree of modularity to K definitions. For example, suppose that initially\r\nKOOL was not concurrent and had no statements that can abruptly change the control, such as return of\r\nmethods, exceptions, break/continue of loops, so there was no need for a multi-layered configuration; in other\r\nwords, suppose that all configuration items were initially part of the top level configuration. Then the rule\r\nfor variable lookup (defined also in Appendix D) would match the environment and the store at the same\r\nconfiguration level. Adding threads and control-changing statements to the language would, unfortunately,\r\nbreak the existing definition of variable lookup, because now each of the involved configuration items are\r\nlocated at different levels in the configuration, so the previous rule would not match anymore. With context\r\ntransformers, no change needs to be done in the existing rule for variable lookup when the structure of\r\nthe configuration changes. The correct environment will be matched (and not the environment of another\r\nthread), because the context transformers are resolved following a “greedy” depth-first strategy.\r\n3.2 K Computations: y-Separated Nested Lists of Tasks\r\nAn important configuration item, present in many K definitions and “wrapped” in configurations with the\r\nConfigLabel k, is the computation, denoted by the syntactic category K. Computations generalize abstract\r\nsyntax trees (ASTs) by adding a special list construct y :\r\nK ::= KLabel(List,[K]) | List·\r\ny[K]\r\nKLabel ::= (one per language construct, plus auxiliary ones as needed)\r\nThe first construct scheme for K abstractly captures any programming language syntax, under the form of\r\nabstract syntax trees, provided that one adds one KLabel for each language construct. In addition to the\r\nlanguage syntax, one may include in KLabel additional labels for semantic reasons and for “heating/cooling”\r\nreasons (explained below). If one wants more K syntactic categories, then one can do that, too, but, for\r\nsimplicity, we prefer to keep only one in this paper. It is often more intuitive to call the language constructs\r\ntaking no arguments constants and write them as “leaves” in K structures; e.g., skip instead of skip(); we\r\ntherefore may tacitly assume an additional syntactic subcategory of K called KConstant, for constructs\r\nsuch as skip, 0, 1, true, etc. Also, for executability reasons, it may be useful to define another syntactic\r\nsubcategory of K, called KResult, for “finished computations”; this may contain certain constants, such as\r\n0, 1, true, etc., but also computations which are proper terms, such as λ . (x, e) (written in AST form).\r\nWe take the liberty to write syntax either in AST form, like in “λ . (x, e)” and “if then else (b, s1, s2)”,\r\nor in more readable mixfix form, “λx.e” and “if b then s1 else s2”. In our Maude implementation of K\r\n16\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/c6ec7bef-1728-4249-85a4-f666af46fa48.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=690f25573ce202e1dd304f7186ce97e03c3c4f6938a3181a23ab2a5f2afd2c3d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 780
      },
      {
        "segments": [
          {
            "segment_id": "c6ec7bef-1728-4249-85a4-f666af46fa48",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "a first-order continuation-like structure), a method stack, an exception stack, and a loop stack (loops can\r\nbreak and continue). Therefore, there are no less than 17 leaf configuration items, each containing important\r\ninformation about the state of the program. Moreover, 10 of them, those within threads, can have multiple\r\ninstances, depending upon the number of threads that are alive at a given moment. Thus, the total number\r\nof leaf configuration items at any given moment is 7+n∗10, where n is the number of threads t that moment.\r\nThe advantage of representing configurations as nested “soups”, is that, like in MSOS [29], subsequent\r\nsemantic equations and rules will only need to mention those configuration items that are needed for those\r\nparticular equations and rules, as opposed to having to mention the entire configuration, whether needed\r\nor not, like in conventional SOS. We can add or remove elements from the configuration multiset as we\r\nlike, only impacting rules that use those particular configuration items. Rules that do not need the changed\r\nconfigurations items do not need to be touched. This is one important aspect of K’s modularity.\r\nThere are two optional conventions/guidelines regarding the use of configurations that help increase the\r\nmodularity of K language definitions. By convention, configuration labels must be distinct in the initial\r\nconfiguration, so that the configurations they wrap can be uniquely identified even when the exact paths\r\nto them are not completely specified. Also, equations and rules are allowed to add new configuration\r\nitem instances (a necessary process when, for example, creating threads) only at the same nesting level as\r\noriginally declared in the nested configuration. These conventions are crucial for K’s context transformation\r\nprocess; essentially, equations and rules in a K definition are unambiguously and automatically modified by\r\ncompleting partial configuration contexts to “fit” the current configuration. This optional process, explained\r\nin detail in [33], gives an additional degree of modularity to K definitions. For example, suppose that initially\r\nKOOL was not concurrent and had no statements that can abruptly change the control, such as return of\r\nmethods, exceptions, break/continue of loops, so there was no need for a multi-layered configuration; in other\r\nwords, suppose that all configuration items were initially part of the top level configuration. Then the rule\r\nfor variable lookup (defined also in Appendix D) would match the environment and the store at the same\r\nconfiguration level. Adding threads and control-changing statements to the language would, unfortunately,\r\nbreak the existing definition of variable lookup, because now each of the involved configuration items are\r\nlocated at different levels in the configuration, so the previous rule would not match anymore. With context\r\ntransformers, no change needs to be done in the existing rule for variable lookup when the structure of\r\nthe configuration changes. The correct environment will be matched (and not the environment of another\r\nthread), because the context transformers are resolved following a “greedy” depth-first strategy.\r\n3.2 K Computations: y-Separated Nested Lists of Tasks\r\nAn important configuration item, present in many K definitions and “wrapped” in configurations with the\r\nConfigLabel k, is the computation, denoted by the syntactic category K. Computations generalize abstract\r\nsyntax trees (ASTs) by adding a special list construct y :\r\nK ::= KLabel(List,[K]) | List·\r\ny[K]\r\nKLabel ::= (one per language construct, plus auxiliary ones as needed)\r\nThe first construct scheme for K abstractly captures any programming language syntax, under the form of\r\nabstract syntax trees, provided that one adds one KLabel for each language construct. In addition to the\r\nlanguage syntax, one may include in KLabel additional labels for semantic reasons and for “heating/cooling”\r\nreasons (explained below). If one wants more K syntactic categories, then one can do that, too, but, for\r\nsimplicity, we prefer to keep only one in this paper. It is often more intuitive to call the language constructs\r\ntaking no arguments constants and write them as “leaves” in K structures; e.g., skip instead of skip(); we\r\ntherefore may tacitly assume an additional syntactic subcategory of K called KConstant, for constructs\r\nsuch as skip, 0, 1, true, etc. Also, for executability reasons, it may be useful to define another syntactic\r\nsubcategory of K, called KResult, for “finished computations”; this may contain certain constants, such as\r\n0, 1, true, etc., but also computations which are proper terms, such as λ . (x, e) (written in AST form).\r\nWe take the liberty to write syntax either in AST form, like in “λ . (x, e)” and “if then else (b, s1, s2)”,\r\nor in more readable mixfix form, “λx.e” and “if b then s1 else s2”. In our Maude implementation of K\r\n16\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/c6ec7bef-1728-4249-85a4-f666af46fa48.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=690f25573ce202e1dd304f7186ce97e03c3c4f6938a3181a23ab2a5f2afd2c3d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 780
      },
      {
        "segments": [
          {
            "segment_id": "7049945a-bc48-477d-9952-6e05b3353aa7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "(see Appendix E), thanks to Maude’s builtin mixfix notation and corresponding parsing for syntax, we\r\nactually write programs using the mixfix notation. Even though theoretically unnecessary, this is actually\r\nvery convenient in practice, because it makes language definitions more readable and, consequently, less\r\nerror-prone. Additionally, programs in the defined languages can be regarded as terms as are, without any\r\nintermediate AST representation for them. In other implementations of K, one may need to use an explicit\r\nparser or to get used to reading syntax in AST representation. Either way, from here on we assume that\r\nprograms, or fragment of programs, parse as computations in K; the following fragments of program in a\r\nhypothetical language are therefore terms of sort K,\r\n1 + 2\r\nif true then (s;while b do s) else s\r\n0\r\nprovided that all the corresponding constructs are defined as constructs for KLabel and KConstant:\r\nKLabel ::= ... | + | ; | if then else | while do\r\nKConstant ::= ... | Bool | Nat\r\nThe second construct scheme for K allows one to sequentialize computational tasks. Intuitively, k1 y k2\r\nsays “process k1 then k2”. How this is used and what is the exact meaning of “process” is left open and\r\ndepends upon the particular definition. For example, in a concrete semantic language definition it can mean\r\n“evaluate k1 then k2”, while in a type inferencer definition it can mean “type and accumulate type constraints\r\nin k1 then do the same for k2”, etc. The following are examples of computations using the y construct:\r\n(if true then · else ·) y while false do ·\r\na1 y \u0003 + a2\r\na2 y a1 + \u0003\r\na3 y (a1 + a2) + \u0003\r\na3 y (a1 y \u0003 + a2) + \u0003\r\nb y if \u0003 then s1 else s2\r\nb y if \u0003 then (s y while b do s) else ·\r\nThe “·” in the first and last computations above is the unit of K. Note that y-separated lists of computations\r\ncan be nested. Most importantly note that, unlike in evaluation contexts, \u0003 is not a “hole” in K, but rather\r\npart of a KLabel; The KLabels involving \u0003 above are\r\nKLabel ::= ... | + \u0003 | \u0003 + | if \u0003 then else\r\nThe \u0003 carries the obvious “plug here” intuition; e.g., one may think of “a1 y \u0003 + a2” as “process a1, then\r\nplug its result in the hole in \u0003 + a2”. Needless to say that the user of K is not expected to declare these\r\nspecial labels. We assume them whenever needed. In our implementation of K in Maude (Appendix E), all\r\nthese are generated automatically as constants of sort KLabel after a simple analysis of the language syntax.\r\nFreezers. To distinguish the labels containing \u0003 in their name from the labels that encode the syntax\r\nof the language under consideration, we call the former freezers. The role of the freezers is therefore to\r\nstore the enclosing computations for future processing. One can freeze computations at will in K, using\r\nfreezers like the ones above, or even by defining new freezers. In complex K definitions, one may need many\r\ncomputation freezers, making definitions look heavy and hard to read if one makes poor choices for freezer\r\nnames. Therefore, we adopt the following freezer naming convention, respected by all the freezers above:\r\nIf a computation can be seen as c[k, k1, ..., kn] for some multi-context c and a freezer is introduced\r\nto freeze everything except k, then the name of the freezer is c[\u0003, , ..., ].\r\nAdditionally, to increase readability, we take the freedom to generalize the adopted mixfix notation in K and\r\n“plug” the remaining computations in the freezer, that is, we write c[\u0003, k1, ..., kn] instead of c[\u0003, , ..., ](k1, ..., kn).\r\nFor instance, if @ is some binary operation and if, for some reason, in contexts of the form (e1@e2)@(e3@e4)\r\n17\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/7049945a-bc48-477d-9952-6e05b3353aa7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e184bbd3d7986310d427da7cf94cd093e34cac16c871b79c95e882bd2710098",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 673
      },
      {
        "segments": [
          {
            "segment_id": "7049945a-bc48-477d-9952-6e05b3353aa7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "(see Appendix E), thanks to Maude’s builtin mixfix notation and corresponding parsing for syntax, we\r\nactually write programs using the mixfix notation. Even though theoretically unnecessary, this is actually\r\nvery convenient in practice, because it makes language definitions more readable and, consequently, less\r\nerror-prone. Additionally, programs in the defined languages can be regarded as terms as are, without any\r\nintermediate AST representation for them. In other implementations of K, one may need to use an explicit\r\nparser or to get used to reading syntax in AST representation. Either way, from here on we assume that\r\nprograms, or fragment of programs, parse as computations in K; the following fragments of program in a\r\nhypothetical language are therefore terms of sort K,\r\n1 + 2\r\nif true then (s;while b do s) else s\r\n0\r\nprovided that all the corresponding constructs are defined as constructs for KLabel and KConstant:\r\nKLabel ::= ... | + | ; | if then else | while do\r\nKConstant ::= ... | Bool | Nat\r\nThe second construct scheme for K allows one to sequentialize computational tasks. Intuitively, k1 y k2\r\nsays “process k1 then k2”. How this is used and what is the exact meaning of “process” is left open and\r\ndepends upon the particular definition. For example, in a concrete semantic language definition it can mean\r\n“evaluate k1 then k2”, while in a type inferencer definition it can mean “type and accumulate type constraints\r\nin k1 then do the same for k2”, etc. The following are examples of computations using the y construct:\r\n(if true then · else ·) y while false do ·\r\na1 y \u0003 + a2\r\na2 y a1 + \u0003\r\na3 y (a1 + a2) + \u0003\r\na3 y (a1 y \u0003 + a2) + \u0003\r\nb y if \u0003 then s1 else s2\r\nb y if \u0003 then (s y while b do s) else ·\r\nThe “·” in the first and last computations above is the unit of K. Note that y-separated lists of computations\r\ncan be nested. Most importantly note that, unlike in evaluation contexts, \u0003 is not a “hole” in K, but rather\r\npart of a KLabel; The KLabels involving \u0003 above are\r\nKLabel ::= ... | + \u0003 | \u0003 + | if \u0003 then else\r\nThe \u0003 carries the obvious “plug here” intuition; e.g., one may think of “a1 y \u0003 + a2” as “process a1, then\r\nplug its result in the hole in \u0003 + a2”. Needless to say that the user of K is not expected to declare these\r\nspecial labels. We assume them whenever needed. In our implementation of K in Maude (Appendix E), all\r\nthese are generated automatically as constants of sort KLabel after a simple analysis of the language syntax.\r\nFreezers. To distinguish the labels containing \u0003 in their name from the labels that encode the syntax\r\nof the language under consideration, we call the former freezers. The role of the freezers is therefore to\r\nstore the enclosing computations for future processing. One can freeze computations at will in K, using\r\nfreezers like the ones above, or even by defining new freezers. In complex K definitions, one may need many\r\ncomputation freezers, making definitions look heavy and hard to read if one makes poor choices for freezer\r\nnames. Therefore, we adopt the following freezer naming convention, respected by all the freezers above:\r\nIf a computation can be seen as c[k, k1, ..., kn] for some multi-context c and a freezer is introduced\r\nto freeze everything except k, then the name of the freezer is c[\u0003, , ..., ].\r\nAdditionally, to increase readability, we take the freedom to generalize the adopted mixfix notation in K and\r\n“plug” the remaining computations in the freezer, that is, we write c[\u0003, k1, ..., kn] instead of c[\u0003, , ..., ](k1, ..., kn).\r\nFor instance, if @ is some binary operation and if, for some reason, in contexts of the form (e1@e2)@(e3@e4)\r\n17\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/7049945a-bc48-477d-9952-6e05b3353aa7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e184bbd3d7986310d427da7cf94cd093e34cac16c871b79c95e882bd2710098",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 673
      },
      {
        "segments": [
          {
            "segment_id": "846429e7-a206-4a87-9843-a93f5b7a041f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "one wishes to freeze e1, e3 and e4 (in order to, e.g., process e2), then, when there is no confusion, one can\r\ntake the freedom to write (e1@ \u0003)@(e3@e4) instead of (( @ \u0003)@( @ ))(e1, e3, e4). This convention is partic\u0002ularly useful when one wants to follow a reduction semantics with evaluation contexts style in K, because\r\none can mechanically associate such a freezer to each context-defining production. For example, the freezer\r\n( @ \u0003)@( @ ) above would be associated to a production of the form “Cxt ::= (Exp@Cxt)@(Exp@Exp)”; see\r\nSection 5.4.6 for more details on how reduction semantics with evaluation contexts is captured by K.\r\n3.3 K Heating/Cooling and Strictness Attributes\r\nAfter defining the desired language syntax so that programs or fragments of programs become terms of sort\r\nK, the very first step towards giving a K semantics to a language is to define the computation (structural)\r\nequations. These allow to regard computations many different, but completely equivalent ways. For example,\r\na1 + a2 may be regarded also as a1 y \u0003 + a2, with the intuition “schedule a1 for processing and freeze a2\r\nin freezer \u0003 + ”, but also as a2 y a1 + \u0003 (if, of course, addition is intended to be non-deterministic). As\r\ndiscussed in Section 3.2, the freezers’ role is to store the remaining computations for future processing.\r\nHeating/Cooling equations, informally. Computation structural equations know how to “pass in front”\r\nof the computation fragments of program that need to be processed, and also how to “plug their results\r\nback” once processed. In most language definitions, all computation structural equations can be generated\r\nautomatically from K strictness operator attributes as explained below; Figure 1 shows several examples of\r\nstrictness attributes. For example, the strict attribute of + is equivalent to the following two computation\r\nstructural equations in K (a1 and a2 range over computations in K):\r\na1 + a2 \n a1 y \u0003 + a2\r\na1 + a2 \n a2 y a1 + \u0003\r\nTo distinguish them from the other equations, we use the symbol “\n” instead of “=” in computational\r\nstructural equations. The symbol “\n” is also used in Cham [5], as a shorthand for combinations of a\r\nheating rule (“*”) and a cooling rule (“)”). Even though in K we use it for equations, which have a\r\nmodel-theoretical semantics that is different from that of pairs of rewrite rules, operationally one can regard\r\nan equation as a pair of rewrite rules. Moreover, “\n” in K carries in fact a heating/cooling intuition similar\r\nto that of Cham. Indeed, one can think of the first rule above as follows: to process a1 + a2, let us first\r\n“heat” a1, applying the equation from left to right; once a1 is processed (using other equations/rules in\r\nthe semantics) producing some result, place that result back into context via a “cooling” step, applying\r\nthe equation from right to left. We actually find the conceptual analogy between computation structural\r\nequations in K and heating/cooling rules in Cham so insightful, that we take the liberty to borrow both\r\nthe notation “\n” and the terminology “heating/cooling” from Cham. However, it is important to realize\r\nthat these heating/cooling equations can be applied at any moment and in any direction, because they\r\nare regarded not as computational steps but as structural identities. For example, one can use the two\r\nheating/cooling equations for “ + ” above to pick and pass in front either a1 or a2, then rewrite it one\r\nstep only using semantic rules (defined later in this section), then plug it back into the sum, then pick\r\nand pass in front either a1 or a2 again and rewrite it one step only, and so on, thus obtaining the desired\r\nnon-deterministic operational semantics of + .\r\nOne should always be aware in K definitions that “\u0003” is nothing but a convenient notation used as part\r\nof label names freezing some computations for future use, and not get carried away and think of “\u0003” as a\r\nspecial “hole expression” of sort K. For example, a hasty reader may think that K’s approach to strictness\r\nis unsound, because one can “prove” wrong equalities as follows:\r\na1 + a2 = a1 y \u0003 + a2 (by the first equation above applied left-to-right)\r\n= a1 y a2 y \u0003 + \u0003 (by the second equation above applied left-to-right)\r\n= a1 y a2 + \u0003 (by the first equation above applied right-to-left)\r\n= a2 + a1 (by the second equation above applied right-to-left)\r\n18\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/846429e7-a206-4a87-9843-a93f5b7a041f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8fa72d931cf39c0ecfb1765d2fcdb0a9f160a7a10e5b9a5da122335a870e9ea9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "846429e7-a206-4a87-9843-a93f5b7a041f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "one wishes to freeze e1, e3 and e4 (in order to, e.g., process e2), then, when there is no confusion, one can\r\ntake the freedom to write (e1@ \u0003)@(e3@e4) instead of (( @ \u0003)@( @ ))(e1, e3, e4). This convention is partic\u0002ularly useful when one wants to follow a reduction semantics with evaluation contexts style in K, because\r\none can mechanically associate such a freezer to each context-defining production. For example, the freezer\r\n( @ \u0003)@( @ ) above would be associated to a production of the form “Cxt ::= (Exp@Cxt)@(Exp@Exp)”; see\r\nSection 5.4.6 for more details on how reduction semantics with evaluation contexts is captured by K.\r\n3.3 K Heating/Cooling and Strictness Attributes\r\nAfter defining the desired language syntax so that programs or fragments of programs become terms of sort\r\nK, the very first step towards giving a K semantics to a language is to define the computation (structural)\r\nequations. These allow to regard computations many different, but completely equivalent ways. For example,\r\na1 + a2 may be regarded also as a1 y \u0003 + a2, with the intuition “schedule a1 for processing and freeze a2\r\nin freezer \u0003 + ”, but also as a2 y a1 + \u0003 (if, of course, addition is intended to be non-deterministic). As\r\ndiscussed in Section 3.2, the freezers’ role is to store the remaining computations for future processing.\r\nHeating/Cooling equations, informally. Computation structural equations know how to “pass in front”\r\nof the computation fragments of program that need to be processed, and also how to “plug their results\r\nback” once processed. In most language definitions, all computation structural equations can be generated\r\nautomatically from K strictness operator attributes as explained below; Figure 1 shows several examples of\r\nstrictness attributes. For example, the strict attribute of + is equivalent to the following two computation\r\nstructural equations in K (a1 and a2 range over computations in K):\r\na1 + a2 \n a1 y \u0003 + a2\r\na1 + a2 \n a2 y a1 + \u0003\r\nTo distinguish them from the other equations, we use the symbol “\n” instead of “=” in computational\r\nstructural equations. The symbol “\n” is also used in Cham [5], as a shorthand for combinations of a\r\nheating rule (“*”) and a cooling rule (“)”). Even though in K we use it for equations, which have a\r\nmodel-theoretical semantics that is different from that of pairs of rewrite rules, operationally one can regard\r\nan equation as a pair of rewrite rules. Moreover, “\n” in K carries in fact a heating/cooling intuition similar\r\nto that of Cham. Indeed, one can think of the first rule above as follows: to process a1 + a2, let us first\r\n“heat” a1, applying the equation from left to right; once a1 is processed (using other equations/rules in\r\nthe semantics) producing some result, place that result back into context via a “cooling” step, applying\r\nthe equation from right to left. We actually find the conceptual analogy between computation structural\r\nequations in K and heating/cooling rules in Cham so insightful, that we take the liberty to borrow both\r\nthe notation “\n” and the terminology “heating/cooling” from Cham. However, it is important to realize\r\nthat these heating/cooling equations can be applied at any moment and in any direction, because they\r\nare regarded not as computational steps but as structural identities. For example, one can use the two\r\nheating/cooling equations for “ + ” above to pick and pass in front either a1 or a2, then rewrite it one\r\nstep only using semantic rules (defined later in this section), then plug it back into the sum, then pick\r\nand pass in front either a1 or a2 again and rewrite it one step only, and so on, thus obtaining the desired\r\nnon-deterministic operational semantics of + .\r\nOne should always be aware in K definitions that “\u0003” is nothing but a convenient notation used as part\r\nof label names freezing some computations for future use, and not get carried away and think of “\u0003” as a\r\nspecial “hole expression” of sort K. For example, a hasty reader may think that K’s approach to strictness\r\nis unsound, because one can “prove” wrong equalities as follows:\r\na1 + a2 = a1 y \u0003 + a2 (by the first equation above applied left-to-right)\r\n= a1 y a2 y \u0003 + \u0003 (by the second equation above applied left-to-right)\r\n= a1 y a2 + \u0003 (by the first equation above applied right-to-left)\r\n= a2 + a1 (by the second equation above applied right-to-left)\r\n18\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/846429e7-a206-4a87-9843-a93f5b7a041f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8fa72d931cf39c0ecfb1765d2fcdb0a9f160a7a10e5b9a5da122335a870e9ea9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "73295a90-f885-427a-8342-92663cad2a91",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "What is wrong in the above “proof” is that one cannot apply the second equation in the second step above,\r\nbecause \u0003 + a2 is nothing but a convenient way to write the frozen computation \u0003 + (a2). One may say\r\nthat there is no problem with the above, because + is intended to be commutative anyway; unfortunately,\r\nthe same could be proved for any non-deterministic construct, for example for a division operation, “/”, if\r\nthat was to be included in our language. Since the heating/cooling equations are thought of as structural\r\nidentities, so that computational steps take place modulo them, then it would certainly be wrong to have\r\nboth “a1/a2” and “a2/a1” in the same computational equivalence class. One of K’s most subtle technical\r\naspects, which fortunately is transparent to users, is to find the right (i.e., as weak as possible) restrictions\r\non the applications of heating/cooling equations, so that each computational equivalence class contains no\r\nmore than one fragment of program. This is called “computation adequacy” and is discussed in detail in\r\nAppendix ??. The idea is to only allow heating and/or cooling of operator arguments that are proper\r\nsyntactic computations (i.e., terms over the original syntax, i.e., different from “·” and containing no “y”).\r\nWith that, for example, the computation equivalence class of the expression x ∗ (y + 2) in the context of a\r\nlanguage definition with non-deterministically strict binary + and ∗, consists of the terms:\r\nx ∗ (y + 2)\r\nx y (\u0003 ∗ (y + 2))\r\nx y (\u0003 ∗ (y y (\u0003 + 2)))\r\nx y (\u0003 ∗ (2 y (y + \u0003)))\r\n(y + 2) y (x ∗ \u0003)\r\ny y (\u0003 + 2) y (x ∗ \u0003)\r\n2 y (y + \u0003) y (x ∗ \u0003)\r\nx ∗ (y y (\u0003 + 2))\r\nx ∗ (2 y (y + \u0003))\r\nNote that there is only one syntactic computation in the computation equivalence class above, namely the\r\noriginal expression itself. This is a crucial desired property of K.\r\nStrict attribute. In K definitions, one typically defines zero, one, or more heating/cooling equations per lan\u0002guage construct, depending on its intended processing strategy. These equations tend to be straightforward\r\nand boring to write, so in K we prefer a higher-level and more compact and intuitive approach: we annotate\r\nthe language syntax with strictness attributes. A language construct annotated as strict, such as for example\r\nthe “ + ” in Figure 1, is automatically associated a heating/cooling equation as above for each of its subex\u0002pressions. If an operator is intended to be strict in only some of its arguments, then the positions of the strict\r\narguments are listed as arguments of the strict attribute. For example, note that the strictness attribute of\r\nif then else in Figure 1 is strict(1); that means that a heating/cooling equation is added only for the first\r\nsubexpression of the conditional, namely the equation “if b then s1 else s2 \n b y if \u0003 then s1 else s2”.\r\nSeqstrict attribute. Recall that the two heating/cooling equations corresponding to the strictness attribute\r\nstrict of + above did not enforce any particular order in which the two subexpressions were processed. It\r\nis often the case that one wants a deterministic order in which the strict arguments of a language construct\r\nare processed, typically from left to right. Such an example is the relational operator ≤ in Figure 1, which\r\nwas declared the strictness attribute seqstrict, saying that its subexpressions are processed deterministically,\r\nfrom left to right. The attribute seqstrict can be used only in definitions with a non-empty KResult and\r\ncan be desugared automatically as follows: generate a heating/cooling equation for each argument like in\r\nthe case of strict, but requiring that all its previous arguments are in KResult. For example, the seqstrict\r\nattribute of ≤ desugars into (a1, a2 range over K and r1 over KResult):\r\na1 ≤ a2 \n a1 y \u0003 ≤ a2\r\nr1 ≤ a2 \n a2 y r1 ≤ \u0003\r\nLike in the case of the strict attribute, seqstrict can also take a list of numbers as argument and then the\r\nheating/cooling equations are generated so that the corresponding arguments are processed in that order.\r\nUseful K labels. One can use heating/cooling equations to also define computational structural equivalences\r\n19\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/73295a90-f885-427a-8342-92663cad2a91.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a2492f7b032e48c89d33fe8b060e77d932caac7d0a0bdde4f8ca085bd183b664",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 727
      },
      {
        "segments": [
          {
            "segment_id": "73295a90-f885-427a-8342-92663cad2a91",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "What is wrong in the above “proof” is that one cannot apply the second equation in the second step above,\r\nbecause \u0003 + a2 is nothing but a convenient way to write the frozen computation \u0003 + (a2). One may say\r\nthat there is no problem with the above, because + is intended to be commutative anyway; unfortunately,\r\nthe same could be proved for any non-deterministic construct, for example for a division operation, “/”, if\r\nthat was to be included in our language. Since the heating/cooling equations are thought of as structural\r\nidentities, so that computational steps take place modulo them, then it would certainly be wrong to have\r\nboth “a1/a2” and “a2/a1” in the same computational equivalence class. One of K’s most subtle technical\r\naspects, which fortunately is transparent to users, is to find the right (i.e., as weak as possible) restrictions\r\non the applications of heating/cooling equations, so that each computational equivalence class contains no\r\nmore than one fragment of program. This is called “computation adequacy” and is discussed in detail in\r\nAppendix ??. The idea is to only allow heating and/or cooling of operator arguments that are proper\r\nsyntactic computations (i.e., terms over the original syntax, i.e., different from “·” and containing no “y”).\r\nWith that, for example, the computation equivalence class of the expression x ∗ (y + 2) in the context of a\r\nlanguage definition with non-deterministically strict binary + and ∗, consists of the terms:\r\nx ∗ (y + 2)\r\nx y (\u0003 ∗ (y + 2))\r\nx y (\u0003 ∗ (y y (\u0003 + 2)))\r\nx y (\u0003 ∗ (2 y (y + \u0003)))\r\n(y + 2) y (x ∗ \u0003)\r\ny y (\u0003 + 2) y (x ∗ \u0003)\r\n2 y (y + \u0003) y (x ∗ \u0003)\r\nx ∗ (y y (\u0003 + 2))\r\nx ∗ (2 y (y + \u0003))\r\nNote that there is only one syntactic computation in the computation equivalence class above, namely the\r\noriginal expression itself. This is a crucial desired property of K.\r\nStrict attribute. In K definitions, one typically defines zero, one, or more heating/cooling equations per lan\u0002guage construct, depending on its intended processing strategy. These equations tend to be straightforward\r\nand boring to write, so in K we prefer a higher-level and more compact and intuitive approach: we annotate\r\nthe language syntax with strictness attributes. A language construct annotated as strict, such as for example\r\nthe “ + ” in Figure 1, is automatically associated a heating/cooling equation as above for each of its subex\u0002pressions. If an operator is intended to be strict in only some of its arguments, then the positions of the strict\r\narguments are listed as arguments of the strict attribute. For example, note that the strictness attribute of\r\nif then else in Figure 1 is strict(1); that means that a heating/cooling equation is added only for the first\r\nsubexpression of the conditional, namely the equation “if b then s1 else s2 \n b y if \u0003 then s1 else s2”.\r\nSeqstrict attribute. Recall that the two heating/cooling equations corresponding to the strictness attribute\r\nstrict of + above did not enforce any particular order in which the two subexpressions were processed. It\r\nis often the case that one wants a deterministic order in which the strict arguments of a language construct\r\nare processed, typically from left to right. Such an example is the relational operator ≤ in Figure 1, which\r\nwas declared the strictness attribute seqstrict, saying that its subexpressions are processed deterministically,\r\nfrom left to right. The attribute seqstrict can be used only in definitions with a non-empty KResult and\r\ncan be desugared automatically as follows: generate a heating/cooling equation for each argument like in\r\nthe case of strict, but requiring that all its previous arguments are in KResult. For example, the seqstrict\r\nattribute of ≤ desugars into (a1, a2 range over K and r1 over KResult):\r\na1 ≤ a2 \n a1 y \u0003 ≤ a2\r\nr1 ≤ a2 \n a2 y r1 ≤ \u0003\r\nLike in the case of the strict attribute, seqstrict can also take a list of numbers as argument and then the\r\nheating/cooling equations are generated so that the corresponding arguments are processed in that order.\r\nUseful K labels. One can use heating/cooling equations to also define computational structural equivalences\r\n19\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/73295a90-f885-427a-8342-92663cad2a91.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a2492f7b032e48c89d33fe8b060e77d932caac7d0a0bdde4f8ca085bd183b664",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 727
      },
      {
        "segments": [
          {
            "segment_id": "dc6b49aa-0454-4dc8-8a2a-27f74e7387f7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "on K terms involving auxiliary K labels, not necessarily corresponding to the original language syntax. For\r\nexample, some language constructs may have an arbitrary number of arguments, not always appearing as a\r\nlist, such as, for example, a letrec construct with a syntax like “letrec x1 = e1 and x2 = e2 and · · · and xn =\r\nen in e”. Since the expressions e1, e2, ..., en will need to be processed at some moment, it is very useful\r\nto extract them and schedule them for processing all at once. We assume two special K labels, strict and\r\nseqstrict, designed for such situations and defined as follows (kl, kl0 ∈ List[K], rl ∈ List[KResult], k ∈ K):\r\nstrict(·) = seqstrict(·) = ·\r\nstrict(kl, k, kl0) \n k y strict(kl, \u0003, kl0)\r\nseqstrict(rl, k, kl0) \n k y seqstrict(rl, \u0003, kl0)\r\nAs before, “\u0003” is not a hole but part of the name of a freezer, in our case of “strict( , \u0003, )” and “seqstrict( , \u0003, )”,\r\nrespectively, written in mixfix notation to ease reading. Recall that in the theoretical developments of K all\r\nsentences are schematas, so the two heating/cooling equations above comprise a recursively enumerable set\r\nof ground equations, one for each instance of the variables, including ones with kl, kl0, or rl empty lists. In\r\npractice, though, the above equations are universally quantified (or parametric) in their variables and their\r\napplication involves a matching modulo associativity; that is precisely how we implemented them in our\r\nMaude implementation of K (see Section E).\r\nGeneral strictness convention. More generally, we allow any K labels to be associated strictness at\u0002tributes. For example, one may define some label myEval as follows:\r\nKLabel ::= · · · | myEval [strict]\r\nThat means that myEval is strict in all its arguments, no matter how many they are, so that one can\r\nschedule e1, e2, . . . , en for processing by wrapping them in a term myEval(e1, e2, . . . , en). With this general\r\nconvention, the strictness of + and ≤ can also be defined as follows\r\nKLabel ::= · · · | + [strict] | ≤ [seqstrict]\r\nwhile the useful K labels strict and seqstrict are nothing but two builtin labels defined as follows:\r\nKLabel ::= · · · | strict [strict] | seqstrict [seqstrict].\r\n3.4 K Semantic Sentences: Equations and Rules\r\nIn its full generality as described in [33], K allows three types of sentences: structural (or non-computational),\r\ncomputational and non-deterministic. Regarded from a rewriting logic point of view, the structural sentences\r\nare always equations, while the non-deterministic ones are always rewrite rules; the computational sentences\r\ncan be either equations or rules, depending upon how one uses the K definition: if used exclusively for\r\nexecution to get an interpreter for the defined language, then it does not matter whether the computational\r\nsentences are equations or rules; if used for proofs by induction on computations, then one may want to\r\nregard all computational sentences as rules, so that the equational equivalence classes are as small and precise\r\nas possible; if used for model-checking a program, then one may regard all the computational sentences as\r\nequations, because they add no new behaviors and keeping them equations significantly reduces the state\u0002space to be analyzed by the model checker. However, to keep the presentation simple, in this paper we only\r\nconsider two types of sentences, like in rewriting logic: equations and rules. Equations are structural in\r\nnature and thus carry no computational meaning; they only say which terms should be viewed as identical\r\nand their role is to transparently modify the term so that rewrite rules can apply. Rewrite rules are seen\r\nas irreversible computational steps and can happen concurrently. All the heating/cooling equations in the\r\nprevious section were K equations. The following are also examples of equations:\r\nJpK = Jk(p) state(∅)K\r\ns1; s2 = s1 y s2\r\nwhile b do s = if b then (s;while b do s) else ·\r\n20\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dc6b49aa-0454-4dc8-8a2a-27f74e7387f7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=85c2a3d8102ff24094455889627ab47b358ce726bb68e74b4fe3803f91ba8493",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 677
      },
      {
        "segments": [
          {
            "segment_id": "dc6b49aa-0454-4dc8-8a2a-27f74e7387f7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "on K terms involving auxiliary K labels, not necessarily corresponding to the original language syntax. For\r\nexample, some language constructs may have an arbitrary number of arguments, not always appearing as a\r\nlist, such as, for example, a letrec construct with a syntax like “letrec x1 = e1 and x2 = e2 and · · · and xn =\r\nen in e”. Since the expressions e1, e2, ..., en will need to be processed at some moment, it is very useful\r\nto extract them and schedule them for processing all at once. We assume two special K labels, strict and\r\nseqstrict, designed for such situations and defined as follows (kl, kl0 ∈ List[K], rl ∈ List[KResult], k ∈ K):\r\nstrict(·) = seqstrict(·) = ·\r\nstrict(kl, k, kl0) \n k y strict(kl, \u0003, kl0)\r\nseqstrict(rl, k, kl0) \n k y seqstrict(rl, \u0003, kl0)\r\nAs before, “\u0003” is not a hole but part of the name of a freezer, in our case of “strict( , \u0003, )” and “seqstrict( , \u0003, )”,\r\nrespectively, written in mixfix notation to ease reading. Recall that in the theoretical developments of K all\r\nsentences are schematas, so the two heating/cooling equations above comprise a recursively enumerable set\r\nof ground equations, one for each instance of the variables, including ones with kl, kl0, or rl empty lists. In\r\npractice, though, the above equations are universally quantified (or parametric) in their variables and their\r\napplication involves a matching modulo associativity; that is precisely how we implemented them in our\r\nMaude implementation of K (see Section E).\r\nGeneral strictness convention. More generally, we allow any K labels to be associated strictness at\u0002tributes. For example, one may define some label myEval as follows:\r\nKLabel ::= · · · | myEval [strict]\r\nThat means that myEval is strict in all its arguments, no matter how many they are, so that one can\r\nschedule e1, e2, . . . , en for processing by wrapping them in a term myEval(e1, e2, . . . , en). With this general\r\nconvention, the strictness of + and ≤ can also be defined as follows\r\nKLabel ::= · · · | + [strict] | ≤ [seqstrict]\r\nwhile the useful K labels strict and seqstrict are nothing but two builtin labels defined as follows:\r\nKLabel ::= · · · | strict [strict] | seqstrict [seqstrict].\r\n3.4 K Semantic Sentences: Equations and Rules\r\nIn its full generality as described in [33], K allows three types of sentences: structural (or non-computational),\r\ncomputational and non-deterministic. Regarded from a rewriting logic point of view, the structural sentences\r\nare always equations, while the non-deterministic ones are always rewrite rules; the computational sentences\r\ncan be either equations or rules, depending upon how one uses the K definition: if used exclusively for\r\nexecution to get an interpreter for the defined language, then it does not matter whether the computational\r\nsentences are equations or rules; if used for proofs by induction on computations, then one may want to\r\nregard all computational sentences as rules, so that the equational equivalence classes are as small and precise\r\nas possible; if used for model-checking a program, then one may regard all the computational sentences as\r\nequations, because they add no new behaviors and keeping them equations significantly reduces the state\u0002space to be analyzed by the model checker. However, to keep the presentation simple, in this paper we only\r\nconsider two types of sentences, like in rewriting logic: equations and rules. Equations are structural in\r\nnature and thus carry no computational meaning; they only say which terms should be viewed as identical\r\nand their role is to transparently modify the term so that rewrite rules can apply. Rewrite rules are seen\r\nas irreversible computational steps and can happen concurrently. All the heating/cooling equations in the\r\nprevious section were K equations. The following are also examples of equations:\r\nJpK = Jk(p) state(∅)K\r\ns1; s2 = s1 y s2\r\nwhile b do s = if b then (s;while b do s) else ·\r\n20\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dc6b49aa-0454-4dc8-8a2a-27f74e7387f7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=85c2a3d8102ff24094455889627ab47b358ce726bb68e74b4fe3803f91ba8493",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 677
      },
      {
        "segments": [
          {
            "segment_id": "0e296954-c425-4dbd-9ee4-051434c304ef",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "The “·” in the “ else” branch is the unit of K. The following are examples of rewrite rules:\r\ni1 + i2 → i when i is the sum of i1 and i2\r\nif true then s1 else s2 → s1\r\nif false then s1 else s2 → s2\r\nk(x y rest) state(σ) → k(σ[x] y rest) state(σ)\r\nStructural equations, like the heating and cooling equations, can be applied back and forth, while the rewrite\r\nrules can only be applied from left-to-right. For example, the heating/cooling equations of + can be applied\r\nleft-to-right to “schedule” the two sub-computations for evaluation and then right-to-left to plug their results\r\nback, and then a rewrite rule like the first one above can apply to irreversibly make the computational step.\r\nOne should be careful when defining language constructs that have “sequential effects” on the configuration,\r\nso that those effects are propagated appropriately: these constructs should be processed only when they are\r\nplaced at the leftmost side of the computation (see, for example, the last rule above for variable lookup).\r\nFigure 3 shows all the equations and rewrite rules corresponding to the K definition of the simple im\u0002perative language in Figure 1, that is, its corresponding rewrite logic theory. For clarity, we grouped the\r\nequations and rules by the syntactic construct whose semantics they define.\r\nWhen defining a language in K, one may need to define three things (these are not always all needed):\r\n• A configuration structure, serving as a backbone for storing everything we need, such as computations,\r\nthreads, states, environments, etc. It can have various layers of information, and configuration items\r\nare allowed to multiply themselves. We have a flat, two-item configuration in our example above.\r\n• Computation structural equations, or heating/cooling equations, allowing one to change representations\r\nof computations at will. Each fragment of program will have a unique computation equivalence class,\r\nwhich can be derived using the computation structural equations.\r\n• Rewriting rules and equations. Rules capture the execution steps of the defined language. Equations\r\ncapture structural rearrangements that do not count as execution steps.\r\nAs already explained in Section 3.2, computations have a monoid structure (with unit a central dot\r\n“·” and with composition y , called “computation sequencing”) and extend the syntax of the language,\r\nmore precisely, its abstract syntax trees (AST). All the original syntactic categories, such as AExp, BExp,\r\nStmt, Pgm in our case, are sinked into computations. Also, all the language constructs become simple K\r\nlabels. To ease notation and reading, we sometimes use intuitive names, such as a, b, s, or p, to refer\r\nto computations originating from AExp, BExp, Stmt, or Pgm, respectively (we did that in Figure 1 but\r\nnot in Figure 3), and use the language constructs in their original, mixfix syntax (we did that both in\r\nFigure 1 and in Figure 3). As pointed out in Section 3.3, most computation structural equations can be\r\nderived automatically from strictness attributes annotating the language constructs. In K we freely use such\r\nstrictness attributes to keep our definitions more compact and less boring. Note, however, that there is\r\nalmost a one-to-one correspondence between the context reduction definition in Figure 1 (left column) and\r\nthe rewrite logic theory in Figure 3 corresponding to the K definition in 1 (right column). As shown in Section\r\n5.4.6, context reduction can be captured formally, automatically and faithfully in K; by “faithfully” we mean\r\nthat everything that can be done with the context reduction definition, can be done, in an isomorphic\r\ncorrespondence, in the resulting K definition.\r\nEven though context reduction can be used as a definitional methodology within K, it will often be more\r\nconvenient to define languages directly in K, using K’s full strength and deviating from the strict obedience\r\nof syntax. For example, note that in order to give the semantics of assignment and while loops, the context\r\nreduction definition in Figure 1 had to “enrich” the syntax with a special “result” statement skip, which was\r\nnot part of the original language; all statements then evaluate to this special statement skip, and skip also\r\nneeds to be propagated through the syntax (only “skip; s → s” in this simple language, but one may need\r\nmore such propagation rules in more complex languages, e.g., “{skip} → skip”, “{varDecl;skip} → skip”,\r\netc.). If one follows the context reduction style in K, then one would have to do the same thing. However, in\r\nFigures 1 and 3 we subtly deviated from the context reduction methodology, because, from a K perspective,\r\n21\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0e296954-c425-4dbd-9ee4-051434c304ef.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c31eebb7f4a36aa932c86a33409ea4424a6ead1c06f7637d70ffc2e596a64820",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 768
      },
      {
        "segments": [
          {
            "segment_id": "0e296954-c425-4dbd-9ee4-051434c304ef",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "The “·” in the “ else” branch is the unit of K. The following are examples of rewrite rules:\r\ni1 + i2 → i when i is the sum of i1 and i2\r\nif true then s1 else s2 → s1\r\nif false then s1 else s2 → s2\r\nk(x y rest) state(σ) → k(σ[x] y rest) state(σ)\r\nStructural equations, like the heating and cooling equations, can be applied back and forth, while the rewrite\r\nrules can only be applied from left-to-right. For example, the heating/cooling equations of + can be applied\r\nleft-to-right to “schedule” the two sub-computations for evaluation and then right-to-left to plug their results\r\nback, and then a rewrite rule like the first one above can apply to irreversibly make the computational step.\r\nOne should be careful when defining language constructs that have “sequential effects” on the configuration,\r\nso that those effects are propagated appropriately: these constructs should be processed only when they are\r\nplaced at the leftmost side of the computation (see, for example, the last rule above for variable lookup).\r\nFigure 3 shows all the equations and rewrite rules corresponding to the K definition of the simple im\u0002perative language in Figure 1, that is, its corresponding rewrite logic theory. For clarity, we grouped the\r\nequations and rules by the syntactic construct whose semantics they define.\r\nWhen defining a language in K, one may need to define three things (these are not always all needed):\r\n• A configuration structure, serving as a backbone for storing everything we need, such as computations,\r\nthreads, states, environments, etc. It can have various layers of information, and configuration items\r\nare allowed to multiply themselves. We have a flat, two-item configuration in our example above.\r\n• Computation structural equations, or heating/cooling equations, allowing one to change representations\r\nof computations at will. Each fragment of program will have a unique computation equivalence class,\r\nwhich can be derived using the computation structural equations.\r\n• Rewriting rules and equations. Rules capture the execution steps of the defined language. Equations\r\ncapture structural rearrangements that do not count as execution steps.\r\nAs already explained in Section 3.2, computations have a monoid structure (with unit a central dot\r\n“·” and with composition y , called “computation sequencing”) and extend the syntax of the language,\r\nmore precisely, its abstract syntax trees (AST). All the original syntactic categories, such as AExp, BExp,\r\nStmt, Pgm in our case, are sinked into computations. Also, all the language constructs become simple K\r\nlabels. To ease notation and reading, we sometimes use intuitive names, such as a, b, s, or p, to refer\r\nto computations originating from AExp, BExp, Stmt, or Pgm, respectively (we did that in Figure 1 but\r\nnot in Figure 3), and use the language constructs in their original, mixfix syntax (we did that both in\r\nFigure 1 and in Figure 3). As pointed out in Section 3.3, most computation structural equations can be\r\nderived automatically from strictness attributes annotating the language constructs. In K we freely use such\r\nstrictness attributes to keep our definitions more compact and less boring. Note, however, that there is\r\nalmost a one-to-one correspondence between the context reduction definition in Figure 1 (left column) and\r\nthe rewrite logic theory in Figure 3 corresponding to the K definition in 1 (right column). As shown in Section\r\n5.4.6, context reduction can be captured formally, automatically and faithfully in K; by “faithfully” we mean\r\nthat everything that can be done with the context reduction definition, can be done, in an isomorphic\r\ncorrespondence, in the resulting K definition.\r\nEven though context reduction can be used as a definitional methodology within K, it will often be more\r\nconvenient to define languages directly in K, using K’s full strength and deviating from the strict obedience\r\nof syntax. For example, note that in order to give the semantics of assignment and while loops, the context\r\nreduction definition in Figure 1 had to “enrich” the syntax with a special “result” statement skip, which was\r\nnot part of the original language; all statements then evaluate to this special statement skip, and skip also\r\nneeds to be propagated through the syntax (only “skip; s → s” in this simple language, but one may need\r\nmore such propagation rules in more complex languages, e.g., “{skip} → skip”, “{varDecl;skip} → skip”,\r\netc.). If one follows the context reduction style in K, then one would have to do the same thing. However, in\r\nFigures 1 and 3 we subtly deviated from the context reduction methodology, because, from a K perspective,\r\n21\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0e296954-c425-4dbd-9ee4-051434c304ef.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c31eebb7f4a36aa932c86a33409ea4424a6ead1c06f7637d70ffc2e596a64820",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 768
      },
      {
        "segments": [
          {
            "segment_id": "9924acb0-34b4-4e3b-b253-ce1af0f747bc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "Configuration\r\n\r\n\r\n\r\nKResult ::= Val\r\nConfigItem ::= k(K) | state(State)\r\nConfig ::= Int | JKK | JSet[ConfigItem]K\r\nInitialization\r\nTermination \u001a\r\nJpK = Jk(p) state(∅)K\r\nJk(v) restConfigK = v\r\nVariable lookup \b\r\nk(x y rest) state(σ) → k(σ[x] y rest) state(σ)\r\nAExp + AExp\r\n\r\n\r\n\r\nk1 + k2 \n k1 y \u0003 + k2\r\nk1 + k2 \n k2 y k1 + \u0003\r\ni1 + i2 → i1 +Int i2\r\nAExp ≤ AExp\r\n\r\n\r\n\r\nk1 ≤ k2 \n k1 y \u0003 ≤ k2\r\ni ≤ k2 \n k2 y i ≤ \u0003\r\ni1 ≤ i2 → i1 ≤Int i2\r\nnot BExp \u001a\r\nnot k \n k y not \u0003\r\nnot b → notBool b\r\nBExp and BExp\r\n\r\n\r\n\r\nk1 and k2 \n k1 y \u0003 and k2\r\ntrue and k → k\r\nfalse and k → false\r\nName := AExp \u001a\r\nx := k \n k y x := \u0003\r\nk(x := v y rest) state(σ) → k(rest) state(σ[v/x])\r\nStmt; Stmt \b\r\nk1; k2 \n k1 y k2\r\nif BExp then Stmt else St\r\n\r\n\r\n\r\nif k then k1 else k2 \n k y if \u0003 then k1 else k2\r\nif true then k1 else k2 → k1\r\nif false then k1 else k2 → k2\r\nwhile BExp do Stmt \b\r\nk((while k1 do k2) y rest) = k((if k1 then (k2;while k1 do k2) else ·) y rest)\r\nhalt AExp \u001a\r\nhalt k \n k y halt \u0003\r\nk((halt i) y rest) = k(i)\r\nFigure 3: Automatically desugared rewriting logic variant of the imperative language in Figure 1\r\nintroducing the skip statement would be a rather artificial and unnecessary step. Instead, we just “dissolved”\r\nthe statements whenever they carried no further computational meaning (by identifying them with the\r\nempty computation) and captured the semantics of sequential composition with precisely one equation,\r\n“k1; k2 = k1 y k2”; when k1 is finished it becomes the empty computation and then k2 becomes naturally\r\n(with no additional rewrite step) the next task.\r\nTo start the rewriting machinery, one needs to create an initial configuration with the given program\r\n(first equation in Figure 3). Typically, the program is placed somewhere in the configuration where a\r\ncomputation is expected. If everything is as expected (program terminates, no “runtime errors”, etc.), the\r\nprogram will eventually become a result. When that happens, one can dissolve the configuration and keep\r\n22\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9924acb0-34b4-4e3b-b253-ce1af0f747bc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=36486f623f7d457d87e6575ec86d4331988c04ff0de63102a9cde400a4b68546",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      },
      {
        "segments": [
          {
            "segment_id": "c144f258-6ab5-4e5f-9ac4-cfdda83cda8d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "the result (second equation in Figure 3). Note that both these steps are purely structural, preparing things\r\nfor evaluation or collecting results, so they have no computational meaning; therefore, they are defined with\r\nequations instead of rewrite rules.\r\n3.5 K Specialized Notation: Attributes, Contexts, Angle Brackets\r\nIn K definitions, rewrite rules and equations can be given either explicitly as above, or implicitly through a\r\nspecialized and optimized K-notation explained next. A beginner would probably prefer explicit equations\r\nand rules, but an expert can take advantage of K’s compact notation and move quickly to the interesting\r\naspects of the definition, letting low-level details to be automatically filled through the implicit desugaring\r\nmechanisms explained below. Here is the intuition behind the major K notations:\r\nK Attributes. We have already discussed the strictness attributes strict and seqstrict, as well as their\r\nautomatic desugaring into heating/cooling equations in Section 3.3. The definition of the imperative language\r\nin Figure 1 made use of another K attribute, extends. The attribute extends can only be used in combination\r\nwith a strict or seqstrict attribute, and corresponds to a rewrite rule saying what to do after the strict\r\narguments were evaluated. A construct may have more than one extends attribute; a rewrite rule will be\r\ngenerated for each. The extends attribute for addition, for example, corresponds to the rule\r\ni1 + i2 → i1 +Int i2 where i1, i2 ∈ Int.\r\nThere is one more attribute, namely one that can be associated to configuration constructs: multiply. The\r\nmultiply attribute is useful when one wants to enhance the modularity of K definitions using K’s context\r\ntransforming capability; it basically says that the corresponding configuration attribute is allowed to multi\u0002ply as part of the same level configuration soup. For example, since threads can be created or terminated\r\ndynamically and since each thread has its own sub-configuration soup (containing a computation, an en\u0002vironment, resources, etc.) in the global program configuration, one may want to associate the attribute\r\nmultiply to the thread ConfigLabel. This way, the context transforming procedure knows how to desugar\r\nrules or equations mentioning the same type of configuration item twice or more times. For example, the\r\nrule for rendez-vous synchronization in Section 6 mentions “k(rv v...) k(rv v...)”, which does not match as\r\ngiven, because each k is part of a different thread; however, since the configuration item label k was not\r\ndeclared to multiply, while thread is, the context transformers will automatically place each k inside a thread:\r\n“thread(k(rv v...)...) thread(k(rv v...)...)”.\r\nK Contexts. To avoid repeating context information that does not change in the left-hand and and the\r\nright-hand -sides of equations and rules, we take the liberty to use the two-dimensional notation\r\nC[t1\r\nt\r\n0\r\n1\r\n, t2\r\nt\r\n0\r\n2\r\n, ..., tn\r\nt\r\n0\r\nn\r\n]\r\nfor rules C[t1, t2, ..., tn] → C[t\r\n0\r\n1\r\n, t0\r\n2\r\n, ..., t0\r\nn], and similarly\r\nC[t1\r\nt\r\n0\r\n1\r\n, t2\r\nt\r\n0\r\n2\r\n, ..., tn\r\nt\r\n0\r\nn\r\n] (dotted horizontal lines)\r\nfor equations C[t1, t2, ..., tn] = C[t\r\n0\r\n1\r\n, t0\r\n2\r\n, ..., t0\r\nn\r\n]. When using K in ASCII, we typically replace the horizontal\r\nlines by ⇒, so we write C[t1 ⇒ t\r\n0\r\n1\r\n, t2 ⇒ t\r\n0\r\n2\r\n, ..., tn ⇒ t\r\n0\r\nn]; to distinguish between equations and rules in this\r\nlatter case, we prefix the sentence with a rl or eq keyword.\r\nK Underscore Variables and Angle Brackets. The K-context notation above allows for two other\r\nnotation optimizations. Like in Prolog, we use an underscore “ ” as a variable matching anything that we\r\ndon’t care (if we had not used the two-dimensional notation, then we would have had to know the name of\r\neach variable, because we would have had to repeat it in the right-hand-side). With the K-context and the\r\n23\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/c144f258-6ab5-4e5f-9ac4-cfdda83cda8d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=64beb7a4373fcc1e7e00a5d3443c9b6622b8cc078e0bacb5346a4baa656d2aff",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 659
      },
      {
        "segments": [
          {
            "segment_id": "c144f258-6ab5-4e5f-9ac4-cfdda83cda8d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "the result (second equation in Figure 3). Note that both these steps are purely structural, preparing things\r\nfor evaluation or collecting results, so they have no computational meaning; therefore, they are defined with\r\nequations instead of rewrite rules.\r\n3.5 K Specialized Notation: Attributes, Contexts, Angle Brackets\r\nIn K definitions, rewrite rules and equations can be given either explicitly as above, or implicitly through a\r\nspecialized and optimized K-notation explained next. A beginner would probably prefer explicit equations\r\nand rules, but an expert can take advantage of K’s compact notation and move quickly to the interesting\r\naspects of the definition, letting low-level details to be automatically filled through the implicit desugaring\r\nmechanisms explained below. Here is the intuition behind the major K notations:\r\nK Attributes. We have already discussed the strictness attributes strict and seqstrict, as well as their\r\nautomatic desugaring into heating/cooling equations in Section 3.3. The definition of the imperative language\r\nin Figure 1 made use of another K attribute, extends. The attribute extends can only be used in combination\r\nwith a strict or seqstrict attribute, and corresponds to a rewrite rule saying what to do after the strict\r\narguments were evaluated. A construct may have more than one extends attribute; a rewrite rule will be\r\ngenerated for each. The extends attribute for addition, for example, corresponds to the rule\r\ni1 + i2 → i1 +Int i2 where i1, i2 ∈ Int.\r\nThere is one more attribute, namely one that can be associated to configuration constructs: multiply. The\r\nmultiply attribute is useful when one wants to enhance the modularity of K definitions using K’s context\r\ntransforming capability; it basically says that the corresponding configuration attribute is allowed to multi\u0002ply as part of the same level configuration soup. For example, since threads can be created or terminated\r\ndynamically and since each thread has its own sub-configuration soup (containing a computation, an en\u0002vironment, resources, etc.) in the global program configuration, one may want to associate the attribute\r\nmultiply to the thread ConfigLabel. This way, the context transforming procedure knows how to desugar\r\nrules or equations mentioning the same type of configuration item twice or more times. For example, the\r\nrule for rendez-vous synchronization in Section 6 mentions “k(rv v...) k(rv v...)”, which does not match as\r\ngiven, because each k is part of a different thread; however, since the configuration item label k was not\r\ndeclared to multiply, while thread is, the context transformers will automatically place each k inside a thread:\r\n“thread(k(rv v...)...) thread(k(rv v...)...)”.\r\nK Contexts. To avoid repeating context information that does not change in the left-hand and and the\r\nright-hand -sides of equations and rules, we take the liberty to use the two-dimensional notation\r\nC[t1\r\nt\r\n0\r\n1\r\n, t2\r\nt\r\n0\r\n2\r\n, ..., tn\r\nt\r\n0\r\nn\r\n]\r\nfor rules C[t1, t2, ..., tn] → C[t\r\n0\r\n1\r\n, t0\r\n2\r\n, ..., t0\r\nn], and similarly\r\nC[t1\r\nt\r\n0\r\n1\r\n, t2\r\nt\r\n0\r\n2\r\n, ..., tn\r\nt\r\n0\r\nn\r\n] (dotted horizontal lines)\r\nfor equations C[t1, t2, ..., tn] = C[t\r\n0\r\n1\r\n, t0\r\n2\r\n, ..., t0\r\nn\r\n]. When using K in ASCII, we typically replace the horizontal\r\nlines by ⇒, so we write C[t1 ⇒ t\r\n0\r\n1\r\n, t2 ⇒ t\r\n0\r\n2\r\n, ..., tn ⇒ t\r\n0\r\nn]; to distinguish between equations and rules in this\r\nlatter case, we prefix the sentence with a rl or eq keyword.\r\nK Underscore Variables and Angle Brackets. The K-context notation above allows for two other\r\nnotation optimizations. Like in Prolog, we use an underscore “ ” as a variable matching anything that we\r\ndon’t care (if we had not used the two-dimensional notation, then we would have had to know the name of\r\neach variable, because we would have had to repeat it in the right-hand-side). With the K-context and the\r\n23\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/c144f258-6ab5-4e5f-9ac4-cfdda83cda8d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=64beb7a4373fcc1e7e00a5d3443c9b6622b8cc078e0bacb5346a4baa656d2aff",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 659
      },
      {
        "segments": [
          {
            "segment_id": "736c2ba5-cb0e-4ad0-9f51-8463f5be0635",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "underscore variable notations, the rule for assignment in our simple imperative language in Figure 3 becomes\r\nLx := v\r\n·\r\ny Mk L σ\r\nσ[v/x]\r\nMstate\r\nThe even more compact notation in Figure 1 uses the K angle bracket convention Lx := v|ik which can be\r\nused whenever the cell-enclosed structure is a list or a set. The angle bracket reads “and so on” (to the right\r\nhere, but it can also be to the left).\r\nLike most notations, the K-notation may look strange, obscure and even artificial at first sight. One is,\r\nof course, free to use it or not to use it. K’s notational conventions were not designed in an adhoc manner,\r\nbut through a series of iterations and refinements, defining large languages in K and observing that many\r\nlanguage or language-related definitions follow similar patterns, in particular that the designer was forced by\r\nthe previously rigid formalism to repeat large portions of the lhs of a rule into its rhs. Repetitive definitions\r\nand redundancy are not only boring and heavy looking, but, more importantly, they are error prone and\r\neven may reduce modularity. Consider, as an example, the angle bracket notation above; writing Lx := v|ik\r\ninstead of Lx := v y Mk gives us the freedom to change the name of the list construct “ y ” without having\r\nto touch most of the existing rules; changing such list construct names is not uncommon — for example, one\r\nmay want to change “ y ” into “ yconcrete ” when one also wants to add a type system to a language, in\r\nwhich case one may use “ ytype ” as a construct for computations that rewrite to types. Nevertheless, if\r\none does not want to use our optimized K-notation then one can simply ignore it. The philosophy of K stays\r\nnot in its specialized notation, but in its approach to define programming languages or language analyses by\r\n“swallowing” program syntax into computation structures, which can be heated/cooled and reduced by means\r\nof ordinary, context-insensitive term rewriting, at the same time giving a “true concurrency” semantics for\r\nthe defined language if that is what one wants. The specialized notation is nothing but an additional benefit\r\nthat the experimented users can take advantage of.\r\n4 Defining “Idealized” Programming Languages in K\r\nIn this section we give K definitions, including both syntax and semantics, to a series of common simple\r\nlanguages and calculi. By calling these “simple” we do not intend to minimize the importance of these\r\nlanguages or calculi2. On the contrary, we selected these particular languages and calculi because we believe\r\nthat they are intrinsically interesting and challenging from a mathematical and foundational point of view.\r\nHowever, looking at them through the eye of the designer of language design frameworks, these languages and\r\ncalculi should be easy to define in an ideal language definitional framework. Whenever necessary, we state\r\nresults saying that the corresponding K definition has the desired properties of the calculus or the language.\r\nThe purpose of this section is twofold: on the one hand, it has an illustrory role, showing various uses of K\r\nthat may give the reader hints on how more complex languages can be defined in K; on the other hand, we\r\nare not aware of any language definitional formalism or technique that can define all these languages and/or\r\ncalculi in a uniform way, so it indirectly shows the strength and versatility of K.\r\nEven though some of the calculi, languages and/or features below are challenging in their own way\r\nfor some of the language definitional frameworks, one should not get tricked to conclude that they serve\r\nas a “definitive benchmark” for evaluating language definitional frameworks. Many language definitional\r\nframeworks look reasonable on paper when defining simple calculi or idealized languages or features like the\r\nones in this section, but they tend to violate some or most of the requirements listed in Section 1, most\r\nimportantly they do not scale. Therefore, we prefer to rather regard the examples in this section as a\r\n“minimal benchmark”, in the sense that a language definitional framework that struggles to define these may,\r\nmost likely, not be practical. Also, the fact that a framework or technique can naturally define these calculi,\r\nlanguages and features, should not be taken as conclusive: it only proves that the framework or technique\r\nis not entirely impractical in general. A much better benchmark could be the K-CHALLENGE language\r\n2Similarly, the fact that groups can be defined as simple three-equation algebraic specifications or first-order theories does\r\nnot make group theory less important or interesting.\r\n24\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/736c2ba5-cb0e-4ad0-9f51-8463f5be0635.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6a434f1f482eba299f39555f51a90591fb5590353e644aba66914e355f4affe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 780
      },
      {
        "segments": [
          {
            "segment_id": "736c2ba5-cb0e-4ad0-9f51-8463f5be0635",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "underscore variable notations, the rule for assignment in our simple imperative language in Figure 3 becomes\r\nLx := v\r\n·\r\ny Mk L σ\r\nσ[v/x]\r\nMstate\r\nThe even more compact notation in Figure 1 uses the K angle bracket convention Lx := v|ik which can be\r\nused whenever the cell-enclosed structure is a list or a set. The angle bracket reads “and so on” (to the right\r\nhere, but it can also be to the left).\r\nLike most notations, the K-notation may look strange, obscure and even artificial at first sight. One is,\r\nof course, free to use it or not to use it. K’s notational conventions were not designed in an adhoc manner,\r\nbut through a series of iterations and refinements, defining large languages in K and observing that many\r\nlanguage or language-related definitions follow similar patterns, in particular that the designer was forced by\r\nthe previously rigid formalism to repeat large portions of the lhs of a rule into its rhs. Repetitive definitions\r\nand redundancy are not only boring and heavy looking, but, more importantly, they are error prone and\r\neven may reduce modularity. Consider, as an example, the angle bracket notation above; writing Lx := v|ik\r\ninstead of Lx := v y Mk gives us the freedom to change the name of the list construct “ y ” without having\r\nto touch most of the existing rules; changing such list construct names is not uncommon — for example, one\r\nmay want to change “ y ” into “ yconcrete ” when one also wants to add a type system to a language, in\r\nwhich case one may use “ ytype ” as a construct for computations that rewrite to types. Nevertheless, if\r\none does not want to use our optimized K-notation then one can simply ignore it. The philosophy of K stays\r\nnot in its specialized notation, but in its approach to define programming languages or language analyses by\r\n“swallowing” program syntax into computation structures, which can be heated/cooled and reduced by means\r\nof ordinary, context-insensitive term rewriting, at the same time giving a “true concurrency” semantics for\r\nthe defined language if that is what one wants. The specialized notation is nothing but an additional benefit\r\nthat the experimented users can take advantage of.\r\n4 Defining “Idealized” Programming Languages in K\r\nIn this section we give K definitions, including both syntax and semantics, to a series of common simple\r\nlanguages and calculi. By calling these “simple” we do not intend to minimize the importance of these\r\nlanguages or calculi2. On the contrary, we selected these particular languages and calculi because we believe\r\nthat they are intrinsically interesting and challenging from a mathematical and foundational point of view.\r\nHowever, looking at them through the eye of the designer of language design frameworks, these languages and\r\ncalculi should be easy to define in an ideal language definitional framework. Whenever necessary, we state\r\nresults saying that the corresponding K definition has the desired properties of the calculus or the language.\r\nThe purpose of this section is twofold: on the one hand, it has an illustrory role, showing various uses of K\r\nthat may give the reader hints on how more complex languages can be defined in K; on the other hand, we\r\nare not aware of any language definitional formalism or technique that can define all these languages and/or\r\ncalculi in a uniform way, so it indirectly shows the strength and versatility of K.\r\nEven though some of the calculi, languages and/or features below are challenging in their own way\r\nfor some of the language definitional frameworks, one should not get tricked to conclude that they serve\r\nas a “definitive benchmark” for evaluating language definitional frameworks. Many language definitional\r\nframeworks look reasonable on paper when defining simple calculi or idealized languages or features like the\r\nones in this section, but they tend to violate some or most of the requirements listed in Section 1, most\r\nimportantly they do not scale. Therefore, we prefer to rather regard the examples in this section as a\r\n“minimal benchmark”, in the sense that a language definitional framework that struggles to define these may,\r\nmost likely, not be practical. Also, the fact that a framework or technique can naturally define these calculi,\r\nlanguages and features, should not be taken as conclusive: it only proves that the framework or technique\r\nis not entirely impractical in general. A much better benchmark could be the K-CHALLENGE language\r\n2Similarly, the fact that groups can be defined as simple three-equation algebraic specifications or first-order theories does\r\nnot make group theory less important or interesting.\r\n24\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/736c2ba5-cb0e-4ad0-9f51-8463f5be0635.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6a434f1f482eba299f39555f51a90591fb5590353e644aba66914e355f4affe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 780
      },
      {
        "segments": [
          {
            "segment_id": "60a134d0-9ef5-4f35-adcf-748c25cfdd1f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "in Section 6, the languages in the appendixes of this paper, or even realistic languages, such as Java and\r\nScheme. All these have been defined in K following the very same uniform definitional approach.\r\n4.1 Defining Turing Machines\r\nEquational encodings of general computation into equational deduction are well-known; for example, [4, 2]\r\nshow such encodings, where the resulting equational specifications, if regarded as term rewrite systems\r\n(TRSs), are confluent and terminate whenever the original computation terminates. Our goal in this section\r\nis to discuss a simple definition of (Turing machine) computations in K. While any of the existing encodings\r\nof Turing machines as unconditional TRSs can also serve as an example of how to define Turing machines\r\nin K (because K includes unconditional TRSs), we find the existing encodings more complex and intricate\r\nthan needed. Indeed, the encodings in [4, 2] aim at emphasizing the strength of equational reasoning or\r\nthe general undecidability of termination of term rewriting; they are not intended to be elegant or compact.\r\nSince K assumes lists and sets whenever needed and since reduction/rewriting takes place modulo (structural)\r\nequations (associativity of lists, etc.), we can give simpler, more intuitive and easier to understand definitions\r\nof Turing machines in K. The K rewrite theories associated to Turing machines below can be faithfully used as\r\nTuring-complete computational engines, because each rewrite step corresponds to precisely one computation\r\nstep in the Turing machine; in other words, there are no artificial rewrite steps.\r\nThere are many equivalent definitions of Turing machines in the literature. We prefer one adapted from\r\n[34], and describe it informally in the sequel. The reader is assumed familiar with basic intuitions of Turing\r\nmachines. Consider a mechanical device which has associated with it a tape of infinite length in both\r\ndirections, partitioned in spaces of equal size, called cells, which are able to hold either a “0” or an “1” and\r\nare rewritable. The device examines exactly one cell at any time, and can, potentially nondeterministically,\r\nperform any of the following four operations (or commands):\r\n1. Write a “1” in the current cell;\r\n2. Write a “0” in the current cell;\r\n3. Shift one cell to the right;\r\n4. Shift one cell to the left.\r\nThe device performs one operation per unit time, called a step. Formally, let Q be a finite set of internal\r\nstates, containing a starting state qs and a halting state qh. Let B = {0, 1} be a set of symbols (or bits)\r\nand C = {0, 1, →, ←} be a set of commands. Then a Turing machine is a multivalued function (i.e., a\r\ntotal relation) M : (Q − {qh}) × B → Q × C. If M is an ordinary function then the Turing machine is\r\ncalled deterministic. We assume that the tape contains only 0’s before the machine starts performing. A\r\nconfiguration of a Turing machine is a 4-tuple consisting of an internal state, a current cell, and two infinite\r\nstrings (notice that the two infinite strings contain only 0’s starting with a certain cell), standing for the\r\ncells on the left and for the cells on the right of the current cell, respectively. We let (q, LbR) denote the\r\nconfiguration in which the machine is in state q, with current cell b, left tape L and right tape R. For\r\nconvenience, we write the left tape L backwards, that is, its head is at its right end; for example, Lb cons\r\na b to the left tape L. Given a configuration (q, LbR), the content of the tape is LbR, which is infinite at\r\nboth ends. We also let (q, LbR) →M (q\r\n0\r\n, L0b\r\n0R0\r\n) denote a configuration transition under one of the four\r\ncommands. Given a configuration in which the internal state is q and the examined cell contains b, and if\r\n(q\r\n0\r\n, c) ∈ M(q, b), then exactly one of the following configuration transitions can take place:\r\n1. (q, LbR) →M (q\r\n0\r\n, LcR) if c = 0 or c = 1;\r\n2. (q, Lbb\r\n0R) →M (q0\r\n, Lbb0R) if c = →;\r\n3. (q, Lb0bR) →M (q\r\n0\r\n, Lb\r\n0\r\nbR) if c = ←.\r\n25\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/60a134d0-9ef5-4f35-adcf-748c25cfdd1f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e78d084548f099815912e0200af1cfdd03f302c058b1aedbe33e23bd7e1ff436",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 716
      },
      {
        "segments": [
          {
            "segment_id": "60a134d0-9ef5-4f35-adcf-748c25cfdd1f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "in Section 6, the languages in the appendixes of this paper, or even realistic languages, such as Java and\r\nScheme. All these have been defined in K following the very same uniform definitional approach.\r\n4.1 Defining Turing Machines\r\nEquational encodings of general computation into equational deduction are well-known; for example, [4, 2]\r\nshow such encodings, where the resulting equational specifications, if regarded as term rewrite systems\r\n(TRSs), are confluent and terminate whenever the original computation terminates. Our goal in this section\r\nis to discuss a simple definition of (Turing machine) computations in K. While any of the existing encodings\r\nof Turing machines as unconditional TRSs can also serve as an example of how to define Turing machines\r\nin K (because K includes unconditional TRSs), we find the existing encodings more complex and intricate\r\nthan needed. Indeed, the encodings in [4, 2] aim at emphasizing the strength of equational reasoning or\r\nthe general undecidability of termination of term rewriting; they are not intended to be elegant or compact.\r\nSince K assumes lists and sets whenever needed and since reduction/rewriting takes place modulo (structural)\r\nequations (associativity of lists, etc.), we can give simpler, more intuitive and easier to understand definitions\r\nof Turing machines in K. The K rewrite theories associated to Turing machines below can be faithfully used as\r\nTuring-complete computational engines, because each rewrite step corresponds to precisely one computation\r\nstep in the Turing machine; in other words, there are no artificial rewrite steps.\r\nThere are many equivalent definitions of Turing machines in the literature. We prefer one adapted from\r\n[34], and describe it informally in the sequel. The reader is assumed familiar with basic intuitions of Turing\r\nmachines. Consider a mechanical device which has associated with it a tape of infinite length in both\r\ndirections, partitioned in spaces of equal size, called cells, which are able to hold either a “0” or an “1” and\r\nare rewritable. The device examines exactly one cell at any time, and can, potentially nondeterministically,\r\nperform any of the following four operations (or commands):\r\n1. Write a “1” in the current cell;\r\n2. Write a “0” in the current cell;\r\n3. Shift one cell to the right;\r\n4. Shift one cell to the left.\r\nThe device performs one operation per unit time, called a step. Formally, let Q be a finite set of internal\r\nstates, containing a starting state qs and a halting state qh. Let B = {0, 1} be a set of symbols (or bits)\r\nand C = {0, 1, →, ←} be a set of commands. Then a Turing machine is a multivalued function (i.e., a\r\ntotal relation) M : (Q − {qh}) × B → Q × C. If M is an ordinary function then the Turing machine is\r\ncalled deterministic. We assume that the tape contains only 0’s before the machine starts performing. A\r\nconfiguration of a Turing machine is a 4-tuple consisting of an internal state, a current cell, and two infinite\r\nstrings (notice that the two infinite strings contain only 0’s starting with a certain cell), standing for the\r\ncells on the left and for the cells on the right of the current cell, respectively. We let (q, LbR) denote the\r\nconfiguration in which the machine is in state q, with current cell b, left tape L and right tape R. For\r\nconvenience, we write the left tape L backwards, that is, its head is at its right end; for example, Lb cons\r\na b to the left tape L. Given a configuration (q, LbR), the content of the tape is LbR, which is infinite at\r\nboth ends. We also let (q, LbR) →M (q\r\n0\r\n, L0b\r\n0R0\r\n) denote a configuration transition under one of the four\r\ncommands. Given a configuration in which the internal state is q and the examined cell contains b, and if\r\n(q\r\n0\r\n, c) ∈ M(q, b), then exactly one of the following configuration transitions can take place:\r\n1. (q, LbR) →M (q\r\n0\r\n, LcR) if c = 0 or c = 1;\r\n2. (q, Lbb\r\n0R) →M (q0\r\n, Lbb0R) if c = →;\r\n3. (q, Lb0bR) →M (q\r\n0\r\n, Lb\r\n0\r\nbR) if c = ←.\r\n25\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/60a134d0-9ef5-4f35-adcf-748c25cfdd1f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e78d084548f099815912e0200af1cfdd03f302c058b1aedbe33e23bd7e1ff436",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 716
      },
      {
        "segments": [
          {
            "segment_id": "cddb26fb-741b-4c5c-9826-94044759a483",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that the relation →M on configurations is nondeterministic in general because M can be a multifunc\u0002tion, but is deterministic if the Turing machine is deterministic (i.e., M is a function). The machine starts\r\nperforming in the internal state qs. If there is no input, the initial configuration on which the Turing machine\r\nis run is (qs, 0\r\nω00ω), where 0ω is the infinite string of zeros. If the Turing machine is intended to be run on\r\na specific input, say x = b1b2· · ·bn, its initial configuration is (qs, 0\r\nω0b1b2· · ·bn0ω). For simplicity, we assume\r\nthat inputs are always encoded as finite sequences of 1’s. We let →?\r\nM denote the transitive and reflexive\r\nclosure of the binary relation on configurations →M above. A Turing machine M terminates when it gets to\r\nits halting state, qh; formally, M terminates on input b1b2 · · · bn iff (qs, 0\r\nω0b1b2 · · · bn0ω) →?\r\nM (qh,LbR) for\r\nsome b ∈ B and some tape instances L and R. Note that a Turing machine cannot get stuck in any state\r\nbut qh, because the mapping M is defined everywhere except in qh. Therefore, a Turing machine carries\r\nout successions of steps, which may or may not terminate. Because of its non-determinism, it may be the\r\ncase that, for the same input, there are both terminating and non-terminating sequences; however, if the\r\nmachine terminates on the given input then there must be at least a terminating sequence for that input. If\r\nthe Turing machine is deterministic then the succession of steps is uniquely determined for any input and,\r\nobviously, the machine either terminates on the given input or it does not. It is well-known that Turing\r\nmachines can compute exactly the partial recursive functions [34].\r\nFrom here on in this section, let us fix a Turing machine M. We next define a K theory, KM, which\r\ncaptures precisely the Turing machine M, in the sense that any computational step in M corresponds to\r\nprecisely one rewrite step in KM. We start by defining the signature, or syntax, of KM . The syntactic\r\ncategory Q contains all the states of M and may obviously differ from Turing machine to Turing machine;\r\nthe other three syntactic categories, B, K and Config are generic for all Turing machines:\r\nQ ::= qs | qh | · · · the finite number of states of M\r\nB ::= 0 | 1\r\nK ::= B | List·\r\ny[K]\r\nConfig ::= LQMstate | LKMleft | LBMcell | LKMright | LSet[Config]M> | JList·[B]K | done\r\nThe configuration items LKMleft and LKMright hold the left and the right tapes, LBMcell holds the current\r\ncell, and LQMstate holds the current state. As usual, the input to the machine, which can be regarded as the\r\ninitial “computational structure”, is given enclosed by double brackets J K, and the initial configuration is\r\nwrapped into a L M> soup. The constant configuration done marks that the Turing machine computation\r\nterminated. The following two equations are generic for all machines M of start state qs and halt state qh:\r\nJinputK = LLqsMstate L·Mleft L0Mcell LinputMrightM>\r\nh|LqhMstate|i> = done\r\nThe first equation initializes the computation by placing the input on the right tape and setting the\r\ncurrent state to the start state. The second terminates the computation when the halting state is reached.\r\nNote that both sentences above are equations (and not rules), because they carry no computational meaning.\r\nNote that the left and right tapes are finite structures in our setting, so they cannot store the infinite\r\nsequences of zeros. However, such infinite sequences are only conceptual; all one needs to be able to do is to\r\ngenerate “one more 0” whenever needed. The following two equations, also generic for all Turing machines\r\nM can “generate new 0s” on each tape on a by-need basis:\r\nL·Mleft = L0Mleft\r\nL·Mright = L0Mright\r\nWe are now ready to give the M-specific rules of KM , where b, c ∈ B and q, q0 ∈ Q:\r\nL q\r\nq\r\n0\r\nMstate Lb\r\nc\r\nMcell when (q\r\n0\r\n, c) ∈ M(q, b)\r\nL q\r\nq\r\n0\r\nMstate h|·\r\nb\r\nMleft L b\r\nb\r\n0\r\nMcell Lb\r\n0\r\n·\r\n|iright when (q\r\n0\r\n, →) ∈ M(q, b)\r\nL q\r\nq\r\n0\r\nMstate h|b\r\n0\r\n·\r\nMleft L b\r\nb\r\n0\r\nMcell L·\r\nb\r\n|iright when (q\r\n0\r\n, ←) ∈ M(q, b)\r\n26\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cddb26fb-741b-4c5c-9826-94044759a483.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a96a2713ae96aa1fc018080858e8850173e19c4b8b8cb141634392d1f4e1daa9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 754
      },
      {
        "segments": [
          {
            "segment_id": "cddb26fb-741b-4c5c-9826-94044759a483",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that the relation →M on configurations is nondeterministic in general because M can be a multifunc\u0002tion, but is deterministic if the Turing machine is deterministic (i.e., M is a function). The machine starts\r\nperforming in the internal state qs. If there is no input, the initial configuration on which the Turing machine\r\nis run is (qs, 0\r\nω00ω), where 0ω is the infinite string of zeros. If the Turing machine is intended to be run on\r\na specific input, say x = b1b2· · ·bn, its initial configuration is (qs, 0\r\nω0b1b2· · ·bn0ω). For simplicity, we assume\r\nthat inputs are always encoded as finite sequences of 1’s. We let →?\r\nM denote the transitive and reflexive\r\nclosure of the binary relation on configurations →M above. A Turing machine M terminates when it gets to\r\nits halting state, qh; formally, M terminates on input b1b2 · · · bn iff (qs, 0\r\nω0b1b2 · · · bn0ω) →?\r\nM (qh,LbR) for\r\nsome b ∈ B and some tape instances L and R. Note that a Turing machine cannot get stuck in any state\r\nbut qh, because the mapping M is defined everywhere except in qh. Therefore, a Turing machine carries\r\nout successions of steps, which may or may not terminate. Because of its non-determinism, it may be the\r\ncase that, for the same input, there are both terminating and non-terminating sequences; however, if the\r\nmachine terminates on the given input then there must be at least a terminating sequence for that input. If\r\nthe Turing machine is deterministic then the succession of steps is uniquely determined for any input and,\r\nobviously, the machine either terminates on the given input or it does not. It is well-known that Turing\r\nmachines can compute exactly the partial recursive functions [34].\r\nFrom here on in this section, let us fix a Turing machine M. We next define a K theory, KM, which\r\ncaptures precisely the Turing machine M, in the sense that any computational step in M corresponds to\r\nprecisely one rewrite step in KM. We start by defining the signature, or syntax, of KM . The syntactic\r\ncategory Q contains all the states of M and may obviously differ from Turing machine to Turing machine;\r\nthe other three syntactic categories, B, K and Config are generic for all Turing machines:\r\nQ ::= qs | qh | · · · the finite number of states of M\r\nB ::= 0 | 1\r\nK ::= B | List·\r\ny[K]\r\nConfig ::= LQMstate | LKMleft | LBMcell | LKMright | LSet[Config]M> | JList·[B]K | done\r\nThe configuration items LKMleft and LKMright hold the left and the right tapes, LBMcell holds the current\r\ncell, and LQMstate holds the current state. As usual, the input to the machine, which can be regarded as the\r\ninitial “computational structure”, is given enclosed by double brackets J K, and the initial configuration is\r\nwrapped into a L M> soup. The constant configuration done marks that the Turing machine computation\r\nterminated. The following two equations are generic for all machines M of start state qs and halt state qh:\r\nJinputK = LLqsMstate L·Mleft L0Mcell LinputMrightM>\r\nh|LqhMstate|i> = done\r\nThe first equation initializes the computation by placing the input on the right tape and setting the\r\ncurrent state to the start state. The second terminates the computation when the halting state is reached.\r\nNote that both sentences above are equations (and not rules), because they carry no computational meaning.\r\nNote that the left and right tapes are finite structures in our setting, so they cannot store the infinite\r\nsequences of zeros. However, such infinite sequences are only conceptual; all one needs to be able to do is to\r\ngenerate “one more 0” whenever needed. The following two equations, also generic for all Turing machines\r\nM can “generate new 0s” on each tape on a by-need basis:\r\nL·Mleft = L0Mleft\r\nL·Mright = L0Mright\r\nWe are now ready to give the M-specific rules of KM , where b, c ∈ B and q, q0 ∈ Q:\r\nL q\r\nq\r\n0\r\nMstate Lb\r\nc\r\nMcell when (q\r\n0\r\n, c) ∈ M(q, b)\r\nL q\r\nq\r\n0\r\nMstate h|·\r\nb\r\nMleft L b\r\nb\r\n0\r\nMcell Lb\r\n0\r\n·\r\n|iright when (q\r\n0\r\n, →) ∈ M(q, b)\r\nL q\r\nq\r\n0\r\nMstate h|b\r\n0\r\n·\r\nMleft L b\r\nb\r\n0\r\nMcell L·\r\nb\r\n|iright when (q\r\n0\r\n, ←) ∈ M(q, b)\r\n26\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cddb26fb-741b-4c5c-9826-94044759a483.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a96a2713ae96aa1fc018080858e8850173e19c4b8b8cb141634392d1f4e1daa9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 754
      },
      {
        "segments": [
          {
            "segment_id": "a2e2ec79-fce2-4cbd-b591-c20dbd1e06c0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Since all K rewrite rules above overlap on the L Mstate subterm, the rewrite steps in KM on an initial\r\nterm of the form Jb1b2 · · · bnK are sequential (non-concurrent); indeed, there is no concurrent rewriting taking\r\nplace in KM, which is consistent with the intended Turing machine computation. The following result states\r\nthat K is not only a Turing-complete framework, but a faithfully Turing-complete one, in the sense that any\r\ncomputation in a Turing machine M can be carried out, step-for-step, as a rewriting sequence in KM. In\r\nother words, KM is M, not an encoding of it, the only difference between the two being their different but\r\nultimately irrelevant notational conventions:\r\nTheorem 1. (Faithful embedding of Turing machines into K) If M is a Turing machine M then\r\n1. (q, LbR) →M (q\r\n0\r\n, L0b\r\n0R0\r\n) iff KM |= LqMstate LLMleft LbMcell LRMright → Lq\r\n0\r\nMstate LL\r\n0\r\nMleft Lb\r\n0\r\nMcell LR0Mright;\r\n2. M terminates on input b1b2 · · · bn iff K |= Jb1b2 · · · bnK →? done; moreover, if that is the case, then\r\ndone is the only normal form of Jb1b2 · · · bnK in KM.\r\nThe first item in the theorem above states that each computational step in M corresponds to a rewrite\r\nstep in KM, while the second item gives a means to “execute” M using a rewrite engine and KM: M\r\nterminates on some input iff KM terminates as a rewrite system on that input wrapped in J K.\r\n4.2 Defining Lambda-Calculi in K\r\nVariants of λ-calculus have been already shown in Figure 1. We here discuss them in more detail. For\r\nsimplicity and direct comparison of K with other formalisms to define λ-calculi, in this section we prefer\r\nto use a substitution-based approach. Therefore, we assume given a substitution function “e[e\r\n0/x]”, which\r\nreplaces each free occurrence of x in e by e\r\n0\r\n, avoiding variable captures via α-conversion. One should not\r\nunderestimate the complexity of applying such a substitution. Even though we provide a syntax-independent\r\n(using a generic notion of “binder”) definition of substitution in our implementation of K in Maude (See\r\nAppendix E), we do not advocate using it when defining non-toy languages. Instead, we prefer the more\r\npractical approach based on environments and closures, as shown in Section 4.9 and in the appendixes.\r\nStandard λ-calculus is one of the most basic calculi. In standard, untyped λ-calculus, there is only one\r\nsyntactic category of λ-expressions, Exp; “evaluation” consists of syntactic transformations of the original\r\nλ-expression. Constant expressions, such as integers or booleans, may be included in Exp, but here we do not\r\ndo that. The syntax of λ-calculus includes a construct for λ-abstraction and one for λ-application. No values\r\nneed to be defined in standard λ-calculus, and no evaluation strategy is imposed (no strictness attributes):\r\nExp ::= λName.Exp | Exp Exp.\r\nThere is only one rewrite rule in our K definition of λ-calculus, which is precisely the β-reduction:\r\n(λx.e) e\r\n0 → e[e0\r\n/x], where x ∈ Name, e, e0 ∈ Exp.\r\nNote that, unlike in reduction semantics, with [11] or without [31] evaluation contexts, when using K (or\r\nany other context-insensitive rewriting-based framework), one does not need to explicitly give the rewrite\r\nrule access to subexpressions. In other words, the K definition of conventional λ-calculus is precisely the\r\nstandard definition of λ-calculus; no different syntax or notational conventions are necessary, and there is\r\nno faithful-embedding result to be proved. However, one should note that, unlike in the conventional λ\u0002calculus where, operationally speaking, β-reduction steps apply non-deterministically but one-at-a-time, the\r\nunderlying K rewriting machinery allows for the β-reduction steps to apply concurrently; the confluence (or\r\nChurch-Rosser property) of λ-calculus ensures the safety of the concurrent application of β-reduction steps.\r\nCall-by-value λ-calculus. In call-by-value λ-calculus, applications of β-reduction are not unrestricted\r\nanymore as in standard λ-calculus: the two sub-expressions involved in a λ-application are first evaluated,\r\n27\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/a2e2ec79-fce2-4cbd-b591-c20dbd1e06c0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7c5442360cf8f4c1416c67f5bc835482fca3aa6798a0501f608dfaa39d0e361f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 673
      },
      {
        "segments": [
          {
            "segment_id": "a2e2ec79-fce2-4cbd-b591-c20dbd1e06c0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Since all K rewrite rules above overlap on the L Mstate subterm, the rewrite steps in KM on an initial\r\nterm of the form Jb1b2 · · · bnK are sequential (non-concurrent); indeed, there is no concurrent rewriting taking\r\nplace in KM, which is consistent with the intended Turing machine computation. The following result states\r\nthat K is not only a Turing-complete framework, but a faithfully Turing-complete one, in the sense that any\r\ncomputation in a Turing machine M can be carried out, step-for-step, as a rewriting sequence in KM. In\r\nother words, KM is M, not an encoding of it, the only difference between the two being their different but\r\nultimately irrelevant notational conventions:\r\nTheorem 1. (Faithful embedding of Turing machines into K) If M is a Turing machine M then\r\n1. (q, LbR) →M (q\r\n0\r\n, L0b\r\n0R0\r\n) iff KM |= LqMstate LLMleft LbMcell LRMright → Lq\r\n0\r\nMstate LL\r\n0\r\nMleft Lb\r\n0\r\nMcell LR0Mright;\r\n2. M terminates on input b1b2 · · · bn iff K |= Jb1b2 · · · bnK →? done; moreover, if that is the case, then\r\ndone is the only normal form of Jb1b2 · · · bnK in KM.\r\nThe first item in the theorem above states that each computational step in M corresponds to a rewrite\r\nstep in KM, while the second item gives a means to “execute” M using a rewrite engine and KM: M\r\nterminates on some input iff KM terminates as a rewrite system on that input wrapped in J K.\r\n4.2 Defining Lambda-Calculi in K\r\nVariants of λ-calculus have been already shown in Figure 1. We here discuss them in more detail. For\r\nsimplicity and direct comparison of K with other formalisms to define λ-calculi, in this section we prefer\r\nto use a substitution-based approach. Therefore, we assume given a substitution function “e[e\r\n0/x]”, which\r\nreplaces each free occurrence of x in e by e\r\n0\r\n, avoiding variable captures via α-conversion. One should not\r\nunderestimate the complexity of applying such a substitution. Even though we provide a syntax-independent\r\n(using a generic notion of “binder”) definition of substitution in our implementation of K in Maude (See\r\nAppendix E), we do not advocate using it when defining non-toy languages. Instead, we prefer the more\r\npractical approach based on environments and closures, as shown in Section 4.9 and in the appendixes.\r\nStandard λ-calculus is one of the most basic calculi. In standard, untyped λ-calculus, there is only one\r\nsyntactic category of λ-expressions, Exp; “evaluation” consists of syntactic transformations of the original\r\nλ-expression. Constant expressions, such as integers or booleans, may be included in Exp, but here we do not\r\ndo that. The syntax of λ-calculus includes a construct for λ-abstraction and one for λ-application. No values\r\nneed to be defined in standard λ-calculus, and no evaluation strategy is imposed (no strictness attributes):\r\nExp ::= λName.Exp | Exp Exp.\r\nThere is only one rewrite rule in our K definition of λ-calculus, which is precisely the β-reduction:\r\n(λx.e) e\r\n0 → e[e0\r\n/x], where x ∈ Name, e, e0 ∈ Exp.\r\nNote that, unlike in reduction semantics, with [11] or without [31] evaluation contexts, when using K (or\r\nany other context-insensitive rewriting-based framework), one does not need to explicitly give the rewrite\r\nrule access to subexpressions. In other words, the K definition of conventional λ-calculus is precisely the\r\nstandard definition of λ-calculus; no different syntax or notational conventions are necessary, and there is\r\nno faithful-embedding result to be proved. However, one should note that, unlike in the conventional λ\u0002calculus where, operationally speaking, β-reduction steps apply non-deterministically but one-at-a-time, the\r\nunderlying K rewriting machinery allows for the β-reduction steps to apply concurrently; the confluence (or\r\nChurch-Rosser property) of λ-calculus ensures the safety of the concurrent application of β-reduction steps.\r\nCall-by-value λ-calculus. In call-by-value λ-calculus, applications of β-reduction are not unrestricted\r\nanymore as in standard λ-calculus: the two sub-expressions involved in a λ-application are first evaluated,\r\n27\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/a2e2ec79-fce2-4cbd-b591-c20dbd1e06c0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7c5442360cf8f4c1416c67f5bc835482fca3aa6798a0501f608dfaa39d0e361f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 673
      },
      {
        "segments": [
          {
            "segment_id": "98116723-3d6d-45a3-a1c4-40c76eb4dcb8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "and then β-reduction is applied. Also, evaluation is inhibited in λ-abstractions, which are therefore regarded\r\nas values. Here is the complete K definition of call-by-value λ-calculus:\r\nVal ::= λName.Exp\r\nExp ::= Val | Exp Exp [strict]\r\nConfig ::= LKMk\r\nKResult ::= Val\r\nL(λx.e) v|ik → Le[v/x]|ik, where x ∈ Name, e ∈ Exp, v ∈ Val.\r\nNote that λ-application is defined strict and there is only one configuration item, LKMk. Reduction takes\r\nplace only on the top of the computation and only when the top construct is a λ-application whose two\r\nsub-expressions are values. Therefore, the concurrency aspect of K is completely inhibited.\r\nCall-by-name λ-calculus. There are two differences between call-by-value and call-by-name λ-calculi: (1)\r\nin the latter, the λ-application is strict only in its first sub-expression and, (consequently) (2) it can apply\r\non any expression as argument, not only on a value:\r\nVal ::= λName.Exp\r\nExp ::= Val | Exp Exp [strict(1)]\r\nConfig ::= LKMk\r\nKResult ::= Val\r\nL(λx.e) e\r\n0\r\n|ik → Le[e\r\n0/x]|ik\r\n, where x ∈ Name, e, e0 ∈ Exp.\r\n4.3 Defining a Simple Imperative Language in K\r\nFigure 4 shows the complete K definition of the simple imperative language discussed in Sections 1 and\r\n3. Let us call this language IMP. Note that the construct “;” for programs does not need to be given an\r\nattribute equation like the one for the construct “;” for statements, because the two constructs get identified\r\nonce the language syntax is sinked into computations. Indeed, from a computational point of view, the two\r\nconstructs have the same semantics: process the first subcomputation, then the second. If one’s intention for\r\ntwo language constructs with the same name is to have different computational semantics, then one should\r\ngive them different names; this can be easily achieved at parse-time.\r\nThere is not much to comment on this simple language definition, except perhaps to note that, except for\r\nthe definition of the K-specific “syntactic” infrastructure (the syntactic categories KResult, K, and Config),\r\nevery single equation or rule (explicit or implicit in the notational conventions) in the definition in Figure 4\r\ndefines a distinct aspect of the language, so it cannot be avoided. This obvious property is actually violated\r\nby many other language definitional formalisms; for example, purely syntactic formalisms, such as SOS or\r\ncontext reduction, even for this simple language have to enrich the syntax with an artificial “skip” statement\r\nthat acts as a “value” to which statements evaluate. This is unnecessary in K, because the concept of\r\n“evaluation” is replaced by “computation processing” in K and computations may place zero, one or more\r\ncomputational items back on the computation structure after they are processed.\r\n4.4 Defining Milner’s CCS in K\r\nThe Calculus of Communicating Systems (CCS) [25] was introduced by Milner as a process calculus/algebra\r\nin which processes can execute concurrently and communicate with each other (send and receive messages)\r\nvia channels, or communication ports. The grammar of CCS is as follows:\r\nCh ::= a | b | ... (channels; given as a set of channel names)\r\nL ::= Ch | Ch (labels; there can be input or output ones)\r\nA ::= τ | L (actions; τ is the “internal” action)\r\nP ::= 0 | Name | A.P | P + P | P|P | P[ϕ] | P\\L (processes)\r\n28\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/98116723-3d6d-45a3-a1c4-40c76eb4dcb8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cf6dcd12316a241c197e46e0238d6fc613c108c5bfee6a6025dbad58bd2a3e19",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 564
      },
      {
        "segments": [
          {
            "segment_id": "98116723-3d6d-45a3-a1c4-40c76eb4dcb8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "and then β-reduction is applied. Also, evaluation is inhibited in λ-abstractions, which are therefore regarded\r\nas values. Here is the complete K definition of call-by-value λ-calculus:\r\nVal ::= λName.Exp\r\nExp ::= Val | Exp Exp [strict]\r\nConfig ::= LKMk\r\nKResult ::= Val\r\nL(λx.e) v|ik → Le[v/x]|ik, where x ∈ Name, e ∈ Exp, v ∈ Val.\r\nNote that λ-application is defined strict and there is only one configuration item, LKMk. Reduction takes\r\nplace only on the top of the computation and only when the top construct is a λ-application whose two\r\nsub-expressions are values. Therefore, the concurrency aspect of K is completely inhibited.\r\nCall-by-name λ-calculus. There are two differences between call-by-value and call-by-name λ-calculi: (1)\r\nin the latter, the λ-application is strict only in its first sub-expression and, (consequently) (2) it can apply\r\non any expression as argument, not only on a value:\r\nVal ::= λName.Exp\r\nExp ::= Val | Exp Exp [strict(1)]\r\nConfig ::= LKMk\r\nKResult ::= Val\r\nL(λx.e) e\r\n0\r\n|ik → Le[e\r\n0/x]|ik\r\n, where x ∈ Name, e, e0 ∈ Exp.\r\n4.3 Defining a Simple Imperative Language in K\r\nFigure 4 shows the complete K definition of the simple imperative language discussed in Sections 1 and\r\n3. Let us call this language IMP. Note that the construct “;” for programs does not need to be given an\r\nattribute equation like the one for the construct “;” for statements, because the two constructs get identified\r\nonce the language syntax is sinked into computations. Indeed, from a computational point of view, the two\r\nconstructs have the same semantics: process the first subcomputation, then the second. If one’s intention for\r\ntwo language constructs with the same name is to have different computational semantics, then one should\r\ngive them different names; this can be easily achieved at parse-time.\r\nThere is not much to comment on this simple language definition, except perhaps to note that, except for\r\nthe definition of the K-specific “syntactic” infrastructure (the syntactic categories KResult, K, and Config),\r\nevery single equation or rule (explicit or implicit in the notational conventions) in the definition in Figure 4\r\ndefines a distinct aspect of the language, so it cannot be avoided. This obvious property is actually violated\r\nby many other language definitional formalisms; for example, purely syntactic formalisms, such as SOS or\r\ncontext reduction, even for this simple language have to enrich the syntax with an artificial “skip” statement\r\nthat acts as a “value” to which statements evaluate. This is unnecessary in K, because the concept of\r\n“evaluation” is replaced by “computation processing” in K and computations may place zero, one or more\r\ncomputational items back on the computation structure after they are processed.\r\n4.4 Defining Milner’s CCS in K\r\nThe Calculus of Communicating Systems (CCS) [25] was introduced by Milner as a process calculus/algebra\r\nin which processes can execute concurrently and communicate with each other (send and receive messages)\r\nvia channels, or communication ports. The grammar of CCS is as follows:\r\nCh ::= a | b | ... (channels; given as a set of channel names)\r\nL ::= Ch | Ch (labels; there can be input or output ones)\r\nA ::= τ | L (actions; τ is the “internal” action)\r\nP ::= 0 | Name | A.P | P + P | P|P | P[ϕ] | P\\L (processes)\r\n28\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/98116723-3d6d-45a3-a1c4-40c76eb4dcb8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cf6dcd12316a241c197e46e0238d6fc613c108c5bfee6a6025dbad58bd2a3e19",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 564
      },
      {
        "segments": [
          {
            "segment_id": "3146e2eb-aab8-4300-a4a7-11a2ec6a0ba4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "K-Annotated Syntax of IMP\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables\r\nVal ::= Int\r\nAExp ::= Val | Name\r\n| AExp + AExp [strict, extends +Int×Int→Int]\r\nBExp ::= Bool\r\n| AExp ≤ AExp [seqstrict, extends ≤Int×Int→Bool]\r\n| not BExp [strict, extends ¬Bool→Bool]\r\n| BExp and BExp [strict(1)]\r\nStmt ::= Stmt; Stmt [s1; s2 = s1 y s2]\r\n| Name := AExp [strict(2)]\r\n| if BExp then Stmt else Stmt [strict(1)]\r\n| while BExp do Stmt\r\n| halt AExp [strict]\r\nPgm ::= Stmt; AExp\r\nK Configuration and Semantics of IMP\r\nKResult ::= Val\r\nK ::= KResult | List·\r\ny[K]\r\nConfig ::= LKMk | LStateMstate\r\n| Val | JKK | LSet[Config]M>\r\nJpK = LLpMk L∅MstateM>\r\nh|LvMk|i> = v\r\nL x\r\nσ[x]\r\n|ikLσMstate\r\ntrue and b → b\r\nfalse and b → false\r\nLx := v\r\n·\r\n|ikL σ\r\nσ[v/x]\r\nMstate\r\nif true then s1 else s2 → s1\r\nif false then s1 else s2 → s2\r\nLwhile b do s|ik = Lif b then (s;while b do s) else ·|ik\r\nLhalt i|ik = LiMk\r\nFigure 4: K definition of IMP.\r\nThere can be any number of channels. Labels are either channel names or over-lined channel names, such\r\nas a, b, etc. The intuition for a label that is a channel name is that a message is being sent on that channel,\r\nwhile the intuition for a label which is an over-lined channel name is that a message is received on that\r\nchannel. An action can be either a label (send/receive) or a silent action, denoted τ. To simplify technical\r\ndevelopments, the over-line notation is extended by convention to actions and the equations\r\nτ = τ\r\nα = α (for any α ∈ A)\r\nare implicitly assumed.\r\nProcesses can be thought of as boxes that can perform actions and can communicate with each other.\r\nThe process 0, also called “nil” or “deadlock”, is the basic process that can perform no action. Processes\r\ncan be assigned names and then referred to by their name in other processes; this is explained in more detail\r\nbelow. A process of the form α.p where α is an action is one which takes the action α and then continues\r\nlike p. The process p + q can be thought of as a process non-deterministically choosing between p and q,\r\n29\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3146e2eb-aab8-4300-a4a7-11a2ec6a0ba4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b4ccc34195be8219b8e7c000166c1fdee47c754ca635479f33e809d6f390f457",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 414
      },
      {
        "segments": [
          {
            "segment_id": "9aa52dec-052c-4a80-802c-9ce17250ce6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "but the choice is being made only if the chosen process can act; therefore, p + q has the initial capabilities\r\nof both p and q, but choosing to perform first an action from either p or q, will prevent the other one from\r\nacting any further. In particular, a process p+ 0 can take whatever action p can take, but it cannot choose to\r\nnon-deterministically transit to 0 and then deadlock. Because of the commutative nature of +, many/most\r\ndevelopments of CCS or extensions of it assume the following structural equivalence on processes:\r\np + q ≡ q + p (for any p, q ∈ P).\r\nThe process p|q is the process thought of3 as executing in parallel processes p and q, that is, it can take any\r\naction that p or q can take; moreover, parallel processes are allowed to communicate via channels: if p takes\r\nthe action a then behaves as p\r\n0\r\n, and if q takes the action a then behaves like q\r\n0\r\n, then the process p|q takes the\r\nsilent action τ then behaves like p\r\n0\r\n|q\r\n0\r\n. Parallel composition is also assumed to be structurally commutative:\r\np|q ≡ q|p (for any p, q ∈ P).\r\nCCS allows channels to be relabeled and even hidden. For technical simplicity, relabeling functions ϕ are\r\nextended to actions and are required to obey the properties\r\nϕ(τ) = τ\r\nϕ(α) = ϕ(α) (for any α ∈ A).\r\nThen the process p[ϕ] is the process obtained from p by relabeling all its actions according to ϕ. Finally, p\\l\r\nis the process that behaves like p except that it cannot export any action over the channel that the label l\r\nrefers to; in other words, p\\l can perform any action p can perform except actions l or l.\r\nThere is one more important aspect of CCS that needs to be discussed before we can give formal definitions\r\nof CCS. A CCS definition consists of a set of process definitions, that is, of a set of equalities\r\nName def = P\r\nwhere each process name is defined precisely once and where, of course, the process expressions bound to\r\nthe process names can refer to any of the defined processes through their names. For notational simplicity,\r\nwe adopt a relatively standard fix-point notation (see e.g., [5]): CCS definitions of the form\r\nxi\r\ndef = pi for i ∈ I\r\nare replaced by a vectorial equality ~x = ~p, and each reference to process name xiin the original process (the\r\none whose behavior one is interested in) is replaced by fixi(~x = ~p). The semantics of fixi(~x = ~p) can now be\r\ngiven locally using a straightforward fixed point reduction rule, namely\r\nfixi(~x = ~p) → pi[fix~\r\ni(~x = ~p)/~x].\r\nFigure 5 shows a conventional SOS definition of CCS (left column), as well as two different K definitions,\r\none following an interleaving semantics (middle column) which is entirely equivalent to the SOS definition,\r\nand another one which is truly concurrent (right column). Rewriting logic and K definitions of CCS equivalent\r\nto the SOS definition can be mechanically derived as well, applying the faithful embedding procedures\r\ndiscussed in Sections 5.1.1 and 5.1.2. If SOS ` p\r\nα→ p\r\n0\r\nthen we say that process p can take action α and then\r\ntransit to p\r\n0\r\n. This labeled transition relation is typically non-deterministic. Note that a significant number\r\nof transitions between various subprocesses of p may need to be derived in order to derive p\r\nα→ p\r\n0\r\n. Also, due\r\nto the inherent non-determinism and the fact that some processes may get blocked, a significant amount of\r\nsearch may be needed to derive a particular transition.\r\nThe K interleaved definition of CCS (middle column) in Figure 5 starts by defining all the process\r\nconstructors strict in their first argument. That means that their first argument process can be heated and\r\ncooled at discretion. Since “|” and “+” are commutative, they are hereby strict in their both arguments.\r\nThere is no need to have a correspondent in K for the SOS rule “α.p\r\nα→ p”; that is because one can already\r\n3The SOS definition of CCS (see Figure 5) provides no capability for saying that p and q run in parallel, or concurrently.\r\n30\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9aa52dec-052c-4a80-802c-9ce17250ce6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f3cb3e26a742caa1470fb409987f36417a8fa36540cc41da4ada48e8563b7ea7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 728
      },
      {
        "segments": [
          {
            "segment_id": "9aa52dec-052c-4a80-802c-9ce17250ce6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "but the choice is being made only if the chosen process can act; therefore, p + q has the initial capabilities\r\nof both p and q, but choosing to perform first an action from either p or q, will prevent the other one from\r\nacting any further. In particular, a process p+ 0 can take whatever action p can take, but it cannot choose to\r\nnon-deterministically transit to 0 and then deadlock. Because of the commutative nature of +, many/most\r\ndevelopments of CCS or extensions of it assume the following structural equivalence on processes:\r\np + q ≡ q + p (for any p, q ∈ P).\r\nThe process p|q is the process thought of3 as executing in parallel processes p and q, that is, it can take any\r\naction that p or q can take; moreover, parallel processes are allowed to communicate via channels: if p takes\r\nthe action a then behaves as p\r\n0\r\n, and if q takes the action a then behaves like q\r\n0\r\n, then the process p|q takes the\r\nsilent action τ then behaves like p\r\n0\r\n|q\r\n0\r\n. Parallel composition is also assumed to be structurally commutative:\r\np|q ≡ q|p (for any p, q ∈ P).\r\nCCS allows channels to be relabeled and even hidden. For technical simplicity, relabeling functions ϕ are\r\nextended to actions and are required to obey the properties\r\nϕ(τ) = τ\r\nϕ(α) = ϕ(α) (for any α ∈ A).\r\nThen the process p[ϕ] is the process obtained from p by relabeling all its actions according to ϕ. Finally, p\\l\r\nis the process that behaves like p except that it cannot export any action over the channel that the label l\r\nrefers to; in other words, p\\l can perform any action p can perform except actions l or l.\r\nThere is one more important aspect of CCS that needs to be discussed before we can give formal definitions\r\nof CCS. A CCS definition consists of a set of process definitions, that is, of a set of equalities\r\nName def = P\r\nwhere each process name is defined precisely once and where, of course, the process expressions bound to\r\nthe process names can refer to any of the defined processes through their names. For notational simplicity,\r\nwe adopt a relatively standard fix-point notation (see e.g., [5]): CCS definitions of the form\r\nxi\r\ndef = pi for i ∈ I\r\nare replaced by a vectorial equality ~x = ~p, and each reference to process name xiin the original process (the\r\none whose behavior one is interested in) is replaced by fixi(~x = ~p). The semantics of fixi(~x = ~p) can now be\r\ngiven locally using a straightforward fixed point reduction rule, namely\r\nfixi(~x = ~p) → pi[fix~\r\ni(~x = ~p)/~x].\r\nFigure 5 shows a conventional SOS definition of CCS (left column), as well as two different K definitions,\r\none following an interleaving semantics (middle column) which is entirely equivalent to the SOS definition,\r\nand another one which is truly concurrent (right column). Rewriting logic and K definitions of CCS equivalent\r\nto the SOS definition can be mechanically derived as well, applying the faithful embedding procedures\r\ndiscussed in Sections 5.1.1 and 5.1.2. If SOS ` p\r\nα→ p\r\n0\r\nthen we say that process p can take action α and then\r\ntransit to p\r\n0\r\n. This labeled transition relation is typically non-deterministic. Note that a significant number\r\nof transitions between various subprocesses of p may need to be derived in order to derive p\r\nα→ p\r\n0\r\n. Also, due\r\nto the inherent non-determinism and the fact that some processes may get blocked, a significant amount of\r\nsearch may be needed to derive a particular transition.\r\nThe K interleaved definition of CCS (middle column) in Figure 5 starts by defining all the process\r\nconstructors strict in their first argument. That means that their first argument process can be heated and\r\ncooled at discretion. Since “|” and “+” are commutative, they are hereby strict in their both arguments.\r\nThere is no need to have a correspondent in K for the SOS rule “α.p\r\nα→ p”; that is because one can already\r\n3The SOS definition of CCS (see Figure 5) provides no capability for saying that p and q run in parallel, or concurrently.\r\n30\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9aa52dec-052c-4a80-802c-9ce17250ce6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f3cb3e26a742caa1470fb409987f36417a8fa36540cc41da4ada48e8563b7ea7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 728
      },
      {
        "segments": [
          {
            "segment_id": "7996f6b1-3295-45ce-a4ca-7a6b2ece909c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "SOSCCS Kinterleaved\r\nCCS KconcurrentCCS\r\nK ::= P | List·\r\ny[K] K ::= P | List·y[K]\r\nConfig ::= LKM | LKM | K 8 K | K ⊕ K\r\n| , + , \\ , [ ] [strict(1)] \\ , [ ] [strict(1)]\r\nα.p\r\nα→ p\r\np\r\nα→ p\r\n0\r\np | q\r\nα→ p\r\n0\r\n| q\r\nLα.p | q|i → Lα.(p | q)|i Lp | q|i = LLpM 8 LqM|i\r\nLα.pM 8 LqM → α.(p | q)\r\np\r\nα→ p\r\n0\r\nq\r\nα→ q\r\n0\r\np | q\r\nτ→ p\r\n0\r\n| q\r\n0\r\nLα.p | α.q|i → Lτ.(p | q)|i Lα.pM 8 Lα.qM → τ.(p | q)\r\np\r\nα→ p\r\n0\r\np + q\r\nα→ p\r\n0\r\nLα.p + q|i → Lα.p|i Lp + q|i = LLpM ⊕ LqM|i\r\nLα.pM ⊕ → α.p\r\np\r\nα→ p\r\n0 α 6∈ {l, l}\r\np\\l\r\nα→ p\r\n0\\l\r\nLα.p\\l|i = Lα.(p\\l)|i if α 6∈ {l, l} – same –\r\np\r\nα→ p\r\n0\r\np[φ]\r\nφ(α) → p\r\n0\r\n[φ]\r\nLα.p[φ]|i = Lφ(α).(p[φ])|i – same –\r\nfixi(~x = p~) → pi[fix~\r\ni(~x = ~p)/~x] Lfixi(~x = ~p)|i = Lpi\r\n[fix~\r\ni(~x = ~p)/~x]|i – same –\r\nFigure 5: SOS and SOS-inspired K definitions of CCS.\r\n31\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/7996f6b1-3295-45ce-a4ca-7a6b2ece909c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c331739847676db5f067e1c146535fabd39eca53fd9f11c46d44ded1e973263a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 219
      },
      {
        "segments": [
          {
            "segment_id": "d052ecb4-84a8-46f5-9f3b-d4a6ac153598",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "think of a process α.p as one that can transit with α in p. With this intuition in mind, one can easily see\r\nhow the rule in the K interleaved definition of CCS correspond to those in its SOS definition. For example,\r\nthe first K rule for parallel composition reads as follows: if process (α.p)|q is allowed to be processed (i.e.,\r\nit is in the top of the computation structure), then it becomes the process emitting α followed by p|q. If\r\none does not like to dually think of α.p as both a process and an action α followed by process p, then one\r\ncan introduce a different notation for the later, say something like α ◦ p or α#p, and modify the rules in\r\nFigure 5 accordingly. We prefer not to introduce a different notation. The K concurrent definition of CCS\r\n(right column in Figure 5) is similar in spirit to the CHAM definition of CCS in [5] and it differs from\r\nthe K interleaved definition in that the constructs “|” and “+” are first translated into truly concurrent\r\nvariants, i.e., ones enabling the computation to concurrently proceed in both argument processes. When\r\none or both of the argument processes rewrite to the expected patterns, the actual irreversible transition is\r\napplied. Theorem 2 establishes the relationship between the SOS and the K definitions of CCS in Figure 5:\r\nTheorem 2. With the CCS definitions in Figure 5, the following properties hold:\r\n• for any p, p0 ∈ P, Kinterleaved\r\nCCS ` LpM →∗\r\nLp\r\n0\r\nM iff Kconcurrent\r\nCCS ` LpM →∗\r\nLp\r\n0\r\nM;\r\n• for any p, p0 ∈ P, if SOSCCS ` p\r\nα→ p\r\n0\r\nthen K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.p0M for any style ∈ {interleaved, concurrent};\r\n• if K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.kM for some style ∈ {interleaved, concurrent}, p ∈ P, and k ∈ K, then there is\r\nsome p\r\n0 ∈ P such that SOSCCS ` p\r\nα→ p\r\n0 and K\r\nstyle\r\nCCS ` Lp\r\n0\r\nM →∗LkM\r\nTheorem 2 tells us that, from an external point of view, an action α is possible on a process p under\r\nthe SOS definition of CCS if and only if the same action α is possible on the process LpM on any of the K\r\ndefinitions of CCS in Figure 5, that is, if and only if K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.kM for some k ∈ K. Moreover, it\r\nactually says that the same holds true for any sequence of actions: sequence α1α2 . . . αn possible in SOSCCS\r\non a process p if and only if ∃k0, k1, k2, ..., kn ∈ K such that k0 = p and K\r\nstyle\r\nCCS ` LkiM →∗\r\nLαi+1.ki+1M for all\r\ni ∈ {0, 1, . . . , n − 1}.\r\nBoth K definitions in Figure 5 are inspired by the SOS definition of CCS. That made them more com\u0002plicated and less intuitive that needed. Figure 6 shows two K definitions of CCS that follow the actual\r\nconcurrency intuitions underlying CCS rather that its particular SOS definition. Let us explain this intuition\r\ninformally: CCS processes are intended to be highly concurrent, in the sense that many sub-computations\r\nhappen at the same time in different places of the system; processes can be put together in parallel “soups”\r\nas well as in non-deterministic choice “soups”; in such soups, processes can evolve truly concurrently; pro\u0002cesses in parallel soups can also communicate with each other; in non-deterministic choice soups, a process\r\nwhich is found to produce an action can preempt and discard all the other processes in the soup. With this\r\nintuition, the definitions in Figure 6 become straightforward. Interestingly, besides giving a truly concurrent\r\nsemantics to CCS, they are also more compact and simpler than the SOS definition, reducing to essentially\r\none unconditional rewrite rule or equation per CCS construct. The following result states the relationship\r\nbetween the original SOS definition of CCS and the two K definitions in Figure 6. In short, that relationship\r\nis: every reduction step in SOS is also possible as a concurrent computation in these equivalent K definitions;\r\nconversely, any action that can be produced as a result of a concurrent computation in the K definitions can\r\nalso be produced by a reduction step in the original SOS definition.\r\nTheorem 3. The K definitions of CCS in Figure 6 have the following properties (p, p0, q, p1, p2 ∈ P):\r\n• KCCS1 ` p →∗ α.q iff KCCS2 ` pˆ →∗ α.qˆ, where pˆ replaces each subprocess of the form p1|p2 by\r\nLp1 p2M| and each process of the form p1 + p2 by Lp1 p2M+ everywhere in p;\r\n• If SOS ` p\r\nα→ p\r\n0\r\nthen KCCS1 ` p →∗ α.p0; and\r\n• If KCCS1 ` p →∗ α.q then there is some p\r\n0\r\nsuch that SOS ` p\r\nα→ p\r\n0 and KCCS1 ` p0 →∗\r\nq.\r\n32\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d052ecb4-84a8-46f5-9f3b-d4a6ac153598.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=179ea2812b6ac074c4d8e182c215377ef1ddafa85c96fd132dc17326cd88c797",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 842
      },
      {
        "segments": [
          {
            "segment_id": "d052ecb4-84a8-46f5-9f3b-d4a6ac153598",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "think of a process α.p as one that can transit with α in p. With this intuition in mind, one can easily see\r\nhow the rule in the K interleaved definition of CCS correspond to those in its SOS definition. For example,\r\nthe first K rule for parallel composition reads as follows: if process (α.p)|q is allowed to be processed (i.e.,\r\nit is in the top of the computation structure), then it becomes the process emitting α followed by p|q. If\r\none does not like to dually think of α.p as both a process and an action α followed by process p, then one\r\ncan introduce a different notation for the later, say something like α ◦ p or α#p, and modify the rules in\r\nFigure 5 accordingly. We prefer not to introduce a different notation. The K concurrent definition of CCS\r\n(right column in Figure 5) is similar in spirit to the CHAM definition of CCS in [5] and it differs from\r\nthe K interleaved definition in that the constructs “|” and “+” are first translated into truly concurrent\r\nvariants, i.e., ones enabling the computation to concurrently proceed in both argument processes. When\r\none or both of the argument processes rewrite to the expected patterns, the actual irreversible transition is\r\napplied. Theorem 2 establishes the relationship between the SOS and the K definitions of CCS in Figure 5:\r\nTheorem 2. With the CCS definitions in Figure 5, the following properties hold:\r\n• for any p, p0 ∈ P, Kinterleaved\r\nCCS ` LpM →∗\r\nLp\r\n0\r\nM iff Kconcurrent\r\nCCS ` LpM →∗\r\nLp\r\n0\r\nM;\r\n• for any p, p0 ∈ P, if SOSCCS ` p\r\nα→ p\r\n0\r\nthen K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.p0M for any style ∈ {interleaved, concurrent};\r\n• if K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.kM for some style ∈ {interleaved, concurrent}, p ∈ P, and k ∈ K, then there is\r\nsome p\r\n0 ∈ P such that SOSCCS ` p\r\nα→ p\r\n0 and K\r\nstyle\r\nCCS ` Lp\r\n0\r\nM →∗LkM\r\nTheorem 2 tells us that, from an external point of view, an action α is possible on a process p under\r\nthe SOS definition of CCS if and only if the same action α is possible on the process LpM on any of the K\r\ndefinitions of CCS in Figure 5, that is, if and only if K\r\nstyle\r\nCCS ` LpM →∗\r\nLα.kM for some k ∈ K. Moreover, it\r\nactually says that the same holds true for any sequence of actions: sequence α1α2 . . . αn possible in SOSCCS\r\non a process p if and only if ∃k0, k1, k2, ..., kn ∈ K such that k0 = p and K\r\nstyle\r\nCCS ` LkiM →∗\r\nLαi+1.ki+1M for all\r\ni ∈ {0, 1, . . . , n − 1}.\r\nBoth K definitions in Figure 5 are inspired by the SOS definition of CCS. That made them more com\u0002plicated and less intuitive that needed. Figure 6 shows two K definitions of CCS that follow the actual\r\nconcurrency intuitions underlying CCS rather that its particular SOS definition. Let us explain this intuition\r\ninformally: CCS processes are intended to be highly concurrent, in the sense that many sub-computations\r\nhappen at the same time in different places of the system; processes can be put together in parallel “soups”\r\nas well as in non-deterministic choice “soups”; in such soups, processes can evolve truly concurrently; pro\u0002cesses in parallel soups can also communicate with each other; in non-deterministic choice soups, a process\r\nwhich is found to produce an action can preempt and discard all the other processes in the soup. With this\r\nintuition, the definitions in Figure 6 become straightforward. Interestingly, besides giving a truly concurrent\r\nsemantics to CCS, they are also more compact and simpler than the SOS definition, reducing to essentially\r\none unconditional rewrite rule or equation per CCS construct. The following result states the relationship\r\nbetween the original SOS definition of CCS and the two K definitions in Figure 6. In short, that relationship\r\nis: every reduction step in SOS is also possible as a concurrent computation in these equivalent K definitions;\r\nconversely, any action that can be produced as a result of a concurrent computation in the K definitions can\r\nalso be produced by a reduction step in the original SOS definition.\r\nTheorem 3. The K definitions of CCS in Figure 6 have the following properties (p, p0, q, p1, p2 ∈ P):\r\n• KCCS1 ` p →∗ α.q iff KCCS2 ` pˆ →∗ α.qˆ, where pˆ replaces each subprocess of the form p1|p2 by\r\nLp1 p2M| and each process of the form p1 + p2 by Lp1 p2M+ everywhere in p;\r\n• If SOS ` p\r\nα→ p\r\n0\r\nthen KCCS1 ` p →∗ α.p0; and\r\n• If KCCS1 ` p →∗ α.q then there is some p\r\n0\r\nsuch that SOS ` p\r\nα→ p\r\n0 and KCCS1 ` p0 →∗\r\nq.\r\n32\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d052ecb4-84a8-46f5-9f3b-d4a6ac153598.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=179ea2812b6ac074c4d8e182c215377ef1ddafa85c96fd132dc17326cd88c797",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 842
      },
      {
        "segments": [
          {
            "segment_id": "6fc1902a-c966-4fcb-8cb2-60fd6180ed4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "K ::= 0 | Name | A.K | K[ϕ] | K\\L\r\n| Set|[K] | Set+[K]\r\nK ::= 0 | Name | A.K | K[ϕ] | K\\L\r\n| LSet[K]M|| LSet[K]M+\r\nα.p | q → α.(p | q)\r\nα.p | α.q → τ.(p | q)\r\nα.p + q → α.p\r\n(α.p)[ϕ] = ϕ(α).(p[ϕ])\r\n(α.p)\\l = α.(p\\l) if α 6∈ {l, l}\r\nh|LsM||i\r\n| = h|s|i|\r\nh|LsM+|i+ = h|s|i+\r\nh|α.p|i| → α.h|p|i|\r\nh|α.p α.q|i| → τ.h|p q|i|\r\nh|α.p|i+ → α.p\r\n(α.p)[ϕ] = ϕ(α).(p[ϕ])\r\n(α.p)\\l = α.(p\\l) if α 6∈ {l, l}\r\nFigure 6: Truly concurrent K definitions of CCS: KCCS1 (left column) and KCCS2 (right column)\r\nThe advantage of KCCS1 over KCCS2 is that it does not change the syntax of the original CCS and it\r\nhas precisely one unconditional rule or equation per CCS construct. It has two related drawbacks compared\r\nto KCCS2: (1) its rules make use of top-level variables that are sets, so matching such rules becomes\r\nhighly-nondeterministic (exponential matches in the number of processes in the soup) and challenging to\r\nimplement, and (2) because of the above, if one does not choose the right matching then KCCS1 may lead to\r\nmany irrelevant small computational steps. For example, there are 2n possible matches of the first rule on\r\na process “p1|p2|...|pn|α.p”, all of them leading eventually to “α.(p1|p2|...|pn|p)” after multiple applications\r\nof the same rule. If one could enforce “greedy matching” on set variables like q in the first and third rules\r\nof KCCS1, then we would have no reservation to claim that KCCS1 is the most elegant and concurrent\r\ndefinition of CCS that we are aware of. KCCS2 achieves this desired greedy matching by wrapping soups\r\ninto corresponding K-cells and then having the rule match the entire cell. However, two additional equations\r\nare necessary to dissolve nested cells of the same type (first two equations in KCCS2).\r\nOur K definitions of CCS discussed in this section were aimed at trace-equivalence with respect to the\r\noriginal definition of CCS. If our goal was to obtain tree-equivalent K definitions of CCS, then we would\r\nhave had to follow an approach similar to that taken in the CHAM definition of CCS in [5], namely to\r\nreplace our “irreversible” rules for action propagation through parallel composition and for external choice\r\nwith appropriate “reversible” heating/cooling equations.\r\n4.5 Defining Milner’s π-Calculus\r\nπ-calculus is a process calculus originally introduced by Milner [26] as a continuation of his CCS. The aim of\r\nthe π-calculus is to describe concurrent computations where the process configurations’ may change during\r\nthe computation and where processes can replicate and can communicate with each other via channels. Unlike\r\nin CCS, communication in π-calculus can result in a channel name being transmitted from one process to\r\nthe other; the receiving process can use the received channel to send or receive data, and is also allowed to\r\nsend it to other processes. Figure 7 shows the original definition of π-calculus (extended with the common\r\nsummation) as well as an equivalent K definition. There are two constructs in π-calculus which bound names,\r\nnamely the input channel z(x).p and the new channel νx.p constructs (here both binding x).\r\n33\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6fc1902a-c966-4fcb-8cb2-60fd6180ed4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7e816096e5cacc6ea8f9cdb3b025f05fe5fa6f7f2f47f331f0899b671272dfa7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 537
      },
      {
        "segments": [
          {
            "segment_id": "6fc1902a-c966-4fcb-8cb2-60fd6180ed4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "K ::= 0 | Name | A.K | K[ϕ] | K\\L\r\n| Set|[K] | Set+[K]\r\nK ::= 0 | Name | A.K | K[ϕ] | K\\L\r\n| LSet[K]M|| LSet[K]M+\r\nα.p | q → α.(p | q)\r\nα.p | α.q → τ.(p | q)\r\nα.p + q → α.p\r\n(α.p)[ϕ] = ϕ(α).(p[ϕ])\r\n(α.p)\\l = α.(p\\l) if α 6∈ {l, l}\r\nh|LsM||i\r\n| = h|s|i|\r\nh|LsM+|i+ = h|s|i+\r\nh|α.p|i| → α.h|p|i|\r\nh|α.p α.q|i| → τ.h|p q|i|\r\nh|α.p|i+ → α.p\r\n(α.p)[ϕ] = ϕ(α).(p[ϕ])\r\n(α.p)\\l = α.(p\\l) if α 6∈ {l, l}\r\nFigure 6: Truly concurrent K definitions of CCS: KCCS1 (left column) and KCCS2 (right column)\r\nThe advantage of KCCS1 over KCCS2 is that it does not change the syntax of the original CCS and it\r\nhas precisely one unconditional rule or equation per CCS construct. It has two related drawbacks compared\r\nto KCCS2: (1) its rules make use of top-level variables that are sets, so matching such rules becomes\r\nhighly-nondeterministic (exponential matches in the number of processes in the soup) and challenging to\r\nimplement, and (2) because of the above, if one does not choose the right matching then KCCS1 may lead to\r\nmany irrelevant small computational steps. For example, there are 2n possible matches of the first rule on\r\na process “p1|p2|...|pn|α.p”, all of them leading eventually to “α.(p1|p2|...|pn|p)” after multiple applications\r\nof the same rule. If one could enforce “greedy matching” on set variables like q in the first and third rules\r\nof KCCS1, then we would have no reservation to claim that KCCS1 is the most elegant and concurrent\r\ndefinition of CCS that we are aware of. KCCS2 achieves this desired greedy matching by wrapping soups\r\ninto corresponding K-cells and then having the rule match the entire cell. However, two additional equations\r\nare necessary to dissolve nested cells of the same type (first two equations in KCCS2).\r\nOur K definitions of CCS discussed in this section were aimed at trace-equivalence with respect to the\r\noriginal definition of CCS. If our goal was to obtain tree-equivalent K definitions of CCS, then we would\r\nhave had to follow an approach similar to that taken in the CHAM definition of CCS in [5], namely to\r\nreplace our “irreversible” rules for action propagation through parallel composition and for external choice\r\nwith appropriate “reversible” heating/cooling equations.\r\n4.5 Defining Milner’s π-Calculus\r\nπ-calculus is a process calculus originally introduced by Milner [26] as a continuation of his CCS. The aim of\r\nthe π-calculus is to describe concurrent computations where the process configurations’ may change during\r\nthe computation and where processes can replicate and can communicate with each other via channels. Unlike\r\nin CCS, communication in π-calculus can result in a channel name being transmitted from one process to\r\nthe other; the receiving process can use the received channel to send or receive data, and is also allowed to\r\nsend it to other processes. Figure 7 shows the original definition of π-calculus (extended with the common\r\nsummation) as well as an equivalent K definition. There are two constructs in π-calculus which bound names,\r\nnamely the input channel z(x).p and the new channel νx.p constructs (here both binding x).\r\n33\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6fc1902a-c966-4fcb-8cb2-60fd6180ed4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7e816096e5cacc6ea8f9cdb3b025f05fe5fa6f7f2f47f331f0899b671272dfa7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 537
      },
      {
        "segments": [
          {
            "segment_id": "3d44b4f2-6059-4831-a71b-41252e67e096",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "N ::= x | y | z | ... an infinite set of names N ::= x | y | z | ... an infinite set of names\r\nA ::= N(N) | NhNi | τ A ::= N(N) | NhNi | τ\r\nP ::= M | P|P | νN.P |!P P ::= 0 | LSet[A.P]M+ | LSet[P]M|| νN.P |!P\r\nM ::= 0 | A.P | M + M\r\n\r\n\r\n\r\n0 + m ≡ m\r\nm1 + m2 ≡ m2 + m1\r\nm1 + (m2 + m3) ≡ (m1 + m2) + m3\r\n0|p ≡ p\r\np1|p2 ≡ p2|p1\r\np1|(p2|p3) ≡ (p1|p2)|p3\r\n\r\n\r\n\r\n\r\n\r\n\r\nL·M+ = 0\r\nL·M| = 0\r\nh|LsM||i| = h|s|i|\r\n\r\n\r\n\r\nα-equivalence of bound names α-equivalence of bound names, regarded as equation\r\nνx.(p|q) ≡ p|νx.q when x not free in p νx.(p|q) = p|νx.q when x not free in p\r\nνx.0 ≡ 0 νx.0 = 0\r\nνx.νy.p ≡ νy.νx.p νx.νy.p = νy.νx.p\r\n!p ≡ p|!p !p = Lp !pM|\r\nτ.p + m → p h|τ.p|i+ → p\r\n(x(y).p + m)|(xhzi.q + n) → p[z/y]|q h|h|x(y).p|i+\r\np[z/y]\r\nh|xhzi.q|i+\r\nq\r\n|i|\r\np → p\r\n0\r\np|q → p\r\n0\r\n|q\r\np → p\r\n0\r\nνx.p → νx.p0\r\np → p\r\n0\r\n, p ≡ q, p0 ≡ q\r\n0\r\nq → q\r\n0\r\nFigure 7: π-Calculus: Original definition (left) and K definition (right)\r\n34\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3d44b4f2-6059-4831-a71b-41252e67e096.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eed6e05692951b6d68e1f6f4a45a18d9e300ce6aedd06db18f74181eade1315e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 247
      },
      {
        "segments": [
          {
            "segment_id": "54459dc9-58e3-45df-aa2d-b43e221fdd10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "4.6 Defining Hoare’s CSP\r\n4.7 Defining Cardelli’s Ambient Calculus\r\n4.8 Defining Agha’s Actors\r\n4.9 Defining Milner’s EXP Language\r\nMilner defined and proved the correctness of his W type inferencer in the context of a simple higher-order\r\nlanguage that he called EXP [24]. Recall that W is the basis for the type checkers of all statically typed func\u0002tional languages, including ML, OCAML, HASKELL, etc. EXP is a simple expression language containing\r\nthe following constructs: lambda abstraction and application, conditional, fix point, and “let” and “letrec”\r\nbinders. Here is the annotated K syntax of EXP (the application is strict in both its subexpressions, while\r\nthe conditional is strict only in its first subexpression; also, let and letrec are defined as syntactic sugar —\r\nnote that the desugaring of let is not general-purpose, in the sense that it is only allowed for the semantics\r\nof EXP, not for its polymorphic type system discussed in Section 4.11):\r\nK-Annotated Syntax of EXP\r\nName ::= standard identifiers\r\nExp ::= Name | ... add basic values (Booleans, integers, etc.)\r\n| λ Name .Exp\r\n| Exp Exp [strict]\r\n| µ Name .Exp\r\n| if Exp then Exp else Exp [strict(1)]\r\n| let Name = Exp in Exp [let x = e in e\r\n0 = (λx.e0\r\n) e]\r\n| letrec Name Name = Exp in Exp [letrec f x = e in e\r\n0 = let f = µf.(λx.e) in e0\r\n]\r\nAs usual in our K definitions, the K computations “swallow” the syntax of the language. We next give\r\ntwo K semantic definitions of EXP, one straightforward based on substitution like the definitions of λ-calculi\r\nin Section 4.2, and another based on environments and closures. Let us first define computations, values and\r\nconfigurations which are common to both definitions:\r\nVal ::= (integers, booleans, other basic values)\r\nKResult ::= Val\r\nK ::= Exp | KResult | List·\r\ny[K]\r\nConfig ::= Val | JKK | LKMk | LSet[Config]M>\r\nThe definitions below may extend the above syntax as needed.\r\nSubstitution-based definition of EXP. The definition below is straightforward:\r\nKsubst\r\nEXP : Substitution-based K Definition of EXP e, e1, e2 ∈ Exp, v ∈ Val, x ∈ Name\r\nVal ::= ... | λ Name .Exp\r\nJeK = LLeMkM>\r\nLLvMkM> = v\r\nL(λx.e) v|ik → Le[v/x]|ik\r\nLµx.e|ik → Le[µx.e/x]|ik\r\nif true then e1 else e2 → e1\r\nif false then e1 else e2 → e2\r\nTo test the semantics, one can now execute programs like the factorial:\r\n35\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/54459dc9-58e3-45df-aa2d-b43e221fdd10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=66b308be38f1bc8651b48dda5044b58aa9c2e1e7f3f7f3d69d13771f4af9c657",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 421
      },
      {
        "segments": [
          {
            "segment_id": "b424cf5e-cf5d-4961-8392-8da4d675ff9e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "J\r\nletrec f x = if x <= 0 then 1 else x * f(x - 1)\r\nin f (f 5)\r\nK\r\nThe definition above yields, when run in Maude, the following result in 12,312 rewrites and about 0.2 seconds:\r\n668950291344912705758811805409037258675274633313802981029567135230163355724496298936687416527198498\r\n1308157637893214090552534408589408121859898481114389650005964960521256960000000000000000000000000000\r\nEnvironment-based definition of EXP. The definition below is based on environments and closures:\r\nKenv\r\nEXP: Environment-based K Definition of EXP e, e1, e2 ∈ Exp, v ∈ Val, x ∈ Name\r\nVal ::= ... | closure(Name, K,Env)\r\nK ::= ... | restore(Env)\r\nConfig ::= ... | LEnvMenv | LStoreMstore\r\nJeK = LLeMk L·Menv L·MstoreM> (initialize the configuration)\r\nh|LvMk|i> = v (dissolve the configuration)\r\nLv y restore(ρ)\r\n·\r\n|ikL\r\nρ\r\nMenv (restore the environment)\r\nL x\r\nσ[ρ[x]]\r\n|ikLρMenv LσMstore\r\nL λx.e\r\nclosure(x, e, ρ)\r\n|ikLρMenv\r\nLclosure(x, e, ρ) v\r\ne y restore(ρ\r\n0\r\n)\r\n|ikL ρ\r\n0\r\nρ[l/x]\r\nMenv L σ\r\nσ[v/l]\r\nMstore (where l is a fresh location)\r\nL µx.e\r\ne y restore(ρ)\r\n|ikL ρ\r\nρ[l/x]\r\nMenv (where l is a fresh location)\r\nif true then e1 else e2 → e1\r\nif false then e1 else e2 → e2\r\nThe definition of the auxiliary computation item restore is so useful in language definitions, that, in our\r\nMaude implementation of K, it is part of the prelude file which is included in all K definitions. These and\r\nmany others can be found in Appendix F.\r\nThere are several things to note and/or prove about the definitions Ksubst\r\nEXP and KenvEXP above. First and\r\nmost importantly, they are confluent and equivalent. Second, the environment-based definition suffers from\r\ntail-recursion problems; indeed, a tail recursive program may unboundedly grow the computation structure.\r\nFortunately and interestingly, that has a very simple fix. All one needs to do is to add the following equation\r\nto Kenv\r\nEXP, which can actually be proved correct (in other words, adding this equation is like adding a lemma,\r\nnot an axiom, so it does not change the intended semantics, it is just an optimization):\r\nrestore(ρ) y restore(ρ\r\n0\r\n) = restore(ρ\r\n0\r\n) for all ρ, ρ0 ∈ Env.\r\nFinally, it is an interesting exercise to prove that the direct definition of letrec as given in Appendix ?? for\r\nthe functional language FUN is actually semantically equivalent to what we get by desugaring it as we did\r\nin this section and then using the semantics of µ.\r\n36\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b424cf5e-cf5d-4961-8392-8da4d675ff9e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=64e9adb4949891a63046d557fe9a912250dfb89dbc0870327d938a04143eaddd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 405
      },
      {
        "segments": [
          {
            "segment_id": "9bec70bf-235a-4471-bf8f-7a0db55c556a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "4.10 Defining Robinson’s Unification\r\nUnification is different many places in computer science. Sections ?? and 4.11 show two possible uses of\r\nunification, the first in the context of defining a simple logic programming language and the second in the\r\ncontext of defining a type inferencer. Unification is straightforward to define equationally using set matching,\r\nin such a way that, when replacing the equations by rewrite rules, one gets an implementation of unification\r\nat no additional cost. For simplicity in exposition, we here assume a mono-sorted syntax, that is, there is\r\nonly one syntactic category for terms, Term, that all operation names are distinct, and that given terms\r\nare well-formed (so we do not bother parsing/checking them). In a many-sorted setting one can rename\r\noverloaded operator names so that one can reduce the many-sorted unification problem to a mono-sorted\r\none. An input to the unification problem consists of a set of parametric equations, which are pairs of terms\r\nover variables. We also allow equations over lists of terms, with the meaning that the listed terms must be\r\ncomponent-wise equal. Here is the formal definition of terms and equations:\r\nTerm and equations syntax\r\nOp ::= σ | τ | ... (any number of operator names)\r\nVar ::= x | y | ... (any number of variable names)\r\nTerm ::= Var | Op(List[Term])\r\nEqns ::= List[Term] ≡ List[Term] | Set[Eqns]\r\nThe following equational properties are all obviously valid:\r\nUnification t, t0 ∈ Term, tl, tl0 ∈ List[Term], σ ∈ Op, x ∈ Var,\r\n(1) tl ≡ tl\r\n·\r\n(2) σ(tl) ≡ σ(tl0)\r\ntl ≡ tl0\r\n(3) t, tl ≡ t\r\n0\r\n, tl0\r\n(t ≡ t\r\n0\r\n) (tl ≡ tl0)\r\n(4) t ≡ x\r\nx ≡ t\r\nwhen t 6∈ Var\r\n(5) (x ≡ t) (x\r\nt\r\n≡ t\r\n0\r\n) when t, t0 6= x\r\n(6) (x ≡ t) (x\r\n0 ≡ t0\r\nt\r\n0\r\n[t/x]\r\n) when x 6= x\r\n0\r\n, x 6= t, x0 6= t\r\n0\r\n, and x 6∈ vars(t), x ∈ vars(t\r\n0\r\n)\r\nThe first equation above eliminates non-informative term constraints. The second and third equations\r\ndistribute constraints over non-variable terms to constraints over their argument subterms. The fourth\r\nswaps the two terms involved in each constraint so that each constraint containing a variable term has\r\nthe term variables as its lhs. The fifth ensures that, eventually, no two term constraints have the same lhs\r\nvariable. Finally, the sixth equation canonizes the constrains in order to give a substitution; note that the side\r\nconditions of the sixth equation guarantee that it cannot be applied forever, thus leading to non-termination.\r\nAs expected, the equations above take a set of equational term constraints and eventually produce a most\r\ngeneral unifier for them:\r\nTheorem 4. Let γ ∈ Eqns be a set of equational term constraints and let us regard the six equations above\r\nas rewrite rules. Then:\r\n37\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9bec70bf-235a-4471-bf8f-7a0db55c556a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=166e99cb0ffdcde226f05e5856f4efa434e39f22c9b8709875a9650f9755cea6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 497
      },
      {
        "segments": [
          {
            "segment_id": "99fc66be-3d02-4a34-b494-a75dc7f5a93e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "• The six-rule rewrite system above terminates (modulo AC); let θ ∈ Eqns be the normal form of γ;\r\n• γ is unifiable iff θ contains only pairs of the form x ≡ t, where x 6∈ vars(t); if that is the case, then\r\nwe identify θ with the implicit substitution that it comprises, that is, θ(x) = t when there is some type\r\nequality x ≡ t in θ, and θ(x) = x when there is no type equality of the form x ≡ t in θ;\r\n• If γ is unifiable then θ is idempotent (i.e., θ ◦ θ = θ) and is a most general unifier of γ.\r\nTherefore, the six equations above give us a simple rewriting procedure for unification. Experiments using the\r\nMaude rewrite engine show that it may also quite efficient (the type inferencer in Section 4.11 is comparable\r\nin performance to state of the art implementations of type inference in languages like OCAML). The tests\r\n“x ∈ vars(t)” and “x ∈ vars(t\r\n0\r\n)” in the sixth equation of the unification definition and in the second item\r\nof the theorem above, respectively, may be a bottle-neck in the performance of an implementation of the\r\nunification definition above. If the underlying rewrite engine provides support for memoization, one may\r\nmemoize such membership tests, so that one pays the price of traversing a term for its variables only once\r\n(though one would need to pay the price of memo table lookup; experiments are probably needed for each\r\napplication to decide whether memoization is useful or not). Moreover, tests “x 6∈ vars(t)” saying whether\r\nequational constraints “x ≡ t” are circular or not can be avoided on rewrite engines providing support for\r\nsubsorting and sort membershipping, like Maude: one can subsort once and for all each equational constraint\r\nof the form x ≡ t with x 6∈ vars(t) to a “proper” constraint, and then allow only proper constraints in the\r\nsort Eqns (the improper ones remain part of the “kind”, or “error supersort” [Eqns]).\r\nIf γ ∈ Eqns is a set of equational constraints and t ∈ Term is some term, then we let γ[t] denote θ(t); if γ\r\nis not unifiable, then γ[t] is some error term (in the kind [Term] when using a rewrite engine like Maude with\r\nsubsorting or kinding). A simple way to calculate γ[t] using the already existing machinery of unification\r\ndefined above is:\r\n1. Add an equational constraint freshVar ≡ t to γ, where freshVar is a variable that does not occur in γ;\r\nlet γ\r\n0 be the new set of constraints;\r\n2. Let the unification procedure solve the constraints in γ\r\n0\r\n;\r\n3. If γ\r\n0\r\nis unifiable, let θ\r\n0 be the resulting substitution, like in the second item in the theorem above;\r\n4. Let θ be the substitution obtained by restricting θ\r\n0\r\nto all variables except freshVar.\r\n5. Let γ[t] be the term θ\r\n0\r\n(freshVar).\r\nThen the following holds:\r\nCorollary 1. With the notation above,\r\n1. γ\r\n0\r\nis unifiable iff γ is unifiable;\r\n2. If the above holds, then θ is the most general unifier of γ;\r\n3. γ[t] = θ(t).\r\n4.11 Defining Milner’s W Polymorphic Type Inferencer\r\nWe next define the W type inferencer in [24] using the same K approach. The overall idea of our definition\r\nof W is that EXP programs are iteratively rewritten, i.e., “evaluated” to types; in particular, the typing\r\nprocess is started by rewriting all integers and booleans to types int and bool, respectively. The K annotated\r\nsyntax below changes the conditional to strict in all its arguments, makes let strict in its second argument,\r\nand desugars letrec like in the definition of EXP in Section 4.9:\r\n38\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/99fc66be-3d02-4a34-b494-a75dc7f5a93e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6b445c0cf42ca0671638dfe642fee72e6726e746c3b0aad8b50488239d9f10a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 637
      },
      {
        "segments": [
          {
            "segment_id": "99fc66be-3d02-4a34-b494-a75dc7f5a93e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "• The six-rule rewrite system above terminates (modulo AC); let θ ∈ Eqns be the normal form of γ;\r\n• γ is unifiable iff θ contains only pairs of the form x ≡ t, where x 6∈ vars(t); if that is the case, then\r\nwe identify θ with the implicit substitution that it comprises, that is, θ(x) = t when there is some type\r\nequality x ≡ t in θ, and θ(x) = x when there is no type equality of the form x ≡ t in θ;\r\n• If γ is unifiable then θ is idempotent (i.e., θ ◦ θ = θ) and is a most general unifier of γ.\r\nTherefore, the six equations above give us a simple rewriting procedure for unification. Experiments using the\r\nMaude rewrite engine show that it may also quite efficient (the type inferencer in Section 4.11 is comparable\r\nin performance to state of the art implementations of type inference in languages like OCAML). The tests\r\n“x ∈ vars(t)” and “x ∈ vars(t\r\n0\r\n)” in the sixth equation of the unification definition and in the second item\r\nof the theorem above, respectively, may be a bottle-neck in the performance of an implementation of the\r\nunification definition above. If the underlying rewrite engine provides support for memoization, one may\r\nmemoize such membership tests, so that one pays the price of traversing a term for its variables only once\r\n(though one would need to pay the price of memo table lookup; experiments are probably needed for each\r\napplication to decide whether memoization is useful or not). Moreover, tests “x 6∈ vars(t)” saying whether\r\nequational constraints “x ≡ t” are circular or not can be avoided on rewrite engines providing support for\r\nsubsorting and sort membershipping, like Maude: one can subsort once and for all each equational constraint\r\nof the form x ≡ t with x 6∈ vars(t) to a “proper” constraint, and then allow only proper constraints in the\r\nsort Eqns (the improper ones remain part of the “kind”, or “error supersort” [Eqns]).\r\nIf γ ∈ Eqns is a set of equational constraints and t ∈ Term is some term, then we let γ[t] denote θ(t); if γ\r\nis not unifiable, then γ[t] is some error term (in the kind [Term] when using a rewrite engine like Maude with\r\nsubsorting or kinding). A simple way to calculate γ[t] using the already existing machinery of unification\r\ndefined above is:\r\n1. Add an equational constraint freshVar ≡ t to γ, where freshVar is a variable that does not occur in γ;\r\nlet γ\r\n0 be the new set of constraints;\r\n2. Let the unification procedure solve the constraints in γ\r\n0\r\n;\r\n3. If γ\r\n0\r\nis unifiable, let θ\r\n0 be the resulting substitution, like in the second item in the theorem above;\r\n4. Let θ be the substitution obtained by restricting θ\r\n0\r\nto all variables except freshVar.\r\n5. Let γ[t] be the term θ\r\n0\r\n(freshVar).\r\nThen the following holds:\r\nCorollary 1. With the notation above,\r\n1. γ\r\n0\r\nis unifiable iff γ is unifiable;\r\n2. If the above holds, then θ is the most general unifier of γ;\r\n3. γ[t] = θ(t).\r\n4.11 Defining Milner’s W Polymorphic Type Inferencer\r\nWe next define the W type inferencer in [24] using the same K approach. The overall idea of our definition\r\nof W is that EXP programs are iteratively rewritten, i.e., “evaluated” to types; in particular, the typing\r\nprocess is started by rewriting all integers and booleans to types int and bool, respectively. The K annotated\r\nsyntax below changes the conditional to strict in all its arguments, makes let strict in its second argument,\r\nand desugars letrec like in the definition of EXP in Section 4.9:\r\n38\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/99fc66be-3d02-4a34-b494-a75dc7f5a93e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6b445c0cf42ca0671638dfe642fee72e6726e746c3b0aad8b50488239d9f10a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 637
      },
      {
        "segments": [
          {
            "segment_id": "93c023d8-9344-481f-abfb-d87609e192f3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "K-Annotated Syntax of EXP for W\r\nName ::= standard identifiers\r\nExp ::= Name | ... add basic values (Booleans, integers, etc.)\r\n| λ Name .Exp\r\n| Exp Exp [strict]\r\n| µ Name .Exp\r\n| if Exp then Exp else Exp [strict]\r\n| let Name = Exp in Exp [strict(2)]\r\n| letrec Name Name = Exp in Exp [letrec f x = e in e\r\n0 = let f = µf.(λx.e) in e0\r\n]\r\nWe consider the usual syntax for (implicitly universal) parametric types:\r\nTypeVar ::= type variables\r\nType ::= TypeVar | int | bool | Type \u0001 Type\r\nAt no but notational expense, we can regard types as terms like in Section 4.10, where Var is replaced by\r\nTypeVar and where Op contains three operations: int and bool taking zero arguments, and \u0001 taking\r\ntwo arguments. This way, we take the liberty to use the unification procedure in Section 4.10 with no\r\nmodification; moreover, if one wants to extend the results and add new type constructs, then all one needs\r\nto do is to add new operator names (type constructs) to Op (no additional equations for unification needed).\r\nWe next give two definitions for W , one substitution-based and another environment-based. Both start\r\nby “swallowing” the syntax and the types into computations K, and then continue by iteratively rewriting\r\nthe computation into a type, accumulating and solving the type constraints as needed. For both definitions\r\nwe need some additional computation infrastructure:\r\n• A computation item let(Type) holding a polymorphic type that needs to be concretized when encoun\u0002tered for processing;\r\n• A computation item K \u0001 K extending the function type construct Type \u0001 Type that is strict in its\r\ntwo arguments (only strictness in the second matters, but for the sake of generality and simplicity\r\nwe keep it strict in both arguments); once the two arguments are processed into types, the resulting\r\ncomputation is, of course, a type (function type);\r\n• A computation item K ≡ K which is also strict in its arguments (like above, only strictness in the\r\nsecond argument is necessary here); once the two arguments are processed, the resulting type equality\r\nis added to the set of type equational constraints to be solved.\r\nHere is the syntax of computations and of configurations that is common to both definitions:\r\nKResult ::= Type\r\nK ::= KResult | let(Type) | K \u0001 K [strict] | K ≡ K [strict] | List·\r\ny[K]\r\nConfig ::= Type | JKK | LKMk | LEqnsMeqns | LSet[Config]M>\r\nand here is the K equation needed to move the type equality resulting from processing K \u0001 K from the\r\ncomputation structure into the set of equational constraints:\r\nLeqn\r\n·\r\n|ikh| ·\r\neqn\r\n|ieqns\r\nwhere eqn ∈ Eqn\r\n(this general purpose equation is part of prelude)\r\nEach of the two definitions of W discussed in the sequel will enrich computations and/or configurations with\r\nspecific constructs. We next present the two definitions, the first based on substitutions and the second on\r\nenvironments, by first presenting the rules which are independent upon the particular style (substitution\r\nor environment) adopted and, therefore, are common to both. These rules are straightforward and self\r\nexplanatory. All they do is to initiate the process of rewriting programs into types by rewriting the basic\r\nvalues into their corresponding types, and then propagate the typing policy through the simple constructs\r\naccumulating at the same time additional type constraints:\r\n39\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/93c023d8-9344-481f-abfb-d87609e192f3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c0075aa514edb39f5bf9dd7aeaaf5a0459e2821ee4a39b0a9692f0a44fe0faaa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 580
      },
      {
        "segments": [
          {
            "segment_id": "93c023d8-9344-481f-abfb-d87609e192f3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "K-Annotated Syntax of EXP for W\r\nName ::= standard identifiers\r\nExp ::= Name | ... add basic values (Booleans, integers, etc.)\r\n| λ Name .Exp\r\n| Exp Exp [strict]\r\n| µ Name .Exp\r\n| if Exp then Exp else Exp [strict]\r\n| let Name = Exp in Exp [strict(2)]\r\n| letrec Name Name = Exp in Exp [letrec f x = e in e\r\n0 = let f = µf.(λx.e) in e0\r\n]\r\nWe consider the usual syntax for (implicitly universal) parametric types:\r\nTypeVar ::= type variables\r\nType ::= TypeVar | int | bool | Type \u0001 Type\r\nAt no but notational expense, we can regard types as terms like in Section 4.10, where Var is replaced by\r\nTypeVar and where Op contains three operations: int and bool taking zero arguments, and \u0001 taking\r\ntwo arguments. This way, we take the liberty to use the unification procedure in Section 4.10 with no\r\nmodification; moreover, if one wants to extend the results and add new type constructs, then all one needs\r\nto do is to add new operator names (type constructs) to Op (no additional equations for unification needed).\r\nWe next give two definitions for W , one substitution-based and another environment-based. Both start\r\nby “swallowing” the syntax and the types into computations K, and then continue by iteratively rewriting\r\nthe computation into a type, accumulating and solving the type constraints as needed. For both definitions\r\nwe need some additional computation infrastructure:\r\n• A computation item let(Type) holding a polymorphic type that needs to be concretized when encoun\u0002tered for processing;\r\n• A computation item K \u0001 K extending the function type construct Type \u0001 Type that is strict in its\r\ntwo arguments (only strictness in the second matters, but for the sake of generality and simplicity\r\nwe keep it strict in both arguments); once the two arguments are processed into types, the resulting\r\ncomputation is, of course, a type (function type);\r\n• A computation item K ≡ K which is also strict in its arguments (like above, only strictness in the\r\nsecond argument is necessary here); once the two arguments are processed, the resulting type equality\r\nis added to the set of type equational constraints to be solved.\r\nHere is the syntax of computations and of configurations that is common to both definitions:\r\nKResult ::= Type\r\nK ::= KResult | let(Type) | K \u0001 K [strict] | K ≡ K [strict] | List·\r\ny[K]\r\nConfig ::= Type | JKK | LKMk | LEqnsMeqns | LSet[Config]M>\r\nand here is the K equation needed to move the type equality resulting from processing K \u0001 K from the\r\ncomputation structure into the set of equational constraints:\r\nLeqn\r\n·\r\n|ikh| ·\r\neqn\r\n|ieqns\r\nwhere eqn ∈ Eqn\r\n(this general purpose equation is part of prelude)\r\nEach of the two definitions of W discussed in the sequel will enrich computations and/or configurations with\r\nspecific constructs. We next present the two definitions, the first based on substitutions and the second on\r\nenvironments, by first presenting the rules which are independent upon the particular style (substitution\r\nor environment) adopted and, therefore, are common to both. These rules are straightforward and self\r\nexplanatory. All they do is to initiate the process of rewriting programs into types by rewriting the basic\r\nvalues into their corresponding types, and then propagate the typing policy through the simple constructs\r\naccumulating at the same time additional type constraints:\r\n39\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/93c023d8-9344-481f-abfb-d87609e192f3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c0075aa514edb39f5bf9dd7aeaaf5a0459e2821ee4a39b0a9692f0a44fe0faaa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 580
      },
      {
        "segments": [
          {
            "segment_id": "b1744cb4-a16c-41cd-9257-e33f1311386c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "K Definition of W: simple language constructs t, t1, t2 ∈ Type\r\ni → int, true → bool, false → bool (and similarly for all the other basic values)\r\nLt1 + t2\r\nint\r\n|ikh| ·\r\nt1 ≡ int, t2 ≡ int\r\n|ieqns (and similarly for all other standard operators)\r\nLt1 t2\r\ntvar\r\n|ikh| ·\r\nt1 ≡ t2 → tvar\r\n|i\r\neqns where tvar is a fresh type variable\r\nLif t then t1 else t2\r\nt1\r\n|ikh| ·\r\nt ≡ bool, t1 ≡ t2\r\n|ieqns\r\nThe rules above assume that the L...Mk and L...Meqns cells will both be part of the same cell in the configuration.\r\nThis will be the case in both subsequent definitions. Due to the strictness attributes, in the above we assumed\r\nthat the corresponding arguments of the language constructs (in which these constructs were defined strict)\r\nhave already been “evaluated” to their types and the corresponding type constraints have been propagated.\r\nBelow is our first K definition of W , based on substitutions. A “path” configuration item is necessary to\r\nstore the set of type variables corresponding to the variables bound with λ or µ in whose scope the expression\r\nthat is being currently processed is. The path is easily maintained by adding to it the fresh type variable\r\ncorresponding to the binding variable whenever a λ or a µ expression is processed, making sure that it is\r\nremoved once the processing of the λ or µ expression is completed:\r\nSubstitution-based K Definition of W t, t1, t2 ∈ Type\r\nK ::= ... | TypeVar\r\nConfig ::= ... | LSet[TypeVar]Mpath\r\nJeK = LLeMk L·Mpath L·MeqnsM> (initialize the configuration)\r\nh|LtMk LγMeqns|i> = γ[t] (dissolve the configuration when done)\r\nLt y tvar\r\n·\r\n|ikh|tvar\r\n·\r\n|ipath (remove tvar from the path)\r\nλx.e → (tvar \u0001 e[tvar/x]) y tvar where tvar is a fresh type variable\r\nµx.e → (tvar ≡ e[tvar/x]) y tvar where tvar is a fresh type variable\r\nlet x = t in e → e[let(t)/x]\r\nL let(t)\r\n(γ[t])[tvars0/tvars]\r\n|ikLηMpath LγMeqns where tvars = vars(γ[t]) − η\r\nand tvars0 are |tvars| fresh type variables\r\nWhen the let-bound “let” types are encountered, their unconstrained and path-unbound type variables (i.e.,\r\ntheir “universal” type variables), are instantiated with fresh type variables. Note that the equational type\r\nconstraints are required to be solved whenever a let-bound type is encountered, because one needs to know\r\nhow many fresh type variables need to be generated to replace the variables in which the let-bound type is\r\npolymorphic (the last rule above). Other than that, there is no requirement on when or if to solve the type\r\nconstraints; in particular, they can be solved concurrently and while the program is still being processed.\r\nOne particularly interesting aspect of the definition above is that we allow λ, µ, and let expressions to be\r\nrewritten at any moment and at any place (not necessarily in “context”), provided that one has a mechanism\r\nto generate fresh type variables there. In concrete and “pure” implementations of the W procedure following\r\nour technique above, one may want to restrict the applications of these rules to the top of the computation,\r\nwhere one can easily generate a fresh type variable (e.g., one may add a new “next fresh variable” cell at the\r\ntop level of the configuration), i.e., to replace them with the following:\r\n40\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b1744cb4-a16c-41cd-9257-e33f1311386c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eae8d9a70ff1c5e0f296fcd1fcef4052567057d65b33d9544965db5150482ec7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 568
      },
      {
        "segments": [
          {
            "segment_id": "b1744cb4-a16c-41cd-9257-e33f1311386c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "K Definition of W: simple language constructs t, t1, t2 ∈ Type\r\ni → int, true → bool, false → bool (and similarly for all the other basic values)\r\nLt1 + t2\r\nint\r\n|ikh| ·\r\nt1 ≡ int, t2 ≡ int\r\n|ieqns (and similarly for all other standard operators)\r\nLt1 t2\r\ntvar\r\n|ikh| ·\r\nt1 ≡ t2 → tvar\r\n|i\r\neqns where tvar is a fresh type variable\r\nLif t then t1 else t2\r\nt1\r\n|ikh| ·\r\nt ≡ bool, t1 ≡ t2\r\n|ieqns\r\nThe rules above assume that the L...Mk and L...Meqns cells will both be part of the same cell in the configuration.\r\nThis will be the case in both subsequent definitions. Due to the strictness attributes, in the above we assumed\r\nthat the corresponding arguments of the language constructs (in which these constructs were defined strict)\r\nhave already been “evaluated” to their types and the corresponding type constraints have been propagated.\r\nBelow is our first K definition of W , based on substitutions. A “path” configuration item is necessary to\r\nstore the set of type variables corresponding to the variables bound with λ or µ in whose scope the expression\r\nthat is being currently processed is. The path is easily maintained by adding to it the fresh type variable\r\ncorresponding to the binding variable whenever a λ or a µ expression is processed, making sure that it is\r\nremoved once the processing of the λ or µ expression is completed:\r\nSubstitution-based K Definition of W t, t1, t2 ∈ Type\r\nK ::= ... | TypeVar\r\nConfig ::= ... | LSet[TypeVar]Mpath\r\nJeK = LLeMk L·Mpath L·MeqnsM> (initialize the configuration)\r\nh|LtMk LγMeqns|i> = γ[t] (dissolve the configuration when done)\r\nLt y tvar\r\n·\r\n|ikh|tvar\r\n·\r\n|ipath (remove tvar from the path)\r\nλx.e → (tvar \u0001 e[tvar/x]) y tvar where tvar is a fresh type variable\r\nµx.e → (tvar ≡ e[tvar/x]) y tvar where tvar is a fresh type variable\r\nlet x = t in e → e[let(t)/x]\r\nL let(t)\r\n(γ[t])[tvars0/tvars]\r\n|ikLηMpath LγMeqns where tvars = vars(γ[t]) − η\r\nand tvars0 are |tvars| fresh type variables\r\nWhen the let-bound “let” types are encountered, their unconstrained and path-unbound type variables (i.e.,\r\ntheir “universal” type variables), are instantiated with fresh type variables. Note that the equational type\r\nconstraints are required to be solved whenever a let-bound type is encountered, because one needs to know\r\nhow many fresh type variables need to be generated to replace the variables in which the let-bound type is\r\npolymorphic (the last rule above). Other than that, there is no requirement on when or if to solve the type\r\nconstraints; in particular, they can be solved concurrently and while the program is still being processed.\r\nOne particularly interesting aspect of the definition above is that we allow λ, µ, and let expressions to be\r\nrewritten at any moment and at any place (not necessarily in “context”), provided that one has a mechanism\r\nto generate fresh type variables there. In concrete and “pure” implementations of the W procedure following\r\nour technique above, one may want to restrict the applications of these rules to the top of the computation,\r\nwhere one can easily generate a fresh type variable (e.g., one may add a new “next fresh variable” cell at the\r\ntop level of the configuration), i.e., to replace them with the following:\r\n40\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b1744cb4-a16c-41cd-9257-e33f1311386c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eae8d9a70ff1c5e0f296fcd1fcef4052567057d65b33d9544965db5150482ec7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 568
      },
      {
        "segments": [
          {
            "segment_id": "39affae1-2bd6-4355-a76d-0ff23fa109fa",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Lλx.e|ik → L(tvar \u0001 e[tvar/x]) y tvar|ik where tvar is a fresh type variable\r\nLµx.e|ik → L(tvar ≡ e[tvar/x]) y tvar|ik where tvar is a fresh type variable\r\nLlet x = t in e|ik → Le[let(t)/x]|ik\r\nOne can show that the two K theories above are equivalent modulo renaming of type variables (that is\r\nbecause our first one is confluent modulo renaming of variables, so one can reorder the applications of the\r\nthree rule to apply only at the top of the computation).\r\nWe believe that the K definition above of W is as simple, if not simpler, to understand as the original W\r\nprocedure proposed by Milner in [24]. However, note that the procedure in [24] is an algorithm, almost an\r\nimplementation, rather than a formal, logic-based definition!\r\nWe next give our second K definition of W. The main difference between our first definition and the\r\nsecond is that the second uses a type environment to map types to binding names instead of a substitution.\r\nAll we have to do is to replace the L...Mpath cell above storing a set of type variables with a L...Mtenv cell storing\r\na type environment (i.e., set of pairs name/type); the later will already contain the set of type variables\r\nvisible in the current scope: let tvars(η) be the type variables bound to names in the type environment η\r\n(the type environment may also contain let-bound types bound to names, which we do not consider when\r\ncomputing tvars(η)). Then our second definition of W is as follows:\r\nEnvironment-based K Definition of W t, t1, t2 ∈ Type\r\nK ::= ... | restore(Set[Name × Type])\r\nConfig ::= ... | LSet[Name × Type]Mtenv\r\nJeK = LLeMk L·Mtenv L·MeqnsM> (initialize the configuration)\r\nh|LtMk LγMeqns|i> = γ[t] (dissolve the configuration)\r\nLt y restore(η)\r\n·\r\n|ikL\r\nη\r\nMtenv (restore the type environment)\r\nL x\r\n(γ[t])[tvars0/tvars]\r\n|ikLηMtenv LγMeqns when η[x] = let(t), tvars = vars(γ[t]) − vars(η)\r\nand tvars0 are |tvars| fresh type variables\r\nL x\r\nη[x]\r\n|ikLηMtenv when η[x] 6= let(t)\r\nL λx.e\r\n(tvar → e) y restore(η)\r\n|ikL η\r\nη[tvar/x]\r\nMtenv where tvar is a fresh type variable\r\nL µx.e\r\ntvar ≡ e y restore(η)\r\n|ikL η\r\nη[tvar/x]\r\nMtenv where tvar is a fresh type variable\r\nL let x = t in e\r\ne y restore(η)\r\n|ikL η\r\nη[let(t)]/x\r\nMenv\r\nBoth our K definitions above are nothing but ordinary rewrite logic theories, same as the formal definition\r\nof EXP itself. That should not, and indeed it does not, mean that our K definitions, when executed, must\r\nnecessarily be slower than an actual implementation of W. Experiments using the second definition above\r\nexecuted in Maude show that our K definition above of W is comparable or even outperforms state of the art\r\nimplementations of type inference in conventional functional languages. For example, on our experiments it\r\nwas faster than the type inferencers of SML and Haskell, and only about twice slower than that of OCAML.\r\n41\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/39affae1-2bd6-4355-a76d-0ff23fa109fa.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b1df8a88f436d1dfadfbb5795f0d6bc2b0b650f3b2361a413c2b358b98f1815a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 503
      },
      {
        "segments": [
          {
            "segment_id": "103b28fd-dd0b-4567-a96a-83e767873ccc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "Concretely, the program (which is polymorphic in 2n + 1 type variables!)\r\nlet f0 = λx.λy.x in\r\nlet f1 = λx.f0(f0x) in\r\nlet f2 = λx.f1(f1x) in\r\n...\r\nlet fn = λx.fn−1(fn−1x) in fn\r\ntakes the following time/space resources to be type checked using OCAML, Haskell, SML, and our K defini\u0002tion executed in Maude, respectively:\r\n- n = 10 n = 12 n = 13 n = 14\r\nOCAML (version 3.09.3) 0.6s 3M 8.1s 5M 31.2s 8M 120.6s 13M\r\nHaskell (ghci version 6.7.20070312) 2.7s 25M 42.4s 31M 207.8s 38 M 1177s 61M\r\nSML (version 110.59) 5s 76M 110.5s 324M 2129.2s 950M out of M\r\nW in K/Maude2.2 with memo 1.2s 17M 18.9s 65M 78s 191M 304s 653M\r\nW in K/Maude2.2 without memo 2.2s 10M 22.4s 47M 81s 152M 305s 563M\r\nThe experiments above have been conducted on a 3.4GHz/2GB Linux machine. Only the user time\r\nhas been recorded. Except for SML, the user time was very close to the real time; for SML, the real time\r\nwas 30% larger than the user time. These ratios appear to scale and be preserved for other programs, too.\r\nMoreover, extensions of the type system with lists, products, side effects (through referencing, dereferencing\r\nand assignment) and weak polymorphism did not add any noticeable slowdown. Therefore, our K definitions\r\nsurprisingly yield quite realistic implementations of type checkers/inferencers when executed on efficient\r\nrewrite engines! While calculating the numbers above, Maude run at an average of 3 million rewrites per\r\nsecond. In Maude, memoization can be enabled by adding the attribute “[memo]” to operations whose\r\nresults one wants memoized; in our case, we only experimented with memoizing the “built-in” operation\r\nvars : Type -> Set{TypeVar} in k-prelude.maude, which extracts the set of type variables that occur in\r\na type. Memoization appears to pay off when the polymorphic types are small, which is typically the case.\r\nOur Maude “implementation” of an extension4 of the K definition of W above has about 30 lines of code.\r\nHow is it be possible that a formal definition of a type system that one can write in 30 lines of code can be\r\nexecuted as is more efficiently than well-engineered implementations of the same type system in widely used\r\nprogramming languages? We think that the answer to this question involves at least two aspects. On the one\r\nhand, Maude, despite its generality, is itself a well-engineered rewrite engine implementing state-of-the-art\r\nAC matching and term indexing algorithms. On the other hand, our K definition makes intensive use of what\r\nMaude is very good at, namely AC matching. For example, note the fourth rule in our rewrite definition of\r\nunification5that precedes Theorem 4: the type variable tv appears twice in the lhs of the rule, once in each of\r\nthe two type equalities involved. Maude will therefore need to search and then index for two type equalities\r\nin the set of type constraints which share the same type variable. Similarly, but even more complicatedly, the\r\nfifth rule involves two type equalities, the second containing in its t\r\n0\r\nsome occurrence of the type variable tv\r\nthat appears in the first. Without appropriate indexing to avoid rematching of rules, which is what Maude\r\ndoes well, such operations can be very expensive. Moreover, note that our type constraints can be “solved”\r\nincrementally (by applying the five unification rewrite rules), as generated, into a most general substitution;\r\nincremental solving of the type constraints can have a significant impact on the complexity of unification as\r\nwe defined it, and Maude indeed does that (one can see it by tracing/logging Maude’s rewrite steps).\r\n4With conventional arithmetic and boolean operators added for writing and testing our definition on meaningful programs\r\n5Type unification is “built-in” in K: it is defined as shown above in k-prelude.maude.\r\n42\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/103b28fd-dd0b-4567-a96a-83e767873ccc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=beebb41ad36718092100ce1df803c8dd02715cf695b0134b7155a70222ab6d49",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 640
      },
      {
        "segments": [
          {
            "segment_id": "103b28fd-dd0b-4567-a96a-83e767873ccc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "Concretely, the program (which is polymorphic in 2n + 1 type variables!)\r\nlet f0 = λx.λy.x in\r\nlet f1 = λx.f0(f0x) in\r\nlet f2 = λx.f1(f1x) in\r\n...\r\nlet fn = λx.fn−1(fn−1x) in fn\r\ntakes the following time/space resources to be type checked using OCAML, Haskell, SML, and our K defini\u0002tion executed in Maude, respectively:\r\n- n = 10 n = 12 n = 13 n = 14\r\nOCAML (version 3.09.3) 0.6s 3M 8.1s 5M 31.2s 8M 120.6s 13M\r\nHaskell (ghci version 6.7.20070312) 2.7s 25M 42.4s 31M 207.8s 38 M 1177s 61M\r\nSML (version 110.59) 5s 76M 110.5s 324M 2129.2s 950M out of M\r\nW in K/Maude2.2 with memo 1.2s 17M 18.9s 65M 78s 191M 304s 653M\r\nW in K/Maude2.2 without memo 2.2s 10M 22.4s 47M 81s 152M 305s 563M\r\nThe experiments above have been conducted on a 3.4GHz/2GB Linux machine. Only the user time\r\nhas been recorded. Except for SML, the user time was very close to the real time; for SML, the real time\r\nwas 30% larger than the user time. These ratios appear to scale and be preserved for other programs, too.\r\nMoreover, extensions of the type system with lists, products, side effects (through referencing, dereferencing\r\nand assignment) and weak polymorphism did not add any noticeable slowdown. Therefore, our K definitions\r\nsurprisingly yield quite realistic implementations of type checkers/inferencers when executed on efficient\r\nrewrite engines! While calculating the numbers above, Maude run at an average of 3 million rewrites per\r\nsecond. In Maude, memoization can be enabled by adding the attribute “[memo]” to operations whose\r\nresults one wants memoized; in our case, we only experimented with memoizing the “built-in” operation\r\nvars : Type -> Set{TypeVar} in k-prelude.maude, which extracts the set of type variables that occur in\r\na type. Memoization appears to pay off when the polymorphic types are small, which is typically the case.\r\nOur Maude “implementation” of an extension4 of the K definition of W above has about 30 lines of code.\r\nHow is it be possible that a formal definition of a type system that one can write in 30 lines of code can be\r\nexecuted as is more efficiently than well-engineered implementations of the same type system in widely used\r\nprogramming languages? We think that the answer to this question involves at least two aspects. On the one\r\nhand, Maude, despite its generality, is itself a well-engineered rewrite engine implementing state-of-the-art\r\nAC matching and term indexing algorithms. On the other hand, our K definition makes intensive use of what\r\nMaude is very good at, namely AC matching. For example, note the fourth rule in our rewrite definition of\r\nunification5that precedes Theorem 4: the type variable tv appears twice in the lhs of the rule, once in each of\r\nthe two type equalities involved. Maude will therefore need to search and then index for two type equalities\r\nin the set of type constraints which share the same type variable. Similarly, but even more complicatedly, the\r\nfifth rule involves two type equalities, the second containing in its t\r\n0\r\nsome occurrence of the type variable tv\r\nthat appears in the first. Without appropriate indexing to avoid rematching of rules, which is what Maude\r\ndoes well, such operations can be very expensive. Moreover, note that our type constraints can be “solved”\r\nincrementally (by applying the five unification rewrite rules), as generated, into a most general substitution;\r\nincremental solving of the type constraints can have a significant impact on the complexity of unification as\r\nwe defined it, and Maude indeed does that (one can see it by tracing/logging Maude’s rewrite steps).\r\n4With conventional arithmetic and boolean operators added for writing and testing our definition on meaningful programs\r\n5Type unification is “built-in” in K: it is defined as shown above in k-prelude.maude.\r\n42\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/103b28fd-dd0b-4567-a96a-83e767873ccc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=beebb41ad36718092100ce1df803c8dd02715cf695b0134b7155a70222ab6d49",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 640
      },
      {
        "segments": [
          {
            "segment_id": "dbe1f507-b752-46b5-bcb4-a6ffeaca2fcc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "4.12 Defining Plotkin’s PCF language\r\n5 Comparing K With Other Formalisms\r\nSince the various language definitional formalisms were all designed to solve more or less the same problem,\r\nit is not surprising that there are deep relationships between almost any two such formalisms. Some of\r\nthese relationships have been spelled out in the literature. In this section we briefly discuss some of the\r\nmore popular language definitional formalisms, and then show how each of them can be captured as a\r\nmethodological fragment of rewriting logic and even of K. Since rewriting logic is a real computational\r\nlogical meta-framework that does not impose on the language designer any particular definitional style, it\r\ncaptures very naturally, with almost zero representational distance, the various other formalisms. Since K\r\nwas not intended to be such a generic meta-framework, but rather a particular definitional style that makes\r\nunrestricted use of the full strength of (unconditional) rewriting logic when defining programing languages\r\nor calculi, it is not surprising that some of the translations into K are less straight-forward. With the\r\nexception of the chemical abstract machine, which, like rewriting logic and K explicitly aims at avoiding\r\nthe obedience of structural operational semantics to syntax and interleaving semantics, the complexity of\r\nthe subsequent translations of formalisms stays in “inhibiting” the otherwise unrestricted computational\r\nmechanism of rewriting logic, so that only one rewrite step is applied at a time, and only in a context that\r\nis allowed by the evaluation strategy of the defined language constructs.\r\nFor simplicity, in each of the formalisms discussed in this section we limit ourselves to ground instances of\r\nrule schematas; in other words, we assume that each rule in each formalism, which may typically be restricted\r\nby side conditions, was replaced by all its concrete instances (typically a recursively enumerable set), one\r\nper variable instances satisfying the side conditions of the rule. One can also translate side conditions in\r\nthe original rules into conditions in the resulting rewriting logic rules and/or equations. In most cases, in\r\nparticular when each rule has precisely one correspondent rule in rewriting logic or K (like in the translation of\r\ncontext reduction into K, for example), the side conditions simply carry over unchanged. In some other cases,\r\nsuch as when a conditional rule in the original formalism translates into more than one rule or equation in the\r\ncorresponding rewrite logic theory and different transitions in the original condition may refer to the same\r\nvariable (like in the translation of general-purpose big-step or small-step SOS into K), one must be careful\r\nto properly propagate the accumulated substitution. Techniques for systematic elimination of conditional\r\nrules in term rewriting, applicable also to rewriting logic, can be used for such propagations of substitutions;\r\nthese include, for example, the following works (in chronological order) [17, 30, 1, 35].\r\nEach of the embeddings of definitional formalisms into rewriting logic and K discussed in this section\r\nis faithful, in the sense that any language definition in any of these formalisms, say L, can be regarded as\r\na rewrite logic theory, say RL, in such a way that there is a one-to-one computational equivalence between\r\nreductions using L and rewrites using RL. Note that these are significantly stronger results than encoding,\r\nor implementing, a framework into another framework: RL is L, not an encoding of it, the only difference\r\nbetween the two being insignificant notational/syntactic conventions. This is totally different from encoding\r\nL on a Turing machine or in a λ-calculus, for example, because such encodings would not preserve the\r\nintended computational granularity of L’s reductions (correct encodings would only preserve the “relational\r\nbehavior” of L: whatever is reduced with L can also be reduced, in any number of steps, with its encod\u0002ings). When a definitional framework is faithfully embedded into another one then the former becomes a\r\nmethodological fragment of the latter. Besides showing the generality and versatility of rewriting logic and K,\r\nthere are two additional reasons for showing that other definitional frameworks fall as (mechanically derived)\r\nmethodological fragments of rewriting logic:\r\n• Existing efficient tool support for rewriting logic, such as execution engines, theorem provers, state\u0002space analyses (including an LTL model checker and a breath-first search for safety property violations),\r\netc., can be used for language definitions in definitional styles that lack tool support; and\r\n• Comparisons and limitation analysis of language definitional frameworks become possible and rigorous,\r\nbecause there is a uniform (meta-)framework, called “ecumenical” in [36], in which all of them co-exist\r\nwithout loosing any of their particularities (both on the positive and on the negative sides).\r\n43\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dbe1f507-b752-46b5-bcb4-a6ffeaca2fcc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=16116b783a1e7d41aa1c944d5a456f70d56df87dfc8a9c449d0487a2df87114f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 773
      },
      {
        "segments": [
          {
            "segment_id": "dbe1f507-b752-46b5-bcb4-a6ffeaca2fcc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "4.12 Defining Plotkin’s PCF language\r\n5 Comparing K With Other Formalisms\r\nSince the various language definitional formalisms were all designed to solve more or less the same problem,\r\nit is not surprising that there are deep relationships between almost any two such formalisms. Some of\r\nthese relationships have been spelled out in the literature. In this section we briefly discuss some of the\r\nmore popular language definitional formalisms, and then show how each of them can be captured as a\r\nmethodological fragment of rewriting logic and even of K. Since rewriting logic is a real computational\r\nlogical meta-framework that does not impose on the language designer any particular definitional style, it\r\ncaptures very naturally, with almost zero representational distance, the various other formalisms. Since K\r\nwas not intended to be such a generic meta-framework, but rather a particular definitional style that makes\r\nunrestricted use of the full strength of (unconditional) rewriting logic when defining programing languages\r\nor calculi, it is not surprising that some of the translations into K are less straight-forward. With the\r\nexception of the chemical abstract machine, which, like rewriting logic and K explicitly aims at avoiding\r\nthe obedience of structural operational semantics to syntax and interleaving semantics, the complexity of\r\nthe subsequent translations of formalisms stays in “inhibiting” the otherwise unrestricted computational\r\nmechanism of rewriting logic, so that only one rewrite step is applied at a time, and only in a context that\r\nis allowed by the evaluation strategy of the defined language constructs.\r\nFor simplicity, in each of the formalisms discussed in this section we limit ourselves to ground instances of\r\nrule schematas; in other words, we assume that each rule in each formalism, which may typically be restricted\r\nby side conditions, was replaced by all its concrete instances (typically a recursively enumerable set), one\r\nper variable instances satisfying the side conditions of the rule. One can also translate side conditions in\r\nthe original rules into conditions in the resulting rewriting logic rules and/or equations. In most cases, in\r\nparticular when each rule has precisely one correspondent rule in rewriting logic or K (like in the translation of\r\ncontext reduction into K, for example), the side conditions simply carry over unchanged. In some other cases,\r\nsuch as when a conditional rule in the original formalism translates into more than one rule or equation in the\r\ncorresponding rewrite logic theory and different transitions in the original condition may refer to the same\r\nvariable (like in the translation of general-purpose big-step or small-step SOS into K), one must be careful\r\nto properly propagate the accumulated substitution. Techniques for systematic elimination of conditional\r\nrules in term rewriting, applicable also to rewriting logic, can be used for such propagations of substitutions;\r\nthese include, for example, the following works (in chronological order) [17, 30, 1, 35].\r\nEach of the embeddings of definitional formalisms into rewriting logic and K discussed in this section\r\nis faithful, in the sense that any language definition in any of these formalisms, say L, can be regarded as\r\na rewrite logic theory, say RL, in such a way that there is a one-to-one computational equivalence between\r\nreductions using L and rewrites using RL. Note that these are significantly stronger results than encoding,\r\nor implementing, a framework into another framework: RL is L, not an encoding of it, the only difference\r\nbetween the two being insignificant notational/syntactic conventions. This is totally different from encoding\r\nL on a Turing machine or in a λ-calculus, for example, because such encodings would not preserve the\r\nintended computational granularity of L’s reductions (correct encodings would only preserve the “relational\r\nbehavior” of L: whatever is reduced with L can also be reduced, in any number of steps, with its encod\u0002ings). When a definitional framework is faithfully embedded into another one then the former becomes a\r\nmethodological fragment of the latter. Besides showing the generality and versatility of rewriting logic and K,\r\nthere are two additional reasons for showing that other definitional frameworks fall as (mechanically derived)\r\nmethodological fragments of rewriting logic:\r\n• Existing efficient tool support for rewriting logic, such as execution engines, theorem provers, state\u0002space analyses (including an LTL model checker and a breath-first search for safety property violations),\r\netc., can be used for language definitions in definitional styles that lack tool support; and\r\n• Comparisons and limitation analysis of language definitional frameworks become possible and rigorous,\r\nbecause there is a uniform (meta-)framework, called “ecumenical” in [36], in which all of them co-exist\r\nwithout loosing any of their particularities (both on the positive and on the negative sides).\r\n43\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dbe1f507-b752-46b5-bcb4-a6ffeaca2fcc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=16116b783a1e7d41aa1c944d5a456f70d56df87dfc8a9c449d0487a2df87114f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 773
      },
      {
        "segments": [
          {
            "segment_id": "5fbe56bc-5182-4313-a800-25ccc07e2d0d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "It is important to realize that each of these faithful embeddings has all the good properties of the embedded\r\nframework, but also all its problems and limitations. In other words, one should not expect that the\r\nrewriting logic embedding of a framework magically overcomes its problems. For example, since all the rules\r\nand equations in our embeddings of SOS or context reduction apply only at the top of the term to reduce,\r\njust like in SOS or context reduction, the true concurrency semantics strength of rewriting logic and K is\r\ndrastically inhibited and reduced to interleaving semantics, just like in SOS or context reduction. Also, the\r\nembedding of SOS is just as non-modular as SOS. Considering the strengths and elegance of K in its full\r\ngenerality, we cannot advocate any of its methodological fragments discussed in this section as ideal language\r\ndefinitional formalisms. These may, nevertheless, be useful when existing definitions are already available\r\nand lack tool support; in that case, K, through its generic tool support, provides specialized tool support for\r\nthe embedded formalisms.\r\nWhile it is hard to argue against the usefulness of the first item above (derived tool support), we are\r\naware of the fact that proponents of existing definitional frameworks or styles may disagree with our con\u0002clusions drawn from the second item (objective comparison and limitation analysis). For example, there are\r\nproponents of existing formalisms who would rather attack existing and sometimes desired language features\r\n(such as, e.g., call/cc or true concurrency) declaring them “obscure” or “pathological”, rather then accept\r\nthat their favorite definitional formalism cannot support them. Since in this paper we are on a quest for\r\nan “ideal” language definitional framework, we shall discuss limitations of existing formalisms without any\r\nattachment to any of them, assuming that all existing language features are equally desirable.\r\n5.1 Structural Operational Semantics (SOS)\r\nIntroduced by Plotkin in [31], also called transition semantics or reduction semantics, (small-step) structural\r\noperational semantics (SOS) semantics captures the notion of one computational step. In a structural\r\noperational semantics of a language or calculus, one typically defines configurations and labels, and then\r\ngives rules of the form (where C, C0, C1, C0\r\n1\r\n, C2, C0\r\n2\r\n, . . . , Cn, C0\r\nn configurations, l, l1, l2, . . . , ln labels):\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\nTriples C\r\nl→ C\r\n0 where C, C0 are configurations and l is a label are called “labeled transitions” or “sequents”.\r\nConfigurations can be just terms over the syntax of the language or calculus, but can also be tuples comprising\r\nboth syntactic terms and semantic components, such as stores, environments, etc. The following is, for\r\nexample, one of the rules in the SOS definition of CCS (here p, p0, q, q0 are processes, α and α are two related\r\nlabels, and τ is the label for “silent” transitions; see Section 4.4 for the complete SOS definition of CCS):\r\np\r\nα→ p\r\n0\r\n, q\r\nα→ q\r\n0\r\np | q\r\nτ→ p\r\n0\r\n| q\r\n0\r\nThe labeled transitions above the line are called “conditions” or “premises”; if they are missing, then the\r\nSOS rule is called “unconditional” and is more simply written as C\r\nl→ C\r\n0\r\n. For example, the following is an\r\nunconditional rule in the SOS definition of CCS:\r\nα.p\r\nα→ p\r\nLabels are not always required; if they are not present then the SOS definition and the corresponding\r\ntransitions are called “unlabeled”. For example, the following is an unlabeled conditional SOS rule defining\r\npart of the small-step operational semantics of addition in the context of an imperative language (here\r\na1, a0\r\n1\r\n, a2 are arithmetic expressions and σ, σ0 are states – we assumed side effects):\r\nha1, σi → ha\r\n0\r\n1\r\n, σ0i\r\nha1 + a2, σi → ha\r\n0\r\n1 + a2, σ0i\r\n44\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/5fbe56bc-5182-4313-a800-25ccc07e2d0d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c83acac0e1c70d3306cf3d1ca4771e3086a5e342bd649143fd8fc520ab35e200",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 675
      },
      {
        "segments": [
          {
            "segment_id": "5fbe56bc-5182-4313-a800-25ccc07e2d0d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "It is important to realize that each of these faithful embeddings has all the good properties of the embedded\r\nframework, but also all its problems and limitations. In other words, one should not expect that the\r\nrewriting logic embedding of a framework magically overcomes its problems. For example, since all the rules\r\nand equations in our embeddings of SOS or context reduction apply only at the top of the term to reduce,\r\njust like in SOS or context reduction, the true concurrency semantics strength of rewriting logic and K is\r\ndrastically inhibited and reduced to interleaving semantics, just like in SOS or context reduction. Also, the\r\nembedding of SOS is just as non-modular as SOS. Considering the strengths and elegance of K in its full\r\ngenerality, we cannot advocate any of its methodological fragments discussed in this section as ideal language\r\ndefinitional formalisms. These may, nevertheless, be useful when existing definitions are already available\r\nand lack tool support; in that case, K, through its generic tool support, provides specialized tool support for\r\nthe embedded formalisms.\r\nWhile it is hard to argue against the usefulness of the first item above (derived tool support), we are\r\naware of the fact that proponents of existing definitional frameworks or styles may disagree with our con\u0002clusions drawn from the second item (objective comparison and limitation analysis). For example, there are\r\nproponents of existing formalisms who would rather attack existing and sometimes desired language features\r\n(such as, e.g., call/cc or true concurrency) declaring them “obscure” or “pathological”, rather then accept\r\nthat their favorite definitional formalism cannot support them. Since in this paper we are on a quest for\r\nan “ideal” language definitional framework, we shall discuss limitations of existing formalisms without any\r\nattachment to any of them, assuming that all existing language features are equally desirable.\r\n5.1 Structural Operational Semantics (SOS)\r\nIntroduced by Plotkin in [31], also called transition semantics or reduction semantics, (small-step) structural\r\noperational semantics (SOS) semantics captures the notion of one computational step. In a structural\r\noperational semantics of a language or calculus, one typically defines configurations and labels, and then\r\ngives rules of the form (where C, C0, C1, C0\r\n1\r\n, C2, C0\r\n2\r\n, . . . , Cn, C0\r\nn configurations, l, l1, l2, . . . , ln labels):\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\nTriples C\r\nl→ C\r\n0 where C, C0 are configurations and l is a label are called “labeled transitions” or “sequents”.\r\nConfigurations can be just terms over the syntax of the language or calculus, but can also be tuples comprising\r\nboth syntactic terms and semantic components, such as stores, environments, etc. The following is, for\r\nexample, one of the rules in the SOS definition of CCS (here p, p0, q, q0 are processes, α and α are two related\r\nlabels, and τ is the label for “silent” transitions; see Section 4.4 for the complete SOS definition of CCS):\r\np\r\nα→ p\r\n0\r\n, q\r\nα→ q\r\n0\r\np | q\r\nτ→ p\r\n0\r\n| q\r\n0\r\nThe labeled transitions above the line are called “conditions” or “premises”; if they are missing, then the\r\nSOS rule is called “unconditional” and is more simply written as C\r\nl→ C\r\n0\r\n. For example, the following is an\r\nunconditional rule in the SOS definition of CCS:\r\nα.p\r\nα→ p\r\nLabels are not always required; if they are not present then the SOS definition and the corresponding\r\ntransitions are called “unlabeled”. For example, the following is an unlabeled conditional SOS rule defining\r\npart of the small-step operational semantics of addition in the context of an imperative language (here\r\na1, a0\r\n1\r\n, a2 are arithmetic expressions and σ, σ0 are states – we assumed side effects):\r\nha1, σi → ha\r\n0\r\n1\r\n, σ0i\r\nha1 + a2, σi → ha\r\n0\r\n1 + a2, σ0i\r\n44\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/5fbe56bc-5182-4313-a800-25ccc07e2d0d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c83acac0e1c70d3306cf3d1ca4771e3086a5e342bd649143fd8fc520ab35e200",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 675
      },
      {
        "segments": [
          {
            "segment_id": "f8cf6c31-44bd-4392-956c-83113d0adaaa",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "For simplicity, from here on we assume labeled rules; if one wants unlabeled rules, one can assume an artificial,\r\ntransparent label. SOS rules should be seen as derivation or proof rules; they allow us to derive possible\r\nlabeled transitions. If SOS is an SOS definition, with configurations ConfigSOS and labels LabelSOS , then\r\nSOS ` C\r\nl→ C\r\n0\r\ndenotes the fact that the labeled transition C\r\nl→ C\r\n0\r\ncan be derived with the rules in SOS. Intuitively, that\r\nmeans that the defined language or calculus can transit from configuration C to configuration C\r\n0\r\nin one\r\nstep, where l labels this transition and can be either some meaningful name or some output that is emitted\r\nto the environment. Since a derivation in SOS can only capture one step of computation and since typical\r\ncomputations may consist of many such steps, it is common to extend SOS definitions with multiple-step\r\ntransitions by extending labels to “label paths”, which are sequences of labels (suppose that label paths are\r\nconstructed using semicolon, e.g., l1; l2; . . . ; lk, where l1, l2, . . . , lk are labels), and adding rules of the form:\r\nC\r\nπ→ C\r\n0\r\n, C0 π\r\n0\r\n→ C\r\n00\r\nC\r\nπ;π0\r\n→ C00\r\nStrengths. Small-step operational semantics precisely defines the notion of one computational step. It\r\nis easily executable so one can quickly get an (inefficient) interpreter for the defined language or analysis,\r\nthough one may need to pay a cost linear in the size of the current program at each step to “traverse” the\r\nprogram via conditional SOS rules in order to find a redex, that is, a place where the next step can take\r\nplace. It is easy to trace and debug. In particular, non-termination of programs results in non-termination of\r\nsearching for a derivation, while erroneous programs (e.g., ones performing division by zero) can be reduced\r\nstep-by-step until the actual error takes place and then one can be given a meaningful error message. It\r\nsupports definitions of non-deterministic or parallel languages, obeying the interleaving semantics approach\r\nto concurrency.\r\nWeaknesses. It is somehow too low level and explicit, which results into relatively large and boring\r\nlanguage definitions; in particular, one needs to explicitly give all the congruence rules for ordinary operators\r\nsuch as addition, multiplication, etc. For that reason, each small step comes at a cost which is worst-case\r\nlinear to the size of the syntactic term to reduce, which, unfortunately, can grow unbounded. It does not\r\ngive a “true concurrency” semantics, that is, one has to chose a certain interleaving (no two rules can be\r\napplied on the same term at the same time), mainly because reduction is forced to occur only at the top.\r\nOne of the main motivations for SOS was that abstract machines are not purely syntactic, that is, they\r\nhave to introduce new syntactic constructs to decompose the abstract syntax tree; on the other hand, SOS\r\nwould and should only work by modifying the structure of the program. We argue that this is not entirely\r\naccurate: one often needs to include additional “syntax” in an SOS language definition, too, in order to give\r\nthe semantics of certain language constructs; sometimes, this additional “syntax” is very semantic in nature.\r\nFor example, one needs to include syntax for values, even though such values were not intended as part of the\r\noriginal language syntax; examples are objects (as nested sets of field values) in object-oriented languages, or\r\nclosures (as environment enclosing structures) in functional languages. Also, one needs to introduce “stuck”\r\nsyntactic constructs when defining abrupt termination of exceptions, and even a conditional “if” construct\r\n(in case the defined language did not provide one) in order to give an SOS semantics for “while”. It is hard\r\nand inconvenient to deal with control in SOS —for example, consider adding halt to a simple imperative\r\nlanguage. One cannot simply give halt an SOS semantics modularly (i.e., in isolation) like to other ordinary\r\nstatements: instead, one has to add a corner case (additional rule) to many other unrelated statements, e.g.:\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhhalt a, σi → hhalt a\r\n0\r\n, σ0i\r\nhhalt i; s, σi → hhalt i, σi\r\nhhalt i; a, σi → hskip;i, σi\r\n45\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f8cf6c31-44bd-4392-956c-83113d0adaaa.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9f55eea71e4bc77ff4d27a72cdf533bc14cb7c2fcc002b4cac99766e9fdb8ba8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 725
      },
      {
        "segments": [
          {
            "segment_id": "f8cf6c31-44bd-4392-956c-83113d0adaaa",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "For simplicity, from here on we assume labeled rules; if one wants unlabeled rules, one can assume an artificial,\r\ntransparent label. SOS rules should be seen as derivation or proof rules; they allow us to derive possible\r\nlabeled transitions. If SOS is an SOS definition, with configurations ConfigSOS and labels LabelSOS , then\r\nSOS ` C\r\nl→ C\r\n0\r\ndenotes the fact that the labeled transition C\r\nl→ C\r\n0\r\ncan be derived with the rules in SOS. Intuitively, that\r\nmeans that the defined language or calculus can transit from configuration C to configuration C\r\n0\r\nin one\r\nstep, where l labels this transition and can be either some meaningful name or some output that is emitted\r\nto the environment. Since a derivation in SOS can only capture one step of computation and since typical\r\ncomputations may consist of many such steps, it is common to extend SOS definitions with multiple-step\r\ntransitions by extending labels to “label paths”, which are sequences of labels (suppose that label paths are\r\nconstructed using semicolon, e.g., l1; l2; . . . ; lk, where l1, l2, . . . , lk are labels), and adding rules of the form:\r\nC\r\nπ→ C\r\n0\r\n, C0 π\r\n0\r\n→ C\r\n00\r\nC\r\nπ;π0\r\n→ C00\r\nStrengths. Small-step operational semantics precisely defines the notion of one computational step. It\r\nis easily executable so one can quickly get an (inefficient) interpreter for the defined language or analysis,\r\nthough one may need to pay a cost linear in the size of the current program at each step to “traverse” the\r\nprogram via conditional SOS rules in order to find a redex, that is, a place where the next step can take\r\nplace. It is easy to trace and debug. In particular, non-termination of programs results in non-termination of\r\nsearching for a derivation, while erroneous programs (e.g., ones performing division by zero) can be reduced\r\nstep-by-step until the actual error takes place and then one can be given a meaningful error message. It\r\nsupports definitions of non-deterministic or parallel languages, obeying the interleaving semantics approach\r\nto concurrency.\r\nWeaknesses. It is somehow too low level and explicit, which results into relatively large and boring\r\nlanguage definitions; in particular, one needs to explicitly give all the congruence rules for ordinary operators\r\nsuch as addition, multiplication, etc. For that reason, each small step comes at a cost which is worst-case\r\nlinear to the size of the syntactic term to reduce, which, unfortunately, can grow unbounded. It does not\r\ngive a “true concurrency” semantics, that is, one has to chose a certain interleaving (no two rules can be\r\napplied on the same term at the same time), mainly because reduction is forced to occur only at the top.\r\nOne of the main motivations for SOS was that abstract machines are not purely syntactic, that is, they\r\nhave to introduce new syntactic constructs to decompose the abstract syntax tree; on the other hand, SOS\r\nwould and should only work by modifying the structure of the program. We argue that this is not entirely\r\naccurate: one often needs to include additional “syntax” in an SOS language definition, too, in order to give\r\nthe semantics of certain language constructs; sometimes, this additional “syntax” is very semantic in nature.\r\nFor example, one needs to include syntax for values, even though such values were not intended as part of the\r\noriginal language syntax; examples are objects (as nested sets of field values) in object-oriented languages, or\r\nclosures (as environment enclosing structures) in functional languages. Also, one needs to introduce “stuck”\r\nsyntactic constructs when defining abrupt termination of exceptions, and even a conditional “if” construct\r\n(in case the defined language did not provide one) in order to give an SOS semantics for “while”. It is hard\r\nand inconvenient to deal with control in SOS —for example, consider adding halt to a simple imperative\r\nlanguage. One cannot simply give halt an SOS semantics modularly (i.e., in isolation) like to other ordinary\r\nstatements: instead, one has to add a corner case (additional rule) to many other unrelated statements, e.g.:\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhhalt a, σi → hhalt a\r\n0\r\n, σ0i\r\nhhalt i; s, σi → hhalt i, σi\r\nhhalt i; a, σi → hskip;i, σi\r\n45\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f8cf6c31-44bd-4392-956c-83113d0adaaa.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9f55eea71e4bc77ff4d27a72cdf533bc14cb7c2fcc002b4cac99766e9fdb8ba8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 725
      },
      {
        "segments": [
          {
            "segment_id": "fa9891f4-9c18-4dcc-996d-52fa3e64fcf6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "If expressions could also halt the program, e.g., if one adds functions, then one or more new rules would\r\nhave to be added to specify the corner case for each arithmetic or boolean construct. Moreover, by having\r\nto explicitly propagate the “halt signal” through all the statements and expressions, one fails to capture the\r\nintended computation granularity of halt: it should just abruptly terminate the execution (compare that\r\nto “propagate the abrupt termination request bottom-up all the way to the top of the program and then\r\nterminate the execution”, which is what happens in terms of deduction in SOS).\r\n5.1.1 SOS as a Methodological Fragment of Rewriting Logic\r\nAs shown in [21, 36], SOS is a methodological fragment of rewriting logic. Indeed, without loosing anything\r\nin the translation, any SOS definition is a rewrite logic theory containing one (conditional) rewrite rule per\r\nSOS (conditional) rule. We next show a slightly different (from those in [21, 36]) but equivalent way to\r\ncapture SOS within rewriting logic. To each SOS rule of the form\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\none can associate a rewrite rule of the form:\r\n{C} → {l, C0} if {C1} → {l1, C0\r\n1\r\n} ∧ {C2} → {l2, C0\r\n2\r\n} ∧ · · · ∧ {Cn} → {ln, C0\r\nn\r\n},\r\nwhere { } : ConfigSOS → ConfigRLS { , } : LabelSOS × ConfigSOS → ConfigRLS are auxiliary operators\r\nconstructing rewriting logic semantics variants of configurations — assume ConfigRLS to be a new sort\r\ncorresponding to such rewriting logic semantics configurations. These configuration “wrappers” are needed\r\nexclusively for embedding reasons. Then the resulting rewriting logic theory, say RLSSOS , has the property:\r\nTheorem 5. (Faithful embedding of SOS into rewrite logic) For any SOS definition SOS, any con\u0002figurations C and C\r\n0\r\n, and any label l, the following holds:\r\nSOS ` C\r\nl→ C\r\n0 ⇐⇒ RLSSOS ` {C} → {l, C0\r\n}.\r\nThe embedding of SOS into rewriting logic presented in [36] is in some sense (the result in [36] considers\r\nunlabeled SOS) even more general than the above, because it allows one to mention, as part of the rewriting\r\nlogic configuration construct (called a “configuration modifier” there), how many small-steps are allowed to\r\nbe rewritten.\r\nOne inherent technicality involved in capturing small-step operational semantics as rewrite theories in\r\na one-to-one notational and computational correspondence is that the rewriting relation is by definition\r\ntransitive, while the small-step relation is not transitive (its transitive closure can be defined a posteriori).\r\nTherefore, one needs to devise mechanisms to “inhibit” rewriting logic’s transitive and uncontrolled applica\u0002tion of rules. Our use of curly brackets as wrappers of SOS configurations into rewriting logic configurations\r\nwas precisely such a inhibitory mechanism. In the case of unlabeled SOS definitions, one must not get tricked\r\nto simply remove the labels in the corresponding rewriting logic definition, thus obtaining rules of the form\r\n{C} → {C\r\n0\r\n} if {C1} → {C\r\n0\r\n1\r\n} ∧ {C2} → {C\r\n0\r\n2\r\n} ∧ · · · ∧ {Cn} → {C\r\n0\r\nn\r\n},\r\nbecause then one fails to faithfully capture the original SOS semantics. Indeed, in rewriting logic there\r\nis nothing to prevent transitive applications of rules when deriving each of the transitions in conditions,\r\nwhich is in sharp contrast with SOS. One simple solution to circumvent that “problem[?, ?]” in the context\r\nof unlabeled SOS definitions is to consider a fake label and then use exactly the transformation above.\r\nDifferent but equivalent ways to embed unlabeled SOS into rewriting logic have been proposed in [21, 36].\r\nThe former uses two different types of configuration wrappers, one for the left-hand-side of the transitions\r\n(“{C}\r\n00) and one for the right-hand-side (“[C]”), yielding rules have the form:\r\n{C} → [C\r\n0\r\n] if {C1} → [C\r\n0\r\n1\r\n] ∧ {C2} → [C\r\n0\r\n2\r\n] ∧ · · · ∧ {Cn} → [C\r\n0\r\nn].\r\n46\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fa9891f4-9c18-4dcc-996d-52fa3e64fcf6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fd343ddc5057cc6ee0668476b0bb57704f5ca47149588278b799450e44a7146f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 691
      },
      {
        "segments": [
          {
            "segment_id": "fa9891f4-9c18-4dcc-996d-52fa3e64fcf6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "If expressions could also halt the program, e.g., if one adds functions, then one or more new rules would\r\nhave to be added to specify the corner case for each arithmetic or boolean construct. Moreover, by having\r\nto explicitly propagate the “halt signal” through all the statements and expressions, one fails to capture the\r\nintended computation granularity of halt: it should just abruptly terminate the execution (compare that\r\nto “propagate the abrupt termination request bottom-up all the way to the top of the program and then\r\nterminate the execution”, which is what happens in terms of deduction in SOS).\r\n5.1.1 SOS as a Methodological Fragment of Rewriting Logic\r\nAs shown in [21, 36], SOS is a methodological fragment of rewriting logic. Indeed, without loosing anything\r\nin the translation, any SOS definition is a rewrite logic theory containing one (conditional) rewrite rule per\r\nSOS (conditional) rule. We next show a slightly different (from those in [21, 36]) but equivalent way to\r\ncapture SOS within rewriting logic. To each SOS rule of the form\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\none can associate a rewrite rule of the form:\r\n{C} → {l, C0} if {C1} → {l1, C0\r\n1\r\n} ∧ {C2} → {l2, C0\r\n2\r\n} ∧ · · · ∧ {Cn} → {ln, C0\r\nn\r\n},\r\nwhere { } : ConfigSOS → ConfigRLS { , } : LabelSOS × ConfigSOS → ConfigRLS are auxiliary operators\r\nconstructing rewriting logic semantics variants of configurations — assume ConfigRLS to be a new sort\r\ncorresponding to such rewriting logic semantics configurations. These configuration “wrappers” are needed\r\nexclusively for embedding reasons. Then the resulting rewriting logic theory, say RLSSOS , has the property:\r\nTheorem 5. (Faithful embedding of SOS into rewrite logic) For any SOS definition SOS, any con\u0002figurations C and C\r\n0\r\n, and any label l, the following holds:\r\nSOS ` C\r\nl→ C\r\n0 ⇐⇒ RLSSOS ` {C} → {l, C0\r\n}.\r\nThe embedding of SOS into rewriting logic presented in [36] is in some sense (the result in [36] considers\r\nunlabeled SOS) even more general than the above, because it allows one to mention, as part of the rewriting\r\nlogic configuration construct (called a “configuration modifier” there), how many small-steps are allowed to\r\nbe rewritten.\r\nOne inherent technicality involved in capturing small-step operational semantics as rewrite theories in\r\na one-to-one notational and computational correspondence is that the rewriting relation is by definition\r\ntransitive, while the small-step relation is not transitive (its transitive closure can be defined a posteriori).\r\nTherefore, one needs to devise mechanisms to “inhibit” rewriting logic’s transitive and uncontrolled applica\u0002tion of rules. Our use of curly brackets as wrappers of SOS configurations into rewriting logic configurations\r\nwas precisely such a inhibitory mechanism. In the case of unlabeled SOS definitions, one must not get tricked\r\nto simply remove the labels in the corresponding rewriting logic definition, thus obtaining rules of the form\r\n{C} → {C\r\n0\r\n} if {C1} → {C\r\n0\r\n1\r\n} ∧ {C2} → {C\r\n0\r\n2\r\n} ∧ · · · ∧ {Cn} → {C\r\n0\r\nn\r\n},\r\nbecause then one fails to faithfully capture the original SOS semantics. Indeed, in rewriting logic there\r\nis nothing to prevent transitive applications of rules when deriving each of the transitions in conditions,\r\nwhich is in sharp contrast with SOS. One simple solution to circumvent that “problem[?, ?]” in the context\r\nof unlabeled SOS definitions is to consider a fake label and then use exactly the transformation above.\r\nDifferent but equivalent ways to embed unlabeled SOS into rewriting logic have been proposed in [21, 36].\r\nThe former uses two different types of configuration wrappers, one for the left-hand-side of the transitions\r\n(“{C}\r\n00) and one for the right-hand-side (“[C]”), yielding rules have the form:\r\n{C} → [C\r\n0\r\n] if {C1} → [C\r\n0\r\n1\r\n] ∧ {C2} → [C\r\n0\r\n2\r\n] ∧ · · · ∧ {Cn} → [C\r\n0\r\nn].\r\n46\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fa9891f4-9c18-4dcc-996d-52fa3e64fcf6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fd343ddc5057cc6ee0668476b0bb57704f5ca47149588278b799450e44a7146f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 691
      },
      {
        "segments": [
          {
            "segment_id": "b56d4832-d8d6-4a21-911f-f1a9876bf5bb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "The latter proposes a “configuration modifier” operator, say “•”, which enables a configuration to be reduced\r\none-step, yielding rules of the form:\r\n•C → C\r\n0\r\nif • C1 → C\r\n0\r\n1 ∧ •C2 → C\r\n0\r\n2 ∧ · · · ∧ •Cn → C\r\n0\r\nn\r\n.\r\nThe corresponding embedding theorems are straightforward to formulate and can be found in [21, 36].\r\nNote that all the various faithful embeddings of SOS into rewriting logic above impose the same important\r\nrestrictions on the resulting rewriting logic theory, namely (1) all matchings, and in particular all rewrite\r\nsteps, happen at the top of the term to rewrite, and because of that, (2) only one rewrite rule can apply\r\nat a time. Analyzing these necessary restrictions (otherwise the embeddings of SOS would not be faithful)\r\nthrough the prism of rewriting logic, one can easily see how they are the source of two of the main limitations\r\nof SOS: lack of modularity and interleaving-only semantics for concurrency. The former follows from the fact\r\nthat, since rules only apply at the top of a term, each rule needs to mention the complete configuration, so\r\nthat other rules that may need semantic components from the configuration can find it locally. The latter\r\nfollows from the fact that there is no way to apply two rules at the same time, because any potentially\r\nconcurrent matchings of rules overlap, so only one can be applied at a time. Third major limitation of SOS,\r\nnamely its incapacity of defining complex control-intensive language features such as call-cc, is less obvious\r\nfrom its embeddings in rewriting logic. On the positive side, one can say that SOS, despite its restrictions,\r\nhas been successfully used to define a variety of language features and calculi, so in some sense it can be\r\nseen as a methodological subset of rewriting logic that proved to be quite usable in practice and sufficient in\r\nmany cases. While one cannot refute these obvious arguments, since we are are a quest for an ideal language\r\ndefinitional framework, the limitations of SOS in the context of modern, real-life complex languages, make\r\nit a less stimulating candidate.\r\n5.1.2 SOS as a Methodological Fragment of K\r\nSince in an SOS definition we have two high-level semantics categories, namely SOS configurations and\r\nSOS labels, we define two configuration items in our formalization of SOS into K, namely LKMk wrapping\r\nSOS configurations and LList·\r\n;\r\n[LabelSOS]Mpath wrapping semicolon-separated sequences, or paths, of labels;\r\nthese are used in all K definitions derived from SOS definitions. In addition to the SOS configurations, the\r\ncomputations K also contain some special “frozen” computations of the form “◦\r\nl→ C\r\n0”, where l is a label\r\nand C\r\n0\r\nsome SOS configuration (which can be read “whatever configuration was there goes via label l to\r\nC\r\n0”), and some special constants, each corresponding uniquely to precisely one rule in the SOS definition\r\n(which can be read “that rule is being processed”):\r\nConfig ::= LKMk | LList·\r\n;\r\n[LabelSOS]Mpath\r\nK ::= ConfigSOS | ◦ LabelSOS −→ ConfigSOS | KConstant\r\nKConstant ::= rule1 | rule2 | . . . (one K constant per SOS rule)\r\nThe role of the frozen computations ◦\r\nl→ C\r\n0\r\nis twofold. On the one hand, the computation C\r\n0\r\nis indeed\r\n“frozen”, until the frozen term gets on the top of the computation and is “scheduled” for processing using the\r\nequation below; on the other hand, when that happen, the label l is also “frozen”, so when C\r\n0\r\nis scheduled\r\nfor processing the label l can be collected in the path. The equation below takes care of both “unfreezing”\r\nC\r\n0 and collecting l in the path, and is generic (for any embedding of SOS definitions into K):\r\nL◦\r\nl→ C\r\n0\r\nC\r\n0\r\nMk h|·\r\nl\r\nMpath\r\nFinally, each SOS rule\r\nrulei:\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\n47\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b56d4832-d8d6-4a21-911f-f1a9876bf5bb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ef0562f116d252096a973d22a763a18a3af2d97e4c9d5b0a46cddc3a8073f252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 685
      },
      {
        "segments": [
          {
            "segment_id": "b56d4832-d8d6-4a21-911f-f1a9876bf5bb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "The latter proposes a “configuration modifier” operator, say “•”, which enables a configuration to be reduced\r\none-step, yielding rules of the form:\r\n•C → C\r\n0\r\nif • C1 → C\r\n0\r\n1 ∧ •C2 → C\r\n0\r\n2 ∧ · · · ∧ •Cn → C\r\n0\r\nn\r\n.\r\nThe corresponding embedding theorems are straightforward to formulate and can be found in [21, 36].\r\nNote that all the various faithful embeddings of SOS into rewriting logic above impose the same important\r\nrestrictions on the resulting rewriting logic theory, namely (1) all matchings, and in particular all rewrite\r\nsteps, happen at the top of the term to rewrite, and because of that, (2) only one rewrite rule can apply\r\nat a time. Analyzing these necessary restrictions (otherwise the embeddings of SOS would not be faithful)\r\nthrough the prism of rewriting logic, one can easily see how they are the source of two of the main limitations\r\nof SOS: lack of modularity and interleaving-only semantics for concurrency. The former follows from the fact\r\nthat, since rules only apply at the top of a term, each rule needs to mention the complete configuration, so\r\nthat other rules that may need semantic components from the configuration can find it locally. The latter\r\nfollows from the fact that there is no way to apply two rules at the same time, because any potentially\r\nconcurrent matchings of rules overlap, so only one can be applied at a time. Third major limitation of SOS,\r\nnamely its incapacity of defining complex control-intensive language features such as call-cc, is less obvious\r\nfrom its embeddings in rewriting logic. On the positive side, one can say that SOS, despite its restrictions,\r\nhas been successfully used to define a variety of language features and calculi, so in some sense it can be\r\nseen as a methodological subset of rewriting logic that proved to be quite usable in practice and sufficient in\r\nmany cases. While one cannot refute these obvious arguments, since we are are a quest for an ideal language\r\ndefinitional framework, the limitations of SOS in the context of modern, real-life complex languages, make\r\nit a less stimulating candidate.\r\n5.1.2 SOS as a Methodological Fragment of K\r\nSince in an SOS definition we have two high-level semantics categories, namely SOS configurations and\r\nSOS labels, we define two configuration items in our formalization of SOS into K, namely LKMk wrapping\r\nSOS configurations and LList·\r\n;\r\n[LabelSOS]Mpath wrapping semicolon-separated sequences, or paths, of labels;\r\nthese are used in all K definitions derived from SOS definitions. In addition to the SOS configurations, the\r\ncomputations K also contain some special “frozen” computations of the form “◦\r\nl→ C\r\n0”, where l is a label\r\nand C\r\n0\r\nsome SOS configuration (which can be read “whatever configuration was there goes via label l to\r\nC\r\n0”), and some special constants, each corresponding uniquely to precisely one rule in the SOS definition\r\n(which can be read “that rule is being processed”):\r\nConfig ::= LKMk | LList·\r\n;\r\n[LabelSOS]Mpath\r\nK ::= ConfigSOS | ◦ LabelSOS −→ ConfigSOS | KConstant\r\nKConstant ::= rule1 | rule2 | . . . (one K constant per SOS rule)\r\nThe role of the frozen computations ◦\r\nl→ C\r\n0\r\nis twofold. On the one hand, the computation C\r\n0\r\nis indeed\r\n“frozen”, until the frozen term gets on the top of the computation and is “scheduled” for processing using the\r\nequation below; on the other hand, when that happen, the label l is also “frozen”, so when C\r\n0\r\nis scheduled\r\nfor processing the label l can be collected in the path. The equation below takes care of both “unfreezing”\r\nC\r\n0 and collecting l in the path, and is generic (for any embedding of SOS definitions into K):\r\nL◦\r\nl→ C\r\n0\r\nC\r\n0\r\nMk h|·\r\nl\r\nMpath\r\nFinally, each SOS rule\r\nrulei:\r\nC1 →\r\nl1 C\r\n0\r\n1\r\n, C2 →\r\nl2 C\r\n0\r\n2\r\n, . . . , Cn →\r\nln C\r\n0\r\nn\r\nC\r\nl→ C0\r\n47\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b56d4832-d8d6-4a21-911f-f1a9876bf5bb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ef0562f116d252096a973d22a763a18a3af2d97e4c9d5b0a46cddc3a8073f252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 685
      },
      {
        "segments": [
          {
            "segment_id": "74489aa6-7228-4ca3-b5d9-a9aa78384794",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "can be converted into one K rule and one K equation as follows:\r\nL C\r\nstrict(C1, C2, . . . , Cn) y rulei y (◦\r\nl→ C\r\n0\r\n)\r\n|ik\r\nLstrict(◦ →\r\nl1 C\r\n0\r\n1\r\n, ◦ →\r\nl2 C\r\n0\r\n2\r\n, . . . , ◦ →\r\nln C\r\n0\r\nn) y rulei\r\n·\r\ny (◦\r\nl→ C\r\n0\r\n)|ik\r\nThe rule above says that in order to process C when this is at the top of the computation (note that there\r\ncould be other tasks following C in LCMk), one should “first” process C1, C2, ..., Cn (in any order and\r\npossibly non-deterministically) and “then” go with l to C\r\n0\r\n. The equation above dissolves the processed C1,\r\nC2, ..., Cn when these reach the expected configurations C\r\n0\r\n1\r\n, C\r\n0\r\n2\r\n, ..., C\r\n0\r\nn with the expected labels l1, l2, ...,\r\nln, respectively, as stated by the original SOS rule. The constant “rulei” is necessary to connect the rule\r\nand the equation above; otherwise, it could be that two SOS rules have the same C and the same number\r\nof conditions, the first rule is “scheduled” and each of its condition left-hand configuration reduces to the\r\nother rule’s corresponding condition right-hand configuration with the same label; if that is the case, then\r\nthe equation above would incorrectly “apply” the SOS rule. In other words, the K definition associated to\r\nan SOS definition intuitively simulates a back-and-forth stack mechanism (recall that strict iteratively allows\r\nany of the wrapped computations to be scheduled for processing for any arbitrary number of steps) that\r\neventually performs the same computational work and task as the original SOS definition. Formally, one\r\ncan prove the following result:\r\nTheorem 6. (Faithful embedding of SOS into K) For any C, C0 ∈ ConfigSOS and l ∈ LabelSOS,\r\nSOS ` C\r\nl→ C\r\n0 ⇐⇒ KSOS ` LCMk L·Mpath → LC0\r\nMk LlMpath\r\nMoreover, for any C, C0 ∈ ConfigSOS and l1, l2, . . . , lk ∈ LabelSOS,\r\nSOS ` C\r\nl1;l2;...;lk −→ C\r\n0 ⇐⇒ KSOS ` LCMk L·Mpath → LC0\r\nMk Ll1; l2; . . . ; lkMpath.\r\nTherefore, SOS can be regarded as a methodological fragment of K, in the sense that for any SOS\r\ndefinition of a language or calculus, one can mechanically derive a corresponding K definition that faithfully\r\ncaptures both the one-step relation and the transition systems associated to the original SOS definition. In\r\nparticular, one can use this embedding to derive tool support for SOS from tool support for K. For example,\r\nwith our K implementation in Maude (Section E), one can use the search or the model-checking capabilities\r\nof Maude to formally analyze SOS definitions; in particular, given a configuration C, one can inquire for one,\r\ntwo, ..., or even all the paths via which a configuration (or a pattern of configurations) C\r\n0\r\ncan be reached, as\r\nwell as for one, two, ..., or all the configurations that can be reached with a given path (or pattern of paths).\r\nHowever, as mentioned at the beginning of this section for all the embeddings, this faithful embedding also\r\ncomes with all the limitations of SOS: no true concurrency semantics (just interleaving), non-modularity,\r\nand incapacity of defining complex features (such as call/cc). Therefore, SOS is far from being an ideal\r\ndefinitional framework, with or without an embedding in K. Theorem 6 shows formally that K is no worse\r\nthan SOS. The rest of this paper shows that K actually smoothly overcomes the limitations of SOS.\r\n5.2 Big-Step Operational Semantics\r\nIntroduced as natural semantics in [16], also named relational semantics in [27], or evaluation semantics, big\u0002step semantics is in some sense “the most denotational” of the operational semantics. One can view big-step\r\ndefinitions as definitions of functions or relations, interpreting each language construct in an appropriate\r\ndomain. A big-step rule has the form\r\nC1 ⇓ R1, C2 ⇓ R2, . . . , Cn ⇓ Rn\r\nC ⇓ R\r\n48\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/74489aa6-7228-4ca3-b5d9-a9aa78384794.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1fc5778f506d1e35fa7733bf90d9459bc79f27a8f76bcae8458b69bd76a6ab2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 683
      },
      {
        "segments": [
          {
            "segment_id": "74489aa6-7228-4ca3-b5d9-a9aa78384794",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "can be converted into one K rule and one K equation as follows:\r\nL C\r\nstrict(C1, C2, . . . , Cn) y rulei y (◦\r\nl→ C\r\n0\r\n)\r\n|ik\r\nLstrict(◦ →\r\nl1 C\r\n0\r\n1\r\n, ◦ →\r\nl2 C\r\n0\r\n2\r\n, . . . , ◦ →\r\nln C\r\n0\r\nn) y rulei\r\n·\r\ny (◦\r\nl→ C\r\n0\r\n)|ik\r\nThe rule above says that in order to process C when this is at the top of the computation (note that there\r\ncould be other tasks following C in LCMk), one should “first” process C1, C2, ..., Cn (in any order and\r\npossibly non-deterministically) and “then” go with l to C\r\n0\r\n. The equation above dissolves the processed C1,\r\nC2, ..., Cn when these reach the expected configurations C\r\n0\r\n1\r\n, C\r\n0\r\n2\r\n, ..., C\r\n0\r\nn with the expected labels l1, l2, ...,\r\nln, respectively, as stated by the original SOS rule. The constant “rulei” is necessary to connect the rule\r\nand the equation above; otherwise, it could be that two SOS rules have the same C and the same number\r\nof conditions, the first rule is “scheduled” and each of its condition left-hand configuration reduces to the\r\nother rule’s corresponding condition right-hand configuration with the same label; if that is the case, then\r\nthe equation above would incorrectly “apply” the SOS rule. In other words, the K definition associated to\r\nan SOS definition intuitively simulates a back-and-forth stack mechanism (recall that strict iteratively allows\r\nany of the wrapped computations to be scheduled for processing for any arbitrary number of steps) that\r\neventually performs the same computational work and task as the original SOS definition. Formally, one\r\ncan prove the following result:\r\nTheorem 6. (Faithful embedding of SOS into K) For any C, C0 ∈ ConfigSOS and l ∈ LabelSOS,\r\nSOS ` C\r\nl→ C\r\n0 ⇐⇒ KSOS ` LCMk L·Mpath → LC0\r\nMk LlMpath\r\nMoreover, for any C, C0 ∈ ConfigSOS and l1, l2, . . . , lk ∈ LabelSOS,\r\nSOS ` C\r\nl1;l2;...;lk −→ C\r\n0 ⇐⇒ KSOS ` LCMk L·Mpath → LC0\r\nMk Ll1; l2; . . . ; lkMpath.\r\nTherefore, SOS can be regarded as a methodological fragment of K, in the sense that for any SOS\r\ndefinition of a language or calculus, one can mechanically derive a corresponding K definition that faithfully\r\ncaptures both the one-step relation and the transition systems associated to the original SOS definition. In\r\nparticular, one can use this embedding to derive tool support for SOS from tool support for K. For example,\r\nwith our K implementation in Maude (Section E), one can use the search or the model-checking capabilities\r\nof Maude to formally analyze SOS definitions; in particular, given a configuration C, one can inquire for one,\r\ntwo, ..., or even all the paths via which a configuration (or a pattern of configurations) C\r\n0\r\ncan be reached, as\r\nwell as for one, two, ..., or all the configurations that can be reached with a given path (or pattern of paths).\r\nHowever, as mentioned at the beginning of this section for all the embeddings, this faithful embedding also\r\ncomes with all the limitations of SOS: no true concurrency semantics (just interleaving), non-modularity,\r\nand incapacity of defining complex features (such as call/cc). Therefore, SOS is far from being an ideal\r\ndefinitional framework, with or without an embedding in K. Theorem 6 shows formally that K is no worse\r\nthan SOS. The rest of this paper shows that K actually smoothly overcomes the limitations of SOS.\r\n5.2 Big-Step Operational Semantics\r\nIntroduced as natural semantics in [16], also named relational semantics in [27], or evaluation semantics, big\u0002step semantics is in some sense “the most denotational” of the operational semantics. One can view big-step\r\ndefinitions as definitions of functions or relations, interpreting each language construct in an appropriate\r\ndomain. A big-step rule has the form\r\nC1 ⇓ R1, C2 ⇓ R2, . . . , Cn ⇓ Rn\r\nC ⇓ R\r\n48\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/74489aa6-7228-4ca3-b5d9-a9aa78384794.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1fc5778f506d1e35fa7733bf90d9459bc79f27a8f76bcae8458b69bd76a6ab2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 683
      },
      {
        "segments": [
          {
            "segment_id": "984b7ae2-cd6f-4186-866a-8e9259e2fce5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "where like in SOS C, C1, C2, ..., Cn are configurations holding fragments of program together with all the\r\nneeded semantic components, and R, R1, R2, ..., Rn are result configurations, i.e., configurations which\r\ncannot be advanced anymore. For example, here is the big-step rule defining addition in a language whose\r\nexpression evaluation has no side-effects (a1, a2 are arithmetic expressions, σ is a state, and i1, i2 are integers):\r\nha1, σi ⇓ i1, ha2, σi ⇓ i2\r\nha1 + a2, σi ⇓ i\r\nwhere i is the sum of i1 and i2\r\nTypically the result configurations are just a value like above or an abstract value (e.g., a type), but when the\r\nlanguage under consideration has side effects, result configurations may need also to contain some semantic\r\ncomponents. We assume that the down-arrow symbol ⇓ is not decorated with any labels; this can be easily\r\nachieved by moving such labels as components into the result configurations. Interestingly, any big-step\r\noperational semantic definition is a special case of a (small-step) SOS definition like in Section 5.1: all what\r\nneeds to do is to replace “→” by ⇓”. The crucial technical difference between the two approaches is that in\r\nbig-step semantics the result configurations are not reducible anymore: one derives directly the final result of\r\nprocessing a configuration (if any). Therefore, all the embeddings of SOS into rewrite logic and K in Section\r\n5.1 are also applicable for big-step operational semantics and their faithfulness theorems still hold. However,\r\nthanks to the particular nature of big-step semantics, we next give simpler embeddings.\r\nStrengths. When it can be given to a language, big-step operational semantics is easy to understand,\r\nsince it relates syntactic entities directly to their expected results. Big-step operational semantics, due to\r\nits straightforward recursive nature, can be easily and efficiently interpreted in any recursive, functional or\r\nlogical framework. Many proponents of big-step operational semantics regard it “almost as an interpreter”\r\nfor the defined language. It is more abstract than many other definitional styles, so one can in principle\r\nmore easily define and prove properties about programs (in languages that can be given a reasonable big\u0002step semantics). It is particularly useful for defining type systems and side-effect free languages or language\r\nfeatures.\r\nWeaknesses. Due to its monolithic, single-step evaluation, it is hard to debug or trace big-step semantic\r\ndefinitions. If the program is wrong, no information is given about where the failure occurred.\r\nDivergence or non-termination is not observable in the specified evaluation relation. In particular, one\r\ncannot define at all non-terminating processes or systems, such as reactive system. Consider, for example,\r\nthe task of giving CCS (see Figure 5 for a small-step SOS definition) a big-step operational semantics; even\r\nif one (unreasonably) assumes that a CCS process terminates, then its big step semantics should “evaluate”\r\nit to all its possible behaviors; even making abstraction (again) of the various semantic choices, such as trace\u0002based versus tree-based semantics, the major problem is that a potential big-step semantics of concurrent\r\nprocesses p|q is not compositional, that is, it is not possible to simply combine the semantics of p and q\r\nin order to obtain the semantics of p|q. A technique for capturing an interleaving semantics for concurrent\r\nsystems using big-step operational semantics is sketched by Mosses in [29] (using the modular features of\r\nhis MSOS), but he did not provide details because he does not encourage the use of the big-step semantics\r\nstyle for concurrency6. It is, in fact, well known and broadly accepted that big-step operational semantics is\r\nsimply unsuitable for concurrency.\r\nBig-step semantics is not modular. For example, to add side effects to expressions, one must redefine the\r\nrules to allow expressions to evaluate to pairs (value-state) and to appropriately propagate side effects; e.g.:\r\nha1, σi ⇓ hi1, σ0i, ha2, σ0i ⇓ hi2, σ00i\r\nha1 + a2, σi ⇓ hi, σ00i\r\nwhere i is the sum of i1 and i2.\r\nTherefore, in order to add side-effects to one’s language, one needs to revisit the entire existing definition to\r\ntake explicit care of propagating the side effects. Additionally it is very inconvenient (and non-modular) to\r\ndefine complex control statements; consider, for example, adding a halt statement to a hypothetical simple\r\n6Personal communication.\r\n49\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/984b7ae2-cd6f-4186-866a-8e9259e2fce5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7a80b28c1fe81c826f4ea5cff929b127c068fd0b8bbc8b9b1cfb44df9cae4b48",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 716
      },
      {
        "segments": [
          {
            "segment_id": "984b7ae2-cd6f-4186-866a-8e9259e2fce5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "where like in SOS C, C1, C2, ..., Cn are configurations holding fragments of program together with all the\r\nneeded semantic components, and R, R1, R2, ..., Rn are result configurations, i.e., configurations which\r\ncannot be advanced anymore. For example, here is the big-step rule defining addition in a language whose\r\nexpression evaluation has no side-effects (a1, a2 are arithmetic expressions, σ is a state, and i1, i2 are integers):\r\nha1, σi ⇓ i1, ha2, σi ⇓ i2\r\nha1 + a2, σi ⇓ i\r\nwhere i is the sum of i1 and i2\r\nTypically the result configurations are just a value like above or an abstract value (e.g., a type), but when the\r\nlanguage under consideration has side effects, result configurations may need also to contain some semantic\r\ncomponents. We assume that the down-arrow symbol ⇓ is not decorated with any labels; this can be easily\r\nachieved by moving such labels as components into the result configurations. Interestingly, any big-step\r\noperational semantic definition is a special case of a (small-step) SOS definition like in Section 5.1: all what\r\nneeds to do is to replace “→” by ⇓”. The crucial technical difference between the two approaches is that in\r\nbig-step semantics the result configurations are not reducible anymore: one derives directly the final result of\r\nprocessing a configuration (if any). Therefore, all the embeddings of SOS into rewrite logic and K in Section\r\n5.1 are also applicable for big-step operational semantics and their faithfulness theorems still hold. However,\r\nthanks to the particular nature of big-step semantics, we next give simpler embeddings.\r\nStrengths. When it can be given to a language, big-step operational semantics is easy to understand,\r\nsince it relates syntactic entities directly to their expected results. Big-step operational semantics, due to\r\nits straightforward recursive nature, can be easily and efficiently interpreted in any recursive, functional or\r\nlogical framework. Many proponents of big-step operational semantics regard it “almost as an interpreter”\r\nfor the defined language. It is more abstract than many other definitional styles, so one can in principle\r\nmore easily define and prove properties about programs (in languages that can be given a reasonable big\u0002step semantics). It is particularly useful for defining type systems and side-effect free languages or language\r\nfeatures.\r\nWeaknesses. Due to its monolithic, single-step evaluation, it is hard to debug or trace big-step semantic\r\ndefinitions. If the program is wrong, no information is given about where the failure occurred.\r\nDivergence or non-termination is not observable in the specified evaluation relation. In particular, one\r\ncannot define at all non-terminating processes or systems, such as reactive system. Consider, for example,\r\nthe task of giving CCS (see Figure 5 for a small-step SOS definition) a big-step operational semantics; even\r\nif one (unreasonably) assumes that a CCS process terminates, then its big step semantics should “evaluate”\r\nit to all its possible behaviors; even making abstraction (again) of the various semantic choices, such as trace\u0002based versus tree-based semantics, the major problem is that a potential big-step semantics of concurrent\r\nprocesses p|q is not compositional, that is, it is not possible to simply combine the semantics of p and q\r\nin order to obtain the semantics of p|q. A technique for capturing an interleaving semantics for concurrent\r\nsystems using big-step operational semantics is sketched by Mosses in [29] (using the modular features of\r\nhis MSOS), but he did not provide details because he does not encourage the use of the big-step semantics\r\nstyle for concurrency6. It is, in fact, well known and broadly accepted that big-step operational semantics is\r\nsimply unsuitable for concurrency.\r\nBig-step semantics is not modular. For example, to add side effects to expressions, one must redefine the\r\nrules to allow expressions to evaluate to pairs (value-state) and to appropriately propagate side effects; e.g.:\r\nha1, σi ⇓ hi1, σ0i, ha2, σ0i ⇓ hi2, σ00i\r\nha1 + a2, σi ⇓ hi, σ00i\r\nwhere i is the sum of i1 and i2.\r\nTherefore, in order to add side-effects to one’s language, one needs to revisit the entire existing definition to\r\ntake explicit care of propagating the side effects. Additionally it is very inconvenient (and non-modular) to\r\ndefine complex control statements; consider, for example, adding a halt statement to a hypothetical simple\r\n6Personal communication.\r\n49\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/984b7ae2-cd6f-4186-866a-8e9259e2fce5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7a80b28c1fe81c826f4ea5cff929b127c068fd0b8bbc8b9b1cfb44df9cae4b48",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 716
      },
      {
        "segments": [
          {
            "segment_id": "4520095d-dc17-4075-89c9-810837c5a686",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "and side-effect-free imperative language —one needs to add a special configuration halting(i), and rules like\r\nthe following:\r\nha, σi ⇓ i\r\nhhalt a, σi ⇓ halting(i)\r\nhs1, σi ⇓ halting(i)\r\nhs1; s2, σi ⇓ halting(i)\r\nhb, σi ⇓ true, hs, σi ⇓ halting(i)\r\nhwhile b do s, σi ⇓ halting(i)\r\nhs, σi ⇓ halting(i)\r\nhs; a, σi ⇓ i\r\nTherefore, one needs to rethink all the language constructs and add big-step rules that propagate the halting\r\nsignal through all the constructs that may halt the program. If each fragment of program may potentially\r\nhalt the program, which is typically the case, then one needs to add a new halt rule for each argument of each\r\nlanguage construct. The situation can easily become unmanageable when the language under consideration\r\nis non-trivial; for example, a language may have exceptions, functions with return, loops with break and\r\ncontinue, etc., the addition of each of these features requiring the language designer to potentially more than\r\ndouble the number of existing rules in the language, not to mention and subtle interactions between the\r\nvarious control-intensive language features (for example, a return from a function crosses the boundaries of\r\nloops, but a break/continue of a loop does not cross the boundaries of a function invocation, etc.).\r\nWe hope that all the arguments above make it clear that big-step operational semantics is far from being\r\nan ideal language definition framework. While it is nevertheless useful to define certain aspects of a language,\r\nsuch as a type system for it, big-step operational semantics has too many limitations to serve as a uniform\r\nand unique definitional framework for languages, language features and/or language analyzers.\r\n5.2.1 Big-Step Semantics as a Methodological Fragment of Rewriting Logic\r\nDue to its straightforward evaluation-like recursive nature, big-step semantics is relatively easy to define in\r\nany other formalism as well as to translate into an interpreter for the defined language into any programming\r\nlanguage. (The difficulty with big-step SOS is to actually give semantics to complex constructs.) It is\r\ntherefore not surprising that one can replace each big-step rule with one conditional rewrite rule and thus\r\nobtain a rewrite logic theory that faithfully captures the big-step definition. For simplicity, we here assume\r\nthat configurations and result configurations are disjoint; in case one needs the result configurations to\r\nmention the same semantic components as the other configurations, then we assume that one uses a different\r\nconfiguration wrapper notation. For example, one can write ha, σi for a reducible configuration containing\r\narithmetic expression a and state σ, and [v, σ] for a result configuration containing value v and state σ.\r\nAlso, we make the reasonable assumption that configurations are not nested. Then one can associate to each\r\nbig-step semantic rule as above a rewrite rule as follows:\r\nC → R if C1 → R1 ∧ C2 → R2 ∧ · · · ∧ Cn → Rn.\r\nA first thing to notice is that, since all these rewrite rules involve configurations, rewriting can only occur\r\nat the top, thus the general application of term rewriting under contexts is disabled by the definitional style.\r\nAnother thing to notice here is that all configurations in the right hand sides are normal forms, thus the\r\ntransitivity rule for rewriting logic also becomes inapplicable. Then the following result can be proved:\r\nTheorem 7. (Faithful embedding of big-step operational semantics into rewrite logic) For any\r\nbig-step operational semantics definition BigStep, any configuration C and any result configuration R,\r\nBigStep ` C ⇓ R ⇐⇒ RLSBigStep ` C → R,\r\nwhere RLSBigStep is the rewrite logic semantic definition obtained from BigStep as above.\r\n50\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4520095d-dc17-4075-89c9-810837c5a686.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0733e8c8d3520b031331798e4615c72d5491dc9dfa36e2cd2816e156339760d1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 615
      },
      {
        "segments": [
          {
            "segment_id": "4520095d-dc17-4075-89c9-810837c5a686",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "and side-effect-free imperative language —one needs to add a special configuration halting(i), and rules like\r\nthe following:\r\nha, σi ⇓ i\r\nhhalt a, σi ⇓ halting(i)\r\nhs1, σi ⇓ halting(i)\r\nhs1; s2, σi ⇓ halting(i)\r\nhb, σi ⇓ true, hs, σi ⇓ halting(i)\r\nhwhile b do s, σi ⇓ halting(i)\r\nhs, σi ⇓ halting(i)\r\nhs; a, σi ⇓ i\r\nTherefore, one needs to rethink all the language constructs and add big-step rules that propagate the halting\r\nsignal through all the constructs that may halt the program. If each fragment of program may potentially\r\nhalt the program, which is typically the case, then one needs to add a new halt rule for each argument of each\r\nlanguage construct. The situation can easily become unmanageable when the language under consideration\r\nis non-trivial; for example, a language may have exceptions, functions with return, loops with break and\r\ncontinue, etc., the addition of each of these features requiring the language designer to potentially more than\r\ndouble the number of existing rules in the language, not to mention and subtle interactions between the\r\nvarious control-intensive language features (for example, a return from a function crosses the boundaries of\r\nloops, but a break/continue of a loop does not cross the boundaries of a function invocation, etc.).\r\nWe hope that all the arguments above make it clear that big-step operational semantics is far from being\r\nan ideal language definition framework. While it is nevertheless useful to define certain aspects of a language,\r\nsuch as a type system for it, big-step operational semantics has too many limitations to serve as a uniform\r\nand unique definitional framework for languages, language features and/or language analyzers.\r\n5.2.1 Big-Step Semantics as a Methodological Fragment of Rewriting Logic\r\nDue to its straightforward evaluation-like recursive nature, big-step semantics is relatively easy to define in\r\nany other formalism as well as to translate into an interpreter for the defined language into any programming\r\nlanguage. (The difficulty with big-step SOS is to actually give semantics to complex constructs.) It is\r\ntherefore not surprising that one can replace each big-step rule with one conditional rewrite rule and thus\r\nobtain a rewrite logic theory that faithfully captures the big-step definition. For simplicity, we here assume\r\nthat configurations and result configurations are disjoint; in case one needs the result configurations to\r\nmention the same semantic components as the other configurations, then we assume that one uses a different\r\nconfiguration wrapper notation. For example, one can write ha, σi for a reducible configuration containing\r\narithmetic expression a and state σ, and [v, σ] for a result configuration containing value v and state σ.\r\nAlso, we make the reasonable assumption that configurations are not nested. Then one can associate to each\r\nbig-step semantic rule as above a rewrite rule as follows:\r\nC → R if C1 → R1 ∧ C2 → R2 ∧ · · · ∧ Cn → Rn.\r\nA first thing to notice is that, since all these rewrite rules involve configurations, rewriting can only occur\r\nat the top, thus the general application of term rewriting under contexts is disabled by the definitional style.\r\nAnother thing to notice here is that all configurations in the right hand sides are normal forms, thus the\r\ntransitivity rule for rewriting logic also becomes inapplicable. Then the following result can be proved:\r\nTheorem 7. (Faithful embedding of big-step operational semantics into rewrite logic) For any\r\nbig-step operational semantics definition BigStep, any configuration C and any result configuration R,\r\nBigStep ` C ⇓ R ⇐⇒ RLSBigStep ` C → R,\r\nwhere RLSBigStep is the rewrite logic semantic definition obtained from BigStep as above.\r\n50\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4520095d-dc17-4075-89c9-810837c5a686.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0733e8c8d3520b031331798e4615c72d5491dc9dfa36e2cd2816e156339760d1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 615
      },
      {
        "segments": [
          {
            "segment_id": "d7b2b1c4-e1e7-4fe7-979a-3095885d0141",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "The only apparent difference between BigStep and RLSBigStep is the different notational conventions they\r\nuse (“→” instead of “⇓” and conditional rewrite rules instead of conditional deduction rules). However, as the\r\nabove theorem shows, there is a one-to-one correspondence also between their corresponding “computations”\r\n(or executions, or derivations). Therefore, RLSBigStep actually is the big-step operational semantics BigStep,\r\nnot an “encoding” of it. Note that, in order to be faithfully equivalent to BigStep computationally, RLSBigStep\r\nlacks the main strength of rewriting logic that makes it an appropriate formalism for concurrency, namely,\r\nthat rewrite rules can apply under any context and in parallel (here all rules are syntactically constrained\r\nso that they can only apply at the top, sequentially).\r\n5.2.2 Big-Step Semantics as a Methodological Fragment of K\r\nOur embedding of big-step semantics into K is very similar to, but simpler than the embedding of SOS into\r\nK. We consider no paths here (these may be methodologically included as part of the result configurations\r\nif one wants to, though labels typically come with concurrent system definitions, for which big-step is\r\nnotoriously inappropriate) and two types of computations, one corresponding to big-step configurations and\r\none corresponding to big-step result configurations:\r\nConfig ::= LKMk\r\nK ::= ConfigBigStep | ResultConfigBigStep | KConstant\r\nKConstant ::= rule1 | rule2 | . . . (one K constant per big-step rule)\r\nThen each big-step rule\r\nrulei:\r\nC1 ⇓ R1, C2 ⇓ R2, . . . , Cn ⇓ Rn\r\nC ⇓ R\r\ncan be converted into one K rule and one K equation as follows:\r\nL C\r\nstrict(C1, C2, . . . , Cn) y rulei y R\r\n|ik\r\nLstrict(R1, R2, . . . , Rn) y rulei\r\n·\r\ny R|ik\r\nThe following expected result can be proved now:\r\nTheorem 8. (Faithful embedding of big-step operational semantics into K) For any big-step oper\u0002ational semantics definition BigStep, any configuration C and any result configuration R,\r\nBigStep ` C ⇓ R ⇐⇒ KBigStep ` LCMk → LRMk,\r\nwhere KBigStep is the K semantic definition obtained from BigStep as above.\r\n5.3 Modular Structural Operational Semantics (MSOS)\r\nModular structural operational semantics (MSOS) was introduced by Peter Mosses in [28] and then discussed\r\nin detail in [29], to deal with the non-modularity issues of small-step and big-step SOS. The solution proposed\r\nin MSOS involves moving the non-syntactic state components to the labels on transitions (as provided by\r\nSOS), plus a discipline for only selecting needed attributes from the states. There are both big-step and\r\nsmall-step variants of MSOS, but we discuss only small-step MSOS here. As discussed in Section 5.2, big\u0002step SOS has too many limitations in addition to its non-modularity; even though big-step MSOS partially\r\nimproves the modularity of big-step SOS, it is far from being an ideal general purpose language definitional\r\nframework, so we do not discuss it anymore in this paper.\r\nBefore we get into the technicalities of MSOS, one natural question to address is why we need modularity\r\nof language definitions. One may argue that defining a programming language is a major initiative that is\r\nbeing done once and for all, so having to go through the defining rules many times is, after all, not such a\r\nbad idea, because it gives one the chance to find and fix potential errors in them. Here are several reasons\r\nwhy modularity is desirable in language definitions:\r\n51\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d7b2b1c4-e1e7-4fe7-979a-3095885d0141.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=460a534d0fe532bbc37b9af7a73644ec82c4ed89fb9de91d3efa0a311e632f05",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 570
      },
      {
        "segments": [
          {
            "segment_id": "d7b2b1c4-e1e7-4fe7-979a-3095885d0141",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "The only apparent difference between BigStep and RLSBigStep is the different notational conventions they\r\nuse (“→” instead of “⇓” and conditional rewrite rules instead of conditional deduction rules). However, as the\r\nabove theorem shows, there is a one-to-one correspondence also between their corresponding “computations”\r\n(or executions, or derivations). Therefore, RLSBigStep actually is the big-step operational semantics BigStep,\r\nnot an “encoding” of it. Note that, in order to be faithfully equivalent to BigStep computationally, RLSBigStep\r\nlacks the main strength of rewriting logic that makes it an appropriate formalism for concurrency, namely,\r\nthat rewrite rules can apply under any context and in parallel (here all rules are syntactically constrained\r\nso that they can only apply at the top, sequentially).\r\n5.2.2 Big-Step Semantics as a Methodological Fragment of K\r\nOur embedding of big-step semantics into K is very similar to, but simpler than the embedding of SOS into\r\nK. We consider no paths here (these may be methodologically included as part of the result configurations\r\nif one wants to, though labels typically come with concurrent system definitions, for which big-step is\r\nnotoriously inappropriate) and two types of computations, one corresponding to big-step configurations and\r\none corresponding to big-step result configurations:\r\nConfig ::= LKMk\r\nK ::= ConfigBigStep | ResultConfigBigStep | KConstant\r\nKConstant ::= rule1 | rule2 | . . . (one K constant per big-step rule)\r\nThen each big-step rule\r\nrulei:\r\nC1 ⇓ R1, C2 ⇓ R2, . . . , Cn ⇓ Rn\r\nC ⇓ R\r\ncan be converted into one K rule and one K equation as follows:\r\nL C\r\nstrict(C1, C2, . . . , Cn) y rulei y R\r\n|ik\r\nLstrict(R1, R2, . . . , Rn) y rulei\r\n·\r\ny R|ik\r\nThe following expected result can be proved now:\r\nTheorem 8. (Faithful embedding of big-step operational semantics into K) For any big-step oper\u0002ational semantics definition BigStep, any configuration C and any result configuration R,\r\nBigStep ` C ⇓ R ⇐⇒ KBigStep ` LCMk → LRMk,\r\nwhere KBigStep is the K semantic definition obtained from BigStep as above.\r\n5.3 Modular Structural Operational Semantics (MSOS)\r\nModular structural operational semantics (MSOS) was introduced by Peter Mosses in [28] and then discussed\r\nin detail in [29], to deal with the non-modularity issues of small-step and big-step SOS. The solution proposed\r\nin MSOS involves moving the non-syntactic state components to the labels on transitions (as provided by\r\nSOS), plus a discipline for only selecting needed attributes from the states. There are both big-step and\r\nsmall-step variants of MSOS, but we discuss only small-step MSOS here. As discussed in Section 5.2, big\u0002step SOS has too many limitations in addition to its non-modularity; even though big-step MSOS partially\r\nimproves the modularity of big-step SOS, it is far from being an ideal general purpose language definitional\r\nframework, so we do not discuss it anymore in this paper.\r\nBefore we get into the technicalities of MSOS, one natural question to address is why we need modularity\r\nof language definitions. One may argue that defining a programming language is a major initiative that is\r\nbeing done once and for all, so having to go through the defining rules many times is, after all, not such a\r\nbad idea, because it gives one the chance to find and fix potential errors in them. Here are several reasons\r\nwhy modularity is desirable in language definitions:\r\n51\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d7b2b1c4-e1e7-4fe7-979a-3095885d0141.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=460a534d0fe532bbc37b9af7a73644ec82c4ed89fb9de91d3efa0a311e632f05",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 570
      },
      {
        "segments": [
          {
            "segment_id": "6b8010da-1a4c-484e-8bf3-6805f335b851",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "1. Having to modify many or all rules whenever a new rule is added that modifies the structure of the\r\nconfiguration is actually more error prone than it may seem, because rules become heavier to read and\r\ndebug; for example, one can write σ instead of σ\r\n0\r\nin a right-hand-side of a rule and a different or wrong\r\nlanguage is being defined.\r\n2. When designing a new language, as opposed to an existing well-understood language, one needs to\r\nexperiment with features and combinations of features; having to do lots of unrelated changes whenever\r\na new feature is added to or removed from the language burdens the language designer with boring\r\ntasks taking considerable time that could have been otherwise spent on actual interesting language\r\ndesign issues.\r\n3. There is a plethora of domain-specific languages these days, generated by the need to abstract away\r\nfrom low-level programming language details to important, domain-specific aspects of the application.\r\nTherefore, there is a need for rapid language design and experimentation for various domains. Moreover,\r\ndomain-specific languages tend to be very dynamic, being added or removed features frequently as the\r\ndomain knowledge evolves. It would be very nice to have the possibility to “drag-and-drop” language\r\nfeatures in one’s language, such as functions, exceptions, objects, etc.; however, in order for that to be\r\npossible, modularity of language feature definitions is crucial.\r\nWhether MSOS gives us such a desired framework for modular language design is still open and debatable,\r\nbut it is certainly the first framework explicitly aiming at modular language design.\r\nA transition in MSOS is of the form P\r\nX→ P\r\n0 or the form P → P0\r\n, where P and P\r\n0 are programs\r\nor fragments of programs and X is a label describing the structure of the remaining configuration both\r\nbefore and after the transition. If X is missing, then the remaining part of the configuration is assumed\r\nto stay unchanged. Specifically, X is a record containing fields denoting the semantic components of the\r\nconfiguration; the preferred notation in MSOS for saying that in label X the semantic component associated\r\nto the field name σ (e.g., a state or a store name) is σ0 (e.g., a function associating values to variables) is\r\nX = {σ = σ0, ...}. Modularity in MSOS is achieved by two important notational conventions: (1) the record\r\ncomprehension notation “. . . ” which indicates that more fields could follow but that they are not of interest\r\nfor this transition, in particular that they stay unchanged after the application of the transition, and (2) by\r\nnot mentioning labels at all when nothing changes on the labels (this is a recent feature of MSOS introduced\r\nby Peter Mosses in a December 2007 talk at the University of Illinois at Urbana-Champaign). If record\r\ncomprehension is used in both the condition and the conclusion of an MSOS rule, then all the occurrences\r\nof “. . .” stand for the same fields with the same semantic components.\r\nIf no labels are mentioned on any of the transitions in the condition and the conclusion of the rule,\r\nthen it means that all the transitions have the same label (labels do not change). This allows for most of\r\nthe MSOS rules in a language or calculus definition to look very natural, without unnecessary decorations\r\nof the transition relations. For example, Figure 8 shows the small-step MSOS rules for advancing the\r\nexpressions that are assigned to variables, bound by a let, or written to the output; note that these rules\r\nhave no conceptual connection with the actual process of assigning or binding a value to a variable, or of\r\nwriting it to the output (their role is to prepare the terrain for the actual assignment, binding, or output\r\nwriting; these are defined shortly), so no labels needed by other rules need to be artificially carried by MSOS\r\ntransitions. For comparison, we also give the K correspondent to each MSOS rule, assuming more or less\r\nthe same conceptual definitional style and configuration structuring. For now, the reader can check the K\r\ncorresponding definitions for illustrory purposes; at the end of this section we compare MSOS with K and,\r\nas part of that comparison, we shall discuss the K definitions in more detail. Fields of an MSOS label can be\r\nread-write, read-only, or write-only. Read-write fields come in pairs, having the same field name, except that\r\nthe “write” field name is primed. They are used for transitions modifying existing configuration fields. For\r\nexample, a store field σ can be read and written, as illustrated by the MSOS rule in Figure 9 for assignment\r\nin a language definition based on a split of state into an environment (ρ) and a store (σ). The rule in Figure\r\n9 says that, if before the transition the environment was ρ0 and the store was σ0, after the transition the\r\nstore will become σ0[ρ0[x] ← i], updating the location of x in the store to i. (We adopted the common\r\n52\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6b8010da-1a4c-484e-8bf3-6805f335b851.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1c396fa7d8fe831e7a3d07469f98f46c2b23486d52b08e3a215be0c7b23a5052",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 845
      },
      {
        "segments": [
          {
            "segment_id": "6b8010da-1a4c-484e-8bf3-6805f335b851",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "1. Having to modify many or all rules whenever a new rule is added that modifies the structure of the\r\nconfiguration is actually more error prone than it may seem, because rules become heavier to read and\r\ndebug; for example, one can write σ instead of σ\r\n0\r\nin a right-hand-side of a rule and a different or wrong\r\nlanguage is being defined.\r\n2. When designing a new language, as opposed to an existing well-understood language, one needs to\r\nexperiment with features and combinations of features; having to do lots of unrelated changes whenever\r\na new feature is added to or removed from the language burdens the language designer with boring\r\ntasks taking considerable time that could have been otherwise spent on actual interesting language\r\ndesign issues.\r\n3. There is a plethora of domain-specific languages these days, generated by the need to abstract away\r\nfrom low-level programming language details to important, domain-specific aspects of the application.\r\nTherefore, there is a need for rapid language design and experimentation for various domains. Moreover,\r\ndomain-specific languages tend to be very dynamic, being added or removed features frequently as the\r\ndomain knowledge evolves. It would be very nice to have the possibility to “drag-and-drop” language\r\nfeatures in one’s language, such as functions, exceptions, objects, etc.; however, in order for that to be\r\npossible, modularity of language feature definitions is crucial.\r\nWhether MSOS gives us such a desired framework for modular language design is still open and debatable,\r\nbut it is certainly the first framework explicitly aiming at modular language design.\r\nA transition in MSOS is of the form P\r\nX→ P\r\n0 or the form P → P0\r\n, where P and P\r\n0 are programs\r\nor fragments of programs and X is a label describing the structure of the remaining configuration both\r\nbefore and after the transition. If X is missing, then the remaining part of the configuration is assumed\r\nto stay unchanged. Specifically, X is a record containing fields denoting the semantic components of the\r\nconfiguration; the preferred notation in MSOS for saying that in label X the semantic component associated\r\nto the field name σ (e.g., a state or a store name) is σ0 (e.g., a function associating values to variables) is\r\nX = {σ = σ0, ...}. Modularity in MSOS is achieved by two important notational conventions: (1) the record\r\ncomprehension notation “. . . ” which indicates that more fields could follow but that they are not of interest\r\nfor this transition, in particular that they stay unchanged after the application of the transition, and (2) by\r\nnot mentioning labels at all when nothing changes on the labels (this is a recent feature of MSOS introduced\r\nby Peter Mosses in a December 2007 talk at the University of Illinois at Urbana-Champaign). If record\r\ncomprehension is used in both the condition and the conclusion of an MSOS rule, then all the occurrences\r\nof “. . .” stand for the same fields with the same semantic components.\r\nIf no labels are mentioned on any of the transitions in the condition and the conclusion of the rule,\r\nthen it means that all the transitions have the same label (labels do not change). This allows for most of\r\nthe MSOS rules in a language or calculus definition to look very natural, without unnecessary decorations\r\nof the transition relations. For example, Figure 8 shows the small-step MSOS rules for advancing the\r\nexpressions that are assigned to variables, bound by a let, or written to the output; note that these rules\r\nhave no conceptual connection with the actual process of assigning or binding a value to a variable, or of\r\nwriting it to the output (their role is to prepare the terrain for the actual assignment, binding, or output\r\nwriting; these are defined shortly), so no labels needed by other rules need to be artificially carried by MSOS\r\ntransitions. For comparison, we also give the K correspondent to each MSOS rule, assuming more or less\r\nthe same conceptual definitional style and configuration structuring. For now, the reader can check the K\r\ncorresponding definitions for illustrory purposes; at the end of this section we compare MSOS with K and,\r\nas part of that comparison, we shall discuss the K definitions in more detail. Fields of an MSOS label can be\r\nread-write, read-only, or write-only. Read-write fields come in pairs, having the same field name, except that\r\nthe “write” field name is primed. They are used for transitions modifying existing configuration fields. For\r\nexample, a store field σ can be read and written, as illustrated by the MSOS rule in Figure 9 for assignment\r\nin a language definition based on a split of state into an environment (ρ) and a store (σ). The rule in Figure\r\n9 says that, if before the transition the environment was ρ0 and the store was σ0, after the transition the\r\nstore will become σ0[ρ0[x] ← i], updating the location of x in the store to i. (We adopted the common\r\n52\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6b8010da-1a4c-484e-8bf3-6805f335b851.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1c396fa7d8fe831e7a3d07469f98f46c2b23486d52b08e3a215be0c7b23a5052",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 845
      },
      {
        "segments": [
          {
            "segment_id": "f3f9ccbc-58da-430a-a937-a3d77f0b97a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "MSOS Language syntax K syntax annotation\r\ne −→ e\r\n0\r\nx := e −→ x := e\r\n0\r\nExp ::= . . . | Name := Exp strict(2)\r\ne1 −→ e\r\n0\r\n1\r\nlet x = e1 in e2 −→ let x = e\r\n0\r\n1\r\nin e2\r\nExp ::= . . . | let Name = Exp in Exp strict(2)\r\na −→ a\r\n0\r\nwrite(a) −→ write(a\r\n0)\r\nStmt ::= . . . | write(Exp) strict\r\nFigure 8: Syntax traversing rules in MSOS and corresponding K strictness attributes\r\nMSOS K\r\nx := v\r\n{ρ=ρ0,σ=σ0,σ0=σ0[v/ρ0[x]],...}\r\n−−−−−−−−−−−−−−−−−−−−→ skip Lx := v\r\n·\r\n|ikLρ0Mρ L σ0\r\nσ0[v/ρ0[x]]\r\nMσ\r\nFigure 9: Semantics of assignment in MSOS and K\r\nSOS convention that unconditional rules are written as just their conclusion transition, omitting their empty\r\ncondition.)\r\nRead-only fields are only inspected by the rule, but not modified. For example, when writing (as above) or\r\nreading the location of a variable in an environment, the environment is not modified. Also, when temporarily\r\nswitching to a different environment to process a subexpression, a new environment is created for the subtask,\r\nbut no different environment is ever needed to be produced as a result of applying a transition; for example,\r\nFigure 10 shows the remaining MSOS environment-based definition of the let construct.\r\nMSOS K\r\ne2\r\n{ρ=ρ0[l/x],σ=σ0[v1/l],...}\r\n−−−−−−−−−−−−−−−−−→ e\r\n0\r\n2\r\nlet x = v1 in e2\r\n{ρ=ρ0,σ=σ0,...}\r\n−−−−−−−−−−→ let x = v1 in e\r\n0\r\n2\r\nL let x = v1 in e2\r\ne2 y restore(ρ0)\r\n|ikL ρ0\r\nρ0[l/x]\r\nMρ L σ0\r\nσ0[v1/l]\r\nMσ\r\nlet x = v1 in v2 −→ v2 — no similar K rule needed —\r\nFigure 10: Semantics of let in MSOS and K\r\nNote that unlike in the case of the write-read label σ for the store, the label ρ does not need a primed\r\nversion; indeed, following the definitional style above, an environment is never changed at the end of a\r\nsmall-step, while a store may be changed. The first MSOS rule above advances e2 a small-step in a correctly\r\nmodified environment and state. It is interesting to note that, even though the environment and the store\r\nin which e2 is evaluated appear to change in a similar way, there is actually a crucial difference between the\r\ntwo, precisely because the former is read-only and the latter is write-read: the fact that the label σ\r\n0\r\nis not\r\nmentioned it means that the condition and the conclusion transitions have the same σ\r\n0\r\n, i.e., the conclusion\r\ntransition carries over the “side effects” propagated by the condition, while the fact that there is no label ρ\r\n0\r\nit means that the environment seen by the let construct does not change as the subexpression e2 is evaluated\r\n(in its properly updated environment).\r\nWrite-only fields are used to record things not analyzable during the execution of the program, such as\r\nthe output or the trace. Their names are always primed and they have a free monoid semantics –everything\r\nwritten on them is actually added at the end. A good example of the usage of write-only fields would be\r\na rule for defining a print/write/output language construct, like the one in Figure 11. Note that, since the\r\n53\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f3f9ccbc-58da-430a-a937-a3d77f0b97a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5a62d740c9ecd604300ebd7fa8a84f776efc3ce49f5d596f5f466ffa27f7e618",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 548
      },
      {
        "segments": [
          {
            "segment_id": "f3f9ccbc-58da-430a-a937-a3d77f0b97a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "MSOS Language syntax K syntax annotation\r\ne −→ e\r\n0\r\nx := e −→ x := e\r\n0\r\nExp ::= . . . | Name := Exp strict(2)\r\ne1 −→ e\r\n0\r\n1\r\nlet x = e1 in e2 −→ let x = e\r\n0\r\n1\r\nin e2\r\nExp ::= . . . | let Name = Exp in Exp strict(2)\r\na −→ a\r\n0\r\nwrite(a) −→ write(a\r\n0)\r\nStmt ::= . . . | write(Exp) strict\r\nFigure 8: Syntax traversing rules in MSOS and corresponding K strictness attributes\r\nMSOS K\r\nx := v\r\n{ρ=ρ0,σ=σ0,σ0=σ0[v/ρ0[x]],...}\r\n−−−−−−−−−−−−−−−−−−−−→ skip Lx := v\r\n·\r\n|ikLρ0Mρ L σ0\r\nσ0[v/ρ0[x]]\r\nMσ\r\nFigure 9: Semantics of assignment in MSOS and K\r\nSOS convention that unconditional rules are written as just their conclusion transition, omitting their empty\r\ncondition.)\r\nRead-only fields are only inspected by the rule, but not modified. For example, when writing (as above) or\r\nreading the location of a variable in an environment, the environment is not modified. Also, when temporarily\r\nswitching to a different environment to process a subexpression, a new environment is created for the subtask,\r\nbut no different environment is ever needed to be produced as a result of applying a transition; for example,\r\nFigure 10 shows the remaining MSOS environment-based definition of the let construct.\r\nMSOS K\r\ne2\r\n{ρ=ρ0[l/x],σ=σ0[v1/l],...}\r\n−−−−−−−−−−−−−−−−−→ e\r\n0\r\n2\r\nlet x = v1 in e2\r\n{ρ=ρ0,σ=σ0,...}\r\n−−−−−−−−−−→ let x = v1 in e\r\n0\r\n2\r\nL let x = v1 in e2\r\ne2 y restore(ρ0)\r\n|ikL ρ0\r\nρ0[l/x]\r\nMρ L σ0\r\nσ0[v1/l]\r\nMσ\r\nlet x = v1 in v2 −→ v2 — no similar K rule needed —\r\nFigure 10: Semantics of let in MSOS and K\r\nNote that unlike in the case of the write-read label σ for the store, the label ρ does not need a primed\r\nversion; indeed, following the definitional style above, an environment is never changed at the end of a\r\nsmall-step, while a store may be changed. The first MSOS rule above advances e2 a small-step in a correctly\r\nmodified environment and state. It is interesting to note that, even though the environment and the store\r\nin which e2 is evaluated appear to change in a similar way, there is actually a crucial difference between the\r\ntwo, precisely because the former is read-only and the latter is write-read: the fact that the label σ\r\n0\r\nis not\r\nmentioned it means that the condition and the conclusion transitions have the same σ\r\n0\r\n, i.e., the conclusion\r\ntransition carries over the “side effects” propagated by the condition, while the fact that there is no label ρ\r\n0\r\nit means that the environment seen by the let construct does not change as the subexpression e2 is evaluated\r\n(in its properly updated environment).\r\nWrite-only fields are used to record things not analyzable during the execution of the program, such as\r\nthe output or the trace. Their names are always primed and they have a free monoid semantics –everything\r\nwritten on them is actually added at the end. A good example of the usage of write-only fields would be\r\na rule for defining a print/write/output language construct, like the one in Figure 11. Note that, since the\r\n53\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f3f9ccbc-58da-430a-a937-a3d77f0b97a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5a62d740c9ecd604300ebd7fa8a84f776efc3ce49f5d596f5f466ffa27f7e618",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 548
      },
      {
        "segments": [
          {
            "segment_id": "3e811afe-939c-4c57-a93d-eb3f34e9a18a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "MSOS K\r\nwrite(i)\r\n{out’=i,...}\r\n−−−−−−−→ skip Lwrite(i)\r\n·\r\n|ikh|·\r\ni\r\nMout\r\nFigure 11: Semantics of write in MSOS and K\r\n“accumulated” write-only field semantic components are not allowed to be modified or used by rules, one\r\nonly mentions the new items being written to a write field, without ever having to mention the existing value\r\nof the field; in other words, one writes “out0 = i” instead of “out0 = o, i” where o is the existing value of the\r\nout write field.\r\nThe idea in MSOS is therefore that one can use the labels to maintain important semantic information\r\nabout the “execution” of a program. The implicit notational conventions of MSOS allow the rules to\r\npropagate this semantic information in the “back-scenes”. This apparently simple trick is actually crucial to\r\nincreasing the modularity of language definitions, because new features needing new semantic components in\r\nthe configuration can add and modify those without having to change any of the existing rules to propagate\r\nthe new semantic components, as an explicit-label framework like SOS would have to. The advantage of\r\nMSOS over SOS can perhaps be seen best when defining language features that change abruptly the execution\r\nflow of the program. Recall that in order to define a halt statement in SOS one needs to possibly more than\r\ndouble the number of rules, because each language construct needs to be changed its semantics to propagate\r\nthe “halting signal” produced by any of its subexpressions. As Figure 12 shows, in MSOS one can define halt\r\nmodularly, adding a write-only label that holds the halting value, if any generated. A top level construct,\r\nMSOS K\r\np\r\nhalt’=()\r\n−−−−−→ p\r\n0\r\nprogram p\r\nhalt’=()\r\n−−−−−→ program p\r\n0\r\n— no similar K rule needed —\r\np\r\nhalt’=v −−−−−→ p\r\n0\r\nprogram p\r\nhalt’=v −−−−−→ v\r\n— no similar K rule needed —\r\ne → e\r\n0\r\nhalt e → halt e\r\n0\r\nStmt ::= . . . | halt Exp [strict]\r\nhalt v\r\nhalt0=v −−−−−→ stuck Lhalt v|ik → LvMk\r\nFigure 12: Semantics of halt in MSOS and K\r\n“program p”, wrapping a program needs to be added to the syntax in order to know where to “catch” the\r\nhalting signal. The first rule advances the program as before if it generates no halting signal, while the\r\nsecond catches the halting value and stops the program with that value.\r\nMSOS is given a semantics based on category theory in [29], but, as the examples above show, one does\r\nnot need to understand category theory in order to understand or use MSOS. The simplest way to explain\r\nMSOS is perhaps through its automatic translation into conventional SOS: each MSOS rule can be desugared\r\ninto a rule that explicitly mentions all the fields with all their values on all the labels; this way, any MSOS\r\ndefinition becomes a conventional SOS definition with labels on transitions. It is important to realize that\r\nthe desugared SOS definition does not enjoy the modularity characteristics of the original MSOS definition\r\n(otherwise one could use MSOS as an “SOS style”); for example, if one decides to add a new label in order\r\nto accommodate a new language feature, then one needs to change all the existing SOS rules. Nevertheless,\r\nonce the MSOS-to-SOS mechanical translation is applied, one can further use the embeddings of SOS into\r\n54\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3e811afe-939c-4c57-a93d-eb3f34e9a18a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b0729c6c9017b293871ca2c64121caaf5951d23dac13e411a26f3e35ad7343f7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 570
      },
      {
        "segments": [
          {
            "segment_id": "3e811afe-939c-4c57-a93d-eb3f34e9a18a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "MSOS K\r\nwrite(i)\r\n{out’=i,...}\r\n−−−−−−−→ skip Lwrite(i)\r\n·\r\n|ikh|·\r\ni\r\nMout\r\nFigure 11: Semantics of write in MSOS and K\r\n“accumulated” write-only field semantic components are not allowed to be modified or used by rules, one\r\nonly mentions the new items being written to a write field, without ever having to mention the existing value\r\nof the field; in other words, one writes “out0 = i” instead of “out0 = o, i” where o is the existing value of the\r\nout write field.\r\nThe idea in MSOS is therefore that one can use the labels to maintain important semantic information\r\nabout the “execution” of a program. The implicit notational conventions of MSOS allow the rules to\r\npropagate this semantic information in the “back-scenes”. This apparently simple trick is actually crucial to\r\nincreasing the modularity of language definitions, because new features needing new semantic components in\r\nthe configuration can add and modify those without having to change any of the existing rules to propagate\r\nthe new semantic components, as an explicit-label framework like SOS would have to. The advantage of\r\nMSOS over SOS can perhaps be seen best when defining language features that change abruptly the execution\r\nflow of the program. Recall that in order to define a halt statement in SOS one needs to possibly more than\r\ndouble the number of rules, because each language construct needs to be changed its semantics to propagate\r\nthe “halting signal” produced by any of its subexpressions. As Figure 12 shows, in MSOS one can define halt\r\nmodularly, adding a write-only label that holds the halting value, if any generated. A top level construct,\r\nMSOS K\r\np\r\nhalt’=()\r\n−−−−−→ p\r\n0\r\nprogram p\r\nhalt’=()\r\n−−−−−→ program p\r\n0\r\n— no similar K rule needed —\r\np\r\nhalt’=v −−−−−→ p\r\n0\r\nprogram p\r\nhalt’=v −−−−−→ v\r\n— no similar K rule needed —\r\ne → e\r\n0\r\nhalt e → halt e\r\n0\r\nStmt ::= . . . | halt Exp [strict]\r\nhalt v\r\nhalt0=v −−−−−→ stuck Lhalt v|ik → LvMk\r\nFigure 12: Semantics of halt in MSOS and K\r\n“program p”, wrapping a program needs to be added to the syntax in order to know where to “catch” the\r\nhalting signal. The first rule advances the program as before if it generates no halting signal, while the\r\nsecond catches the halting value and stops the program with that value.\r\nMSOS is given a semantics based on category theory in [29], but, as the examples above show, one does\r\nnot need to understand category theory in order to understand or use MSOS. The simplest way to explain\r\nMSOS is perhaps through its automatic translation into conventional SOS: each MSOS rule can be desugared\r\ninto a rule that explicitly mentions all the fields with all their values on all the labels; this way, any MSOS\r\ndefinition becomes a conventional SOS definition with labels on transitions. It is important to realize that\r\nthe desugared SOS definition does not enjoy the modularity characteristics of the original MSOS definition\r\n(otherwise one could use MSOS as an “SOS style”); for example, if one decides to add a new label in order\r\nto accommodate a new language feature, then one needs to change all the existing SOS rules. Nevertheless,\r\nonce the MSOS-to-SOS mechanical translation is applied, one can further use the embeddings of SOS into\r\n54\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3e811afe-939c-4c57-a93d-eb3f34e9a18a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b0729c6c9017b293871ca2c64121caaf5951d23dac13e411a26f3e35ad7343f7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 570
      },
      {
        "segments": [
          {
            "segment_id": "fa394c49-1ee4-44ed-8615-3ffcbf682c02",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "rewriting logic and K described in Sections 5.1 (small-step SOS) and 5.2 (big-step SOS), and thus give an\r\nembedding of MSOS into rewriting logic and K, respectively. An embedding of MSOS in rewriting logic has\r\nalso been proposed in [21]; also, the MSOS tool [7], which can execute MSOS definitions, is implemented\r\nusing rewriting logic in Maude. While such embeddings are interesting and instructive in their own way,\r\nand they also indirectly give an intuition for the definitional capability of the various formalisms involved,\r\nwe believe that they should not be used as an absolute measure. Indeed, the whole point of MSOS is to\r\nprovide a framework facilitating one to write methodologically better SOS definitions. MSOS was, unlike\r\nK, not intended to be an alternative to SOS; the proponents of SOS will find little or no difficulty in using\r\nMSOS, and there is no doubt that MSOS brings a significant degree of modularity to SOS.\r\nTherefore, a systematic derivation of a computationally faithful K definition from an MSOS definition is\r\npossible, which allows one to use the machinery of K (rewriting and formal analysis mechanisms) for MSOS.\r\nHowever, as mentioned above, such a translation would not be “conceptually faithful”, because it would not\r\ncapture the inherent modularity of MSOS over SOS; that modularity aspect would be “lost in translation”.\r\nThat being said, in the remaining of this section we focus on conceptual similarities and differences between\r\nMSOS and K, irrespective of any particular translation of one into the other.\r\n• Perhaps the main difference between the two is that MSOS is still heavily based on conditional rules,\r\nthat is, on rules with computational premises (in addition to the conventional side conditions), while\r\nK only uses unconditional rules (possibly using side conditions). The hasty reader could obviously say\r\nthat conditional is more general than unconditional because any unconditional rule is a special case\r\nof a conditional rule, so therefore MSOS and even SOS are more general than K. First, as discussed\r\nabove and shown in detail in Sections 5.2 and 5.1, thanks to K having equations in addition to rules,\r\nthe “conditionality” of rules in SOS-like formalisms does not have any computational or definitional\r\nadvantage over unconditional rules in K, simply because one could use equations to embed a “scheduler”\r\nfor derivations using conditional rules on top of K’s derivation infrastructure based on unconditional\r\nrules. Second, conditional rules in SOS-like definitional frameworks, including MSOS, are typically\r\nused to reduce the semantics of a language construct to that of its sub-constructs; in particular, the\r\nevaluation context of a program or fragment of program is captured by a proof, or derivation context.\r\nThis is a laudable goal which proved to be particularly useful in inductive proofs. However, it comes\r\nwith a major drawback: the evaluation context is lost during the computation/evaluation, in the sense\r\nthat it is not being made available to rules. Thus, it is very hard to give SOS semantics to control\u0002intensive language constructs that non-trivially alter the evaluation context. In particular, we are not\r\naware of any natural/elegant way to give an SOS or MSOS semantics to a language construct like\r\ncall/cc7.\r\n• We do not regard the use of strictness attributes, such as those in the definitions of assignment, let and\r\nwrite above, as a major difference between MSOS and K. Indeed, MSOS or mostly any other formalism\r\ncan adopt K’s strictness attributes and desugar them into its corresponding rules. However, the way\r\nthese are desugared in K, namely into a heating/cooling unconditional rule, is of course specific to K.\r\n• Both MSOS and K make intensive use of labels: MSOS carries labeled semantic components on its\r\nsyntax-to-syntax transitions, while in K everything is in some label, including the syntax itself. There\u0002fore, unlike in MSOS, syntax has no preferential role in K. Moreover, labels in K can be “nested”\r\nand are “dynamic”, that is, the semantic or syntactic information associated to each label can be\r\nitself subject to decomposition and grouping into labels, and labels can be created and terminated\r\ndynamically, as the program evolves. Labels in MSOS are statically desugared, cannot be dynamically\r\ncreated or terminated, and can only be “top-level” (not nested) and must be tagged with a type: read\u0002only, write-only, read-write. This tagging is crucial in MSOS, being intimately used in its generation\r\n7Some proponents of SOS-like formalisms claim that constructs like call/cc are obscure and hard to use anyway, so being\r\nor not being able to define them formally is irrelevant. Our position is that a designer of a language design framework should\r\nrefrain from commenting on the usefulness of particular language constructs; this is the responsibility of the one using the\r\nframework, the language designer. In our (admittedly subjective) view, a language definitional framework worth its salt should\r\nsimply support the definition of any language feature; the fact that a definitional framework cannot define a particular feature\r\nin current use (call/cc is used in Scheme, SML, Haskell, etc.) shows a serious limitation of that framework.\r\n55\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fa394c49-1ee4-44ed-8615-3ffcbf682c02.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=73e0535aa4ec42e82ea0c60be3fe5dd4733f4e70589b85c84eb9594cb43e57a7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 847
      },
      {
        "segments": [
          {
            "segment_id": "fa394c49-1ee4-44ed-8615-3ffcbf682c02",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "rewriting logic and K described in Sections 5.1 (small-step SOS) and 5.2 (big-step SOS), and thus give an\r\nembedding of MSOS into rewriting logic and K, respectively. An embedding of MSOS in rewriting logic has\r\nalso been proposed in [21]; also, the MSOS tool [7], which can execute MSOS definitions, is implemented\r\nusing rewriting logic in Maude. While such embeddings are interesting and instructive in their own way,\r\nand they also indirectly give an intuition for the definitional capability of the various formalisms involved,\r\nwe believe that they should not be used as an absolute measure. Indeed, the whole point of MSOS is to\r\nprovide a framework facilitating one to write methodologically better SOS definitions. MSOS was, unlike\r\nK, not intended to be an alternative to SOS; the proponents of SOS will find little or no difficulty in using\r\nMSOS, and there is no doubt that MSOS brings a significant degree of modularity to SOS.\r\nTherefore, a systematic derivation of a computationally faithful K definition from an MSOS definition is\r\npossible, which allows one to use the machinery of K (rewriting and formal analysis mechanisms) for MSOS.\r\nHowever, as mentioned above, such a translation would not be “conceptually faithful”, because it would not\r\ncapture the inherent modularity of MSOS over SOS; that modularity aspect would be “lost in translation”.\r\nThat being said, in the remaining of this section we focus on conceptual similarities and differences between\r\nMSOS and K, irrespective of any particular translation of one into the other.\r\n• Perhaps the main difference between the two is that MSOS is still heavily based on conditional rules,\r\nthat is, on rules with computational premises (in addition to the conventional side conditions), while\r\nK only uses unconditional rules (possibly using side conditions). The hasty reader could obviously say\r\nthat conditional is more general than unconditional because any unconditional rule is a special case\r\nof a conditional rule, so therefore MSOS and even SOS are more general than K. First, as discussed\r\nabove and shown in detail in Sections 5.2 and 5.1, thanks to K having equations in addition to rules,\r\nthe “conditionality” of rules in SOS-like formalisms does not have any computational or definitional\r\nadvantage over unconditional rules in K, simply because one could use equations to embed a “scheduler”\r\nfor derivations using conditional rules on top of K’s derivation infrastructure based on unconditional\r\nrules. Second, conditional rules in SOS-like definitional frameworks, including MSOS, are typically\r\nused to reduce the semantics of a language construct to that of its sub-constructs; in particular, the\r\nevaluation context of a program or fragment of program is captured by a proof, or derivation context.\r\nThis is a laudable goal which proved to be particularly useful in inductive proofs. However, it comes\r\nwith a major drawback: the evaluation context is lost during the computation/evaluation, in the sense\r\nthat it is not being made available to rules. Thus, it is very hard to give SOS semantics to control\u0002intensive language constructs that non-trivially alter the evaluation context. In particular, we are not\r\naware of any natural/elegant way to give an SOS or MSOS semantics to a language construct like\r\ncall/cc7.\r\n• We do not regard the use of strictness attributes, such as those in the definitions of assignment, let and\r\nwrite above, as a major difference between MSOS and K. Indeed, MSOS or mostly any other formalism\r\ncan adopt K’s strictness attributes and desugar them into its corresponding rules. However, the way\r\nthese are desugared in K, namely into a heating/cooling unconditional rule, is of course specific to K.\r\n• Both MSOS and K make intensive use of labels: MSOS carries labeled semantic components on its\r\nsyntax-to-syntax transitions, while in K everything is in some label, including the syntax itself. There\u0002fore, unlike in MSOS, syntax has no preferential role in K. Moreover, labels in K can be “nested”\r\nand are “dynamic”, that is, the semantic or syntactic information associated to each label can be\r\nitself subject to decomposition and grouping into labels, and labels can be created and terminated\r\ndynamically, as the program evolves. Labels in MSOS are statically desugared, cannot be dynamically\r\ncreated or terminated, and can only be “top-level” (not nested) and must be tagged with a type: read\u0002only, write-only, read-write. This tagging is crucial in MSOS, being intimately used in its generation\r\n7Some proponents of SOS-like formalisms claim that constructs like call/cc are obscure and hard to use anyway, so being\r\nor not being able to define them formally is irrelevant. Our position is that a designer of a language design framework should\r\nrefrain from commenting on the usefulness of particular language constructs; this is the responsibility of the one using the\r\nframework, the language designer. In our (admittedly subjective) view, a language definitional framework worth its salt should\r\nsimply support the definition of any language feature; the fact that a definitional framework cannot define a particular feature\r\nin current use (call/cc is used in Scheme, SML, Haskell, etc.) shows a serious limitation of that framework.\r\n55\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fa394c49-1ee4-44ed-8615-3ffcbf682c02.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=73e0535aa4ec42e82ea0c60be3fe5dd4733f4e70589b85c84eb9594cb43e57a7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 847
      },
      {
        "segments": [
          {
            "segment_id": "3fae2eb4-432b-4b20-91d9-0eb20cf622da",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "of labeled transition systems. The semantics of K is a “true concurrency” one, based on unlabeled\r\nconcurrent transitions (in other words, “the necessary labeling is encoded in the state”) implicit in the\r\nunderlying rewriting mechanism. Unlike in MSOS, in K there is no special step corresponding to the\r\n“desugaring” of labels: due to the way associative and associative/commutative matching works, one\r\nsimply mentions in each rule only the configuration components of interest; this simplicity compared\r\nto MSOS is largely facilitated by the fact that rules in K are unconditional, otherwise some MSOS-like\r\nmechanism to synchronize labels in conditions with their counterparts in hypotheses would be unavoid\u0002able. Note that the nesting and dynamicity of labels is a crucial characteristic of K; for example, as\r\nseen in Section 6, each thread in our definitions corresponds to a label containing inside a computation,\r\nvarious execution stacks, the resources that particular thread holds, etc. One could argue that all this\r\ninformation can be flattened in some way or another at the top-level; however, that is neither necessary\r\nnot appealing in K. One could also argue that nested labels could be added to MSOS as well; however,\r\nsince the use of nested labels in K tends to be most effective when the syntax itself appears nested in\r\nthe configuration structure and since syntax plays a special role in MSOS, it is not clear whether it is\r\npossible or even beneficial to do that in MSOS.\r\nIt may be worth discussing in more depth the use of labels in K versus in MSOS. The MSOS definitions\r\nabove have all been given K variants which show how one makes use of similar labels in K. While this\r\nmay give the reader some intuition about the relationships and differences between the two, one should be\r\naware that this is not the only way to define these language constructs in K. The above K definitions follow\r\na common K style in which special environment labels are being maintained as part of the configuration,\r\nwhere expressions that modify the environment are “responsible” for cleaning up the environment after\r\nthey execute (using a restore computation item like above). An alternative would be to instead tag each\r\nexpression that can potentially be scheduled for evaluation with its evaluating environment; this way, one\r\nwould never need to worry about recovering environments. This was the approach that was first used in K\r\n[32] and is similar in spirit to the one followed by the CK abstract machine [] (see Section ??). Assuming\r\nexpressions e paired with their evaluation environment ρ using the pairing construct he, ρi, the K rules for\r\nassignment and let above become, respectively:\r\nLhx := v, ρ0i\r\n·\r\n|ikL σ0\r\nσ0[v/ρ0[x]]\r\nMσ\r\nLhlet x = v1 in e2\r\ne2\r\n, ρ0\r\nρ0[l/x]\r\ni|ikL σ0\r\nσ0[v1/l]\r\nMσ\r\nAs explained in Section ??, this style has the advantage that nothing needs to be done for tail-recursive\r\nfunctions: they do not increase the size of the computation structure by stacking useless restore items. How\u0002ever, this style of defining a language has the drawback that it enforces an environment-based approach, so\r\nlanguage definitions are less modular. Also, strictness attributes should either be dropped or their automatic\r\ndesugaring changed into corresponding heating/cooling rules where the environment is being silently passed\r\nto the “heated” subexpressions. Since tail recursion can be easily handled also when expressions are not\r\ntagged with their environments (see Section ??), we prefer to avoid tagging expressions with their evaluation\r\nenvironments in most K definitions.\r\nFigure 9 shows well the relationship between MSOS and K in what regards their use of labels. In MSOS,\r\nseveral semantic components corresponding to labels may be changed by each transition. For example, is the\r\nstore before the assignment transition (σ) is σ0 and the environment is ρ0, then the store after the transition\r\n(σ\r\n0\r\n) becomes σ0[v/ρ0[x]]. In K, this change of store is captured by underlying the existing store, σ0, and\r\nwriting below the line the modified store, σ0[v/ρ0[x]]; however, in K, unlike in MSOS, the “syntax” change\r\nis captured exactly the same way: the current statement is underlined, and below the line a “dot” signifies\r\nthat the assignment is simply erased from the computation structure. Both in MSOS and K the current\r\nenvironment (ρ) is accessed but let unchanged. As mentioned in the paragraph above, other semantic styles\r\nwithin K are also possible.\r\n56\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3fae2eb4-432b-4b20-91d9-0eb20cf622da.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6aa954ea6a9e057e03e764c78ba9b02d9dbceb55137f64de6010d0dad7e62d6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 744
      },
      {
        "segments": [
          {
            "segment_id": "3fae2eb4-432b-4b20-91d9-0eb20cf622da",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "of labeled transition systems. The semantics of K is a “true concurrency” one, based on unlabeled\r\nconcurrent transitions (in other words, “the necessary labeling is encoded in the state”) implicit in the\r\nunderlying rewriting mechanism. Unlike in MSOS, in K there is no special step corresponding to the\r\n“desugaring” of labels: due to the way associative and associative/commutative matching works, one\r\nsimply mentions in each rule only the configuration components of interest; this simplicity compared\r\nto MSOS is largely facilitated by the fact that rules in K are unconditional, otherwise some MSOS-like\r\nmechanism to synchronize labels in conditions with their counterparts in hypotheses would be unavoid\u0002able. Note that the nesting and dynamicity of labels is a crucial characteristic of K; for example, as\r\nseen in Section 6, each thread in our definitions corresponds to a label containing inside a computation,\r\nvarious execution stacks, the resources that particular thread holds, etc. One could argue that all this\r\ninformation can be flattened in some way or another at the top-level; however, that is neither necessary\r\nnot appealing in K. One could also argue that nested labels could be added to MSOS as well; however,\r\nsince the use of nested labels in K tends to be most effective when the syntax itself appears nested in\r\nthe configuration structure and since syntax plays a special role in MSOS, it is not clear whether it is\r\npossible or even beneficial to do that in MSOS.\r\nIt may be worth discussing in more depth the use of labels in K versus in MSOS. The MSOS definitions\r\nabove have all been given K variants which show how one makes use of similar labels in K. While this\r\nmay give the reader some intuition about the relationships and differences between the two, one should be\r\naware that this is not the only way to define these language constructs in K. The above K definitions follow\r\na common K style in which special environment labels are being maintained as part of the configuration,\r\nwhere expressions that modify the environment are “responsible” for cleaning up the environment after\r\nthey execute (using a restore computation item like above). An alternative would be to instead tag each\r\nexpression that can potentially be scheduled for evaluation with its evaluating environment; this way, one\r\nwould never need to worry about recovering environments. This was the approach that was first used in K\r\n[32] and is similar in spirit to the one followed by the CK abstract machine [] (see Section ??). Assuming\r\nexpressions e paired with their evaluation environment ρ using the pairing construct he, ρi, the K rules for\r\nassignment and let above become, respectively:\r\nLhx := v, ρ0i\r\n·\r\n|ikL σ0\r\nσ0[v/ρ0[x]]\r\nMσ\r\nLhlet x = v1 in e2\r\ne2\r\n, ρ0\r\nρ0[l/x]\r\ni|ikL σ0\r\nσ0[v1/l]\r\nMσ\r\nAs explained in Section ??, this style has the advantage that nothing needs to be done for tail-recursive\r\nfunctions: they do not increase the size of the computation structure by stacking useless restore items. How\u0002ever, this style of defining a language has the drawback that it enforces an environment-based approach, so\r\nlanguage definitions are less modular. Also, strictness attributes should either be dropped or their automatic\r\ndesugaring changed into corresponding heating/cooling rules where the environment is being silently passed\r\nto the “heated” subexpressions. Since tail recursion can be easily handled also when expressions are not\r\ntagged with their environments (see Section ??), we prefer to avoid tagging expressions with their evaluation\r\nenvironments in most K definitions.\r\nFigure 9 shows well the relationship between MSOS and K in what regards their use of labels. In MSOS,\r\nseveral semantic components corresponding to labels may be changed by each transition. For example, is the\r\nstore before the assignment transition (σ) is σ0 and the environment is ρ0, then the store after the transition\r\n(σ\r\n0\r\n) becomes σ0[v/ρ0[x]]. In K, this change of store is captured by underlying the existing store, σ0, and\r\nwriting below the line the modified store, σ0[v/ρ0[x]]; however, in K, unlike in MSOS, the “syntax” change\r\nis captured exactly the same way: the current statement is underlined, and below the line a “dot” signifies\r\nthat the assignment is simply erased from the computation structure. Both in MSOS and K the current\r\nenvironment (ρ) is accessed but let unchanged. As mentioned in the paragraph above, other semantic styles\r\nwithin K are also possible.\r\n56\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3fae2eb4-432b-4b20-91d9-0eb20cf622da.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6aa954ea6a9e057e03e764c78ba9b02d9dbceb55137f64de6010d0dad7e62d6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 744
      },
      {
        "segments": [
          {
            "segment_id": "0482332a-b2f9-4903-8e12-77fa3b4cd8ec",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 10 shows the conceptually major difference between MSOS and K. MSOS inherits from SOS its\r\ndefinitional style based on the use of conditional rules, while K builds upon the belief that conditional rules\r\nare unnecessary in programming language definitions. In order to prepare the right semantic content for the\r\ncondition transition, in MSOS one is expected to explicitly state which label contents change; the semantic\r\ncontents of every other label stays unchanged. While in K one is also expected to explicitly change the\r\ncontents of the very same labels using its unique mechanism to “change” (underline what changes and write\r\nthe new contents underneath the line), one does that using one unconditional rule. The next subexpression\r\nto evaluate is “scheduled” on the computation structure, without worrying about ever “coming back” to\r\nthe original let construct. If additional work needs to be done after processing the subexpression, such as\r\nrestoring the environment in K definition in Figure 10, appropriate computation items need to be a priori\r\nplaced on the computation structure. Depending upon the style adopted, more, less, or no post-processing is\r\nrequired; for example, the style adopted in the paragraph above requires no environment restoration, because\r\neach expression carries its evaluation environment with it. Because of K’s “no coming back” approach, no\r\nrules are necessary to state what to do once the subexpression is completely processed; in particular, no K\r\nrule corresponding to the second MSOS rule in Figure 10 is necessary.\r\nLet us next discuss the similarities and differences between MSOS and K in the context of defining\r\ncontrol-intensive statements, such as the halt statement in Figure 12. Because of its conditional-rule-based\r\nnature, MSOS needs to declare a top level construct, “program p”, in addition to the actual halt construct;\r\nthis way, one can either let the computation advance normally when no halting signal was recorded in the\r\nwrite-only halt’ label (first rule), or stop it at the top level appropriately when a halting signal was recorded\r\nin the label (second rule). Since in K the complete computation is explicit in the configuration structure, one\r\nneeds not add any artificial construct (e.g., program) in order to define another (e.g., halt) and consequently\r\nno rules deciding whether the artificial construct should let the computation go or stop it. All one needs to\r\ndo when a “halt v” is encountered is to discard the existing computation and replace it by v. This puts the\r\nsame little load on the language designer as a context reduction definition of halt (see Section ??).\r\nTo better compare MSOS and K in the context of control-intensive statements, Figure 13 shows the\r\ndefinition of exceptions in both formalisms. Figure 13 also shows that there are cases where labels are\r\nneeded in MSOS definitions where corresponding labels are not needed in corresponding K definitions, and\r\nvice-versa. Like for halt, a special write-only label, throw’ in this case, is necessary in the MSOS definition.\r\nMSOS K\r\ne1\r\nthrow’=()\r\n−−−−−−→ e\r\n0\r\n1\r\ntry e1 catch(x)e2\r\nthrow’=()\r\n−−−−−−→ try e\r\n0\r\n1\r\ncatch(x)e2\r\nLtry e1 catch(x)e2 y r\r\ne1 y popx\r\nMk L ·\r\nhr, ρ0i\r\n|iχLρ0Mρ\r\ntry v catch(x)e2 −→ v Lv y popx\r\nr\r\nMk Lhr, i\r\n·\r\n|iχ\r\ne1\r\nthrow’=v −−−−−−→ e\r\n0\r\n1\r\ntry e1 catch(x)e2\r\nthrow’=()\r\n−−−−−−→ (λx.e2)v\r\nL throw v y\r\n(λx.e2)v y r\r\nMk Lhr, ρ0i\r\n·\r\n|iχL\r\nρ0\r\nMρ\r\ne → e\r\n0\r\nthrow e → throw e\r\n0\r\nStmt ::= . . . | throw Exp [strict]\r\nthrow v\r\nthrow’=v −−−−−−→ stuck — no similar K rule needed —\r\nFigure 13: Semantics of parametric exceptions in MSOS and K\r\nThe MSOS rules are straightforward, following the same intuition as for the definition of halt. The first MSOS\r\n57\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0482332a-b2f9-4903-8e12-77fa3b4cd8ec.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=59d4b9b294da1e83ce6a4bb9723d59b742d6481f4045ab2c0145e845167d2533",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 634
      },
      {
        "segments": [
          {
            "segment_id": "0482332a-b2f9-4903-8e12-77fa3b4cd8ec",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 10 shows the conceptually major difference between MSOS and K. MSOS inherits from SOS its\r\ndefinitional style based on the use of conditional rules, while K builds upon the belief that conditional rules\r\nare unnecessary in programming language definitions. In order to prepare the right semantic content for the\r\ncondition transition, in MSOS one is expected to explicitly state which label contents change; the semantic\r\ncontents of every other label stays unchanged. While in K one is also expected to explicitly change the\r\ncontents of the very same labels using its unique mechanism to “change” (underline what changes and write\r\nthe new contents underneath the line), one does that using one unconditional rule. The next subexpression\r\nto evaluate is “scheduled” on the computation structure, without worrying about ever “coming back” to\r\nthe original let construct. If additional work needs to be done after processing the subexpression, such as\r\nrestoring the environment in K definition in Figure 10, appropriate computation items need to be a priori\r\nplaced on the computation structure. Depending upon the style adopted, more, less, or no post-processing is\r\nrequired; for example, the style adopted in the paragraph above requires no environment restoration, because\r\neach expression carries its evaluation environment with it. Because of K’s “no coming back” approach, no\r\nrules are necessary to state what to do once the subexpression is completely processed; in particular, no K\r\nrule corresponding to the second MSOS rule in Figure 10 is necessary.\r\nLet us next discuss the similarities and differences between MSOS and K in the context of defining\r\ncontrol-intensive statements, such as the halt statement in Figure 12. Because of its conditional-rule-based\r\nnature, MSOS needs to declare a top level construct, “program p”, in addition to the actual halt construct;\r\nthis way, one can either let the computation advance normally when no halting signal was recorded in the\r\nwrite-only halt’ label (first rule), or stop it at the top level appropriately when a halting signal was recorded\r\nin the label (second rule). Since in K the complete computation is explicit in the configuration structure, one\r\nneeds not add any artificial construct (e.g., program) in order to define another (e.g., halt) and consequently\r\nno rules deciding whether the artificial construct should let the computation go or stop it. All one needs to\r\ndo when a “halt v” is encountered is to discard the existing computation and replace it by v. This puts the\r\nsame little load on the language designer as a context reduction definition of halt (see Section ??).\r\nTo better compare MSOS and K in the context of control-intensive statements, Figure 13 shows the\r\ndefinition of exceptions in both formalisms. Figure 13 also shows that there are cases where labels are\r\nneeded in MSOS definitions where corresponding labels are not needed in corresponding K definitions, and\r\nvice-versa. Like for halt, a special write-only label, throw’ in this case, is necessary in the MSOS definition.\r\nMSOS K\r\ne1\r\nthrow’=()\r\n−−−−−−→ e\r\n0\r\n1\r\ntry e1 catch(x)e2\r\nthrow’=()\r\n−−−−−−→ try e\r\n0\r\n1\r\ncatch(x)e2\r\nLtry e1 catch(x)e2 y r\r\ne1 y popx\r\nMk L ·\r\nhr, ρ0i\r\n|iχLρ0Mρ\r\ntry v catch(x)e2 −→ v Lv y popx\r\nr\r\nMk Lhr, i\r\n·\r\n|iχ\r\ne1\r\nthrow’=v −−−−−−→ e\r\n0\r\n1\r\ntry e1 catch(x)e2\r\nthrow’=()\r\n−−−−−−→ (λx.e2)v\r\nL throw v y\r\n(λx.e2)v y r\r\nMk Lhr, ρ0i\r\n·\r\n|iχL\r\nρ0\r\nMρ\r\ne → e\r\n0\r\nthrow e → throw e\r\n0\r\nStmt ::= . . . | throw Exp [strict]\r\nthrow v\r\nthrow’=v −−−−−−→ stuck — no similar K rule needed —\r\nFigure 13: Semantics of parametric exceptions in MSOS and K\r\nThe MSOS rules are straightforward, following the same intuition as for the definition of halt. The first MSOS\r\n57\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0482332a-b2f9-4903-8e12-77fa3b4cd8ec.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=59d4b9b294da1e83ce6a4bb9723d59b742d6481f4045ab2c0145e845167d2533",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 634
      },
      {
        "segments": [
          {
            "segment_id": "20225be8-18be-4645-9b21-2596a9dc678e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "rule for throw states nothing but the fact that it is strict, so its K correspondent is obvious: a strictness\r\nattribute. K needs overall fewer rules to complete the semantics of exceptions, namely three instead of four.\r\nAn exception stack is added to the configuration, here referred to using the label χ; the current environment\r\nand computation are stacked when the try/catch is initiated, and are then properly recovered when the\r\ntried block terminates (normally or abnormally). Note that it is straightforward to modify the K semantics\r\nof exceptions above so that once an exception is thrown the program is terminated after executing the\r\ncatch block. All we need to do is to omit adding r after (λx.e2)v in the third K rule; to achieve the same\r\nmodification in MSOS one would need to implement a top-level catching mechanism like the one for halt in\r\nFigure 12. The exception stack in our K definition of exceptions could be avoided, though we prefer not\r\nto. For example, one could place special markers in the computation structure when exception blocks are\r\ninitiated, and then, when exceptions are thrown, discard computation items until corresponding markers are\r\nreached. This is easy to define but it is less efficient when executed. When one can execute and formally\r\nanalyze programming language definitions (e.g., model checking them), efficiency is an important aspect of\r\na language definition.\r\nStrengths. MSOS has all the strengths of SOS. Moreover, MSOS offers the language designer a framework\r\nwhere modular language definitions can be developed. In other words, if one uses MSOS properly, one needs\r\nnot revisit definitions of unrelated language features when adding new features to a language.\r\nWeaknesses. With respect to definitional strength, MSOS does not improve over SOS. Any MSOS defi\u0002nition can be completely desugared into an SOS definition, which also gives the labeled-transition system\r\nsemantics underlying MSOS. In other words, if the semantics of a language or language feature cannot be\r\ndefined using SOS, then it cannot be defined using MSOS either. In particular, one can only give interleaving\r\nsemantics to concurrent languages/systems using MSOS8. Another important limitation of MSOS is that it\r\ndoes not have an explicit representation and control over evaluation contexts, thus having inherent difficulty\r\nto define control-intensive language constructs. For example, at our knowledge, there is still no MSOS def\u0002inition of constructs like call/cc. In a discussion with Peter Mosses in December 2007, it turned out that\r\nthere could be some systematic way to provide a handle on evaluation contexts in MSOS. The idea would be\r\nto use a “builtin” label that “automatically” collects the evaluation context as the proof tree of a derivation\r\nis being build. Since in SOS-like formalisms, including MSOS, the evaluation context is captured as a proof\r\ntree, in order for the above to work it is important to understand how a proof tree can be obtained back\r\nfrom an evaluation context. Also, having an explicit representation of the evaluation context in one of its\r\nlabels may make the use of conditional rules and SOS-like derivation trees redundant.\r\n5.4 Context Reduction: Reduction Semantics with Evaluation Contexts\r\nReduction semantics with evaluation contexts, called context reduction for simplicity in this paper, has been\r\nintroduced by Felleisen and his collaborators (see, e.g., [11, 40]) as a variant SOS where the evaluation context\r\nis explicit in the term being reduced.\r\n5.4.1 Evaluation Contexts\r\nIn a context reduction language definition one starts by defining the syntax of evaluation contexts, or simply\r\njust contexts, which is typically done by means of a context-free grammar (CFG). A context is a program or\r\nfragment of program with a “hole”, the hole being a placeholder where the next computational step takes\r\nplace. Figure 14 shows the CFG of evaluation contexts defined for a simple imperative language like that\r\nin Figure 1; as in the previous section, we also show the corresponding K definition (the right column) for\r\n8One can, again, argue that interleaving semantics is all that matters anyway. Our position is, again, that “interleaving\r\nversus true concurrency” is an important choice that needs to be addressed by the language designer not by the designer of\r\nlanguage design frameworks. From a definitional framework design perspective, the very fact that there are language designers\r\nwho prefer a true concurrency semantics for their language (and there are many) is overwhelming evidence that it should be\r\nsimply supported by the framework.\r\n58\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/20225be8-18be-4645-9b21-2596a9dc678e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=00b3e460db83db20b1162adda92d989954d1eed2aa58f25de9d8c47d5b810b3b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 744
      },
      {
        "segments": [
          {
            "segment_id": "20225be8-18be-4645-9b21-2596a9dc678e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "rule for throw states nothing but the fact that it is strict, so its K correspondent is obvious: a strictness\r\nattribute. K needs overall fewer rules to complete the semantics of exceptions, namely three instead of four.\r\nAn exception stack is added to the configuration, here referred to using the label χ; the current environment\r\nand computation are stacked when the try/catch is initiated, and are then properly recovered when the\r\ntried block terminates (normally or abnormally). Note that it is straightforward to modify the K semantics\r\nof exceptions above so that once an exception is thrown the program is terminated after executing the\r\ncatch block. All we need to do is to omit adding r after (λx.e2)v in the third K rule; to achieve the same\r\nmodification in MSOS one would need to implement a top-level catching mechanism like the one for halt in\r\nFigure 12. The exception stack in our K definition of exceptions could be avoided, though we prefer not\r\nto. For example, one could place special markers in the computation structure when exception blocks are\r\ninitiated, and then, when exceptions are thrown, discard computation items until corresponding markers are\r\nreached. This is easy to define but it is less efficient when executed. When one can execute and formally\r\nanalyze programming language definitions (e.g., model checking them), efficiency is an important aspect of\r\na language definition.\r\nStrengths. MSOS has all the strengths of SOS. Moreover, MSOS offers the language designer a framework\r\nwhere modular language definitions can be developed. In other words, if one uses MSOS properly, one needs\r\nnot revisit definitions of unrelated language features when adding new features to a language.\r\nWeaknesses. With respect to definitional strength, MSOS does not improve over SOS. Any MSOS defi\u0002nition can be completely desugared into an SOS definition, which also gives the labeled-transition system\r\nsemantics underlying MSOS. In other words, if the semantics of a language or language feature cannot be\r\ndefined using SOS, then it cannot be defined using MSOS either. In particular, one can only give interleaving\r\nsemantics to concurrent languages/systems using MSOS8. Another important limitation of MSOS is that it\r\ndoes not have an explicit representation and control over evaluation contexts, thus having inherent difficulty\r\nto define control-intensive language constructs. For example, at our knowledge, there is still no MSOS def\u0002inition of constructs like call/cc. In a discussion with Peter Mosses in December 2007, it turned out that\r\nthere could be some systematic way to provide a handle on evaluation contexts in MSOS. The idea would be\r\nto use a “builtin” label that “automatically” collects the evaluation context as the proof tree of a derivation\r\nis being build. Since in SOS-like formalisms, including MSOS, the evaluation context is captured as a proof\r\ntree, in order for the above to work it is important to understand how a proof tree can be obtained back\r\nfrom an evaluation context. Also, having an explicit representation of the evaluation context in one of its\r\nlabels may make the use of conditional rules and SOS-like derivation trees redundant.\r\n5.4 Context Reduction: Reduction Semantics with Evaluation Contexts\r\nReduction semantics with evaluation contexts, called context reduction for simplicity in this paper, has been\r\nintroduced by Felleisen and his collaborators (see, e.g., [11, 40]) as a variant SOS where the evaluation context\r\nis explicit in the term being reduced.\r\n5.4.1 Evaluation Contexts\r\nIn a context reduction language definition one starts by defining the syntax of evaluation contexts, or simply\r\njust contexts, which is typically done by means of a context-free grammar (CFG). A context is a program or\r\nfragment of program with a “hole”, the hole being a placeholder where the next computational step takes\r\nplace. Figure 14 shows the CFG of evaluation contexts defined for a simple imperative language like that\r\nin Figure 1; as in the previous section, we also show the corresponding K definition (the right column) for\r\n8One can, again, argue that interleaving semantics is all that matters anyway. Our position is, again, that “interleaving\r\nversus true concurrency” is an important choice that needs to be addressed by the language designer not by the designer of\r\nlanguage design frameworks. From a definitional framework design perspective, the very fact that there are language designers\r\nwho prefer a true concurrency semantics for their language (and there are many) is overwhelming evidence that it should be\r\nsimply supported by the framework.\r\n58\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/20225be8-18be-4645-9b21-2596a9dc678e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=00b3e460db83db20b1162adda92d989954d1eed2aa58f25de9d8c47d5b810b3b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 744
      },
      {
        "segments": [
          {
            "segment_id": "f687736d-6f4a-404c-bd55-afe20fbc7c52",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "a direct comparison. Note how the intended evaluation strategies of the various language constructs are\r\nContext syntax Language syntax K Syntax annotation\r\nCxt ::= \u0003\r\n| Cxt + AExp | AExp + Cxt\r\n| Cxt ≤ AExp | Int ≤ Cxt\r\n| not Cxt\r\n| Cxt andBExp\r\n| Name := Cxt\r\n| Cxt; Stmt\r\n| if Cxt then Stmt else Stmt\r\n| halt Cxt\r\n| Cxt; AExp\r\nAExp ::= AExp + AExp\r\n| AExp ≤ AExp\r\nBExp ::= not BExp\r\n| BExp and BExp\r\nStmt ::= Name := AExp\r\n| Stmt; Stmt\r\n| if BExp then Stmt else Stmt\r\n| halt AExp\r\n| Stmt; AExp\r\nstrict\r\nseqstrict\r\nstrict\r\nstrict(1)\r\nstrict(2)\r\nstrict(1)\r\nstrict\r\nFigure 14: Evaluation contexts and their K correspondent strictness attributes\r\nreflected in the definition of evaluation contexts: “+” is non-deterministically strict (so the evaluation hole\r\n“\u0003” can go to either of its subexpressions), “≤” is sequentially strict (“\u0003” goes to the first subexpression until\r\nevaluated to an Int, then to the second subexpression), “and” is intended to be shortcut (via an appropriate\r\nrule) so only its first argument needs to be evaluated, “:=” is strict only its second argument while sequential\r\ncompositions (both of them) “;” are strict in their first argument, and the conditional is only strict in its\r\nfirst argument. Note that there is no production “Cxt ::= ... | while Cxt do Stmt” as one may (wrongly)\r\nexpect. That is because such a production would allow the evaluation of the boolean expression in the while\r\nloop to a boolean value; supposing that that value is true, then, unless one modifies the syntax in some\r\nrather awkward way, there is no chance to recover the original boolean expression to evaluate it after the\r\nevaluation of the statement. The preferred solution to handle loops remains the same as in SOS, namely to\r\nexplicitly unroll them into conditional statements. To avoid ambiguous parsing, from here on we assume left\r\nassociativity for binary constructs and also take a liberty to use parentheses for grouping even though they\r\nwere not defined explicitly as part of the CFG.\r\nHere are some examples of correct evaluation contexts:\r\n\u0003\r\n3 + \u0003\r\n3 ≤ \u0003 + 7\r\n5 ≤ \u0003 + (3 + a), where a is any well-formed arithmetic expression\r\nif \u0003 then s1 else s2, where s1 and s2 are any well-formed statements\r\n\u0003; x := 5, where x is any variable\r\n\u0003; x + y, where x and y are any variables\r\nHere are some examples of incorrect evaluation contexts:\r\n\u0003 + (2 + \u0003) — a context can have only one hole\r\nx + y — a context must contain a hole\r\nx + y; \u0003 — one cannot place a semicolon after an expression in our grammar\r\n\u0003 := 7 — the grammar of contexts disallows this; holes are placeholders where computations can\r\ntake place\r\nif true then \u0003 else skip — a hole (or a computational step) can only appear in the condition of\r\na conditional; one must first eliminate the conditional, using a rule\r\n59\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f687736d-6f4a-404c-bd55-afe20fbc7c52.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d3d5d0169f0dd479a7973ba2e63781dcdec6297bf2a4c73231839af1eafd572f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "f687736d-6f4a-404c-bd55-afe20fbc7c52",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "a direct comparison. Note how the intended evaluation strategies of the various language constructs are\r\nContext syntax Language syntax K Syntax annotation\r\nCxt ::= \u0003\r\n| Cxt + AExp | AExp + Cxt\r\n| Cxt ≤ AExp | Int ≤ Cxt\r\n| not Cxt\r\n| Cxt andBExp\r\n| Name := Cxt\r\n| Cxt; Stmt\r\n| if Cxt then Stmt else Stmt\r\n| halt Cxt\r\n| Cxt; AExp\r\nAExp ::= AExp + AExp\r\n| AExp ≤ AExp\r\nBExp ::= not BExp\r\n| BExp and BExp\r\nStmt ::= Name := AExp\r\n| Stmt; Stmt\r\n| if BExp then Stmt else Stmt\r\n| halt AExp\r\n| Stmt; AExp\r\nstrict\r\nseqstrict\r\nstrict\r\nstrict(1)\r\nstrict(2)\r\nstrict(1)\r\nstrict\r\nFigure 14: Evaluation contexts and their K correspondent strictness attributes\r\nreflected in the definition of evaluation contexts: “+” is non-deterministically strict (so the evaluation hole\r\n“\u0003” can go to either of its subexpressions), “≤” is sequentially strict (“\u0003” goes to the first subexpression until\r\nevaluated to an Int, then to the second subexpression), “and” is intended to be shortcut (via an appropriate\r\nrule) so only its first argument needs to be evaluated, “:=” is strict only its second argument while sequential\r\ncompositions (both of them) “;” are strict in their first argument, and the conditional is only strict in its\r\nfirst argument. Note that there is no production “Cxt ::= ... | while Cxt do Stmt” as one may (wrongly)\r\nexpect. That is because such a production would allow the evaluation of the boolean expression in the while\r\nloop to a boolean value; supposing that that value is true, then, unless one modifies the syntax in some\r\nrather awkward way, there is no chance to recover the original boolean expression to evaluate it after the\r\nevaluation of the statement. The preferred solution to handle loops remains the same as in SOS, namely to\r\nexplicitly unroll them into conditional statements. To avoid ambiguous parsing, from here on we assume left\r\nassociativity for binary constructs and also take a liberty to use parentheses for grouping even though they\r\nwere not defined explicitly as part of the CFG.\r\nHere are some examples of correct evaluation contexts:\r\n\u0003\r\n3 + \u0003\r\n3 ≤ \u0003 + 7\r\n5 ≤ \u0003 + (3 + a), where a is any well-formed arithmetic expression\r\nif \u0003 then s1 else s2, where s1 and s2 are any well-formed statements\r\n\u0003; x := 5, where x is any variable\r\n\u0003; x + y, where x and y are any variables\r\nHere are some examples of incorrect evaluation contexts:\r\n\u0003 + (2 + \u0003) — a context can have only one hole\r\nx + y — a context must contain a hole\r\nx + y; \u0003 — one cannot place a semicolon after an expression in our grammar\r\n\u0003 := 7 — the grammar of contexts disallows this; holes are placeholders where computations can\r\ntake place\r\nif true then \u0003 else skip — a hole (or a computational step) can only appear in the condition of\r\na conditional; one must first eliminate the conditional, using a rule\r\n59\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f687736d-6f4a-404c-bd55-afe20fbc7c52.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d3d5d0169f0dd479a7973ba2e63781dcdec6297bf2a4c73231839af1eafd572f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "3d81df7a-0674-401a-9015-aa1a175081f8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "skip; \u0003 — one cannot evaluate the second statement in a sequential composition; skip must be\r\ndiscarded first using a rule\r\nContext reduction operational semantics is based on a tacitly assumed parsing-like mechanism that takes\r\na program or a fragment of program p and decomposes it into a context c and a subprogram or fragment of\r\nprogram e, such that p = c[e]. Here are some examples of such decompositions:\r\n7 = (\u0003)[7]\r\n3 + x = (3 + \u0003)[x] = (\u0003 + x)[3] = (\u0003)[3 + x]\r\n3 ≤ (2 + x) + 7 = (3 ≤ \u0003 + 7)[2 + x] = (\u0003 ≤ (2 + x) + 7)[3] = ...\r\nIf one picks the empty context c = \u0003 in the decomposition of p as c[e] as we did in the first example above,\r\nthen e is p and thus the characteristic rule of context reduction defined below is useless. Choosing good\r\nstrategies to search for splits of terms into contextual representations can be a key factor in implementations\r\nof context reduction engines; in our experiments with embeddings of context reduction into rewriting logic\r\n(see Section 5.4.7), this was the factor that influenced the performance of the resulting reduction engine\r\nthe most; in our experiments, for example, context reduction was most effective when a depth-first-search\r\nstrategy for contextual representations was employed. For simplicity, we considered only one type of context\r\nin Figure 14, but in general one can have various types, depending upon the types of their “holes” and of\r\ntheir “result”.\r\n5.4.2 The Characteristic Context Reduction Rule\r\nThe characteristic reduction rule underlying context reduction is\r\ne → e\r\n0\r\nc[e] → c[e\r\n0\r\n]\r\n,\r\nwhere c is any appropriate evaluation context (i.e., such that c[e] and c[e\r\n0\r\n] are well-formed programs or\r\nfragments of program), capturing the intuition that reductions are allowed to take place only in appropriate\r\nevaluation contexts. Context reduction tends to be a purely syntactic definitional framework (following the\r\nslogan “everything is syntax”). If semantic components are necessary in a particular definition, then they\r\nare typically “swallowed by the syntax”. For example, if one needs a state as part of the configuration for a\r\nparticular language definition, then one adds the context production\r\nCxt ::= · · · | hCxt, Statei,\r\nwhere the State, an inherently semantic component of the semantics, becomes part of the evaluation context.\r\nIf one does not like mixing syntactic and semantic components of a definition and prefers instead to work\r\nwith configuration tuples like in SOS, then one can9 make use of the contextual representation notation only\r\non the syntactic component of configurations, case in which the characteristic reduction rule becomes\r\nhe, γi → he\r\n0\r\n, γ0i\r\nhc[e], γi → hc[e\r\n0\r\n], γ0i\r\n,\r\nwhere γ and γ\r\n0\r\nconsist of configuration semantic components that are necessary to evaluate e and e\r\n0\r\n,\r\nrespectively, such as stores, stacks, locks, etc. The first type of characteristic reduction rule above can be\r\nseen as an instance of the second when γ is empty. Advantages and disadvantages of these two styles are\r\ndiscussed in Section 5.4.4.\r\nWhen characteristic reduction rules like above are applied, we say that e reduces to e\r\n0\r\nin context c.\r\nInterestingly, the characteristic rule of context reduction tends to be the only “conditional” rule, in the sense\r\nthat the remaining rules take no reduction premises (though they may still require side conditions). The\r\n9We are not aware of such uses of context reduction in the literature.\r\n60\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3d81df7a-0674-401a-9015-aa1a175081f8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e8c90cf0765dd49ab8b8e96ef9e5c1bf76cb8af967c29155538b8fb510e76a5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 601
      },
      {
        "segments": [
          {
            "segment_id": "3d81df7a-0674-401a-9015-aa1a175081f8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "skip; \u0003 — one cannot evaluate the second statement in a sequential composition; skip must be\r\ndiscarded first using a rule\r\nContext reduction operational semantics is based on a tacitly assumed parsing-like mechanism that takes\r\na program or a fragment of program p and decomposes it into a context c and a subprogram or fragment of\r\nprogram e, such that p = c[e]. Here are some examples of such decompositions:\r\n7 = (\u0003)[7]\r\n3 + x = (3 + \u0003)[x] = (\u0003 + x)[3] = (\u0003)[3 + x]\r\n3 ≤ (2 + x) + 7 = (3 ≤ \u0003 + 7)[2 + x] = (\u0003 ≤ (2 + x) + 7)[3] = ...\r\nIf one picks the empty context c = \u0003 in the decomposition of p as c[e] as we did in the first example above,\r\nthen e is p and thus the characteristic rule of context reduction defined below is useless. Choosing good\r\nstrategies to search for splits of terms into contextual representations can be a key factor in implementations\r\nof context reduction engines; in our experiments with embeddings of context reduction into rewriting logic\r\n(see Section 5.4.7), this was the factor that influenced the performance of the resulting reduction engine\r\nthe most; in our experiments, for example, context reduction was most effective when a depth-first-search\r\nstrategy for contextual representations was employed. For simplicity, we considered only one type of context\r\nin Figure 14, but in general one can have various types, depending upon the types of their “holes” and of\r\ntheir “result”.\r\n5.4.2 The Characteristic Context Reduction Rule\r\nThe characteristic reduction rule underlying context reduction is\r\ne → e\r\n0\r\nc[e] → c[e\r\n0\r\n]\r\n,\r\nwhere c is any appropriate evaluation context (i.e., such that c[e] and c[e\r\n0\r\n] are well-formed programs or\r\nfragments of program), capturing the intuition that reductions are allowed to take place only in appropriate\r\nevaluation contexts. Context reduction tends to be a purely syntactic definitional framework (following the\r\nslogan “everything is syntax”). If semantic components are necessary in a particular definition, then they\r\nare typically “swallowed by the syntax”. For example, if one needs a state as part of the configuration for a\r\nparticular language definition, then one adds the context production\r\nCxt ::= · · · | hCxt, Statei,\r\nwhere the State, an inherently semantic component of the semantics, becomes part of the evaluation context.\r\nIf one does not like mixing syntactic and semantic components of a definition and prefers instead to work\r\nwith configuration tuples like in SOS, then one can9 make use of the contextual representation notation only\r\non the syntactic component of configurations, case in which the characteristic reduction rule becomes\r\nhe, γi → he\r\n0\r\n, γ0i\r\nhc[e], γi → hc[e\r\n0\r\n], γ0i\r\n,\r\nwhere γ and γ\r\n0\r\nconsist of configuration semantic components that are necessary to evaluate e and e\r\n0\r\n,\r\nrespectively, such as stores, stacks, locks, etc. The first type of characteristic reduction rule above can be\r\nseen as an instance of the second when γ is empty. Advantages and disadvantages of these two styles are\r\ndiscussed in Section 5.4.4.\r\nWhen characteristic reduction rules like above are applied, we say that e reduces to e\r\n0\r\nin context c.\r\nInterestingly, the characteristic rule of context reduction tends to be the only “conditional” rule, in the sense\r\nthat the remaining rules take no reduction premises (though they may still require side conditions). The\r\n9We are not aware of such uses of context reduction in the literature.\r\n60\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3d81df7a-0674-401a-9015-aa1a175081f8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e8c90cf0765dd49ab8b8e96ef9e5c1bf76cb8af967c29155538b8fb510e76a5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 601
      },
      {
        "segments": [
          {
            "segment_id": "3b04475f-1fef-43e1-97ba-99fdcc5bc683",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "characteristic rules above are essentially a convenience to the designer, so that one can write semantic rules\r\nmore compactly like “true and b → b” instead of “c[true and b] → c[b]”. The essence of context reduction is\r\nnot its characteristic reduction rule, but its approach in defining evaluation contexts as a grammar and then\r\nusing them as an explicit part of languages or calculi definitions. For example, if for some reasons one does\r\nnot want to have an “implicit” characteristic rule, say because one’s executional framework is unconditional,\r\nthen one can simply replace each rule “l → r” with a rule “c[l] → c[r]”, stating “explicitly” that the reduction\r\nfrom l to r takes place in context. The characteristic rule of context reduction can therefore be regarded\r\nas “syntactic sugar”, or convenience to the designer. In our theoretical developments in Sections 5.4.5 and\r\nSection 5.4.6 translating context reduction definitions automatically into rewriting logic and K definitions,\r\nrespectively, we are going to assume the “desugared” version of context reduction rules.\r\n5.4.3 From One to Many Steps\r\nThe reduction relation → above captures precisely one computational step, so it is commonly called a one\u0002step or a small-step reduction relation. If Γ is a context reduction definition, then we write Γ ` t → t\r\n0\r\nwhenever t → t\r\n0\r\ncan be derived as a small-step reduction using the rules in Γ (including the characteristic\r\nrule(s), if any). The one step reduction relation captures the computational capability of the defined system\r\nand is particularly useful in formal proofs. However, to “execute” context reduction definitions one needs\r\nto apply the one-step reduction relation repetitively. The following two derivation rules define the transitive\r\nclosure of the one-step reduction relation:\r\nt → t\r\n0\r\nt \u0010 t\r\n0\r\nand\r\nt → u, u \u0010 t\r\n00\r\nt \u0010 t\r\n0\r\nAs usual, we write Γ ` t \u0010 t\r\n0 whenever t \u0010 t0\r\nis derivable using all the rules in Γ plus the two rules above.\r\n5.4.4 An Example\r\nThanks to the characteristic reduction rule of context reduction above which is implicit in context reduction\r\nlanguage definitions, unlike in SOS one only needs to worry about giving rules capturing basic computation\r\nsteps and not how computations are propagated along the syntax. With this in mind, context reduction\r\ndefinitions of the simple imperative language in Figure 1 can be easily derived from a conventional SOS\r\ndefinition of the language. Figure 15 shows two complete context reduction semantic definitions for the\r\nsimple imperative language in Figure 1, one in which the state is encapsulated as part of the evaluation\r\ncontext (Version 1), and another one where the state is added as part of the configuration (Version 2).\r\nVersion 1 has the advantage that reduction rules look simpler and more natural (syntactic), without\r\ncarrying the state as part of the configuration everywhere just because one or two rules may need it, like\r\nin SOS. The disadvantage of this approach is that what used to be called “syntax” now contains rather\r\nsemantic components, such as the state of the program. Note that once one adds syntax to evaluation\r\ncontexts that does not correspond to constructs in the syntax of the language, such as the pairing of a\r\ncontext and a state, one needs to also extend the original syntax with corresponding constructs, so that\r\nthe parsing-like mechanism decomposing a syntactic term into a context and a redex can be applied. For\r\nexample, the production “Cxt ::= hCxt, Statei” suggests that a pairing “configuration” construct of the form\r\n“hAExp, Statei” is also available (actually one for each syntactic category that can be reduced, not only for\r\nAExp), just like in Version 2. In that case, the top-level reductions take place between such configuration\r\nstructures, just like in Version 2. The rule for halt in Version 1 could have also been “c[halt i] → i”, though it\r\nwould yield some perhaps undesired top-level nondeterminism: a configuration parsed as hc[halt i], σi could\r\nindeed reduce to hi, σi by applying the characteristic rule of context reduction in the context h\u0003, σi, but it\r\ncould also reduce directly to i because an alternative parsing of it is “hc, σi[halt i]”, thus allowing top-level\r\nreductions between terms of different syntactic categories.\r\nThe advantage of Version 2 is that syntactic and semantic components of a language definition are kept\r\nseparate; also, rules of language constructs that need state information for their semantics, such as variable\r\nlookup and assignment, need not mention the rest of the evaluation context. Both Version 1 and Version 2\r\n61\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3b04475f-1fef-43e1-97ba-99fdcc5bc683.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2cc4fb1debe266c814f3f3a79e8f36982516695976dbad75322e438bcf4f913a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 776
      },
      {
        "segments": [
          {
            "segment_id": "3b04475f-1fef-43e1-97ba-99fdcc5bc683",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "characteristic rules above are essentially a convenience to the designer, so that one can write semantic rules\r\nmore compactly like “true and b → b” instead of “c[true and b] → c[b]”. The essence of context reduction is\r\nnot its characteristic reduction rule, but its approach in defining evaluation contexts as a grammar and then\r\nusing them as an explicit part of languages or calculi definitions. For example, if for some reasons one does\r\nnot want to have an “implicit” characteristic rule, say because one’s executional framework is unconditional,\r\nthen one can simply replace each rule “l → r” with a rule “c[l] → c[r]”, stating “explicitly” that the reduction\r\nfrom l to r takes place in context. The characteristic rule of context reduction can therefore be regarded\r\nas “syntactic sugar”, or convenience to the designer. In our theoretical developments in Sections 5.4.5 and\r\nSection 5.4.6 translating context reduction definitions automatically into rewriting logic and K definitions,\r\nrespectively, we are going to assume the “desugared” version of context reduction rules.\r\n5.4.3 From One to Many Steps\r\nThe reduction relation → above captures precisely one computational step, so it is commonly called a one\u0002step or a small-step reduction relation. If Γ is a context reduction definition, then we write Γ ` t → t\r\n0\r\nwhenever t → t\r\n0\r\ncan be derived as a small-step reduction using the rules in Γ (including the characteristic\r\nrule(s), if any). The one step reduction relation captures the computational capability of the defined system\r\nand is particularly useful in formal proofs. However, to “execute” context reduction definitions one needs\r\nto apply the one-step reduction relation repetitively. The following two derivation rules define the transitive\r\nclosure of the one-step reduction relation:\r\nt → t\r\n0\r\nt \u0010 t\r\n0\r\nand\r\nt → u, u \u0010 t\r\n00\r\nt \u0010 t\r\n0\r\nAs usual, we write Γ ` t \u0010 t\r\n0 whenever t \u0010 t0\r\nis derivable using all the rules in Γ plus the two rules above.\r\n5.4.4 An Example\r\nThanks to the characteristic reduction rule of context reduction above which is implicit in context reduction\r\nlanguage definitions, unlike in SOS one only needs to worry about giving rules capturing basic computation\r\nsteps and not how computations are propagated along the syntax. With this in mind, context reduction\r\ndefinitions of the simple imperative language in Figure 1 can be easily derived from a conventional SOS\r\ndefinition of the language. Figure 15 shows two complete context reduction semantic definitions for the\r\nsimple imperative language in Figure 1, one in which the state is encapsulated as part of the evaluation\r\ncontext (Version 1), and another one where the state is added as part of the configuration (Version 2).\r\nVersion 1 has the advantage that reduction rules look simpler and more natural (syntactic), without\r\ncarrying the state as part of the configuration everywhere just because one or two rules may need it, like\r\nin SOS. The disadvantage of this approach is that what used to be called “syntax” now contains rather\r\nsemantic components, such as the state of the program. Note that once one adds syntax to evaluation\r\ncontexts that does not correspond to constructs in the syntax of the language, such as the pairing of a\r\ncontext and a state, one needs to also extend the original syntax with corresponding constructs, so that\r\nthe parsing-like mechanism decomposing a syntactic term into a context and a redex can be applied. For\r\nexample, the production “Cxt ::= hCxt, Statei” suggests that a pairing “configuration” construct of the form\r\n“hAExp, Statei” is also available (actually one for each syntactic category that can be reduced, not only for\r\nAExp), just like in Version 2. In that case, the top-level reductions take place between such configuration\r\nstructures, just like in Version 2. The rule for halt in Version 1 could have also been “c[halt i] → i”, though it\r\nwould yield some perhaps undesired top-level nondeterminism: a configuration parsed as hc[halt i], σi could\r\nindeed reduce to hi, σi by applying the characteristic rule of context reduction in the context h\u0003, σi, but it\r\ncould also reduce directly to i because an alternative parsing of it is “hc, σi[halt i]”, thus allowing top-level\r\nreductions between terms of different syntactic categories.\r\nThe advantage of Version 2 is that syntactic and semantic components of a language definition are kept\r\nseparate; also, rules of language constructs that need state information for their semantics, such as variable\r\nlookup and assignment, need not mention the rest of the evaluation context. Both Version 1 and Version 2\r\n61\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3b04475f-1fef-43e1-97ba-99fdcc5bc683.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2cc4fb1debe266c814f3f3a79e8f36982516695976dbad75322e438bcf4f913a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 776
      },
      {
        "segments": [
          {
            "segment_id": "4d9ee354-e08d-4e27-826d-861182fe010e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "Version 1 Version 2 K\r\nCxt ::= · · · | hCxt, Statei\r\nhc, σi[x] → hc, σi[σ[x]] or\r\nhc[x], σi → hc[σ[x]], σi\r\nhx, σi → hσ[x], σi L x\r\nσ[x]\r\n|ikLσMstate\r\ni1 + i2 → i1 +Int i2 hi1 + i2, σi → hi1 +Int i2, σi i1 + i2 → i1 +Int i2\r\ni1 ≤ i2 → i1 ≤Int i2 hi1 ≤ i2, σi → hi1 ≤Int i2, σi i1 ≤ i2 → i1 ≤Int i2\r\nnot b → notBool b hnot b, σi → hnotBool b, σi not b → notBool b\r\ntrue and b → b htrue and b, σi → hb, σi true and b → b\r\nfalse and b → false hfalse and b, σi → hfalse, σi false and b → false\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\nhx := v, σi → hskip, σ[v/x]i Lx := v\r\n·\r\n|ikL σ\r\nσ[v/x]\r\nMstate\r\nskip; s → s hskip; s, σi → hs, σi k1; k2 \n k1 y k2\r\nif true then s1 else s2 → s1 hif true then s1 else s2, σi → hs1, σi if true then s1 else s2 → s1\r\nif false then s1 else s2 → s2 hif false then s1 else s2, σi → hs2, σi if false then s1 else s2 → s2\r\nwhile b do s →\r\nif b then (s;while b do s) else skip\r\nhwhile b do s, σi →\r\nhif b then (s;while b do s) else skip, σi\r\nL while b do s\r\nif b then (s;while b do s) else ·\r\n|ik\r\nhc, σi[halt i] → hi, σi or\r\nhc[halt i], σi → hi, σi\r\nhc[halt i], σi → hi, σi Lhalt i|ik → LiMk\r\nskip; a → a hskip; a, σi → ha, σi —no K rule needed—\r\nFigure 15: A language definition in context reduction (left and middle columns) and K (right column)\r\ntherefore employ top-level reductions between configurations containing a program (or an arithmetic expres\u0002sion) and a state. If one wants to devise a top-level reduction relation that takes programs (with no states)\r\nto integers, then one needs to add rules for configuration initialization and termination, like in Figure 1.\r\nContext reduction is an inherently small-step structural operational semantic approach: for each of\r\nthe two variants discussed, the rules above define precisely one step of computation (after the potential\r\napplications of the characteristic rule of context reduction, which propagates the computational step to the\r\ntop level). Therefore, in order to completely evaluate a program one needs to transitively apply the one-step\r\ntransition relation. Let us next discuss an example of reduction using the first context reduction variant\r\nabove. Our goal is to derive\r\nJx := 1; y := 2; if not(x ≤ y) then x := 0 else y := 0; x + y, ∅K \u0010 h1, σi\r\nfor some state σ. From here on we use the following (standard) notation for instantiated contexts: the redex\r\nis placed in a box replacing the hole of the context. For example, the fact that expression 2 ≤ (x+x)+y is seen\r\nas a context instance (2 ≤ \u0003+y)[x+x] is written compactly and intuitively as follows: 2 ≤ x + x +y. With\r\nthis notation, one gets the sequence of reductions in Figure 16, where the label above the arrow represents\r\nthe implicit and obvious name of the rule that was applied; boxed labels symbolize that the corresponding\r\nreduction step was applied in context, using implicitly the characteristic context reduction rule. To avoid\r\nwriting parentheses for disambiguation, we assume sequential composition to be left-associative. Note that\r\nthe evaluation context changes almost at each step during the reduction sequence in Figure 16.\r\nStrengths. Context reduction improves over SOS in at least two ways:\r\n1. Since reductions can only happen in proper evaluation contexts and propagation of computation is\r\ndone once and for all using the characteristic rule of context reduction, one needs not worry about\r\npropagating local computations up-wards along the syntax; this way, definitions in context reduction\r\n62\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4d9ee354-e08d-4e27-826d-861182fe010e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3104922e6a7b16cc32d650e6e4977505fa0f3ddf83faf2a3ddcd86e05f2793d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 692
      },
      {
        "segments": [
          {
            "segment_id": "4d9ee354-e08d-4e27-826d-861182fe010e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "Version 1 Version 2 K\r\nCxt ::= · · · | hCxt, Statei\r\nhc, σi[x] → hc, σi[σ[x]] or\r\nhc[x], σi → hc[σ[x]], σi\r\nhx, σi → hσ[x], σi L x\r\nσ[x]\r\n|ikLσMstate\r\ni1 + i2 → i1 +Int i2 hi1 + i2, σi → hi1 +Int i2, σi i1 + i2 → i1 +Int i2\r\ni1 ≤ i2 → i1 ≤Int i2 hi1 ≤ i2, σi → hi1 ≤Int i2, σi i1 ≤ i2 → i1 ≤Int i2\r\nnot b → notBool b hnot b, σi → hnotBool b, σi not b → notBool b\r\ntrue and b → b htrue and b, σi → hb, σi true and b → b\r\nfalse and b → false hfalse and b, σi → hfalse, σi false and b → false\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\nhx := v, σi → hskip, σ[v/x]i Lx := v\r\n·\r\n|ikL σ\r\nσ[v/x]\r\nMstate\r\nskip; s → s hskip; s, σi → hs, σi k1; k2 \n k1 y k2\r\nif true then s1 else s2 → s1 hif true then s1 else s2, σi → hs1, σi if true then s1 else s2 → s1\r\nif false then s1 else s2 → s2 hif false then s1 else s2, σi → hs2, σi if false then s1 else s2 → s2\r\nwhile b do s →\r\nif b then (s;while b do s) else skip\r\nhwhile b do s, σi →\r\nhif b then (s;while b do s) else skip, σi\r\nL while b do s\r\nif b then (s;while b do s) else ·\r\n|ik\r\nhc, σi[halt i] → hi, σi or\r\nhc[halt i], σi → hi, σi\r\nhc[halt i], σi → hi, σi Lhalt i|ik → LiMk\r\nskip; a → a hskip; a, σi → ha, σi —no K rule needed—\r\nFigure 15: A language definition in context reduction (left and middle columns) and K (right column)\r\ntherefore employ top-level reductions between configurations containing a program (or an arithmetic expres\u0002sion) and a state. If one wants to devise a top-level reduction relation that takes programs (with no states)\r\nto integers, then one needs to add rules for configuration initialization and termination, like in Figure 1.\r\nContext reduction is an inherently small-step structural operational semantic approach: for each of\r\nthe two variants discussed, the rules above define precisely one step of computation (after the potential\r\napplications of the characteristic rule of context reduction, which propagates the computational step to the\r\ntop level). Therefore, in order to completely evaluate a program one needs to transitively apply the one-step\r\ntransition relation. Let us next discuss an example of reduction using the first context reduction variant\r\nabove. Our goal is to derive\r\nJx := 1; y := 2; if not(x ≤ y) then x := 0 else y := 0; x + y, ∅K \u0010 h1, σi\r\nfor some state σ. From here on we use the following (standard) notation for instantiated contexts: the redex\r\nis placed in a box replacing the hole of the context. For example, the fact that expression 2 ≤ (x+x)+y is seen\r\nas a context instance (2 ≤ \u0003+y)[x+x] is written compactly and intuitively as follows: 2 ≤ x + x +y. With\r\nthis notation, one gets the sequence of reductions in Figure 16, where the label above the arrow represents\r\nthe implicit and obvious name of the rule that was applied; boxed labels symbolize that the corresponding\r\nreduction step was applied in context, using implicitly the characteristic context reduction rule. To avoid\r\nwriting parentheses for disambiguation, we assume sequential composition to be left-associative. Note that\r\nthe evaluation context changes almost at each step during the reduction sequence in Figure 16.\r\nStrengths. Context reduction improves over SOS in at least two ways:\r\n1. Since reductions can only happen in proper evaluation contexts and propagation of computation is\r\ndone once and for all using the characteristic rule of context reduction, one needs not worry about\r\npropagating local computations up-wards along the syntax; this way, definitions in context reduction\r\n62\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4d9ee354-e08d-4e27-826d-861182fe010e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3104922e6a7b16cc32d650e6e4977505fa0f3ddf83faf2a3ddcd86e05f2793d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 692
      },
      {
        "segments": [
          {
            "segment_id": "cf142be5-718f-4c0e-98d3-3b2637c8ca84",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "h x := 1 ; y := 2; if not(x ≤ y) then x := 0 else y := 0; x + y, ∅i\r\n:=→ h skip; y := 2 ; if not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1)i\r\nskip → h y := 2 ; if not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1)i\r\n:=→ h skip; if not x ≤ y then x := 0 else y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\nskip → hif not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\nlookup → hif not 1 ≤ y then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)ii\r\nlookup → hif not 1 ≤ 2 then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\n≤→ hif not false then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\nnot false → h if true then x := 0 else y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\niffalse → h y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\n:=→ h skip; x + y , (x 7→ 1, y 7→ 0)i\r\nskip → hx + y , (x 7→ 1, y 7→ 0)i\r\nlookup → h x + 0, (x 7→ 1, y 7→ 0)i\r\nlookup → h 1 + 0 , (x 7→ 1, y 7→ 0)i\r\n+→ h1,(x 7→ 1, y 7→ 0)i\r\nFigure 16: Sample reduction sequence using the context reduction definition in Figure 15\r\nbecome more compact than SOS definitions. In simple terms, context reduction yields more compact\r\ndefinitions than ordinary SOS because it uses parsing to find the next redex rather than towered\r\nsmall-step rules.\r\n2. It provides the possibility of also altering the evaluation context in which a reduction occurs. More\r\nprecisely, unlike SOS, context reduction allows the possibility to handle evaluation contexts like any\r\nother entities in the language, in particular to pass them to other contexts or to store them. This way\r\none can easily and elegantly define the semantics of control-intensive language features such as return\r\nof functions, break/continue of loops, exceptions, and even callcc.\r\nAs shown shortly, context reduction can be faithfully translated (i.e., nothing is lost in translation) into\r\nrewriting logic and even in a small fragment of K, replacing each context reduction rule by a corresponding\r\nrewrite logic or K rule. That implies that language definitions in K are provably at least as powerful\r\nand compact as those using context reduction. However, when using the unleashed computation handling\r\ncapabilities of K by disobeying what was called in [5] “the rigidity of syntax”, one can often write even more\r\ncompact, and in our (admittedly subjective) view more natural, language definitions.\r\nWeaknesses. The advantages of context reduction over SOS-like approaches, namely the compactness of\r\ndefinitions and the explicit control over evaluation contexts, come at a price. We next discuss the drawbacks\r\nof context reduction, first by comparison with SOS and then in general.\r\nThe discussion above may imply that context reduction is strictly superior to SOS or other syntactic\r\napproaches. That is, unfortunately, not true. SOS’ conditional rules have an important advantage, which\r\ncannot be recovered in context reduction: they easily and naturally create execution environments just for\r\nthe sub-expressions (or other fragments of program) to be processed as part of the condition, without having\r\nto worry about recovering the execution environment when the processing of the sub-expression is finished.\r\nFor example, recall the MSOS definition (one can obtain an equivalent SOS definition by desugaring MSOS\r\n63\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cf142be5-718f-4c0e-98d3-3b2637c8ca84.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4edcda4730b57f0e99bb8f0c7c4b1c08759c3d7de28d672cc7fedf5b9bfc384e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 659
      },
      {
        "segments": [
          {
            "segment_id": "cf142be5-718f-4c0e-98d3-3b2637c8ca84",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "h x := 1 ; y := 2; if not(x ≤ y) then x := 0 else y := 0; x + y, ∅i\r\n:=→ h skip; y := 2 ; if not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1)i\r\nskip → h y := 2 ; if not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1)i\r\n:=→ h skip; if not x ≤ y then x := 0 else y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\nskip → hif not x ≤ y then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\nlookup → hif not 1 ≤ y then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)ii\r\nlookup → hif not 1 ≤ 2 then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\n≤→ hif not false then x := 0 else y := 0; x + y, (x 7→ 1, y 7→ 2)i\r\nnot false → h if true then x := 0 else y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\niffalse → h y := 0 ; x + y, (x 7→ 1, y 7→ 2)i\r\n:=→ h skip; x + y , (x 7→ 1, y 7→ 0)i\r\nskip → hx + y , (x 7→ 1, y 7→ 0)i\r\nlookup → h x + 0, (x 7→ 1, y 7→ 0)i\r\nlookup → h 1 + 0 , (x 7→ 1, y 7→ 0)i\r\n+→ h1,(x 7→ 1, y 7→ 0)i\r\nFigure 16: Sample reduction sequence using the context reduction definition in Figure 15\r\nbecome more compact than SOS definitions. In simple terms, context reduction yields more compact\r\ndefinitions than ordinary SOS because it uses parsing to find the next redex rather than towered\r\nsmall-step rules.\r\n2. It provides the possibility of also altering the evaluation context in which a reduction occurs. More\r\nprecisely, unlike SOS, context reduction allows the possibility to handle evaluation contexts like any\r\nother entities in the language, in particular to pass them to other contexts or to store them. This way\r\none can easily and elegantly define the semantics of control-intensive language features such as return\r\nof functions, break/continue of loops, exceptions, and even callcc.\r\nAs shown shortly, context reduction can be faithfully translated (i.e., nothing is lost in translation) into\r\nrewriting logic and even in a small fragment of K, replacing each context reduction rule by a corresponding\r\nrewrite logic or K rule. That implies that language definitions in K are provably at least as powerful\r\nand compact as those using context reduction. However, when using the unleashed computation handling\r\ncapabilities of K by disobeying what was called in [5] “the rigidity of syntax”, one can often write even more\r\ncompact, and in our (admittedly subjective) view more natural, language definitions.\r\nWeaknesses. The advantages of context reduction over SOS-like approaches, namely the compactness of\r\ndefinitions and the explicit control over evaluation contexts, come at a price. We next discuss the drawbacks\r\nof context reduction, first by comparison with SOS and then in general.\r\nThe discussion above may imply that context reduction is strictly superior to SOS or other syntactic\r\napproaches. That is, unfortunately, not true. SOS’ conditional rules have an important advantage, which\r\ncannot be recovered in context reduction: they easily and naturally create execution environments just for\r\nthe sub-expressions (or other fragments of program) to be processed as part of the condition, without having\r\nto worry about recovering the execution environment when the processing of the sub-expression is finished.\r\nFor example, recall the MSOS definition (one can obtain an equivalent SOS definition by desugaring MSOS\r\n63\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cf142be5-718f-4c0e-98d3-3b2637c8ca84.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4edcda4730b57f0e99bb8f0c7c4b1c08759c3d7de28d672cc7fedf5b9bfc384e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 659
      },
      {
        "segments": [
          {
            "segment_id": "083a2e63-ccb1-4929-95de-891b2dab3be9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "into SOS [29]) of let in Figures 8 and 10,\r\ne1 −→ e\r\n0\r\n1\r\nlet x = e1 in e2 −→ let x = e\r\n0\r\n1\r\nin e2\r\ne2\r\nenv=ρ[v1/x]\r\n−−−−−−−−→ e\r\n0\r\n2\r\nlet x = v1 in e2\r\nenv=ρ\r\n−−−−→ let x = v1 in e\r\n0\r\n2\r\nlet x = v1 in v2 −→ v2\r\nThese rules say that the binding expression e1 must be first evaluated to a value v1, which is then bound to x in\r\nthe environment while the body of the let, e2, is being reduced; the value v2 that e2 hereby eventually reduces\r\nto is the result of the evaluation of the let. The important thing to notice here is the second rule: e2 is reduced\r\nin one step to e\r\n0\r\n2\r\nin a modified environment (ρ[v1/x]), while let x = v1 in e2 reduces to let x = v1 in e\r\n0\r\n2 under\r\nthe original environment (ρ). When using SOS or MSOS, the language designer is therefore not concerned\r\nwith “recovering” the environment after the reduction of e2. A similar scenario happens when giving an\r\nSOS semantics of function invocation in an environment-based definition. Unfortunately, neither of these is\r\npossible in context reduction. Even though the third rule above could be used as is in a hypothetical context\r\nreduction definition and the first rule can be replaced by an evaluation context production giving evaluation\r\naccess to the binding expression,\r\nCxt ::= ... | let Name = Cxt in Exp,\r\nthere is no way to find an equivalent for the second rule in context reduction. What one would like to say is,\r\nusing an unconditional rule, that in an expression of the form let x = v1 in e2 evaluation access is given to\r\ne2, but in the modified environment ρ[v1/x]; then, once e2 is completely reduced, the environment changes\r\nback to ρ. This is simply not possible in context reduction, unless one modifies the syntax in some rather\r\naggressive way (introducing, e.g., explicit environment restore statements), which would lack generality and\r\nbe against the “syntactic” spirit of context reduction.\r\nAlso, one should not be fooled thinking that context reduction is a generalization of SOS, so one can\r\nuse conditional SOS-like rules as an escape whenever a particular task cannot be accomplished using un\u0002conditional context reduction rules. For example, one cannot use a rule like the second one above, simply\r\nbecause one “loses the context” in the condition; indeed, if e2 reduces to a call/cc during the processing\r\nof the condition, then one cannot provide it with the whole evaluation context. How does K solve these\r\nproblems, considering that it is also an unconditional-rule framework? The answer is that K, by its nature,\r\nexplicitly disobeys the purity of syntax; in the case of let, one uses the computation structure to perform\r\nthe desired tasks in the desired order (that is the precise role of the computation structure): bind x to v1,\r\nschedule e2 for processing, then recover the original environment. Similar environment recovering steps need\r\nto be taken when defining control-changing statements such as return of functions, exceptions, or call/cc.\r\nNeither of these can be defined in context reduction following an environment-based definitional style.\r\nThe designated approach in context reduction to avoid the complications discussed in the paragraph\r\nabove is to discard the environment-based style all together and follow instead a substitution-based style.\r\nSubstitution is the basis of λ-calculus’ β-reduction rule and can be used to define other common language\r\nconstructs, such as let and letrec. However, some language constructs that have straightforward environment\u0002based definitions, such as references, objects, threads, etc., require quite intricate and tricky substitution\u0002based definitions, if any can be found. While substitution-based semantic techniques are interesting in their\r\nown way and are worth considering in some practical cases, we believe that a language designer should simply\r\nnot be forced by the underlying framework to follow a substitution-based style. Moreover, an executable\r\ndefinitional framework should not disregard efficiency, and substitution is expensive. An executable language\r\ndefinition in which each computational step has a complexity linear in the size of the program is simply\r\nimpractical (wrt executability); not to mention that the size of the program to reduce can grow unbounded\r\nin a substitution-based framework. As seen in Section 4, K also allows substitution-based definitions which\r\n64\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/083a2e63-ccb1-4929-95de-891b2dab3be9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0ef72869bbe9784059fbb00c0f2c26913220a8f6755919cdd46c1fb7f4293915",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 735
      },
      {
        "segments": [
          {
            "segment_id": "083a2e63-ccb1-4929-95de-891b2dab3be9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "into SOS [29]) of let in Figures 8 and 10,\r\ne1 −→ e\r\n0\r\n1\r\nlet x = e1 in e2 −→ let x = e\r\n0\r\n1\r\nin e2\r\ne2\r\nenv=ρ[v1/x]\r\n−−−−−−−−→ e\r\n0\r\n2\r\nlet x = v1 in e2\r\nenv=ρ\r\n−−−−→ let x = v1 in e\r\n0\r\n2\r\nlet x = v1 in v2 −→ v2\r\nThese rules say that the binding expression e1 must be first evaluated to a value v1, which is then bound to x in\r\nthe environment while the body of the let, e2, is being reduced; the value v2 that e2 hereby eventually reduces\r\nto is the result of the evaluation of the let. The important thing to notice here is the second rule: e2 is reduced\r\nin one step to e\r\n0\r\n2\r\nin a modified environment (ρ[v1/x]), while let x = v1 in e2 reduces to let x = v1 in e\r\n0\r\n2 under\r\nthe original environment (ρ). When using SOS or MSOS, the language designer is therefore not concerned\r\nwith “recovering” the environment after the reduction of e2. A similar scenario happens when giving an\r\nSOS semantics of function invocation in an environment-based definition. Unfortunately, neither of these is\r\npossible in context reduction. Even though the third rule above could be used as is in a hypothetical context\r\nreduction definition and the first rule can be replaced by an evaluation context production giving evaluation\r\naccess to the binding expression,\r\nCxt ::= ... | let Name = Cxt in Exp,\r\nthere is no way to find an equivalent for the second rule in context reduction. What one would like to say is,\r\nusing an unconditional rule, that in an expression of the form let x = v1 in e2 evaluation access is given to\r\ne2, but in the modified environment ρ[v1/x]; then, once e2 is completely reduced, the environment changes\r\nback to ρ. This is simply not possible in context reduction, unless one modifies the syntax in some rather\r\naggressive way (introducing, e.g., explicit environment restore statements), which would lack generality and\r\nbe against the “syntactic” spirit of context reduction.\r\nAlso, one should not be fooled thinking that context reduction is a generalization of SOS, so one can\r\nuse conditional SOS-like rules as an escape whenever a particular task cannot be accomplished using un\u0002conditional context reduction rules. For example, one cannot use a rule like the second one above, simply\r\nbecause one “loses the context” in the condition; indeed, if e2 reduces to a call/cc during the processing\r\nof the condition, then one cannot provide it with the whole evaluation context. How does K solve these\r\nproblems, considering that it is also an unconditional-rule framework? The answer is that K, by its nature,\r\nexplicitly disobeys the purity of syntax; in the case of let, one uses the computation structure to perform\r\nthe desired tasks in the desired order (that is the precise role of the computation structure): bind x to v1,\r\nschedule e2 for processing, then recover the original environment. Similar environment recovering steps need\r\nto be taken when defining control-changing statements such as return of functions, exceptions, or call/cc.\r\nNeither of these can be defined in context reduction following an environment-based definitional style.\r\nThe designated approach in context reduction to avoid the complications discussed in the paragraph\r\nabove is to discard the environment-based style all together and follow instead a substitution-based style.\r\nSubstitution is the basis of λ-calculus’ β-reduction rule and can be used to define other common language\r\nconstructs, such as let and letrec. However, some language constructs that have straightforward environment\u0002based definitions, such as references, objects, threads, etc., require quite intricate and tricky substitution\u0002based definitions, if any can be found. While substitution-based semantic techniques are interesting in their\r\nown way and are worth considering in some practical cases, we believe that a language designer should simply\r\nnot be forced by the underlying framework to follow a substitution-based style. Moreover, an executable\r\ndefinitional framework should not disregard efficiency, and substitution is expensive. An executable language\r\ndefinition in which each computational step has a complexity linear in the size of the program is simply\r\nimpractical (wrt executability); not to mention that the size of the program to reduce can grow unbounded\r\nin a substitution-based framework. As seen in Section 4, K also allows substitution-based definitions which\r\n64\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/083a2e63-ccb1-4929-95de-891b2dab3be9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0ef72869bbe9784059fbb00c0f2c26913220a8f6755919cdd46c1fb7f4293915",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 735
      },
      {
        "segments": [
          {
            "segment_id": "942eac34-dafb-4305-a27f-a7f42560e97f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "are as simple and natural, if not simpler and more natural, than their corresponding context reduction\r\ndefinitions. However, K does not enforce, encourage or discourage substitution-based definitions. We believe\r\nthat that should be the choice of the language designer and not imposed by the framework.\r\nWe next discuss several other weaknesses of context reduction, not necessarily by comparison with SOS.\r\n• Context reduction is based on an implicit mechanism to split a program or a fragment of program p\r\ninto an evaluation context c and a fragment of program, also called redex, e, so that p = c[e]. This split\r\noperation is somehow assumed atomic and non-computational, so it elegantly captures and hides all\r\nthe small-step propagation rules of SOS. However, this decomposition is not obvious and may require\r\nsignificant computational resources, sometimes linear in the size of the program or worse. Moreover,\r\nsince a new evaluation context needs to be recalculated at almost any reduction step, it can easily\r\nbecome the major bottleneck in the efficiency of an interpreter implemented following the context\r\nreduction approach. While such an interpreter would be no worse than one implemented following the\r\nsmall-step SOS approach, it can still be a lot slower than it needs to be, thus making context reduction\r\nunattractive as an executable language definitional framework (see the “ideal framework” requirements\r\nin Section 1). Techniques such as refocusing [?] have been proposed to incrementally compute the next\r\nevaluation context, but these techniques appear to work only when the decomposition of the program\r\ninto an evaluation context and a redex is deterministic.\r\n• It is inconvenient to define concurrent languages using context reduction. That is because concurrent\r\nprocesses typically communicate with each other from different places in the configuration, so one\r\nmay need contexts with more than one hole, preferably with an arbitrary number of them. While\r\nsome attempts to define and handle multi-contexts have been proposed (see, e.g., [?]), computing\r\nand matching such contexts on complex configurations becomes a significantly non-trivial issue with\r\npotentially serious impact on performance.\r\n• Context reduction is still far from serving as a solid foundation for concurrency, because, just like\r\nSOS, it only captures an interleaving semantics of a defined concurrent system. In particular, context\r\nreduction can only be used to give an interleaving semantics of CCS (middle column in Figure 5), but\r\nnot a truly concurrent one (right column in Figure 5).\r\n• It still says nothing about models, being essentially a purely syntactic reduction technique.\r\nK has all the strengths of context reduction, at the same time avoiding its limitations. Indeed, K’s match\u0002ing is comparatively cheap and rather standard in term rewriting; existing advanced indexing techniques\r\nin term rewriting can be and are being used (by running K in Maude, for example) to efficiently execute\r\nK definitions. K is particularly useful to define concurrent languages, because, if used properly, can give a\r\ntruly concurrent semantics to the defined languages at the same time also allowing an interleaving semantics\r\n— K’s approach is to let the language designer, rather than the limitations of the framework, decide what\r\nsemantics for concurrency is desired. Also, K has a model-theoretical semantics, for the time being borrowed\r\nvia its desugaring into rewriting logic.\r\n65\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/942eac34-dafb-4305-a27f-a7f42560e97f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=88d543ace9dbea8542a7de469259889613938efbcf7cb91a877d544a945d4d6f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 550
      },
      {
        "segments": [
          {
            "segment_id": "942eac34-dafb-4305-a27f-a7f42560e97f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "are as simple and natural, if not simpler and more natural, than their corresponding context reduction\r\ndefinitions. However, K does not enforce, encourage or discourage substitution-based definitions. We believe\r\nthat that should be the choice of the language designer and not imposed by the framework.\r\nWe next discuss several other weaknesses of context reduction, not necessarily by comparison with SOS.\r\n• Context reduction is based on an implicit mechanism to split a program or a fragment of program p\r\ninto an evaluation context c and a fragment of program, also called redex, e, so that p = c[e]. This split\r\noperation is somehow assumed atomic and non-computational, so it elegantly captures and hides all\r\nthe small-step propagation rules of SOS. However, this decomposition is not obvious and may require\r\nsignificant computational resources, sometimes linear in the size of the program or worse. Moreover,\r\nsince a new evaluation context needs to be recalculated at almost any reduction step, it can easily\r\nbecome the major bottleneck in the efficiency of an interpreter implemented following the context\r\nreduction approach. While such an interpreter would be no worse than one implemented following the\r\nsmall-step SOS approach, it can still be a lot slower than it needs to be, thus making context reduction\r\nunattractive as an executable language definitional framework (see the “ideal framework” requirements\r\nin Section 1). Techniques such as refocusing [?] have been proposed to incrementally compute the next\r\nevaluation context, but these techniques appear to work only when the decomposition of the program\r\ninto an evaluation context and a redex is deterministic.\r\n• It is inconvenient to define concurrent languages using context reduction. That is because concurrent\r\nprocesses typically communicate with each other from different places in the configuration, so one\r\nmay need contexts with more than one hole, preferably with an arbitrary number of them. While\r\nsome attempts to define and handle multi-contexts have been proposed (see, e.g., [?]), computing\r\nand matching such contexts on complex configurations becomes a significantly non-trivial issue with\r\npotentially serious impact on performance.\r\n• Context reduction is still far from serving as a solid foundation for concurrency, because, just like\r\nSOS, it only captures an interleaving semantics of a defined concurrent system. In particular, context\r\nreduction can only be used to give an interleaving semantics of CCS (middle column in Figure 5), but\r\nnot a truly concurrent one (right column in Figure 5).\r\n• It still says nothing about models, being essentially a purely syntactic reduction technique.\r\nK has all the strengths of context reduction, at the same time avoiding its limitations. Indeed, K’s match\u0002ing is comparatively cheap and rather standard in term rewriting; existing advanced indexing techniques\r\nin term rewriting can be and are being used (by running K in Maude, for example) to efficiently execute\r\nK definitions. K is particularly useful to define concurrent languages, because, if used properly, can give a\r\ntruly concurrent semantics to the defined languages at the same time also allowing an interleaving semantics\r\n— K’s approach is to let the language designer, rather than the limitations of the framework, decide what\r\nsemantics for concurrency is desired. Also, K has a model-theoretical semantics, for the time being borrowed\r\nvia its desugaring into rewriting logic.\r\n65\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/942eac34-dafb-4305-a27f-a7f42560e97f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=88d543ace9dbea8542a7de469259889613938efbcf7cb91a877d544a945d4d6f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 550
      },
      {
        "segments": [
          {
            "segment_id": "4b392f51-3453-481f-a618-288997164fae",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.5 Context Reduction as a Methodological Fragment of Rewriting Logic\r\nIn this section we show how one can automatically embed context reduction into rewrite logic. We first give a\r\nstraightforward embedding, which is easy to prove correct but which does not take advantage of performance\u0002improving techniques currently supported by rewrite engines, so consequently it is relatively slow when\r\nexecuted or formally analyzed. We then discuss simple optimizations which increases the performance of\r\nthe resulting rewrite definitions an order of magnitude or more. All the embeddings of context reduction\r\ninto rewriting logic discussed in this section are simple enough that one can use a rewrite engine directly to\r\nwrite, execute and formally analyze context reduction definitions without a need to implement a translator.\r\nIn this paper we only consider evaluation contexts which can be defined by means of a context-free grammar\r\n(CFG). However, the CFG defining evaluation contexts can be non-deterministic, in the sense that a term\r\nis allowed to be split many different ways as a context and a reducible redex.\r\nAll our embeddings are based on an explicit machinery to non-deterministically split a term into a context\r\nand a subterm, as well as to plug a subterm into a context and thus obtain a larger term. Figure 17 shows\r\na general and automatic procedure to generate a rewriting logic specification from any evaluation context\r\ngrammar, followed by an example instantiating this general procedure on the evaluation context grammar in\r\nFigure 14. For simplicity of both theoretical (embedding transformations and their correctness proofs) and\r\npractical (execution and formal analysis) developments, we prefer to collapse all the syntactic categories into\r\none category, Syntax, and all the context categories into another one, Context. When using order-sorted term\r\nrewrite settings (e.g., Maude), that can be elegantly done by adding the two syntactic categories as new sorts\r\nand then subsorting the syntactic and context sorts to them, respectively; this approach has the advantage\r\nthat the rewrite framework may reject programs which are not well-formed without a need for an external\r\nparser. If subsorting is not available in one’s setting, then one can simply replace each syntactic category by\r\neither Syntax or Context. Our construction also works without collapsing of non-terminals, but it is more\r\ntechnical, requires more operations, rules and equations, and it is likely not worth the effort without a real\r\nmotivation to use it in term rewrite settings without support for subsorting. We have made experiments\r\nwith both approaches and found no penalty on performance when collapsing syntactic categories.\r\nThe implicit context reduction notation “context[term]” for contextual representations of terms, as well\r\nas its implicitly assumed “split” of syntax and “plug” into contexts, are defined explicitly using the new\r\nsyntactic categories. A term c[t] can be thought of as a contextual representation of some term, where c\r\nis an evaluation context and t is the sub-term in the hole. The plug operation is only defined on terms in\r\ncontextual representation. One generic (i.e., independent upon the particular context reduction definition\r\nbeing embedded) rule and one generic equation are added: “split(N) → \u0003[N]” initiates the process of\r\nsplitting a term into a contextual representation and “plug(\u0003[N]) = N” terminates the process of plugging a\r\nterm into a context. It is important that the first be a rewrite rule (because it can lead to non-determinism;\r\nthis is explained below), while the second can safely be an equation.\r\nEach evaluation context production translates into one equation and one conditional rewrite rule. The\r\nequation tells how contexts having that production at the top are instantiated (or the plug operation,\r\nfollowing the terminology of context reduction), while the conditional rule tells how that production can\r\nbe used to split a term into a context and a subterm. The equations defining plug are straightforward:\r\nfor each production in the original CFG of evaluation contexts, iteratively plug the subterm in the smaller\r\ncontext; when the hole is reached, replace it by the subterm via the generic equation. The conditional rules\r\nfor split also look straightforward, but how and why they work is more subtle. For any context production,\r\nif the term to split matches the pattern of the production, then first split the subterm corresponding to\r\nthe position of the subcontext and then use that contextual representation of the subterm to construct\r\nthe contextual representation of the original term; at any moment, one has the option to stop splitting\r\nthanks to the generic rule “split(N0) → \u0003[N0]”. The reason for which we use a conditional rule instead of a\r\nconditional equation is that splitting, unlike plugging, can be non-deterministic. Recall that the use of an\r\narrow/transition in the condition of a rule has an existential nature and that, in Maude, that is executed by\r\nperforming an exhaustive search, or reachability analysis of all the zero-, one- or more-step rewrites of the\r\ncondition lhs (split(N) in our case) into the condition rhs (C[R] in our case). Indeed, if one uses Maude’s\r\nsearch command one can list all possible splits, or “parsings”, of a term into a contextual representation.\r\n66\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4b392f51-3453-481f-a618-288997164fae.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c536e18731368d0900222dcfe9dae2ecb2b3ebbaab736e01a7c38f9f93d037d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 854
      },
      {
        "segments": [
          {
            "segment_id": "4b392f51-3453-481f-a618-288997164fae",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.5 Context Reduction as a Methodological Fragment of Rewriting Logic\r\nIn this section we show how one can automatically embed context reduction into rewrite logic. We first give a\r\nstraightforward embedding, which is easy to prove correct but which does not take advantage of performance\u0002improving techniques currently supported by rewrite engines, so consequently it is relatively slow when\r\nexecuted or formally analyzed. We then discuss simple optimizations which increases the performance of\r\nthe resulting rewrite definitions an order of magnitude or more. All the embeddings of context reduction\r\ninto rewriting logic discussed in this section are simple enough that one can use a rewrite engine directly to\r\nwrite, execute and formally analyze context reduction definitions without a need to implement a translator.\r\nIn this paper we only consider evaluation contexts which can be defined by means of a context-free grammar\r\n(CFG). However, the CFG defining evaluation contexts can be non-deterministic, in the sense that a term\r\nis allowed to be split many different ways as a context and a reducible redex.\r\nAll our embeddings are based on an explicit machinery to non-deterministically split a term into a context\r\nand a subterm, as well as to plug a subterm into a context and thus obtain a larger term. Figure 17 shows\r\na general and automatic procedure to generate a rewriting logic specification from any evaluation context\r\ngrammar, followed by an example instantiating this general procedure on the evaluation context grammar in\r\nFigure 14. For simplicity of both theoretical (embedding transformations and their correctness proofs) and\r\npractical (execution and formal analysis) developments, we prefer to collapse all the syntactic categories into\r\none category, Syntax, and all the context categories into another one, Context. When using order-sorted term\r\nrewrite settings (e.g., Maude), that can be elegantly done by adding the two syntactic categories as new sorts\r\nand then subsorting the syntactic and context sorts to them, respectively; this approach has the advantage\r\nthat the rewrite framework may reject programs which are not well-formed without a need for an external\r\nparser. If subsorting is not available in one’s setting, then one can simply replace each syntactic category by\r\neither Syntax or Context. Our construction also works without collapsing of non-terminals, but it is more\r\ntechnical, requires more operations, rules and equations, and it is likely not worth the effort without a real\r\nmotivation to use it in term rewrite settings without support for subsorting. We have made experiments\r\nwith both approaches and found no penalty on performance when collapsing syntactic categories.\r\nThe implicit context reduction notation “context[term]” for contextual representations of terms, as well\r\nas its implicitly assumed “split” of syntax and “plug” into contexts, are defined explicitly using the new\r\nsyntactic categories. A term c[t] can be thought of as a contextual representation of some term, where c\r\nis an evaluation context and t is the sub-term in the hole. The plug operation is only defined on terms in\r\ncontextual representation. One generic (i.e., independent upon the particular context reduction definition\r\nbeing embedded) rule and one generic equation are added: “split(N) → \u0003[N]” initiates the process of\r\nsplitting a term into a contextual representation and “plug(\u0003[N]) = N” terminates the process of plugging a\r\nterm into a context. It is important that the first be a rewrite rule (because it can lead to non-determinism;\r\nthis is explained below), while the second can safely be an equation.\r\nEach evaluation context production translates into one equation and one conditional rewrite rule. The\r\nequation tells how contexts having that production at the top are instantiated (or the plug operation,\r\nfollowing the terminology of context reduction), while the conditional rule tells how that production can\r\nbe used to split a term into a context and a subterm. The equations defining plug are straightforward:\r\nfor each production in the original CFG of evaluation contexts, iteratively plug the subterm in the smaller\r\ncontext; when the hole is reached, replace it by the subterm via the generic equation. The conditional rules\r\nfor split also look straightforward, but how and why they work is more subtle. For any context production,\r\nif the term to split matches the pattern of the production, then first split the subterm corresponding to\r\nthe position of the subcontext and then use that contextual representation of the subterm to construct\r\nthe contextual representation of the original term; at any moment, one has the option to stop splitting\r\nthanks to the generic rule “split(N0) → \u0003[N0]”. The reason for which we use a conditional rule instead of a\r\nconditional equation is that splitting, unlike plugging, can be non-deterministic. Recall that the use of an\r\narrow/transition in the condition of a rule has an existential nature and that, in Maude, that is executed by\r\nperforming an exhaustive search, or reachability analysis of all the zero-, one- or more-step rewrites of the\r\ncondition lhs (split(N) in our case) into the condition rhs (C[R] in our case). Indeed, if one uses Maude’s\r\nsearch command one can list all possible splits, or “parsings”, of a term into a contextual representation.\r\n66\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/4b392f51-3453-481f-a618-288997164fae.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c536e18731368d0900222dcfe9dae2ecb2b3ebbaab736e01a7c38f9f93d037d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 854
      },
      {
        "segments": [
          {
            "segment_id": "5cd06538-27ea-4c6f-bd2d-395d2975ac21",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "(1) Context reduction syntax Rewriting logic syntax + 1 rule + 1 equation\r\nSyntactic nonterminals N1, N2, ... One non-terminal (or sort), Syntax\r\nContext nonterminals Cxt1, Cxt2, ... One non-terminal (or sort), Context\r\nImplicit notation “context[term]”\r\nand implicit “split” of syntax\r\nand “plug” into context\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\nSyntax ::= ... | Context[Syntax] | split(Syntax) | plug(Syntax)\r\nsplit(N) → \u0003[N]\r\nplug(\u0003[N]) = N\r\n(2) Context production Rewriting logic equation and conditional rule\r\nCxt0::= π(N1, ..., Nn, Cxt) split(π(N1, ..., Nn, N)) → π(N1, ..., Nn, C)[R] if split(N) → C[R]\r\nplug(π(N1, ..., Nn, C)[R]) = π(N1, ..., Nn, plug(C[R]))\r\nwhere\r\nCxt0::= π(N1, ..., Nn, Cxt) is an evaluation context production with N1, ..., Nn all its syntactic nonterminals and\r\nCxt its contextual nonterminal. In other words, the implicit context reduction “parsing”, as well as its assumed\r\n“split” and “plug” operations, are replaced by explicit rewrite logic sentences.\r\nEvaluation context grammar Corresponding rewriting logic rules and equations\r\nCxt ::= \u0003\r\nsplit(p) → \u0003[p]\r\nplug(\u0003[p]) = p\r\nCxt ::= ... | Cxt + AExp split(a1 + a2) → (c + a2)[r] if split(a1) → c[r]\r\nplug((c + a2)[r]) = plug(c[r]) + a2\r\nCxt ::= ... | AExp + Cxt split(a1 + a2) → (a1 + c)[r] if split(a2) → c[r]\r\nplug((a1 + c)[r]) = a1 + plug(c[r])\r\nCxt ::= ... | Cxt ≤ AExp split(a1 ≤ a2) → (c ≤ a2)[r] if split(a1) → c[r]\r\nplug((c ≤ a2)[r]) = plug(c[r]) ≤ a2\r\nCxt ::= ... | Int ≤ Cxt split(i1 ≤ a2) → (i1 ≤ c)[r] if split(a2) → c[r]\r\nplug((i1 ≤ c)[r]) = i1 ≤ plug(c[r])\r\nCxt ::= ... | not Cxt split(not b) → (not c)[r] if split(b) → c[r]\r\nplug((not c)[r]) = not plug(c[r])\r\nCxt ::= ... | Cxt and BExp split(b1 and b2) → (c and b2)[r] if split(b1) → c[r]\r\nplug((c and b2)[r]) = plug(c[r]) and b2\r\nCxt ::= ... | Name := Cxt split(x := a) → (x := c)[r] if split(a) → c[r]\r\nplug((x := c)[r]) = x := plug(c[r])\r\nCxt ::= ... | Cxt; Stmt split(s1; s2) → (c; s2)[r] if split(s1) → c[r]\r\nplug((c; s2)[r]) = plug(c[r]); s2\r\nCxt ::= ... | if Cxt then Stmt else Stmt split(if b then s1 else s2) → (if c then s1 else s2)[r] if split(b) → c[r]\r\nplug((if c then s1 else s2)[r]) = if plug(c[r]) then s1 else s2\r\nCxt ::= ... | halt Cxt split(halt a) → (halt c)[r] if split(a) → c[r]\r\nplug((halt c)[r]) = halt plug(c[r])\r\nCxt ::= ... | Cxt; AExp split(s; a) → (c; a)[r] if split(s) → c[r]\r\nplug((c; a)[r]) = plug(c[r]); a\r\nFigure 17: Embedding an evaluation context grammar into rewriting logic (Γ R\u0003\r\nΓ\r\n) and example\r\n67\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/5cd06538-27ea-4c6f-bd2d-395d2975ac21.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1c7f5086c200b79426eef30adeadf767b12a9daa803a2a27312244dab41d4fdf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 470
      },
      {
        "segments": [
          {
            "segment_id": "fbd16455-f9ee-484d-8503-7547466334b0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction rule Rewriting logic conditional rule\r\nrulei : l(c1[l1], ..., cn[ln]) → r(c\r\n0\r\n1[r1], ..., c0\r\nn0 [rn0 ]) rulei : {l(N1, ..., Nn)} → {r(plug(c\r\n0\r\n1[r1]), ..., plug(c\r\n0\r\nn[rn0 ]))}\r\nif split(N1) → c1[l1] ∧ · · · ∧ split(Nn) → cn[ln]\r\nwhere\r\n“Syntax ::= ... | {Syntax}” is an additional “wrapper”, with the same intuition as the homonymous wrapper in the\r\nembedding of SOS in Section 5.1.1: {t} inhibits “uncontrolled” rewrites in t, all rewrites take place at the top.\r\nContext reduction rules Corresponding rewriting logic rules\r\nhc, σi[x] → hc, σi[σ[x]] or\r\nhc[x], σi → hc[σ[x]], σi\r\n{p} → {plug(hc, σi[σ[x]])} if split(p) → hc, σi[x] or\r\n{hp, σi} → {hplug(c[σ[x]]), σi} if split(p) → c[x]\r\ni1 + i2 → i1 +Int i2 {p} → {plug(c[i1 +Int i2])} if split(p) → c[i1 + i2]\r\ni1 ≤ i2 → i1 ≤Int i2 {p} → {plug(c[i1 ≤Int i2])} if split(p) → c[i1 ≤ i2]\r\nnot b → notBool b {p} → {plug(c[notBool b])} if split(p) → c[not b]\r\ntrue and b → b {p} → {plug(c[b])} if split(p) → c[true and b]\r\nfalse and b → false {p} → {plug(c[false])} if split(p) → c[false and b]\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\n{p} → {plug(hc, σ[v/x]i[skip])} if split(p) → hc, σi[x := v] or\r\n{hp, σi} → {hplug(c[skip]), σ[v/x]i} if split(p) → c[x := v]\r\nskip; s → s {p} → {plug(c[s])} if split(p) → c[skip; s]\r\nif true then s1 else s2 → s1 {p} → {plug(c[s1])} if split(p) → c[if true then s1 else s2]\r\nif false then s1 else s2 → s2 {p} → {plug(c[s2])} if split(p) → c[if false then s1 else s2]\r\nwhile b do s → if b then (s; while b do s) else skip {p} → {plug(c[if b then (s; while b do s) else skip])} if split(p) → c[while b do s]\r\nhc, σi[halt i] → hi, σi or\r\nhc[halt i], σi → hi, σi\r\n{p} → {hi, σi} if split(p) → hc, σi[halt i] or\r\n{hp, σi} → {hi, σi} if split(p) → c[halt i]\r\nskip; a → a {p} → {plug(c[a])} if split(p) → c[skip; a]\r\nFigure 18: First embedding of context reduction into rewriting logic (Γ R1\r\nΓ\r\n) and example\r\nTheorem 9. (Embedding splitting/plugging into rewriting logic) Let Γ be any context reduction\r\ndefinition (we are only interested in its evaluation context syntax here), and let R\u0003\r\nΓ\r\nbe the rewrite logic\r\ntheory associated to Γ using the embeddings of syntax (1) and contexts (2) in Figure 17. Then the following\r\nare equivalent for any t ∈ Syntax:\r\n• t can be split or “parsed” as c[r] in Γ;\r\n• R\u0003\r\nΓ ` split(t) → c[r];\r\n• R\u0003\r\nΓ ` plug(c[r]) = t.\r\nThe theorem above says that the process of splitting a term t into a context and a redex in context\r\nreduction, which can be non-deterministic, reduces to reachability in the corresponding rewrite logic theory\r\nof a contextual representation pattern c[r] of the original term marked for splitting, split(t). Rewrite engines\r\nsuch as Maude provide a search command that does precisely that.\r\nFigure 18 shows our first embedding of context reduction into rewriting logic. Each context reduction\r\nsemantic rule translates into one rewrite logic conditional rule. We allow context reduction rules to have\r\nin their lhs and rhs an arbitrary number of subterms in contextual representation. For example, if the lhs\r\nl of a context reduction rule has n such subterms, say c1[l1], ..., cn[ln], then we write it l(c1[l1], ..., cn[ln])\r\n(we avoid the notation l[c1[l1], ..., cn[ln]] because the use of square brackets for both object- and meta\u0002notation may be confusing). Moreover, note that we allow contexts to have any pattern, not only context\r\n68\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fbd16455-f9ee-484d-8503-7547466334b0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bbf9f1a3837f6cc63bed68e4cc47a843ba8e07e4e61fb8a7f3f04abd9de5d157",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 651
      },
      {
        "segments": [
          {
            "segment_id": "fbd16455-f9ee-484d-8503-7547466334b0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction rule Rewriting logic conditional rule\r\nrulei : l(c1[l1], ..., cn[ln]) → r(c\r\n0\r\n1[r1], ..., c0\r\nn0 [rn0 ]) rulei : {l(N1, ..., Nn)} → {r(plug(c\r\n0\r\n1[r1]), ..., plug(c\r\n0\r\nn[rn0 ]))}\r\nif split(N1) → c1[l1] ∧ · · · ∧ split(Nn) → cn[ln]\r\nwhere\r\n“Syntax ::= ... | {Syntax}” is an additional “wrapper”, with the same intuition as the homonymous wrapper in the\r\nembedding of SOS in Section 5.1.1: {t} inhibits “uncontrolled” rewrites in t, all rewrites take place at the top.\r\nContext reduction rules Corresponding rewriting logic rules\r\nhc, σi[x] → hc, σi[σ[x]] or\r\nhc[x], σi → hc[σ[x]], σi\r\n{p} → {plug(hc, σi[σ[x]])} if split(p) → hc, σi[x] or\r\n{hp, σi} → {hplug(c[σ[x]]), σi} if split(p) → c[x]\r\ni1 + i2 → i1 +Int i2 {p} → {plug(c[i1 +Int i2])} if split(p) → c[i1 + i2]\r\ni1 ≤ i2 → i1 ≤Int i2 {p} → {plug(c[i1 ≤Int i2])} if split(p) → c[i1 ≤ i2]\r\nnot b → notBool b {p} → {plug(c[notBool b])} if split(p) → c[not b]\r\ntrue and b → b {p} → {plug(c[b])} if split(p) → c[true and b]\r\nfalse and b → false {p} → {plug(c[false])} if split(p) → c[false and b]\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\n{p} → {plug(hc, σ[v/x]i[skip])} if split(p) → hc, σi[x := v] or\r\n{hp, σi} → {hplug(c[skip]), σ[v/x]i} if split(p) → c[x := v]\r\nskip; s → s {p} → {plug(c[s])} if split(p) → c[skip; s]\r\nif true then s1 else s2 → s1 {p} → {plug(c[s1])} if split(p) → c[if true then s1 else s2]\r\nif false then s1 else s2 → s2 {p} → {plug(c[s2])} if split(p) → c[if false then s1 else s2]\r\nwhile b do s → if b then (s; while b do s) else skip {p} → {plug(c[if b then (s; while b do s) else skip])} if split(p) → c[while b do s]\r\nhc, σi[halt i] → hi, σi or\r\nhc[halt i], σi → hi, σi\r\n{p} → {hi, σi} if split(p) → hc, σi[halt i] or\r\n{hp, σi} → {hi, σi} if split(p) → c[halt i]\r\nskip; a → a {p} → {plug(c[a])} if split(p) → c[skip; a]\r\nFigure 18: First embedding of context reduction into rewriting logic (Γ R1\r\nΓ\r\n) and example\r\nTheorem 9. (Embedding splitting/plugging into rewriting logic) Let Γ be any context reduction\r\ndefinition (we are only interested in its evaluation context syntax here), and let R\u0003\r\nΓ\r\nbe the rewrite logic\r\ntheory associated to Γ using the embeddings of syntax (1) and contexts (2) in Figure 17. Then the following\r\nare equivalent for any t ∈ Syntax:\r\n• t can be split or “parsed” as c[r] in Γ;\r\n• R\u0003\r\nΓ ` split(t) → c[r];\r\n• R\u0003\r\nΓ ` plug(c[r]) = t.\r\nThe theorem above says that the process of splitting a term t into a context and a redex in context\r\nreduction, which can be non-deterministic, reduces to reachability in the corresponding rewrite logic theory\r\nof a contextual representation pattern c[r] of the original term marked for splitting, split(t). Rewrite engines\r\nsuch as Maude provide a search command that does precisely that.\r\nFigure 18 shows our first embedding of context reduction into rewriting logic. Each context reduction\r\nsemantic rule translates into one rewrite logic conditional rule. We allow context reduction rules to have\r\nin their lhs and rhs an arbitrary number of subterms in contextual representation. For example, if the lhs\r\nl of a context reduction rule has n such subterms, say c1[l1], ..., cn[ln], then we write it l(c1[l1], ..., cn[ln])\r\n(we avoid the notation l[c1[l1], ..., cn[ln]] because the use of square brackets for both object- and meta\u0002notation may be confusing). Moreover, note that we allow contexts to have any pattern, not only context\r\n68\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fbd16455-f9ee-484d-8503-7547466334b0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bbf9f1a3837f6cc63bed68e4cc47a843ba8e07e4e61fb8a7f3f04abd9de5d157",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 651
      },
      {
        "segments": [
          {
            "segment_id": "98884bbc-8c9c-4a2a-ab10-28134bb68e70",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "variables; for example, a variable lookup context reduction rule can be either “hc, σi[x] → hc, σi[σ(x)]” or\r\n“hc[x], σi → hc[σ[x]], σi”. A rule in context reduction operates as follows: (1) match the lhs pattern at the top\r\nof the term to reduce, making sure that each of the subterms corresponding to the contextual representation\r\nsub-patterns can indeed be split as indicated; and (2) then reduce the original term to the rhs pattern\r\ninstantiated accordingly, plugging all the subterms appearing in contextual representations in the rhs. The\r\nabove does not exclude matching contexts in the lhs or storing them in the rhs, as needed for example to\r\ndefine constructs that change the control abruptly, such as call/cc; all is required here is that contextual\r\nrepresentations appearing in the lhs have the meaning of a split, while those in the rhs have the meaning\r\nof a plug. Our corresponding conditional rewrite rule does precisely that: the { } in the lhs guarantees\r\nthat the reduction takes place at the top of the original term, the condition exhaustively searches for all the\r\nsplits, and the rhs plugs all the contextual representations. The only difference between the original context\r\nreduction rule and its corresponding rewrite logic conditional rule is that the rewrite logic rule makes explicit\r\nthe splits and plugs that are implicit in the context reduction rule.\r\nTheorem 10. (First faithful embedding of context reduction into rewriting logic) Let Γ be any\r\ncontext reduction definition and let R1\r\nΓ\r\nbe the rewrite logic theory associated to Γ using the embedding\r\nprocedure in Figure 18. Then\r\n1. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R1\r\nΓ ` {t} →1 {t\r\n0} using rulei; moreover,\r\nrulei applies similarly (same contexts, same substitution; all modulo correspondence in Theorem 9.);\r\n2. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R1\r\nΓ ` {t} → {t\r\n0}.\r\nThe first item above says that the resulting rewrite logic theory captures faithfully the small-step reduction\r\nrelation of the original context reduction definition. The faithfulness of this embedding (i.e., there is precisely\r\none top-level application of a rewrite rule that corresponds to a context reduction rule), comes from the fact\r\nthat the consistent use of the “{ }” wrapper inhibits any other application of any other rule on the wrapped\r\nterm. Therefore, a small-step reduction in context reduction also reduces to reachability analysis in the\r\ncorresponding rewrite theory; one can also use the search capability of a system like Maude to find all the\r\nnext terms that a given term evaluates to (Maude provides the capability to search for the first n terms\r\nthat match a given pattern using up to m rules, where n and m are user-provided parameters). Note that\r\nthis step-for-step correspondence is stronger (and better) than the strong bisimilarity of the two definitions;\r\nfor example, if rulei can be applied two different ways in Γ, then its corresponding rule can also be applied\r\ntwo different ways in R1\r\nΓ\r\n. The second item above says that the resulting rewrite theory can be used to\r\nperform any computation possible in the original context reduction theory, and vice-versa (the step-for\u0002step correspondence is guaranteed in combination with the first item above). Therefore, there is absolutely\r\nno difference between computations using Γ and computations using R1\r\nΓ\r\n, except for irrelevant syntactic\r\nconventions/notations. This strong correspondence between reductions in Γ and rewrites in R1\r\nΓ\r\ntells that\r\nR1\r\nΓ\r\nis precisely Γ, not an encoding of it. In other words, context reduction can be faithfully regarded as a\r\nmethodological fragment of rewriting logic, same like SOS.\r\nThe discussion above implies that, from a theoretical perspective, the embedding in Figure 18 is as good\r\nas one can hope. However, its simplicity cames at a price in performance, which unfortunately tends to\r\nbe at its worst precisely in the most common cases. Consider, for example, the context reduction rules for\r\n“+” and “≤” in the language definition in Figure 15, which after desugaring of the characteristic context\r\nreduction rule (as explained at the end of Section 5.4.2) become:\r\nc[i1 + i2] → c[i1 +Int i2]\r\nc[i1 ≤ i2] → c[i1 ≤Int i2].\r\nWith the embedding in Figure 18, these translate into the conditional rewrite rules\r\n{p} → plug(c[i1 +Int i2]) if split(p) → c[i1 + i2]\r\n{p} → plug(c[i1 ≤Int i2]) if split(p) → c[i1 ≤ i2],\r\n69\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/98884bbc-8c9c-4a2a-ab10-28134bb68e70.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dc38bf35c9ab1e74de0c7b2c555f046d9cc5fd8c94e2bc0c9f9bde3823bbee06",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 747
      },
      {
        "segments": [
          {
            "segment_id": "98884bbc-8c9c-4a2a-ab10-28134bb68e70",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "variables; for example, a variable lookup context reduction rule can be either “hc, σi[x] → hc, σi[σ(x)]” or\r\n“hc[x], σi → hc[σ[x]], σi”. A rule in context reduction operates as follows: (1) match the lhs pattern at the top\r\nof the term to reduce, making sure that each of the subterms corresponding to the contextual representation\r\nsub-patterns can indeed be split as indicated; and (2) then reduce the original term to the rhs pattern\r\ninstantiated accordingly, plugging all the subterms appearing in contextual representations in the rhs. The\r\nabove does not exclude matching contexts in the lhs or storing them in the rhs, as needed for example to\r\ndefine constructs that change the control abruptly, such as call/cc; all is required here is that contextual\r\nrepresentations appearing in the lhs have the meaning of a split, while those in the rhs have the meaning\r\nof a plug. Our corresponding conditional rewrite rule does precisely that: the { } in the lhs guarantees\r\nthat the reduction takes place at the top of the original term, the condition exhaustively searches for all the\r\nsplits, and the rhs plugs all the contextual representations. The only difference between the original context\r\nreduction rule and its corresponding rewrite logic conditional rule is that the rewrite logic rule makes explicit\r\nthe splits and plugs that are implicit in the context reduction rule.\r\nTheorem 10. (First faithful embedding of context reduction into rewriting logic) Let Γ be any\r\ncontext reduction definition and let R1\r\nΓ\r\nbe the rewrite logic theory associated to Γ using the embedding\r\nprocedure in Figure 18. Then\r\n1. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R1\r\nΓ ` {t} →1 {t\r\n0} using rulei; moreover,\r\nrulei applies similarly (same contexts, same substitution; all modulo correspondence in Theorem 9.);\r\n2. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R1\r\nΓ ` {t} → {t\r\n0}.\r\nThe first item above says that the resulting rewrite logic theory captures faithfully the small-step reduction\r\nrelation of the original context reduction definition. The faithfulness of this embedding (i.e., there is precisely\r\none top-level application of a rewrite rule that corresponds to a context reduction rule), comes from the fact\r\nthat the consistent use of the “{ }” wrapper inhibits any other application of any other rule on the wrapped\r\nterm. Therefore, a small-step reduction in context reduction also reduces to reachability analysis in the\r\ncorresponding rewrite theory; one can also use the search capability of a system like Maude to find all the\r\nnext terms that a given term evaluates to (Maude provides the capability to search for the first n terms\r\nthat match a given pattern using up to m rules, where n and m are user-provided parameters). Note that\r\nthis step-for-step correspondence is stronger (and better) than the strong bisimilarity of the two definitions;\r\nfor example, if rulei can be applied two different ways in Γ, then its corresponding rule can also be applied\r\ntwo different ways in R1\r\nΓ\r\n. The second item above says that the resulting rewrite theory can be used to\r\nperform any computation possible in the original context reduction theory, and vice-versa (the step-for\u0002step correspondence is guaranteed in combination with the first item above). Therefore, there is absolutely\r\nno difference between computations using Γ and computations using R1\r\nΓ\r\n, except for irrelevant syntactic\r\nconventions/notations. This strong correspondence between reductions in Γ and rewrites in R1\r\nΓ\r\ntells that\r\nR1\r\nΓ\r\nis precisely Γ, not an encoding of it. In other words, context reduction can be faithfully regarded as a\r\nmethodological fragment of rewriting logic, same like SOS.\r\nThe discussion above implies that, from a theoretical perspective, the embedding in Figure 18 is as good\r\nas one can hope. However, its simplicity cames at a price in performance, which unfortunately tends to\r\nbe at its worst precisely in the most common cases. Consider, for example, the context reduction rules for\r\n“+” and “≤” in the language definition in Figure 15, which after desugaring of the characteristic context\r\nreduction rule (as explained at the end of Section 5.4.2) become:\r\nc[i1 + i2] → c[i1 +Int i2]\r\nc[i1 ≤ i2] → c[i1 ≤Int i2].\r\nWith the embedding in Figure 18, these translate into the conditional rewrite rules\r\n{p} → plug(c[i1 +Int i2]) if split(p) → c[i1 + i2]\r\n{p} → plug(c[i1 ≤Int i2]) if split(p) → c[i1 ≤ i2],\r\n69\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/98884bbc-8c9c-4a2a-ab10-28134bb68e70.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dc38bf35c9ab1e74de0c7b2c555f046d9cc5fd8c94e2bc0c9f9bde3823bbee06",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 747
      },
      {
        "segments": [
          {
            "segment_id": "fbdc019c-911c-46c2-833b-980f3b6c5dee",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "where p ranges over Syntax. In fact, as seen in the example in Figure 18, all the lhs’es of all the rewrite\r\nrules corresponding to the context reduction rules in the first definition in Figure 15 will have the form {p}.\r\nThe reason the lhs’es of the rewrite rules are the same and lack any structure is because the contextual\r\nrepresentations in the lhs’es of the reduction rules appear at the top, with no structure above them, which\r\nis the most common type of context reduction rule encountered. The λµ-calculus defined in Figure ?? also\r\nhas only rules of this type.\r\nTo apply a conditional rewrite rule as above, a rewrite engine would first match the lhs and then would\r\nperform the expensive (exhaustive) search in the condition. In other words, the structure of the lhs acts as a\r\ncheap “guard” for the expensive search. Unfortunately, since the lhs has no structure, it will always match.\r\nThat means that the expensive searches in the conditions of all the rewrite rules will be, in the worst case,\r\nexecuted one after the other until a split is eventually found (if any). If one thinks in terms of implementing\r\ncontext reduction in general, then this is what a naive implementation would do. If one thinks in terms of\r\nexecuting term rewrite systems, then this fails to take advantage of some important performance-increasing\r\nadvances in term rewriting, such as indexing [?]. In short, indexing techniques use the structure of the rules’\r\nlhs’es to augment the term structure to be rewritten with information about which rule can potentially be\r\napplied in which nodes. This information is dynamically updated, as the term is rewritten. If the rules’ lhs’es\r\ndo not significantly overlap, it is generally assumed that it takes constant time to find a matching rewrite\r\nrule. This is similar in spirit to hashing, where the access time into a hash table is generally assumed to\r\ntake constant time when there are no or little key collisions. Thinking intuitively in terms of hashing, from\r\nan indexing perspective a rewrite system with rules having the same lhs’es is as bad/useless as a hash table\r\nin which all accesses are collisions.\r\nIdeally, in an efficient implementation of context reduction one would like to adapt/modify indexing\r\ntechniques, which currently work for context-insensitive term rewriting, or to invent new techniques serving\r\nthe same purpose. This seems highly non-trivial and tedious, though. An alternative is to device an\r\nembedding transformation of context reduction into term rewriting that takes better or full advantage of\r\nexisting, context-insensitive indexing. Without context-sensitive indexing hardwired in the reduction engine,\r\ndue to the inherent non-determinism in parsing/splitting syntax into contextual representations it can be\r\nshown that in the worst case one needs to search the entire term to find a legal position where a reduction\r\ncan take place. What we would like to achieve though is a quick test for which rule applies on a particular\r\nredex once a split is found. Such a quick test can be achieved for free on rewrite systems making use of\r\nindexing (e.g., Maude) if one slightly modifies the embedding translation of context reduction into rewriting\r\nlogic as shown in Figure 19. The main idea is to keep the structure of the lhs of the reduction rules in\r\nthe lhs of the corresponding rewriting rules. This structure is crucial for indexing. To allow it, one needs\r\nto do the necessary splitting as a separate step. The first rewrite rule associated to a context reduction\r\nrule enables the splitting process on the corresponding contextual representations in the lhs of the original\r\nreduction rule. An immediate effect of these rules is that, unlike in the first embedding, a term can now be\r\nsplit at multiple positions, not only at its top. Note that the splitting “task” needs to be propagated at each\r\nstep (achieved prepending the split operation on top of the rhs).\r\nTheorem 11. (Second faithful embedding of context reduction into rewriting logic) Let Γ be\r\nany context reduction definition and let R2\r\nΓ\r\nbe the complete rewrite logic theory associated to Γ using the\r\nembedding procedure in Figure 19. Then\r\n1. (matching becomes deduction) A term t matches rulei in Γ whose lhs is l(c1[l1], ..., cn[ln]) iff\r\nR2\r\nΓ ` split(t)\r\nsplit\r\n→?l(c1[l1], ..., cn[ln]), where\r\nsplit\r\n→?is the rewrite relation restricted to split rules;\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R2\r\nΓ ` split(t)\r\nsplit\r\n→? u and R2\r\nΓ ` {u} →1\r\n{split(t\r\n0\r\n)} using rulei; moreover, rulei applies similarly (same contexts and same substitution);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R2\r\nΓ ` {split(t)} → {\u0003[t\r\n0\r\n]}.\r\nLike for the first embedding, one can now use a context-insensitive rewrite engine, in particular its search\r\ncapabilities, to explore computations in the original context reduction definition. For example, if one is\r\n70\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fbdc019c-911c-46c2-833b-980f3b6c5dee.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ee0d96fa7a1358f299901b0e40099c46a69edc9970d664ca8a5e7dccc494f6b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 830
      },
      {
        "segments": [
          {
            "segment_id": "fbdc019c-911c-46c2-833b-980f3b6c5dee",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "where p ranges over Syntax. In fact, as seen in the example in Figure 18, all the lhs’es of all the rewrite\r\nrules corresponding to the context reduction rules in the first definition in Figure 15 will have the form {p}.\r\nThe reason the lhs’es of the rewrite rules are the same and lack any structure is because the contextual\r\nrepresentations in the lhs’es of the reduction rules appear at the top, with no structure above them, which\r\nis the most common type of context reduction rule encountered. The λµ-calculus defined in Figure ?? also\r\nhas only rules of this type.\r\nTo apply a conditional rewrite rule as above, a rewrite engine would first match the lhs and then would\r\nperform the expensive (exhaustive) search in the condition. In other words, the structure of the lhs acts as a\r\ncheap “guard” for the expensive search. Unfortunately, since the lhs has no structure, it will always match.\r\nThat means that the expensive searches in the conditions of all the rewrite rules will be, in the worst case,\r\nexecuted one after the other until a split is eventually found (if any). If one thinks in terms of implementing\r\ncontext reduction in general, then this is what a naive implementation would do. If one thinks in terms of\r\nexecuting term rewrite systems, then this fails to take advantage of some important performance-increasing\r\nadvances in term rewriting, such as indexing [?]. In short, indexing techniques use the structure of the rules’\r\nlhs’es to augment the term structure to be rewritten with information about which rule can potentially be\r\napplied in which nodes. This information is dynamically updated, as the term is rewritten. If the rules’ lhs’es\r\ndo not significantly overlap, it is generally assumed that it takes constant time to find a matching rewrite\r\nrule. This is similar in spirit to hashing, where the access time into a hash table is generally assumed to\r\ntake constant time when there are no or little key collisions. Thinking intuitively in terms of hashing, from\r\nan indexing perspective a rewrite system with rules having the same lhs’es is as bad/useless as a hash table\r\nin which all accesses are collisions.\r\nIdeally, in an efficient implementation of context reduction one would like to adapt/modify indexing\r\ntechniques, which currently work for context-insensitive term rewriting, or to invent new techniques serving\r\nthe same purpose. This seems highly non-trivial and tedious, though. An alternative is to device an\r\nembedding transformation of context reduction into term rewriting that takes better or full advantage of\r\nexisting, context-insensitive indexing. Without context-sensitive indexing hardwired in the reduction engine,\r\ndue to the inherent non-determinism in parsing/splitting syntax into contextual representations it can be\r\nshown that in the worst case one needs to search the entire term to find a legal position where a reduction\r\ncan take place. What we would like to achieve though is a quick test for which rule applies on a particular\r\nredex once a split is found. Such a quick test can be achieved for free on rewrite systems making use of\r\nindexing (e.g., Maude) if one slightly modifies the embedding translation of context reduction into rewriting\r\nlogic as shown in Figure 19. The main idea is to keep the structure of the lhs of the reduction rules in\r\nthe lhs of the corresponding rewriting rules. This structure is crucial for indexing. To allow it, one needs\r\nto do the necessary splitting as a separate step. The first rewrite rule associated to a context reduction\r\nrule enables the splitting process on the corresponding contextual representations in the lhs of the original\r\nreduction rule. An immediate effect of these rules is that, unlike in the first embedding, a term can now be\r\nsplit at multiple positions, not only at its top. Note that the splitting “task” needs to be propagated at each\r\nstep (achieved prepending the split operation on top of the rhs).\r\nTheorem 11. (Second faithful embedding of context reduction into rewriting logic) Let Γ be\r\nany context reduction definition and let R2\r\nΓ\r\nbe the complete rewrite logic theory associated to Γ using the\r\nembedding procedure in Figure 19. Then\r\n1. (matching becomes deduction) A term t matches rulei in Γ whose lhs is l(c1[l1], ..., cn[ln]) iff\r\nR2\r\nΓ ` split(t)\r\nsplit\r\n→?l(c1[l1], ..., cn[ln]), where\r\nsplit\r\n→?is the rewrite relation restricted to split rules;\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R2\r\nΓ ` split(t)\r\nsplit\r\n→? u and R2\r\nΓ ` {u} →1\r\n{split(t\r\n0\r\n)} using rulei; moreover, rulei applies similarly (same contexts and same substitution);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R2\r\nΓ ` {split(t)} → {\u0003[t\r\n0\r\n]}.\r\nLike for the first embedding, one can now use a context-insensitive rewrite engine, in particular its search\r\ncapabilities, to explore computations in the original context reduction definition. For example, if one is\r\n70\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/fbdc019c-911c-46c2-833b-980f3b6c5dee.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ee0d96fa7a1358f299901b0e40099c46a69edc9970d664ca8a5e7dccc494f6b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 830
      },
      {
        "segments": [
          {
            "segment_id": "c5c902ac-b7fc-4fef-ae44-c97dce037701",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction rule Two rewriting logic unconditional rules\r\nrulei :\r\nl(c1[l1], ..., cn[ln]) → r(c\r\n0\r\n1[r1], ..., c0\r\nn0 [rn0 ]) \r\n\r\n\r\n\r\nif l is proper (i.e., not a variable) then add the rule\r\nsplit(l(N1, ..., Nn)) → l(split(N1), ..., split(Nn))\r\nadd the rule\r\nrulei :\r\n{l(c1[l1], ..., cn[ln])} → {split(r(plug(c\r\n0\r\n1[r1]), ..., plug(c\r\n0\r\nn[rn0 ])))}\r\nContext reduction rules Corresponding rewriting logic rules\r\nhc, σi[x] → hc, σi[σ[x]] or {hc, σi[x]} → {split(plug(hc, σi[σ[x]]))} or\r\nhc[x], σi → hc[σ[x]], σi\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi\r\n{hc[x], σi} → {split(hplug(c[σ[x]]), σi)}\r\ni1 + i2 → i1 +Int i2 {c[i1 + i2]} → {split(plug(c[i1 +Int i2]))}\r\ni1 ≤ i2 → i1 ≤Int i2 {c[i1 ≤ i2]} → {split(plug(c[i1 ≤Int i2]))}\r\nnot b → notBool b {c[not b]} → {split(plug(c[notBool b]))}\r\ntrue and b → b {c[true and b]} → {split(plug(c[b]))}\r\nfalse and b → false {c[false and b]} → {split(plug(c[false]))}\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or {hc, σi[x := v]} → {split(plug(hc, σ[v/x]i[skip]))} or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi (may be redundant)\r\n{hc[x := v], σi} → {split(hplug(c[skip]), σ[v/x]i)}\r\nskip; s → s {c[skip; s]} → {split(plug(c[s]))}\r\nif true then s1 else s2 → s1 {c[if true then s1 else s2]} → {split(plug(c[s1]))}\r\nif false then s1 else s2 → s2 {c[if false then s1 else s2]} → {split(plug(c[s2]))}\r\nwhile b do s → if b then (s; while b do s) else skip {c[while b do s]} → {split(plug(c[if b then (s; while b do s) else skip]))}\r\nhc, σi[halt i] → hi, σi or {hc, σi[halt i]} → {split(hi, σi)} or\r\nhc[halt i], σi → hi, σi\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi (may be redundant)\r\n{hc[halt i], σi} → {split(hi, σi)}\r\nskip; a → a {c[skip; a]} → {split(plug(c[a]))}\r\nFigure 19: Second embedding of context reduction into rewriting logic (Γ R2\r\nΓ\r\n) and example\r\n71\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/c5c902ac-b7fc-4fef-ae44-c97dce037701.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d18ab34fb5ca6fe67e91aed87b6fc3c147d410fd76ecac1b2940dc20fcbe0b6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 338
      },
      {
        "segments": [
          {
            "segment_id": "8c63acd4-3be8-4f20-a83e-523052d5b4d1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "interested in listing all terms that are reachable from a given term t using the original context reduction\r\ndefinition, then all one needs to do is to invoke a search procedure on the term {split(t)} and limit its\r\nresponses to those matching the pattern “{\u0003[Syntax]}”. Moreover, if one is only interested in the values that\r\na program t can reduce to, then, assuming that one defined a syntactic category Value, all one needs to do is\r\nto filter the results to those matching the pattern “{\u0003[Value]}”. Even more interestingly, if one is interested\r\nin all those reachable configurations in which x = 0 and y = z, then, assuming that State is defined as a\r\ncomma-separated set of pairs “variable 7→ value”, all one needs to do is to limit the results of the search to\r\nthose terms matching the pattern “{\u0003[hSyntax,(x 7→ 0, y 7→ v, z 7→ v, State)i]}”. However, unlike for the first\r\nembedding, with this second embedding one cannot blindly let the rewrite engine execute context reduction\r\ndefinitions. That is because the rewrite engine may choose to stop the rewriting of the term {split(t)} after\r\neach application of a rule of the form rulei, by choosing to apply the rule split(N) → \u0003[N] (see Figure 18).\r\nWhat makes our first embedding (Γ R1\r\nΓ\r\n) appropriate for executing Γ by letting a rewrite engine\r\nto blindly execute R1\r\nΓ\r\nis that its computational correspondence property (3 in Theorem 10) lets t\r\n0\r\nin the\r\nsame rewriting context as t, so the rewriting process can continue, and that all the “erroneous” context\r\nrepresentation attempts (i.e., ones that cannot be applied a reduction rule) are eventually hidden away by\r\nfailing conditions. To achieve a similar effect, all we need to do with our second embedding in Figure 19 is\r\nto separate the propagation of splitting after each rule application from the actual rules.\r\nFigure 20 shows our third and best direct embedding of context reduction into rewriting logic. An\r\nadditional wrapper of syntax is introduced, “•”, which is responsible for executing precisely one reduction\r\nstep in the original context reduction definition, and then consuming itself. To execute multiple reduction\r\nsteps sequentially, we need to transitively close this one-step relation. This can be easily achieved with\r\nthe conditional rule in Figure 20. One should not get tricked and drop the top wrapper, because then\r\nthere is nothing to stop the applications of rewrite rules at any places in the term to rewrite, potentially\r\nincluding places which are not allowed to be evaluated yet, such as, for example, in the branches of a\r\nconditional. Moreover, such applications of rules could happen concurrently, which is strictly disallowed by\r\ncontext reduction. The role of the two wrappers, • and { }, is precisely to inhibit the otherwise unrestricted\r\npotential to apply rewrite rules everywhere and concurrently: rules are now applied sequentially and only at\r\nthe top of the original term, exactly like in context reduction.\r\nTheorem 12. (Third faithful embedding of context reduction into rewriting logic) Let Γ be any\r\ncontext reduction definition and let R3\r\nΓ\r\nbe the rewrite logic theory associated to Γ using the embedding\r\nprocedure in Figure 20. Then\r\n1. (matching becomes deduction) A term t matches rulei in Γ whose lhs is l(c1[l1], ..., cn[ln]) iff\r\nR3\r\nΓ ` split(t)\r\nsplit\r\n→?l(c1[l1], ..., cn[ln]), where\r\nsplit\r\n→?is the rewrite relation restricted to split rules;\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R3\r\nΓ ` split(t)\r\nsplit\r\n→? u and R3\r\nΓ ` •(u) →1\r\nt\r\n0\r\nusing rulei; moreover, rulei applies similarly (same contexts and same substitution);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R3\r\nΓ ` {t} → {t\r\n0}.\r\nThe faithful embeddings of context reduction into rewriting logic above can be used at least two different\r\nways. On the one hand, they can be used as compilation steps transforming a context-sensitive reduction\r\nsystem into an equivalent context-insensitive term rewrite system, which can further be interpreted or com\u0002piled using conventional rewrite techniques and existing rewrite engines. In particular, as suggested by the\r\nnumbers in Section 5.4.7 comparing Maude running the resulting rewrite theory against PLT-Redex running\r\na direct brute-force implementation of the original context reduction definition, it may serve as a means\r\ntowards getting a more efficient implementation of context reduction executable engines. On the other\r\nhand, the embeddings above are so simple, that one can simply use them manually and thus “think context\r\nreduction” in rewriting logic.\r\n72\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/8c63acd4-3be8-4f20-a83e-523052d5b4d1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9090fc496488478815389cbf28690b19d614a6ec6c82f1b02e3602c358ebce44",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "8c63acd4-3be8-4f20-a83e-523052d5b4d1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "interested in listing all terms that are reachable from a given term t using the original context reduction\r\ndefinition, then all one needs to do is to invoke a search procedure on the term {split(t)} and limit its\r\nresponses to those matching the pattern “{\u0003[Syntax]}”. Moreover, if one is only interested in the values that\r\na program t can reduce to, then, assuming that one defined a syntactic category Value, all one needs to do is\r\nto filter the results to those matching the pattern “{\u0003[Value]}”. Even more interestingly, if one is interested\r\nin all those reachable configurations in which x = 0 and y = z, then, assuming that State is defined as a\r\ncomma-separated set of pairs “variable 7→ value”, all one needs to do is to limit the results of the search to\r\nthose terms matching the pattern “{\u0003[hSyntax,(x 7→ 0, y 7→ v, z 7→ v, State)i]}”. However, unlike for the first\r\nembedding, with this second embedding one cannot blindly let the rewrite engine execute context reduction\r\ndefinitions. That is because the rewrite engine may choose to stop the rewriting of the term {split(t)} after\r\neach application of a rule of the form rulei, by choosing to apply the rule split(N) → \u0003[N] (see Figure 18).\r\nWhat makes our first embedding (Γ R1\r\nΓ\r\n) appropriate for executing Γ by letting a rewrite engine\r\nto blindly execute R1\r\nΓ\r\nis that its computational correspondence property (3 in Theorem 10) lets t\r\n0\r\nin the\r\nsame rewriting context as t, so the rewriting process can continue, and that all the “erroneous” context\r\nrepresentation attempts (i.e., ones that cannot be applied a reduction rule) are eventually hidden away by\r\nfailing conditions. To achieve a similar effect, all we need to do with our second embedding in Figure 19 is\r\nto separate the propagation of splitting after each rule application from the actual rules.\r\nFigure 20 shows our third and best direct embedding of context reduction into rewriting logic. An\r\nadditional wrapper of syntax is introduced, “•”, which is responsible for executing precisely one reduction\r\nstep in the original context reduction definition, and then consuming itself. To execute multiple reduction\r\nsteps sequentially, we need to transitively close this one-step relation. This can be easily achieved with\r\nthe conditional rule in Figure 20. One should not get tricked and drop the top wrapper, because then\r\nthere is nothing to stop the applications of rewrite rules at any places in the term to rewrite, potentially\r\nincluding places which are not allowed to be evaluated yet, such as, for example, in the branches of a\r\nconditional. Moreover, such applications of rules could happen concurrently, which is strictly disallowed by\r\ncontext reduction. The role of the two wrappers, • and { }, is precisely to inhibit the otherwise unrestricted\r\npotential to apply rewrite rules everywhere and concurrently: rules are now applied sequentially and only at\r\nthe top of the original term, exactly like in context reduction.\r\nTheorem 12. (Third faithful embedding of context reduction into rewriting logic) Let Γ be any\r\ncontext reduction definition and let R3\r\nΓ\r\nbe the rewrite logic theory associated to Γ using the embedding\r\nprocedure in Figure 20. Then\r\n1. (matching becomes deduction) A term t matches rulei in Γ whose lhs is l(c1[l1], ..., cn[ln]) iff\r\nR3\r\nΓ ` split(t)\r\nsplit\r\n→?l(c1[l1], ..., cn[ln]), where\r\nsplit\r\n→?is the rewrite relation restricted to split rules;\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff R3\r\nΓ ` split(t)\r\nsplit\r\n→? u and R3\r\nΓ ` •(u) →1\r\nt\r\n0\r\nusing rulei; moreover, rulei applies similarly (same contexts and same substitution);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff R3\r\nΓ ` {t} → {t\r\n0}.\r\nThe faithful embeddings of context reduction into rewriting logic above can be used at least two different\r\nways. On the one hand, they can be used as compilation steps transforming a context-sensitive reduction\r\nsystem into an equivalent context-insensitive term rewrite system, which can further be interpreted or com\u0002piled using conventional rewrite techniques and existing rewrite engines. In particular, as suggested by the\r\nnumbers in Section 5.4.7 comparing Maude running the resulting rewrite theory against PLT-Redex running\r\na direct brute-force implementation of the original context reduction definition, it may serve as a means\r\ntowards getting a more efficient implementation of context reduction executable engines. On the other\r\nhand, the embeddings above are so simple, that one can simply use them manually and thus “think context\r\nreduction” in rewriting logic.\r\n72\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/8c63acd4-3be8-4f20-a83e-523052d5b4d1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9090fc496488478815389cbf28690b19d614a6ec6c82f1b02e3602c358ebce44",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 766
      },
      {
        "segments": [
          {
            "segment_id": "5547696b-2751-4bcc-b977-f0a105ff37bc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction rule Two rewriting logic unconditional rules\r\nrulei :\r\nl(c1[l1], ..., cn[ln]) → r(c\r\n0\r\n1[r1], ..., c0\r\nn0 [rn0 ]) \r\n\r\n\r\n\r\nif l is proper (i.e., not a variable) then add the rule\r\nsplit(l(N1, ..., Nn)) → l(split(N1), ..., split(Nn))\r\nadd the rule\r\nrulei :\r\n•(l(c1[l1], ..., cn[ln])) → r(plug(c\r\n0\r\n1[r1]), ..., plug(c\r\n0\r\nn[rn0 ]))\r\nwhere\r\n“Syntax ::= ... | •(Syntax)” is an additional “wrapper”, with the same intuition as the homonymous wrapper in\r\nthe embedding of SOS in Section 5.1.1: •(t) reduces t one step (the intuition for “step” comes from Γ).\r\nTransitive closure Rewriting logic conditional rule\r\nt → t\r\n0\r\nt \u0010 t\r\n0\r\nand\r\nt → u, u \u0010 t\r\n00\r\nt \u0010 t\r\n0 {t} → {t\r\n0\r\n} if • (split(t)) → t\r\n0\r\nContext reduction rules Corresponding rewriting logic rules\r\n{p} → {p\r\n0\r\n} if • (split(p)) → p\r\n0\r\nhc, σi[x] → hc, σi[σ[x]] or •(hc, σi[x]) → plug(hc, σi[σ[x]]) or\r\nhc[x], σi → hc[σ[x]], σi\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi\r\n•(hc[x], σi) → hplug(c[σ[x]]), σi\r\ni1 + i2 → i1 +Int i2 •(c[i1 + i2]) → plug(c[i1 +Int i2]))\r\ni1 ≤ i2 → i1 ≤Int i2 •(c[i1 ≤ i2]) → plug(c[i1 ≤Int i2])\r\nnot b → notBool b •(c[not b]) → plug(c[notBool b])\r\ntrue and b → b •(c[true and b]) → plug(c[b])\r\nfalse and b → false •(c[false and b]) → plug(c[false])\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or •(hc, σi[x := v]) → plug(hc, σ[v/x]i[skip]) or\r\nhc[x := v], σi → hc[skip], σ[v/x]i\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi (may be redundant)\r\n•(hc[x := v], σi) → hplug(c[skip]), σ[v/x]i\r\nskip; s → s •(c[skip; s]) → plug(c[s])\r\nif true then s1 else s2 → s1 •(c[if true then s1 else s2]) → plug(c[s1])\r\nif false then s1 else s2 → s2 •(c[if false then s1 else s2]) → plug(c[s2])\r\nwhile b do s → if b then (s; while b do s) else skip •(c[while b do s]) → plug(c[if b then (s; while b do s) else skip])\r\nhc, σi[halt i] → hi, σi or •(hc, σi[halt i]) → hi, σi or\r\nhc[halt i], σi → hi, σi\r\n\u001a\r\nsplit(hp, σi) → hsplit(p), σi (may be redundant)\r\n•(hc[halt i], σi) → hi, σi\r\nskip; a → a •(c[skip; a]) → plug(c[a])\r\nFigure 20: Third embedding of context reduction into rewriting logic (Γ R3\r\nΓ\r\n) and example\r\n73\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/5547696b-2751-4bcc-b977-f0a105ff37bc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e04d07bd978da31f5e91bdc42bc8f337be1cd671e8eb86240eaae10e449f041",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 424
      },
      {
        "segments": [
          {
            "segment_id": "97e697ea-cb9f-414b-b61a-3a7a52f278e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.6 Context Reduction as a Methodological Fragment of K\r\nIn this section we discuss an automatic embedding procedure of any context reduction definition Γ into a\r\nK definition KΓ. This embedding is also faithful to the computational granularity of the original context\r\nreduction definition, in the sense that any computational step in Γ has a precise one-step correspondent\r\nin KΓ and vice-versa. Additionally, KΓ is as compact as Γ: it adds one heating/cooling rule per context\r\nevaluation production and one rewrite rule per context reduction rule. Therefore, if one wants to use context\r\nreduction within K then one is free to do so, but, of course, one cannot circumvent the limitations of context\r\nreduction. As shown by the languages defined in the appendixes of this paper in K, such as imperative,\r\nfunctional, object-oriented and logic programming languages, one may be better off using the full strength\r\nof K, unlimited by restricted methodological fragments of K, such as context reduction.\r\nFigure 21 shows our faithful embedding procedure together with an example applying it on our running\r\nsimple imperative language. The result below shows the faithfulness of this embedding:\r\nTheorem 13. (Faithful embedding of context reduction into K) Let Γ be any context reduction\r\ndefinition and let KΓ be the K theory associated to Γ using the embedding procedure in Figure 21. Then\r\n1. (embedding splitting/plugging into K deduction) A term t can be split or “parsed” as c[r] in Γ\r\niff KΓ ` t \n?c[r];\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff KΓ ` t \n? u, KΓ ` t0 \n? u0\r\n, and\r\nKΓ ` LuM →1Lu\r\n0\r\nM using rulei; moreover, rulei applies similarly (same contexts and same substitution,\r\nall modulo the correspondence in 1.);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff KΓ ` LtM → Lt\r\n0\r\nM.\r\n5.4.7 Experiments\r\n5.5 Abstract State Machines and the SECD Machine\r\n5.6 The Chemical Abstract Machine\r\nBerry and Boudol’s chemical abstract machine, or CHAM [?], is both a model of concurrency and a specific\r\nstyle of giving operational semantics definitions. Berry and Boudol identify a number of limitations inherent\r\nin SOS, particularly its lack of true concurrency, and what they called SOS’s “rigidity to syntax” [?]. They\r\nthen present the CHAM as an alternative to SOS. In fact, as pointed out in [?], what the CHAM is, is a\r\nparticular definitional style within RLS. That is, every CHAM is, by definition, a specific kind of rewrite\r\ntheory; and CHAM computation is precisely concurrent rewriting computation; that is, proof in rewriting\r\nlogic.\r\nThe basic metaphor giving its name to the Cham is inspired by Banˆatre and Le M`etayer’s GAMMA\r\nlanguage [3]. It views a distributed state as a “solution” in which many “molecules” float, and understands\r\nconcurrent transitions as “reactions”. It is possible to define a variety of chemical abstract machines. Each\r\nof them corresponds to a rewrite theory satisfying certain common conditions.\r\nThere is an interesting analogy between CHAM and K. If one regards computations as “chemical so\u0002lutions”, then what we call “computation structural equation” above can be thought of as a pair of rules\r\n“heating/cooling” in CHAM. Recall that the role of “heating” in CHAM is to rearrange the solution so\r\nthat “reactions” can take place. Once reactions take place, “cooling” rules insert the result of the reaction\r\nback into the solution. Therefore, reactions in CHAM take place “modulo” heating and cooling. Of course,\r\nmultiple reactions can take place at the same time, which is what makes CHAM an elegant model for true\r\nconcurrency. Similarly, rewrites in K definitions take place “modulo” computation structural equations and\r\nconcurrently.\r\nWe find the conceptual analogy between K and CHAM so insightful, that we take the liberty to occasion\u0002ally replace the equality symbol “=” in our computation structural equations with the symbol “\n”, which\r\nis used in CHAM for heating/cooling.\r\n74\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/97e697ea-cb9f-414b-b61a-3a7a52f278e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20d1abbff6e9467d72e90754605be9a033ceb795879b4d2e8e85a9bd605a3862",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 661
      },
      {
        "segments": [
          {
            "segment_id": "97e697ea-cb9f-414b-b61a-3a7a52f278e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "5.4.6 Context Reduction as a Methodological Fragment of K\r\nIn this section we discuss an automatic embedding procedure of any context reduction definition Γ into a\r\nK definition KΓ. This embedding is also faithful to the computational granularity of the original context\r\nreduction definition, in the sense that any computational step in Γ has a precise one-step correspondent\r\nin KΓ and vice-versa. Additionally, KΓ is as compact as Γ: it adds one heating/cooling rule per context\r\nevaluation production and one rewrite rule per context reduction rule. Therefore, if one wants to use context\r\nreduction within K then one is free to do so, but, of course, one cannot circumvent the limitations of context\r\nreduction. As shown by the languages defined in the appendixes of this paper in K, such as imperative,\r\nfunctional, object-oriented and logic programming languages, one may be better off using the full strength\r\nof K, unlimited by restricted methodological fragments of K, such as context reduction.\r\nFigure 21 shows our faithful embedding procedure together with an example applying it on our running\r\nsimple imperative language. The result below shows the faithfulness of this embedding:\r\nTheorem 13. (Faithful embedding of context reduction into K) Let Γ be any context reduction\r\ndefinition and let KΓ be the K theory associated to Γ using the embedding procedure in Figure 21. Then\r\n1. (embedding splitting/plugging into K deduction) A term t can be split or “parsed” as c[r] in Γ\r\niff KΓ ` t \n?c[r];\r\n2. (step-for-step correspondence) Γ ` t → t\r\n0 using rulei iff KΓ ` t \n? u, KΓ ` t0 \n? u0\r\n, and\r\nKΓ ` LuM →1Lu\r\n0\r\nM using rulei; moreover, rulei applies similarly (same contexts and same substitution,\r\nall modulo the correspondence in 1.);\r\n3. (computational correspondence) Γ ` t \u0010 t\r\n0\r\niff KΓ ` LtM → Lt\r\n0\r\nM.\r\n5.4.7 Experiments\r\n5.5 Abstract State Machines and the SECD Machine\r\n5.6 The Chemical Abstract Machine\r\nBerry and Boudol’s chemical abstract machine, or CHAM [?], is both a model of concurrency and a specific\r\nstyle of giving operational semantics definitions. Berry and Boudol identify a number of limitations inherent\r\nin SOS, particularly its lack of true concurrency, and what they called SOS’s “rigidity to syntax” [?]. They\r\nthen present the CHAM as an alternative to SOS. In fact, as pointed out in [?], what the CHAM is, is a\r\nparticular definitional style within RLS. That is, every CHAM is, by definition, a specific kind of rewrite\r\ntheory; and CHAM computation is precisely concurrent rewriting computation; that is, proof in rewriting\r\nlogic.\r\nThe basic metaphor giving its name to the Cham is inspired by Banˆatre and Le M`etayer’s GAMMA\r\nlanguage [3]. It views a distributed state as a “solution” in which many “molecules” float, and understands\r\nconcurrent transitions as “reactions”. It is possible to define a variety of chemical abstract machines. Each\r\nof them corresponds to a rewrite theory satisfying certain common conditions.\r\nThere is an interesting analogy between CHAM and K. If one regards computations as “chemical so\u0002lutions”, then what we call “computation structural equation” above can be thought of as a pair of rules\r\n“heating/cooling” in CHAM. Recall that the role of “heating” in CHAM is to rearrange the solution so\r\nthat “reactions” can take place. Once reactions take place, “cooling” rules insert the result of the reaction\r\nback into the solution. Therefore, reactions in CHAM take place “modulo” heating and cooling. Of course,\r\nmultiple reactions can take place at the same time, which is what makes CHAM an elegant model for true\r\nconcurrency. Similarly, rewrites in K definitions take place “modulo” computation structural equations and\r\nconcurrently.\r\nWe find the conceptual analogy between K and CHAM so insightful, that we take the liberty to occasion\u0002ally replace the equality symbol “=” in our computation structural equations with the symbol “\n”, which\r\nis used in CHAM for heating/cooling.\r\n74\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/97e697ea-cb9f-414b-b61a-3a7a52f278e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20d1abbff6e9467d72e90754605be9a033ceb795879b4d2e8e85a9bd605a3862",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 661
      },
      {
        "segments": [
          {
            "segment_id": "bfb7d76f-462c-45cf-b2aa-225aeb144a4a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Context reduction syntax K syntax\r\nSyntax nonterminals N1, N2, ... One top non-terminal (or sort), K\r\nContext nonterminals Cxt1, Cxt2, ... Nothing needed\r\nImplicit notation “context[term]” and\r\nimplicit “split” and “plug” \u001b\r\n \r\n\u001a\r\nAn associative binary operator y on K, i.e.,\r\nK ::= ... | List·\r\ny[K]\r\nEvaluation context production K heating/cooling rule\r\nCxt0::= π(N1, ..., Nn, Cxt) π(N1, ..., Nn, K) \n K y π(N1, ..., Nn, \u0003)\r\nRecall from Section 3 that π(N1, ..., Nn, \u0003) is syntactic sugar for a (new) operation called π( , ..., , \u0003)\r\n(underscores “ ” serve as argument placeholders) applied to N1, ..., Nn.\r\nContext reduction rule K rule\r\nl → r LlM → LrM\r\nwhere\r\nK ::= ... | LKM is a “top-level” wrapper for K\r\nand\r\nγ[t] = t y γ\r\nπ(t1, ..., tn, γ) = γ y π(t1, ...,tn, \u0003)\r\nπ(t1, ..., tn) = π(t1, ...,tn)\r\nz = z\r\nHere t, t1, ..., tn range over non-contextual terms (i.e., ones which are not evaluation contexts, but can potentially\r\ncontain instantiated contexts), γ ranges over evaluation contexts, and z is any variable, contextual or not. In\r\nother words, the evaluation contexts are flattened into K computation structures by iteratively “extracting\r\nsubcontexts and placing them in front”, until the redex becomes the first computational task.\r\nContext reduction definition Corresponding K definition\r\nhc, σi[x] → hc, σi[σ[x]] or Lx y c y h\u0003, σiM → Lσ[x] y c y h\u0003, σiM or\r\nhc[x], σi → hc[σ[x]], σi Lhx y c, σiM → Lhσ[x] y c, σiM\r\ni1 + i2 → i1 +Int i2 Li1 + i2|i → Li1 +Int i2|i\r\ni1 ≤ i2 → i1 ≤Int i2 Li1 ≤ i2|i → Li1 ≤Int i2|i\r\nnot b → notBool b Lnot b|i → LnotBool b|i\r\ntrue and b → b Ltrue and b|i → Lb|i\r\nfalse and b → false Lfalse and b|i → Lfalse|i\r\nhc, σi[x := v] → hc, σ[v/x]i[skip] or Lx := v y c y h\u0003, σiM → Lskip y c y h\u0003, σ[v/x]iM or\r\nhc[x := v], σi → hc[skip], σ[v/x]i Lhx := v y c, σiM → Lhskip y c, σ[v/x]iM\r\nskip; s → s Lskip; s|i → Ls|i\r\nif true then s1 else s2 → s1 Lif true then s1 else s2|i → Ls1|i\r\nif false then s1 else s2 → s2 Lif false then s1 else s2|i → Ls2|i\r\nwhile b do s → if b then (s; while b do s) else skip Lwhile b do s|i → Lif b then (s; while b do s) else skip|i\r\nhc, σi[halt i] → hi, σi or Lhalt i y c y h\u0003, σiM → Lhi, σiM or\r\nhc[halt i], σi → hi, σi Lhhalt i y c, σiM → Lhi, σiM\r\nskip; a → a Lskip; a|i → La|i\r\nFigure 21: Embedding of context reduction into K (Γ KΓ) and example\r\n75\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/bfb7d76f-462c-45cf-b2aa-225aeb144a4a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1ce5227da0aa67c89c97f110098ae773f540b04b6d0b14bc1911ff5d08e0d071",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 492
      },
      {
        "segments": [
          {
            "segment_id": "87d5acf7-10ad-4c93-a2f9-cd662c38518c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "However, CHAM is not only a special case of rewriting logic, but also a special case of K. What makes this\r\npossible is the fact that both CHAM and K make use of unconditional rules. The major distinction between\r\nCHAM and K, in addition to dropping all the chemical intuitions, is that rules in K can also match and apply\r\nacross “molecules”, grabbing from each molecule what is needed without any need for an “airlock” operation.\r\nHere is how a CHAM can be transformed mechanically in a K definition, say KCHAM (for simplicity, we here\r\nassume only one type of molecule, say M):\r\n• Add automatically a “solution” syntactic category as a comma-separated multiset, say S, as well as\r\nthe CHAM special wrapper of solutions into molecules, {| |}:\r\nM ::= ... | {|S|} (“...” stay for “same as in the CHAM”)\r\nS ::= Set,[M] solutions of molecules of type M\r\n• Add an “airlock” operation and equation:\r\nS ::= ... | M / {|S|} (airlock added as solution construct)\r\n{|m, s|} = {|m / {|s|} |} (m ∈ M, s ∈ SM )\r\n• For each CHAM rule, i.e., a rule of the form\r\nm1, m2, ..., mk → m0\r\n1\r\n, m0\r\n2\r\n, ..., m0\r\nl\r\nadd a K rule of the form\r\n{|m1, m2, ..., mk|} → {|m0\r\n1\r\n, m0\r\n2\r\n, ..., m0\r\nl\r\n|}\r\n• For each heating/cooling rule “t \n t\r\n0” in CHAM add either one equation t = t0 or two rules t → t0\r\nand t\r\n0 → t; separate heating or cooling CHAM rules are just the same rules in K.\r\nIt is easy now easy to see that s →∗s\r\n0\r\nin CHAM iff KCHAM ` s →∗s\r\n0\r\n.\r\n76\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/87d5acf7-10ad-4c93-a2f9-cd662c38518c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=beeb1c67bb366d694c442016e987e160ba7e692a00aab87aead7eb848f98521f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 308
      },
      {
        "segments": [
          {
            "segment_id": "1575320f-8760-46a3-bd8e-7ba3ce2ed8bd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "6 The K-CHALLENGE Language\r\nWe next propose a language design scenario in which a hypothetical language designer starts with the simple\r\nimperative language in Figure 4 and extends it with various non-trivial language features. The purpose of\r\nthis section is not to propose any novel interesting programming language (though one could write quite\r\ninteresting and tricky K-CHALLENGE programs). The goal of this section is twofold:\r\n1. To challenge the existing language definitional frameworks with a non-trivial language design task, at\r\nthe same time revealing some of their inherent limitations, and\r\n2. To show how K avoids those limitations and how it can support the proposed design scenario, requiring\r\nthe designer to do minimal changes on the existing design when adding each new feature.\r\nA major goal of an ideal language definitional framework is, of course, to support arbitrarily complex language\r\ndesigns with minimal burden on the user. We argue that, at least for the proposed non-trivial language\r\ndesign scenario, K indeed requires minimal changes on existing definitions when adding new features. We\r\nalso discuss how other definitional frameworks fail to have this property. To make this language design\r\nscenario as realistic as possible, at each moment we pretend that the newly added feature is the last one to\r\nbe added to the language. In other words, a feature that can be potentially added in the future cannot be\r\nused to justify a particular definitional choice at the current moment. For example, if one knew upfront that\r\none wanted to eventually add references with explicit variable address extraction to one’s language, then one\r\nmay choose upfront to split the state into an environment and a store. However, we want to point out that\r\nif such a “radical” structural change requires one to revisit all or most of the existing definitions, then the\r\nunderlying framework is far from ideal.\r\nThis section may indirectly also suggest that modularity of language definitions can perhaps be achieved\r\nonly within a particular and well-defined universe. For example, one may devise a modular definitional\r\nmethodology (e.g., a purely “syntactic” substitution-based one), where say each additional language feature\r\nis added without touching any of definitions of the previous features, in a purely functional universe known a\r\npriori not to allow for side effects or concurrency. If complex side effects are allowed in the universe then one\r\nmay need to develop a different definitional methodology, which may also change when one adds concurrency.\r\nMoreover, the addition of new features may make previous features “obsolete” of even conflicting. For\r\nexample, adding references with explicit variable address access may make the language designer prefer an\r\nassignment construct that takes a location and a value instead of a variable and a value as before; the two\r\ncannot be both kept in the language because of conflicting semantics (if x is a variable holding a location l\r\nthen one may choose x := l\r\n0\r\neither to write l\r\n0\r\nin x, or to write value l\r\n0 at location l). Finally, any definitional\r\nmethodology developed for imperative, functional or object-oriented languages may need to be radically\r\nchanged or even dropped all together when one defines a logic programming language.\r\nVariant 1 — increment. Let us add an increment construct, ++Name, taking a variable, incrementing\r\nits value, and then returning the new, incremented value. In K one can do it easily as follows:\r\nAExp ::= . . . | ++ Name\r\nL++ x\r\ni\r\n|ikL σ\r\nσ[i/x]\r\nMstate where i = σ[x] + 1\r\nNo change is required on the existing definition in Figure 4; all what needs to do is to add the syntax and the\r\nsemantics of the new language construct above. Since expressions now have side effects, a big step definition\r\nof the previous variant of the language would need to be radically changed. Indeed, if expressions have no side\r\neffects, then a big-step definition can associate configurations he, σi to values v using, for example, sequents\r\nof the form he, σi ⇓ v with the meaning “expression e evaluates in state σ to value v”. Once expressions\r\nhave side effects, one needs to change all the existing rules to use sequents of the form he, σi ⇓ hv, σ0i (σ\r\n0\r\nis\r\nthe state obtained after evaluating e in state σ to value v).\r\n77\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/1575320f-8760-46a3-bd8e-7ba3ce2ed8bd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=34cc059620a6435830676d7baa4253a53fa5b2812e6bd95e61e3cc1a32e93625",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 731
      },
      {
        "segments": [
          {
            "segment_id": "1575320f-8760-46a3-bd8e-7ba3ce2ed8bd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "6 The K-CHALLENGE Language\r\nWe next propose a language design scenario in which a hypothetical language designer starts with the simple\r\nimperative language in Figure 4 and extends it with various non-trivial language features. The purpose of\r\nthis section is not to propose any novel interesting programming language (though one could write quite\r\ninteresting and tricky K-CHALLENGE programs). The goal of this section is twofold:\r\n1. To challenge the existing language definitional frameworks with a non-trivial language design task, at\r\nthe same time revealing some of their inherent limitations, and\r\n2. To show how K avoids those limitations and how it can support the proposed design scenario, requiring\r\nthe designer to do minimal changes on the existing design when adding each new feature.\r\nA major goal of an ideal language definitional framework is, of course, to support arbitrarily complex language\r\ndesigns with minimal burden on the user. We argue that, at least for the proposed non-trivial language\r\ndesign scenario, K indeed requires minimal changes on existing definitions when adding new features. We\r\nalso discuss how other definitional frameworks fail to have this property. To make this language design\r\nscenario as realistic as possible, at each moment we pretend that the newly added feature is the last one to\r\nbe added to the language. In other words, a feature that can be potentially added in the future cannot be\r\nused to justify a particular definitional choice at the current moment. For example, if one knew upfront that\r\none wanted to eventually add references with explicit variable address extraction to one’s language, then one\r\nmay choose upfront to split the state into an environment and a store. However, we want to point out that\r\nif such a “radical” structural change requires one to revisit all or most of the existing definitions, then the\r\nunderlying framework is far from ideal.\r\nThis section may indirectly also suggest that modularity of language definitions can perhaps be achieved\r\nonly within a particular and well-defined universe. For example, one may devise a modular definitional\r\nmethodology (e.g., a purely “syntactic” substitution-based one), where say each additional language feature\r\nis added without touching any of definitions of the previous features, in a purely functional universe known a\r\npriori not to allow for side effects or concurrency. If complex side effects are allowed in the universe then one\r\nmay need to develop a different definitional methodology, which may also change when one adds concurrency.\r\nMoreover, the addition of new features may make previous features “obsolete” of even conflicting. For\r\nexample, adding references with explicit variable address access may make the language designer prefer an\r\nassignment construct that takes a location and a value instead of a variable and a value as before; the two\r\ncannot be both kept in the language because of conflicting semantics (if x is a variable holding a location l\r\nthen one may choose x := l\r\n0\r\neither to write l\r\n0\r\nin x, or to write value l\r\n0 at location l). Finally, any definitional\r\nmethodology developed for imperative, functional or object-oriented languages may need to be radically\r\nchanged or even dropped all together when one defines a logic programming language.\r\nVariant 1 — increment. Let us add an increment construct, ++Name, taking a variable, incrementing\r\nits value, and then returning the new, incremented value. In K one can do it easily as follows:\r\nAExp ::= . . . | ++ Name\r\nL++ x\r\ni\r\n|ikL σ\r\nσ[i/x]\r\nMstate where i = σ[x] + 1\r\nNo change is required on the existing definition in Figure 4; all what needs to do is to add the syntax and the\r\nsemantics of the new language construct above. Since expressions now have side effects, a big step definition\r\nof the previous variant of the language would need to be radically changed. Indeed, if expressions have no side\r\neffects, then a big-step definition can associate configurations he, σi to values v using, for example, sequents\r\nof the form he, σi ⇓ v with the meaning “expression e evaluates in state σ to value v”. Once expressions\r\nhave side effects, one needs to change all the existing rules to use sequents of the form he, σi ⇓ hv, σ0i (σ\r\n0\r\nis\r\nthe state obtained after evaluating e in state σ to value v).\r\n77\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/1575320f-8760-46a3-bd8e-7ba3ce2ed8bd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=34cc059620a6435830676d7baa4253a53fa5b2812e6bd95e61e3cc1a32e93625",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 731
      },
      {
        "segments": [
          {
            "segment_id": "1b972bba-f217-42d7-8061-56151f8a1fea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "The other definitional styles discussed in this paper, namely (small-step) SOS, MSOS and context reduc\u0002tion can define increment as easily and modularly as K.\r\nVariant 2 — merging expressions. One annoying aspect of the current language is that one can only\r\nwrite/read integer values in the state, meaning also that one can only assign integer type expressions to\r\nvariables. We would naturally like to eliminate this limitation and add arbitrary expressions to the language,\r\nand allow them to be assigned to variables. That means, in particular that we would like to merge the\r\ndifferent categories of expressions, currently AExp and BExp, into only one syntactic category, say Exp; a\r\ntype checker can be also easily defined in K to ensure that expressions are used properly, but we do not do\r\nit here. Also, we take the opportunity to add one more type of expressions, namely floats, which should, of\r\ncourse, enjoy the same first-class citizen rights of the other expressions. One more change to the language\r\ndesign is also in place here. In the original design, a program was chosen to be a statement followed by an\r\nexpression. Inspired by languages such as BC, suppose that we prefer at this stage to extend the expressions\r\nwith a construct “Exp ::= ... | Stmt;Exp” and to eliminate programs all together, because we can replace\r\nthem with expressions. There are quite some changes above; however, they can all be done very easily in K:\r\n• Replace AExp, BExp and Pgm by Exp everywhere. This can be done either by editing the existing\r\ndefinitions mechanically (a tedious, but automatic process), or better, by using a conventional re\u0002name module composition operator if the underlying implementation of K offers support for module\r\ncomposition. For example, with our Maude implementation of K, one can simply import the mod\u0002ule “Variant1 ∗ (sort AExp to Exp, sort BExp to Exp, sort Pgm to Exp)”. For example, the syntax of\r\n≤ becomes “Exp ::= ... | Exp ≤ Exp” and that of halt becomes “Stmt ::= ... | haltExp”. All these\r\nare purely syntactic changes, with no influence on the K semantics. In fact, when using our current\r\nimplementation of K in Maude (see Section E), none of the existing equations or rules needs to change.\r\n• Add boolean and float numbers to values, that is, add “Val ::= ... | Bool | Float”, together with\r\nadditional attributes (grayed below) for language constructs intended to also work with floats, namely\r\n+ and ≤ :\r\nExp + Exp [strict, extends +Int, extends +Float ]\r\nExp ≤ Exp [seqstrict, extends ≤Int\r\n, extends ≤Float ]\r\nThe changes mentioned above are simple and necessary: the first merges the three syntactic categories\r\ninto one, the second extends the strict addition to floats, and the third extends the sequentially strict less\u0002then to floats. Any definitional style or framework must, in one way or another, do at least the above; some\r\nmay need more changes than necessary. Regarding the first change, note that renaming is a well-understood\r\nmodule composition operator in algebraic specification supported by most algebraic specification engines, so\r\none needs no justification for it in K. In other formalisms, including big-step/small-step SOS (modular or\r\nnot) and context reduction, one may need to resort on less elegant manual (though admittedly mechanical)\r\nchanges of syntactic category names, as well as of corresponding side conditions of rules. Moreover, since so\r\nfar the expressions evaluated only to integer values and since less-than is sequentially strict, the (small-step)\r\nSOS definition would most likely contain a rule\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhi ≤ a, σi → hi ≤ a\r\n0\r\n, σ0i\r\n, where i ∈ Int, a, a0 ∈ AExp, σ, σ0 ∈ State.\r\nUnless one envisioned such possible language extensions upfront and defined the rule above for any values\r\nv ∈ Val instead of for any integer i ∈ Int, similar rules need to be added for each extension, in particular\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhf ≤ a, σi → hf ≤ a\r\n0\r\n, σ0i\r\n, where f ∈ Float, a, a0 ∈ AExp, σ, σ0 ∈ State.\r\nSimilarly, if in a context reduction definition of this language the sequential strictness of “≤” was defined\r\nusing a production “Cxt ::= ... | Int ≤ Cxt” like in Figure 1, then one needs to add one more production to\r\nevaluation contexts, namely “Cxt ::= ... | Float ≤ Cxt”.\r\n78\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/1b972bba-f217-42d7-8061-56151f8a1fea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f267e843a5f5b2797fc30c08e47379db002829cd2f81bff32e91ab84de369fb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 754
      },
      {
        "segments": [
          {
            "segment_id": "1b972bba-f217-42d7-8061-56151f8a1fea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "The other definitional styles discussed in this paper, namely (small-step) SOS, MSOS and context reduc\u0002tion can define increment as easily and modularly as K.\r\nVariant 2 — merging expressions. One annoying aspect of the current language is that one can only\r\nwrite/read integer values in the state, meaning also that one can only assign integer type expressions to\r\nvariables. We would naturally like to eliminate this limitation and add arbitrary expressions to the language,\r\nand allow them to be assigned to variables. That means, in particular that we would like to merge the\r\ndifferent categories of expressions, currently AExp and BExp, into only one syntactic category, say Exp; a\r\ntype checker can be also easily defined in K to ensure that expressions are used properly, but we do not do\r\nit here. Also, we take the opportunity to add one more type of expressions, namely floats, which should, of\r\ncourse, enjoy the same first-class citizen rights of the other expressions. One more change to the language\r\ndesign is also in place here. In the original design, a program was chosen to be a statement followed by an\r\nexpression. Inspired by languages such as BC, suppose that we prefer at this stage to extend the expressions\r\nwith a construct “Exp ::= ... | Stmt;Exp” and to eliminate programs all together, because we can replace\r\nthem with expressions. There are quite some changes above; however, they can all be done very easily in K:\r\n• Replace AExp, BExp and Pgm by Exp everywhere. This can be done either by editing the existing\r\ndefinitions mechanically (a tedious, but automatic process), or better, by using a conventional re\u0002name module composition operator if the underlying implementation of K offers support for module\r\ncomposition. For example, with our Maude implementation of K, one can simply import the mod\u0002ule “Variant1 ∗ (sort AExp to Exp, sort BExp to Exp, sort Pgm to Exp)”. For example, the syntax of\r\n≤ becomes “Exp ::= ... | Exp ≤ Exp” and that of halt becomes “Stmt ::= ... | haltExp”. All these\r\nare purely syntactic changes, with no influence on the K semantics. In fact, when using our current\r\nimplementation of K in Maude (see Section E), none of the existing equations or rules needs to change.\r\n• Add boolean and float numbers to values, that is, add “Val ::= ... | Bool | Float”, together with\r\nadditional attributes (grayed below) for language constructs intended to also work with floats, namely\r\n+ and ≤ :\r\nExp + Exp [strict, extends +Int, extends +Float ]\r\nExp ≤ Exp [seqstrict, extends ≤Int\r\n, extends ≤Float ]\r\nThe changes mentioned above are simple and necessary: the first merges the three syntactic categories\r\ninto one, the second extends the strict addition to floats, and the third extends the sequentially strict less\u0002then to floats. Any definitional style or framework must, in one way or another, do at least the above; some\r\nmay need more changes than necessary. Regarding the first change, note that renaming is a well-understood\r\nmodule composition operator in algebraic specification supported by most algebraic specification engines, so\r\none needs no justification for it in K. In other formalisms, including big-step/small-step SOS (modular or\r\nnot) and context reduction, one may need to resort on less elegant manual (though admittedly mechanical)\r\nchanges of syntactic category names, as well as of corresponding side conditions of rules. Moreover, since so\r\nfar the expressions evaluated only to integer values and since less-than is sequentially strict, the (small-step)\r\nSOS definition would most likely contain a rule\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhi ≤ a, σi → hi ≤ a\r\n0\r\n, σ0i\r\n, where i ∈ Int, a, a0 ∈ AExp, σ, σ0 ∈ State.\r\nUnless one envisioned such possible language extensions upfront and defined the rule above for any values\r\nv ∈ Val instead of for any integer i ∈ Int, similar rules need to be added for each extension, in particular\r\nha, σi → ha\r\n0\r\n, σ0i\r\nhf ≤ a, σi → hf ≤ a\r\n0\r\n, σ0i\r\n, where f ∈ Float, a, a0 ∈ AExp, σ, σ0 ∈ State.\r\nSimilarly, if in a context reduction definition of this language the sequential strictness of “≤” was defined\r\nusing a production “Cxt ::= ... | Int ≤ Cxt” like in Figure 1, then one needs to add one more production to\r\nevaluation contexts, namely “Cxt ::= ... | Float ≤ Cxt”.\r\n78\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/1b972bba-f217-42d7-8061-56151f8a1fea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f267e843a5f5b2797fc30c08e47379db002829cd2f81bff32e91ab84de369fb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 754
      },
      {
        "segments": [
          {
            "segment_id": "b6297bf0-a70f-47d1-a27a-ac7b8dba84ad",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that adding such artifact rules or declarations is not necessary in K, because the seqstrict attribute\r\nis defined in terms of computations (K) and result computations (KResult), and that values were already\r\ndefined to be computation results (a necessary step when using the seqstrict attribute). In fact, our major\r\nreason for introducing the strictness attributes was precisely to eliminate the need to introduce or revisit such\r\nlow-level and uninteresting rules. The user of K needs to think and define the intended evaluation strategy of\r\neach language construct once and for all (right after defining its syntax). Thinking and designing a language\r\nin terms of computations and computation transformations, as opposed to particular syntactic categories\r\nand syntactic transformations, brings in our view a level of abstraction that enhances the modularity of the\r\ndefinitional framework.\r\nVariation 3 – output. Let us now add output to our language, that is, a statement “output Exp” taking\r\nan expression, evaluating it, and then outputting its value into a buffer (i.e., list) that collects all the output.\r\nIn addition to the strict language construct “output Exp”, the configuration also needs to incorporate an\r\noutput buffer, say wrapped by configuration item label output. Since values can be now collected in the\r\noutput buffer, there is no need for a program to evaluate or to halt to a value; in other words, one can pass\r\nto the “J K” operation a statement computation and modify the configuration initialization and termination,\r\nas well as the syntax and semantics of halt, accordingly (halt takes no arguments now, so we remove its\r\nprevious syntax/semantics and add the following instead):\r\nStmt ::= ... | output [strict] | halt\r\nConfig ::= ... | List[Val] | LList[Val]Moutput\r\nJsK = LLsMk L·Mstate L·MoutputM>\r\nh|L·Mk LvlMoutput|i> = vl\r\nLhalt|ik → L·Mk\r\nLoutput v\r\n·\r\n|ikh|·\r\nv\r\nMoutput\r\nWe claim that the K definition above is minimal. Indeed, the two declarations for halt (new syntax and rule)\r\nwere necessary because we decided for a completely different halt statement. Also, each of the remaining\r\nsix declarations above states a different and necessary part of the semantics of output: the first declares its\r\nsyntax and evaluation strategy, the second declares the buffer in which the output values are collected, the\r\nthird defines the new structure of the configuration that accommodates evaluations of statements and lists\r\nof values as results, the fourth and the fifth define the initialization and the termination of the computation\r\nusing the new configuration structure, while the sixth gives the actual semantics of output.\r\nAdding output to a language defined using conventional big-step or small-step SOS is devastating: one\r\nneeds to change every single rule to accommodate the new configuration containing the output buffer in\r\naddition to the syntax and the state. Like K, MSOS elegantly avoids doing that; all what needs to do in\r\nMSOS is to add an output label on transitions that is only used in the semantics of output. Context reduction\r\nis more modular than SOS, but one’s skill plays a more important role in achieving overall modularity. For\r\nexample, the immediate way to add output “modularly” in a context reduction definition is to change the\r\ncontext production “Cxt ::= ... | JCxt, StateK” into “Cxt ::= ... | JCxt, State, OutputK”. None of the other\r\nproductions need to change and so do all the existing reduction rules that do not mention the configuration\r\nconstruct, e.g., “if true then s1 else s2”, etc. Unfortunately, as an artifact of how matching works in context\r\nreduction, rules that use the configuration need to change to accommodate the new configuration. For\r\nexample, the rule “Jc, σK[x] → Jc, σK[σ[x]]” needs to change to “Jc, σ, oK[x] → Jc, σ, oK[σ[x]]”, even though\r\nthe new addition to the configuration, the output, plays no role in the semantics of variable lookup. The\r\n“user’s skill” we mentioned above to make context reduction also modular in this case, is to envision possible\r\nconfiguration changes and thus define a configuration as a list structure containing various configuration\r\nitems, for example:\r\nConfigItem ::= State | Output | ...\r\nCxt ::= JCxt, ConfigItem∗K\r\n79\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b6297bf0-a70f-47d1-a27a-ac7b8dba84ad.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e04cc690caaa1932c80c5ac7f1b4cfa1997708acf75bd2368c81959482c62dbe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 698
      },
      {
        "segments": [
          {
            "segment_id": "b6297bf0-a70f-47d1-a27a-ac7b8dba84ad",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that adding such artifact rules or declarations is not necessary in K, because the seqstrict attribute\r\nis defined in terms of computations (K) and result computations (KResult), and that values were already\r\ndefined to be computation results (a necessary step when using the seqstrict attribute). In fact, our major\r\nreason for introducing the strictness attributes was precisely to eliminate the need to introduce or revisit such\r\nlow-level and uninteresting rules. The user of K needs to think and define the intended evaluation strategy of\r\neach language construct once and for all (right after defining its syntax). Thinking and designing a language\r\nin terms of computations and computation transformations, as opposed to particular syntactic categories\r\nand syntactic transformations, brings in our view a level of abstraction that enhances the modularity of the\r\ndefinitional framework.\r\nVariation 3 – output. Let us now add output to our language, that is, a statement “output Exp” taking\r\nan expression, evaluating it, and then outputting its value into a buffer (i.e., list) that collects all the output.\r\nIn addition to the strict language construct “output Exp”, the configuration also needs to incorporate an\r\noutput buffer, say wrapped by configuration item label output. Since values can be now collected in the\r\noutput buffer, there is no need for a program to evaluate or to halt to a value; in other words, one can pass\r\nto the “J K” operation a statement computation and modify the configuration initialization and termination,\r\nas well as the syntax and semantics of halt, accordingly (halt takes no arguments now, so we remove its\r\nprevious syntax/semantics and add the following instead):\r\nStmt ::= ... | output [strict] | halt\r\nConfig ::= ... | List[Val] | LList[Val]Moutput\r\nJsK = LLsMk L·Mstate L·MoutputM>\r\nh|L·Mk LvlMoutput|i> = vl\r\nLhalt|ik → L·Mk\r\nLoutput v\r\n·\r\n|ikh|·\r\nv\r\nMoutput\r\nWe claim that the K definition above is minimal. Indeed, the two declarations for halt (new syntax and rule)\r\nwere necessary because we decided for a completely different halt statement. Also, each of the remaining\r\nsix declarations above states a different and necessary part of the semantics of output: the first declares its\r\nsyntax and evaluation strategy, the second declares the buffer in which the output values are collected, the\r\nthird defines the new structure of the configuration that accommodates evaluations of statements and lists\r\nof values as results, the fourth and the fifth define the initialization and the termination of the computation\r\nusing the new configuration structure, while the sixth gives the actual semantics of output.\r\nAdding output to a language defined using conventional big-step or small-step SOS is devastating: one\r\nneeds to change every single rule to accommodate the new configuration containing the output buffer in\r\naddition to the syntax and the state. Like K, MSOS elegantly avoids doing that; all what needs to do in\r\nMSOS is to add an output label on transitions that is only used in the semantics of output. Context reduction\r\nis more modular than SOS, but one’s skill plays a more important role in achieving overall modularity. For\r\nexample, the immediate way to add output “modularly” in a context reduction definition is to change the\r\ncontext production “Cxt ::= ... | JCxt, StateK” into “Cxt ::= ... | JCxt, State, OutputK”. None of the other\r\nproductions need to change and so do all the existing reduction rules that do not mention the configuration\r\nconstruct, e.g., “if true then s1 else s2”, etc. Unfortunately, as an artifact of how matching works in context\r\nreduction, rules that use the configuration need to change to accommodate the new configuration. For\r\nexample, the rule “Jc, σK[x] → Jc, σK[σ[x]]” needs to change to “Jc, σ, oK[x] → Jc, σ, oK[σ[x]]”, even though\r\nthe new addition to the configuration, the output, plays no role in the semantics of variable lookup. The\r\n“user’s skill” we mentioned above to make context reduction also modular in this case, is to envision possible\r\nconfiguration changes and thus define a configuration as a list structure containing various configuration\r\nitems, for example:\r\nConfigItem ::= State | Output | ...\r\nCxt ::= JCxt, ConfigItem∗K\r\n79\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b6297bf0-a70f-47d1-a27a-ac7b8dba84ad.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e04cc690caaa1932c80c5ac7f1b4cfa1997708acf75bd2368c81959482c62dbe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 698
      },
      {
        "segments": [
          {
            "segment_id": "e237400f-be05-44ed-a2de-3ea92a7f71d3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "Then one can write the reduction rules to match in the list of configuration items only those items of interest,\r\nfor example (γ, γ0 ∈ ConfigItem∗, c ∈ Cxt, σ ∈ State, x ∈ Name, o ∈ Output, v ∈ Val):\r\nJc,(γ, σ, γ0)K[x] → Jc,(γ, σ, γ0)K[σ[x]]\r\nJc,(γ, o, γ0)K[output v] → Jc,(γ,(o, v), γ0)K[skip]\r\nEven though one still needs to mention irrelevant variables just for matching reasons, such as the lists of\r\nconfiguration items γ and γ\r\n0\r\n, the context reduction definition becomes with this change much more modular\r\nthan before. From a K perspective, a slight inconvenience in both MSOS and context reduction is that\r\none needs to introduce (if not already in the language) the “value” statement skip and then, using an\r\nadditional reduction step, discard it; in K one just dissolves a statement once finished, thus capturing the\r\nintended computation granularity of the statement construct. Introducing skip and changing the computation\r\ngranularity of statements is, however, generally accepted by purely syntactic definitional approaches.\r\nVariation 4(a) – λ with substitution. The language defined so far has no capabilities to group code\r\nin functions or procedures. We next enrich our language with λ-expressions; more precisely, we add λ\u0002abstraction and λ-application as new expression constructs and then give them a substitution-based seman\u0002tics. Any of the variants of λ-calculus discussed in Section 4.2 can be considered. For the sake of concreteness\r\nwe, however, choose the call-by-value parameter passing style here:\r\nVal ::= . . . | λName.Exp\r\nExp ::= . . . | Exp Exp [strict]\r\nL(λx.e) v\r\ne[v/x]\r\n|ik where x ∈ Name, e ∈ Exp, v ∈ Val.\r\nOne (rather standard) problem with definitions like the above in the context of λ-calculus with imperative\r\nfeatures, is that one cannot assign the bound variable (x) in the body of the λ-abstraction (e), so one may\r\nneed a static analysis to discard programs that do it. A (rather standard) alternative to this is to instead\r\nintroduce a fresh variable, say y, bind it to the argument value (v) in the state, and then replace the bound\r\nvariable x by y. We can do all these in one step in K, replacing the rule above with the following one:\r\nL(λx.e) v\r\ne[y/x]\r\n|ikL σ\r\nσ[v/y]\r\nMstate where y ∈ Name is a fresh name.\r\nThe reason we need a fresh name (y) and an α-conversion to replace the bound name (x) in the rule above\r\ninstead of just binding x to v in the state, is because x may already be used outside the scope of the\r\nλ-abstraction and we obviously do not want to affect its value there.\r\nContext reduction definitions take a similar approach to add the features above. When adopting a\r\nsubstitution-based style as above (which may not necessarily be always possible or the best, e.g., when\r\nadding references and concurrency to the language), a slight advantage of SOS approaches is that they do\r\nnot need a fresh name: instead, they just initiate in the condition of the rule a reduction of e in the modified\r\nstate σ[v/x], and then continue the reduction in the conclusion of the rule using the original state, σ.\r\nNow that binding is available, the language designer may want to disallow reads and writes of variables\r\nthat were not explicitly bound. From here on, we therefore assume that the original expressions/program to\r\nevaluate is closed (this can be easily achieved automatically by wrapping the entire program in a series of λ\r\nabstractions binding all the originally free variables and then calling it on initial values for those variables).\r\nVariation 4(b) – λ with closures\r\nSuppose that, for several reasons, our language designer decides to switch to an environment-based\r\ndefinition of her language. As usual, we assume an infinite number of possible locations and that we can\r\nget fresh locations whenever needed. A major structural change in the configuration is required, namely the\r\nstate is split into an environment and a store. This structural change inevitably affects the existing rules that\r\nrelied on the state (i.e., explicitly matched it), but, fortunately, the other rules need not be touched. Below\r\n80\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e237400f-be05-44ed-a2de-3ea92a7f71d3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be4842675c240e960cae89c4bddd6f90841979cc2203cc638fd5651c2c9eb3c5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 703
      },
      {
        "segments": [
          {
            "segment_id": "e237400f-be05-44ed-a2de-3ea92a7f71d3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "Then one can write the reduction rules to match in the list of configuration items only those items of interest,\r\nfor example (γ, γ0 ∈ ConfigItem∗, c ∈ Cxt, σ ∈ State, x ∈ Name, o ∈ Output, v ∈ Val):\r\nJc,(γ, σ, γ0)K[x] → Jc,(γ, σ, γ0)K[σ[x]]\r\nJc,(γ, o, γ0)K[output v] → Jc,(γ,(o, v), γ0)K[skip]\r\nEven though one still needs to mention irrelevant variables just for matching reasons, such as the lists of\r\nconfiguration items γ and γ\r\n0\r\n, the context reduction definition becomes with this change much more modular\r\nthan before. From a K perspective, a slight inconvenience in both MSOS and context reduction is that\r\none needs to introduce (if not already in the language) the “value” statement skip and then, using an\r\nadditional reduction step, discard it; in K one just dissolves a statement once finished, thus capturing the\r\nintended computation granularity of the statement construct. Introducing skip and changing the computation\r\ngranularity of statements is, however, generally accepted by purely syntactic definitional approaches.\r\nVariation 4(a) – λ with substitution. The language defined so far has no capabilities to group code\r\nin functions or procedures. We next enrich our language with λ-expressions; more precisely, we add λ\u0002abstraction and λ-application as new expression constructs and then give them a substitution-based seman\u0002tics. Any of the variants of λ-calculus discussed in Section 4.2 can be considered. For the sake of concreteness\r\nwe, however, choose the call-by-value parameter passing style here:\r\nVal ::= . . . | λName.Exp\r\nExp ::= . . . | Exp Exp [strict]\r\nL(λx.e) v\r\ne[v/x]\r\n|ik where x ∈ Name, e ∈ Exp, v ∈ Val.\r\nOne (rather standard) problem with definitions like the above in the context of λ-calculus with imperative\r\nfeatures, is that one cannot assign the bound variable (x) in the body of the λ-abstraction (e), so one may\r\nneed a static analysis to discard programs that do it. A (rather standard) alternative to this is to instead\r\nintroduce a fresh variable, say y, bind it to the argument value (v) in the state, and then replace the bound\r\nvariable x by y. We can do all these in one step in K, replacing the rule above with the following one:\r\nL(λx.e) v\r\ne[y/x]\r\n|ikL σ\r\nσ[v/y]\r\nMstate where y ∈ Name is a fresh name.\r\nThe reason we need a fresh name (y) and an α-conversion to replace the bound name (x) in the rule above\r\ninstead of just binding x to v in the state, is because x may already be used outside the scope of the\r\nλ-abstraction and we obviously do not want to affect its value there.\r\nContext reduction definitions take a similar approach to add the features above. When adopting a\r\nsubstitution-based style as above (which may not necessarily be always possible or the best, e.g., when\r\nadding references and concurrency to the language), a slight advantage of SOS approaches is that they do\r\nnot need a fresh name: instead, they just initiate in the condition of the rule a reduction of e in the modified\r\nstate σ[v/x], and then continue the reduction in the conclusion of the rule using the original state, σ.\r\nNow that binding is available, the language designer may want to disallow reads and writes of variables\r\nthat were not explicitly bound. From here on, we therefore assume that the original expressions/program to\r\nevaluate is closed (this can be easily achieved automatically by wrapping the entire program in a series of λ\r\nabstractions binding all the originally free variables and then calling it on initial values for those variables).\r\nVariation 4(b) – λ with closures\r\nSuppose that, for several reasons, our language designer decides to switch to an environment-based\r\ndefinition of her language. As usual, we assume an infinite number of possible locations and that we can\r\nget fresh locations whenever needed. A major structural change in the configuration is required, namely the\r\nstate is split into an environment and a store. This structural change inevitably affects the existing rules that\r\nrelied on the state (i.e., explicitly matched it), but, fortunately, the other rules need not be touched. Below\r\n80\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e237400f-be05-44ed-a2de-3ea92a7f71d3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be4842675c240e960cae89c4bddd6f90841979cc2203cc638fd5651c2c9eb3c5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 703
      },
      {
        "segments": [
          {
            "segment_id": "3b4ca8d8-76c2-4abc-a00b-a3cdc76b24a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "we only list those rules that changed, mentioning that we take a liberty here to use the restore computation\r\nitem also used in Section 4.9 which is builtin in our implementation of K (see Appendix F):\r\nConfig ::= LKMk | LEnvMenv | LStoreMstore | LList[Val]Moutput | LSet[Config]M>\r\nJeK = LLeMk L·Menv L·Mstore L·MoutputM>\r\nL x\r\nσ[ρ[x]]\r\n|ikLρMenv LσMstore\r\nLx := v\r\n·\r\n|ikLρMenv L σ\r\nσ[v/ρ[x]]\r\nMstore\r\nL++ x\r\ni\r\n|ikLρMenv L σ\r\nσ[i/ρ[x]]\r\nMstore where i is σ[ρ[x]] + 1\r\nVal ::= . . . | closure(Name,Exp,Env)\r\nExp ::= . . . | λName.Exp | Exp Exp [strict]\r\nL λx.e\r\nclosure(x, e, ρ)\r\n|ikLρMenv\r\nLclosure(x, e, ρ) v\r\ne y restore(ρ\r\n0\r\n)\r\n|ikL ρ\r\n0\r\nρ[l/x]\r\nMenv L σ\r\nσ[v/l]\r\nMstore where l is a fresh location\r\nVariant 5 – recursion. Let us next add an explicit construct for recursion, namely µ:\r\nExp ::= . . . | µName.Exp\r\nLµx.e|ik = L(λx.e) (µx.e)|ik\r\nOne could also give µ a direct semantics, not relying on λ, but one would have to add a closure value like we\r\ndid for the semantics of λ. Note that we need not worry about affecting the intended computation granularity\r\nof µ with our definition above, because we used an equation, not a rule. Other formalisms may be forced to\r\ngive µ a direct semantics if unaffected computation granularity is important to the designer.\r\nVariant 6 – references. Let us next add references to the language, together with dereferencing and\r\nexplicit address extraction for names. These suggest one major change in the design of the language: the\r\nassignment statement can be changed to assign values to locations, instead of to variables. To do so, one\r\nalso needs to extend the values with locations and re-refine the assignment to be strict in both its arguments.\r\nHere are all the changes needed to the existing language in order to incorporate the above (one also needs\r\nto remove the annotated syntax for assignment and its rule from the previous definition):\r\n81\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/3b4ca8d8-76c2-4abc-a00b-a3cdc76b24a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3f1168f3351d6bb4de9514502ea057ccc9fbd5a6039f820c7d9208a0608fd7b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 349
      },
      {
        "segments": [
          {
            "segment_id": "1b686bb0-b73b-480f-ba27-780a32c14188",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "Val ::= . . . | Loc\r\nExp ::= . . . | ref Exp [strict] | ∗ Exp [strict] | & Name\r\nStmt := . . . | Exp := Exp [strict]\r\nLref v\r\nl\r\n|ikL σ\r\nσ[v/l]\r\nMstore where l is a fresh location\r\nL ∗ l\r\nσ[l]\r\n|ikLσMstore\r\nL& x\r\nρ[x]\r\n|ikLρMenv\r\nLl := v\r\n·\r\n|ikL σ\r\nσ[v/l]\r\nMstore\r\nVariant 7 – call with current continuation. To add call/cc to the language, all one needs to do is to\r\nadd the following without changing anything to the existing definitions:\r\nExp ::= . . . | callccExp [strict]\r\nVal ::= . . . | cc(K,Env)\r\nL callcc v\r\nv cc(k, ρ)\r\ny kMk LρMenv\r\nLcc(k, ρ) v y\r\nv y k\r\nMk L\r\nρ\r\nMenv\r\nVariant 8 – nondeterminism. Recall that one of our major goals was to design a language definitional\r\nframework that is executable. Nondeterminism is trivial to add to all non-functional/non-denotational\r\ndefinitional approaches. Here is our definition of a trivial non-deterministic random boolean choice:\r\nExp ::= . . . | randomBool\r\nrandomBool → true\r\nrandomBool → false\r\nWhile functional or denotational approaches also give support for nondeterminism, these approaches have a\r\ndifferent goal than ours: to capture all possible behaviors of a nondeterministic program as a value. Needless\r\nto say that that operation is very expensive and, sometimes impossible: for example when a program has\r\nan infinite number of behaviors. Our goal is to get executable semantics, so that programs with infinite\r\nbehaviors can still be executed, with the possibility to also obtain all possible behaviors if one is interested\r\nin that (using, e.g., a search command in our Maude implementation of K — Appendix E).\r\nVariant 9 – aspects. There are many approaches to aspects and aspect-oriented programming these days.\r\nWe, of course, do not intend to cover all those here. We only want to show how easily and modularly one\r\ncan add aspects to a language formally defined in K. To illustrate this point, we consider only one language\r\nconstruct, “aspect s”, taking a statement and executing it whenever a function is being called from from\r\nthere on. The aspect statement is executed “as is”, in the sense that aspects come with no static scoping\r\nfor the variables that they may access or change. It is easy to modify our definition to assume statically\r\nscoped aspects, but that is not our purpose here. We allow the aspect to be dynamically changed during the\r\nexecution of the program. To achieve that, we define one more configuration cell that keeps the aspect:\r\n82\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/1b686bb0-b73b-480f-ba27-780a32c14188.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5ae72a56a934fa9716b92fa25e4fd2eab09effb9c2d0748df815a628989c6da5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 444
      },
      {
        "segments": [
          {
            "segment_id": "d68326ea-a423-40fc-ae1e-1ec588361243",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Stmt ::= . . . | aspect Stmt\r\nConfig ::= . . . | LKMaspect\r\nJsK = LLsMk L·Menv L·Mstore L·Moutput L·MaspectM>\r\nLaspect s\r\n·\r\n|ikL\r\ns\r\nMaspect\r\nThere are several semantic choices possible, aspect-oriented frameworks opting for one or more of them. For\r\nexample, one possibility is to grab the aspect available at function declaration time, another is grab it at\r\nfunction application time. Also, for any of these two possibilities, the aspect can be executed in caller’s\r\ncontext or in callee’s context. Any of these can be easily defined in K. For example, here is a definition in\r\nwhich the aspect is grabbed at function declaration time and later executed in callee’s context:\r\nL λx.e\r\nclosure(x,(s y e), ρ)\r\n|ikLρMenv LsMaspect\r\nand here is a definition in which the aspect is executed in callee’s context at function invocation time:\r\nL closure(x, e, ρ) v\r\ns y e y restore(ρ\r\n0\r\n)\r\n|ikL ρ\r\n0\r\nρ[l/x]\r\nMenv L σ\r\nσ[v/l]\r\nMstore LsMaspect (where l is a fresh location)\r\nVariant 10 – concurrency with lock synchronization. Let us next extend this language with dynamic\r\nthreads that can run concurrently. Whether multi-threading with shared memory is how concurrency should\r\nbe supported in languages is an interesting subject open to debate (where we have our personal and therefore\r\nsubjective opinions, but here we refrain from commenting on this subject). Wearing the hat of the designer\r\nof a language design framework (and not that of a programming language designer), our position here is\r\nthat a powerful language design framework should support all existing approaches to concurrency; at the\r\ntime this paper was written (end of 2007) multi-threading with shared memory was still the most practical\r\napproach to concurrency.\r\nWe consider the following additional syntax:\r\nStmt ::= . . . | spawn Stmt | acquire Exp [strict] | release Exp [strict]\r\nspawn s spawns a new thread executing statement s concurrently with the rest of the threads. The newly\r\ncreated thread inherits the environment of its parent at creation time, which is the means by which memory\r\nis shared, and dissolves itself when the statement s is completely processed. Threads synchronize through\r\nacquiring and releasing locks. Any values can be used as locks, including functions, and two locks are\r\nconsidered equal if and only if they are identical as value terms (not even α-equivalent). Locks can be\r\nacquired and released multiple times by the same thread and only one thread can hold a lock at any given\r\ntime. A lock is effectively released by a thread only when the number of releases matches the number of\r\nacquires. If a lock is not available (because it is taken by another thread), then the thread attempting to\r\nacquire it waits until the lock is released.\r\nWe modify the configuration so that the information pertaining to each thread (i.e., computation, envi\u0002ronment and lock/counter pairs) is held into one cell of type thread. An additional top-level cell is needed\r\nto hold all the busy locks. The semantics of thread termination is to dissolve its corresponding thread cell,\r\nreleasing all its resources. Therefore, the execution of a program is terminated when there is no thread cell\r\nleft. Here is the new configuration structure, its initialization and its termination:\r\nConfig ::= . . . | LSet[Val × Nat]Mholds | LSet[Config]Mthread | LSet[Val]Mbusy\r\nJsK = LLLsMk L·Menv L·MholdsMthread L·Mstore L·Moutput L·Maspect L·MbusyM>\r\nLL Mstore LvlMoutput L Maspect L MbusyM> = vl\r\nBefore we attempt to give the semantics of the concurrency-related language constructs, some explana\u0002tions are needed with regards to the change of the configuration structure. A major problem when changing\r\n83\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d68326ea-a423-40fc-ae1e-1ec588361243.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6e2c075bb8130c7db937f5f9daafecf1fee12ee3f18a25ea77b748eac1ae047a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 616
      },
      {
        "segments": [
          {
            "segment_id": "d68326ea-a423-40fc-ae1e-1ec588361243",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Stmt ::= . . . | aspect Stmt\r\nConfig ::= . . . | LKMaspect\r\nJsK = LLsMk L·Menv L·Mstore L·Moutput L·MaspectM>\r\nLaspect s\r\n·\r\n|ikL\r\ns\r\nMaspect\r\nThere are several semantic choices possible, aspect-oriented frameworks opting for one or more of them. For\r\nexample, one possibility is to grab the aspect available at function declaration time, another is grab it at\r\nfunction application time. Also, for any of these two possibilities, the aspect can be executed in caller’s\r\ncontext or in callee’s context. Any of these can be easily defined in K. For example, here is a definition in\r\nwhich the aspect is grabbed at function declaration time and later executed in callee’s context:\r\nL λx.e\r\nclosure(x,(s y e), ρ)\r\n|ikLρMenv LsMaspect\r\nand here is a definition in which the aspect is executed in callee’s context at function invocation time:\r\nL closure(x, e, ρ) v\r\ns y e y restore(ρ\r\n0\r\n)\r\n|ikL ρ\r\n0\r\nρ[l/x]\r\nMenv L σ\r\nσ[v/l]\r\nMstore LsMaspect (where l is a fresh location)\r\nVariant 10 – concurrency with lock synchronization. Let us next extend this language with dynamic\r\nthreads that can run concurrently. Whether multi-threading with shared memory is how concurrency should\r\nbe supported in languages is an interesting subject open to debate (where we have our personal and therefore\r\nsubjective opinions, but here we refrain from commenting on this subject). Wearing the hat of the designer\r\nof a language design framework (and not that of a programming language designer), our position here is\r\nthat a powerful language design framework should support all existing approaches to concurrency; at the\r\ntime this paper was written (end of 2007) multi-threading with shared memory was still the most practical\r\napproach to concurrency.\r\nWe consider the following additional syntax:\r\nStmt ::= . . . | spawn Stmt | acquire Exp [strict] | release Exp [strict]\r\nspawn s spawns a new thread executing statement s concurrently with the rest of the threads. The newly\r\ncreated thread inherits the environment of its parent at creation time, which is the means by which memory\r\nis shared, and dissolves itself when the statement s is completely processed. Threads synchronize through\r\nacquiring and releasing locks. Any values can be used as locks, including functions, and two locks are\r\nconsidered equal if and only if they are identical as value terms (not even α-equivalent). Locks can be\r\nacquired and released multiple times by the same thread and only one thread can hold a lock at any given\r\ntime. A lock is effectively released by a thread only when the number of releases matches the number of\r\nacquires. If a lock is not available (because it is taken by another thread), then the thread attempting to\r\nacquire it waits until the lock is released.\r\nWe modify the configuration so that the information pertaining to each thread (i.e., computation, envi\u0002ronment and lock/counter pairs) is held into one cell of type thread. An additional top-level cell is needed\r\nto hold all the busy locks. The semantics of thread termination is to dissolve its corresponding thread cell,\r\nreleasing all its resources. Therefore, the execution of a program is terminated when there is no thread cell\r\nleft. Here is the new configuration structure, its initialization and its termination:\r\nConfig ::= . . . | LSet[Val × Nat]Mholds | LSet[Config]Mthread | LSet[Val]Mbusy\r\nJsK = LLLsMk L·Menv L·MholdsMthread L·Mstore L·Moutput L·Maspect L·MbusyM>\r\nLL Mstore LvlMoutput L Maspect L MbusyM> = vl\r\nBefore we attempt to give the semantics of the concurrency-related language constructs, some explana\u0002tions are needed with regards to the change of the configuration structure. A major problem when changing\r\n83\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d68326ea-a423-40fc-ae1e-1ec588361243.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6e2c075bb8130c7db937f5f9daafecf1fee12ee3f18a25ea77b748eac1ae047a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 616
      },
      {
        "segments": [
          {
            "segment_id": "ec4a8d76-4c36-4f2d-abf1-6830ace076fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 84,
            "page_width": 612,
            "page_height": 792,
            "content": "the structure of the configuration is that some of the previously defined rules and equations may not match\r\nanymore against the new configuration. Indeed, consider for example the rule for variable lookup:\r\nL x\r\nσ[ρ[x]]\r\n|ikLρMenv LσMstore\r\nSince in the new configuration the store is located on a level different from that of the computation and the\r\nenvironment, this rule will never match with the new configuration structure. To fix this problem, one would\r\napparently have to revisit the existing definitions and modify them to account for the new configuration\r\nstructure, for example:\r\nh|L x\r\nσ[ρ[x]]\r\n|ikLρMenv|ithread LσMstore\r\nThis is of course very inconvenient and violates one of our major requirements for an ideal language def\u0002initional framework: modularity. How can we derive the second rule above from the first? K provides a\r\nmechanism called context transforming, which is responsible for automatically completing “partially” defined\r\nterms. This is explained in detail in [33]. In short, cell wrappers can be defined as “structural” and possibly\r\n“repetitive” in K; this additional information can be then used to automatically and unambiguously10 trans\u0002form terms in general, and K rules and equations in particular, by completing them with potentially missing\r\nstructural information. For example, all the cells in this language definition are defined as “structural” and\r\nL...Mthread is also defined as “repetitive”. When using the algebraic notation for K as in [33], the language\r\ndesigner can add this information rigorously, using operation attributes to the cell wrapper constructs. We\r\nhave not yet devised any rigorous non-algebraic way to introduce this configuration structural information;\r\nfor the remaining of this section we just draw a picture like the one below showing the configuration struc\u0002ture together with the repetitiveness information (a star “∗” as a superscript of a cell means that the cell is\r\nallowed to repeat) and let the reader mentally replay the context transforming process:\r\nL...M>\r\nL...M\r\n∗\r\nthread\r\nL...Mk L...Menv L...Mholds\r\nL...Mstore L...Moutput L...Maspect L...Mbusy\r\nThe context transforming process is not only necessary in order to achieve the much desired modularity, but\r\nit also allows the designer to write semantic rules and equations more succinctly and conceptually: one only\r\nneeds to focus on what is needed from the configuration in order to give the semantics of a construct, rather\r\nthan where that information is located in the (continuously evolving) configuration structure. Thanks to\r\ncontext transforming, we need to make no change to the existing rules or equations when adding threads to\r\nour language. All we need to do is to add the definitions of the new constructs.\r\nHere is the semantics of thread creation and termination:\r\nLspawn s\r\n·\r\n|ikLρMenv ·\r\nLLsMk LρMenv L·MholdsMthread\r\nh|L·Mk LlcMholds|ithread\r\n·\r\nL ls\r\nls − lc\r\nMbusy\r\nHere is the semantics of lock acquire:\r\nLacquire v\r\n·\r\n|ikh|(v, n\r\ns(n)\r\n)|iholds\r\nLacquire v\r\n·\r\n|ikh| ·\r\n(v, 0)\r\n|iholds L ls\r\nls v\r\nMbusy when v 6∈ ls\r\n10In case of ambiguity, the most “local” grouping is always chosen, following a depth-first traversal of the term.\r\n84\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/ec4a8d76-4c36-4f2d-abf1-6830ace076fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bb09ed5336e110fb69c7453ee8392f65ccd78dd440c55ea6dd36bcafb006617d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 512
      },
      {
        "segments": [
          {
            "segment_id": "76e556e1-ee7b-4fb1-bcbd-7eaa39806fa1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Finally, here is the semantics of lock release:\r\nLrelease v\r\n·\r\n|ikh|(v, s(n)\r\nn\r\n)|iholds\r\nLrelease v\r\n·\r\n|ikh|(v, 0)\r\n·\r\n|iholds h|v\r\n·\r\n|ibusy\r\nAn interesting question is what is the resulting semantics of halt in this multi-threaded extension of\r\nour language, that is, whether it halts only the current thread or the entire program. Since its previous\r\nsemantics was to just dissolve the computation that generated it, the answer is that it only halts the current\r\nthread. This is quite an acceptable semantics. Supposing that one wants a semantics that stops the entire\r\nmulti-threaded program, then one has to remove the current rule for halt and add the following instead:\r\nh|Lhalt|ikLvlMoutput|i> → vl\r\nVariant 11 – rendez-vous synchronization. Let us next define a rendez-vous synchronization construct,\r\nsay rv v, taking also a “lock”, or better say a “barrier” argument. The thread executing this command is\r\nblocked until another thread executes a similar rendez-vous command with the same value v. When that\r\nhappens, the two threads discard their rv v statements and continue their executions concurrently. Here is\r\nthe semantics of rendez-vous synchronization in K:\r\nStmt ::= . . . | rv Exp [strict]\r\nLrv v\r\n·\r\n|ikLrv v\r\n·\r\n|ik\r\nNote that, according to the structural and repetitiveness information about the configuration, the only way\r\nfor the context transforming process to complete the rule above to match the configuration is as follows:\r\nh|Lrv v\r\n·\r\n|ik|i\r\nthread h|Lrv v\r\n·\r\n|ik|i\r\nthread\r\nVariant 12 – distributed agents with message communication. Let us next add distributed agents\r\nto the language, where each agent encapsulates a multi-threaded program with a locally shared store and\r\nwhere agents communicate with each other by both asynchronous and synchronous messages. Agents can\r\ncreate other agents and messages can contain any value, including other agent names to be used for sending\r\nor receiving messages. Here is the additional syntax:\r\nAgent ::= agent identifiers or names\r\nVal ::= ... | Agent\r\nExp ::= ... | new-agent Stmt | receive-from Exp [strict] | receive | me | parent\r\nStmt ::= ... | send-asynch Exp Exp [strict] | send-synch Exp Exp [strict]\r\nAgent is therefore a set set of agent names, which are regarded as any other values in the language, so that\r\nthey can be passed and returned by functions, assigned to variables, send and received by messages, etc.\r\nnew-agent s creates a new agent which will execute statement s concurrently with the rest of the agents (and\r\nthe multiple threads inside those). Unlike in π-calculus (see Section ??), we here disallow nested agents:\r\nall agents are located at the top. Communication between agents is exclusively via messages, which can\r\nbe send asynchronously or synchronously. Messages contain a sender name, a receiver name, and a value.\r\nreceive-from e first evaluates e to an agent name, say a, and then the receiving thread blocks until a message\r\nfrom a is received; when that happens, the thread is unblocked and the received value is passed to it. receive\r\nis similar, except that the receiving thread will accept any message sent to its enclosing agent. The special\r\nexpression constructs me and parent evaluate to the current agent’s name and to its parent’s, respectively;\r\nthis way, each agent is given access to two basic communication capabilities (access to more agents can be\r\ngranted dynamically by other agents, by sending agent names via messages). send-asynch e1 e2 evaluates e1\r\n85\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/76e556e1-ee7b-4fb1-bcbd-7eaa39806fa1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eda575f709227a1199093bf472fcb488351aee7745c460f0157521507ce18868",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "76e556e1-ee7b-4fb1-bcbd-7eaa39806fa1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Finally, here is the semantics of lock release:\r\nLrelease v\r\n·\r\n|ikh|(v, s(n)\r\nn\r\n)|iholds\r\nLrelease v\r\n·\r\n|ikh|(v, 0)\r\n·\r\n|iholds h|v\r\n·\r\n|ibusy\r\nAn interesting question is what is the resulting semantics of halt in this multi-threaded extension of\r\nour language, that is, whether it halts only the current thread or the entire program. Since its previous\r\nsemantics was to just dissolve the computation that generated it, the answer is that it only halts the current\r\nthread. This is quite an acceptable semantics. Supposing that one wants a semantics that stops the entire\r\nmulti-threaded program, then one has to remove the current rule for halt and add the following instead:\r\nh|Lhalt|ikLvlMoutput|i> → vl\r\nVariant 11 – rendez-vous synchronization. Let us next define a rendez-vous synchronization construct,\r\nsay rv v, taking also a “lock”, or better say a “barrier” argument. The thread executing this command is\r\nblocked until another thread executes a similar rendez-vous command with the same value v. When that\r\nhappens, the two threads discard their rv v statements and continue their executions concurrently. Here is\r\nthe semantics of rendez-vous synchronization in K:\r\nStmt ::= . . . | rv Exp [strict]\r\nLrv v\r\n·\r\n|ikLrv v\r\n·\r\n|ik\r\nNote that, according to the structural and repetitiveness information about the configuration, the only way\r\nfor the context transforming process to complete the rule above to match the configuration is as follows:\r\nh|Lrv v\r\n·\r\n|ik|i\r\nthread h|Lrv v\r\n·\r\n|ik|i\r\nthread\r\nVariant 12 – distributed agents with message communication. Let us next add distributed agents\r\nto the language, where each agent encapsulates a multi-threaded program with a locally shared store and\r\nwhere agents communicate with each other by both asynchronous and synchronous messages. Agents can\r\ncreate other agents and messages can contain any value, including other agent names to be used for sending\r\nor receiving messages. Here is the additional syntax:\r\nAgent ::= agent identifiers or names\r\nVal ::= ... | Agent\r\nExp ::= ... | new-agent Stmt | receive-from Exp [strict] | receive | me | parent\r\nStmt ::= ... | send-asynch Exp Exp [strict] | send-synch Exp Exp [strict]\r\nAgent is therefore a set set of agent names, which are regarded as any other values in the language, so that\r\nthey can be passed and returned by functions, assigned to variables, send and received by messages, etc.\r\nnew-agent s creates a new agent which will execute statement s concurrently with the rest of the agents (and\r\nthe multiple threads inside those). Unlike in π-calculus (see Section ??), we here disallow nested agents:\r\nall agents are located at the top. Communication between agents is exclusively via messages, which can\r\nbe send asynchronously or synchronously. Messages contain a sender name, a receiver name, and a value.\r\nreceive-from e first evaluates e to an agent name, say a, and then the receiving thread blocks until a message\r\nfrom a is received; when that happens, the thread is unblocked and the received value is passed to it. receive\r\nis similar, except that the receiving thread will accept any message sent to its enclosing agent. The special\r\nexpression constructs me and parent evaluate to the current agent’s name and to its parent’s, respectively;\r\nthis way, each agent is given access to two basic communication capabilities (access to more agents can be\r\ngranted dynamically by other agents, by sending agent names via messages). send-asynch e1 e2 evaluates e1\r\n85\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/76e556e1-ee7b-4fb1-bcbd-7eaa39806fa1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eda575f709227a1199093bf472fcb488351aee7745c460f0157521507ce18868",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "d1d9399d-6348-4820-a33c-59556fb1c662",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 86,
            "page_width": 612,
            "page_height": 792,
            "content": "to an agent, say a, and e2 to a value, say v, sends a message to a containing a, and then dissolves letting\r\nthe execution to continue normally. send-synch is similar but it blocks the current thread until (one of the\r\nthreads in) the destination agent receives the message.\r\nAn agent terminates when it has no thread left, and a program terminates when it has no agent left.\r\nHere is the new configuration syntax, together with its structural/repetition information, as well as the\r\ninitialization and termination equations (when no agents left, remaining messages are discarded):\r\nConfig ::= . . . | LSet[Config]Magent | LAgent, Agent, ValMmessage\r\nJsK = LLLLsMk L·Menv L·MholdsMthread L·Mstore L·Maspect L·Mbusy LnMme LnMparentMagent L·MoutputM> where n ∈ Agent fresh\r\nLLvlMoutput MM> → vl when M contains only messages (zero or more)\r\nL...M>\r\nL L...Moutput ...M\r\n∗\r\nmessage L...M\r\n∗\r\nagent\r\nL L...Mparent L...M L...Mstore L...Maspect L...Mbusy ...Mme\r\n∗\r\nthread\r\nL...Mk L...Menv L...Mholds\r\nNote that the output is shared by all agents and that there can be multiple agents and messages floating\r\nin the top-level soup, same way multiple threads can float in each agent. The following K rules are straight\u0002forward; they do formally precisely what was described informally above. Recall that context transforming\r\nis assumed to complete the partial configuration structural information in these rules:\r\nLnew-agent s\r\nm\r\n|ikLnMme ·\r\nLLLsMk L·Menv L·MholdsMthread L·Mstore L·Maspect L·Mbusy LmMme LnMparentMagent\r\nwhere m ∈ Agent fresh\r\nLAMagent → · when A contains no thread\r\nLme\r\nn\r\n|ikLnMme\r\nLparent\r\nn\r\n|ikLnMparent\r\nLsend-asynch m v\r\n·\r\n|ikLnMme ·\r\nLn, m, vMmessage\r\nLreceive-from n\r\nv\r\n|ikLmMme Ln, m, vMmessage\r\n·\r\nLreceive\r\nv\r\n|ikLmMme L , m, vMmessage\r\n·\r\nh|Lsend-synch m v\r\n·\r\n|ikLnMme|iagent h|Lreceive-from n\r\nv\r\n|ikLmMme|iagent\r\nLsend-synch m v\r\n·\r\n|ikh|Lreceive\r\nv\r\n|ikLmMme|iagent\r\n86\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d1d9399d-6348-4820-a33c-59556fb1c662.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=390e526c4fad951713e414979d7970cfb8ae65d3b4b14f4a0ff2c3107f64bde5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 307
      },
      {
        "segments": [
          {
            "segment_id": "2cd9d885-0ce2-42e7-b583-68228e66b454",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 87,
            "page_width": 612,
            "page_height": 792,
            "content": "None of the definitions of the existing features needs to change. It is interesting, again, to analyze the\r\nresulting semantics of halt. If halt was defined as in “Variant 3” (extension with output), then it would just\r\ndissolve the remaining computation in the current thread in the current agent. If halt was defined like in the\r\nalternative rule proposed at the end of “Variant 10” (extension with concurrency), then it would halt the\r\nentire program. Therefore, the two semantic alternatives for halt have extreme behaviors. For this language,\r\nit may make sense to have a halt statement that halts only the issuing agent, dissolving all its threads but\r\nallowing the remaining agents to continue their executions. If that is what one wants, then one needs to\r\nremove the previous rule of halt and add the following rule instead:\r\nh|Lhalt|ik|iagent → ·\r\nVariant 13 – self-generation of code. There is an increasingly broad interest in generative programming\r\nthese days. We next add support for dynamic code generation to our language.\r\nExp ::= . . . | quote Exp | unquote Exp | eval Exp [strict]\r\nVal ::= . . . | code(K)\r\nK ::= . . . | quote(Nat, List[K]) | code(List[K]) | KyK [strict] | Id(List[K]) [strict(2)] | K, K [strict]\r\nLquote(k)|ik = Lquote(0, k)|ik\r\nquote(n, k1 y k2) = quote(n, k1)y quote(n, k2) code(k1)ycode(k2) = code(k1 y k2)\r\nquote(n, f(kl)) = f(quote(n, kl)) if f 6= quote, unquote f(code(kl)) = code(f(kl))\r\nquote(n, quote(k)) = quote(quote(s(n), k))\r\nquote(0, unquote(k)) = k\r\nquote(s(n), unquote(k)) = unquote(quote(n, k))\r\nquote(n,(k, kl)) = quote(n, k), quote(n, kl) if kl 6= · code(k), code(kl) = code(k, kl)\r\nquote(n, k) = code(k) if k ∈ Val ∪ Name eval code(k) = k\r\n87\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/2cd9d885-0ce2-42e7-b583-68228e66b454.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=412bb365c7fcc3c09111da4682511afc1f77daa31a02f23b5d2aca02a0a891c3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 302
      },
      {
        "segments": [
          {
            "segment_id": "0a733376-eef5-4a39-a5cc-61143cbc04a0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 88,
            "page_width": 612,
            "page_height": 792,
            "content": "References\r\n[1] Sergio Antoy, Bernd Brassel, and Michael Hanus. Conditional narrowing without conditions. In PPDP,\r\npages 20–31, 2003.\r\n[2] Franz Baader and Tobias Nipkow. Term rewriting and all that. Cambridge University Press, New York,\r\nNY, USA, 1998.\r\n[3] Jean-Pierre Banˆatre and Daniel Le M´etayer. The GAMMA model and its discipline of programming.\r\nScience of Computer Programming, 15(1):55–77, 1990.\r\n[4] Jan Bergstra and J. V. Tucker. Equational specifications, complete term rewriting systems, and com\u0002putable and semicomputable algebras. Journal of the Association for Computing Machinery, 42(6):1194–\r\n1230, 1995.\r\n[5] G´erard Berry and G´erard Boudol. The chemical abstract machine. Theoretical Computer Science,\r\n96(1):217–248, 1992.\r\n[6] Peter Borovansk´y, Claude Kirchner, H´el`ene Kirchner, Pierre-Etienne Moreau, and Christophe Ringeis\u0002sen. An overview of ELAN. ENTCS, 15, 1998.\r\n[7] Fabricio Chalub and Christiano Braga. Maude MSOS tool. In Grit Denker and Carolyn Talcott, editors,\r\nProceedings of the Sixth International Workshop on Rewriting Logic and its Applications (WRLA 2006),\r\nvolume 176(4) of Electronic Notes in Theoretical Computer Science, pages 133–146. Elsevier, 2007.\r\n[8] Feng Chen, Mark Hills, and Grigore Rosu. A Rewrite Logic Approach to Semantic Definition, Design\r\nand Analysis of Object-Oriented Languages. Technical Report UIUCDCS-R-2006-2702, Department of\r\nComputer Science, University of Illinois at Urbana-Champaign, March 2006.\r\n[9] M. Clavel, F. Dur´an, S. Eker, J. Meseguer, P. Lincoln, N. Mart´ı-Oliet, and C. Talcott. All About Maude,\r\nA High-Performance Logical Framework, volume 4350 of Lecture Notes in Computer Science. Springer,\r\n2007.\r\n[10] Azadeh Farzan, Feng Chen, Jos´e Meseguer, and Grigore Rosu. Formal analysis of Java programs in\r\nJavaFAN. In Rajeev Alur and Doron Peled, editors, Computer Aided Verification, 16th International\r\nConference, CAV 2004, Boston, MA, USA, July 13-17, 2004, Proceedings, volume 3114 of Lecture Notes\r\nin Computer Science, pages 501–505. Springer, 2004.\r\n[11] Matthias Felleisen and Robert Hieb. A revised report on the syntactic theories of sequential control and\r\nstate. Theoretical Computer Science, 103(2):235–271, 1992.\r\n[12] Joseph Goguen, Timothy Winkler, Jos´e Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouannaud. In\u0002troducing OBJ. In Software Engineering with OBJ: algebraic specification in action. Kluwer, 2000.\r\n[13] Yuri Gurevich. Evolving algebras 1993: Lipari guide. In Specification and validation methods, pages\r\n9–36. Oxford University Press, Inc., New York, NY, USA, 1995.\r\n[14] Mark Hills and Grigore Rosu. KOOL: An Application of Rewriting Logic to Language Prototyping and\r\nAnalysis. In Proceedings of the 18th International Conference on Rewriting Techniques and Applications\r\n(RTA’07), volume 4533 of LNCS, pages 246–256. Springer, 2007.\r\n[15] Mark Hills and Grigore Rosu. On Formal Analysis of OO Languages using Rewriting Logic: Designing\r\nfor Performance. In Proceedings of the 9th IFIP International Conference on Formal Methods for\r\nOpen Object-Based Distributed Systems (FMOODS’07), volume 4468 of LNCS, pages 107–121. Springer\u0002Verlag, 2007.\r\n88\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0a733376-eef5-4a39-a5cc-61143cbc04a0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1a691dfa5d6143350f2c99b7df7bcf010822d0195c083b3a53bdfba161dfac7f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 451
      },
      {
        "segments": [
          {
            "segment_id": "066f4d91-805b-4118-bfad-6c2e5cfe2aa4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 89,
            "page_width": 612,
            "page_height": 792,
            "content": "[16] Gilles Kahn. Natural semantics. In Franz-Josef Brandenburg, Guy Vidal-Naquet, and Martin Wirs\u0002ing, editors, STACS 87, 4th Annual Symposium on Theoretical Aspects of Computer Science, Passau,\r\nGermany, February 19-21, 1987, Proceedings, volume 247 of Lecture Notes in Computer Science, pages\r\n22–39. Springer, 1987.\r\n[17] Massimo Marchiori. On deterministic conditional rewriting. Computation Structures Group, Memo\r\n405, MIT Laboratory for Computer Science, 1997.\r\n[18] Narciso Mart´ı-Oliet and Jos´e Meseguer. Rewriting logic: roadmap and bibliography. Theoretical Com\u0002puter Science, 285:121–154, 2002.\r\n[19] Jacob Matthews, Robert Bruce Findler, Matthew Flatt, and Matthias Felleisen. A visual environment for\r\ndeveloping context-sensitive term rewriting systems. In Proceedings of 15th International Conference on\r\nRewriting Techniques and Applications, (RTA’04), volume 3091 of Lecture Notes in Computer Science,\r\npages 301–311, 2004.\r\n[20] Jos´e Meseguer. Conditional rewriting logic as a unified model of concurrency. Theoretical Computer\r\nScience, 96(1):73–155, 1992.\r\n[21] Jos´e Meseguer and Christiano Braga. Modular rewriting semantics of programming languages. In\r\nCharles Rattray, Savi Maharaj, and Carron Shankland, editors, Algebraic Methodology and Software\r\nTechnology, 10th International Conference, AMAST 2004, Stirling, Scotland, UK, July 12-16, 2004,\r\nProceedings, volume 3116 of Lecture Notes in Computer Science, pages 364–378. Springer, 2004.\r\n[22] Jos´e Meseguer and Grigore Rosu. Rewriting logic semantics: From language specifications to formal\r\nanalysis tools. In IJCAR ’04, pages 1–44, 2004.\r\n[23] Jos´e Meseguer and Grigore Rosu. The rewriting logic semantics project. J. TCS, 373(3):213–237, 2007.\r\nAlso appeared in SOS ’05, volume 156(1) of ENTCS, pages 27–56, 2006.\r\n[24] Robin Milner. A theory of type polymorphism in programming. J. Comput. Syst. Sci., 17(3):348–375,\r\n1978.\r\n[25] Robin Milner. Communication and Concurrency. 1989.\r\n[26] Robin Milner. Functions as processes. In Mike Paterson, editor, ICALP, volume 443 of Lecture Notes\r\nin Computer Science, pages 167–180. Springer, 1990.\r\n[27] Robin Milner, Mads Tofte, Robert Harper, and David Macqueen. The Definition of Standard ML\r\n(Revised). MIT Press, Cambridge, MA, USA, 1997.\r\n[28] Peter D. Mosses. Foundations of modular sos. In Miroslaw Kutylowski, Leszek Pacholski, and Tomasz\r\nWierzbicki, editors, MFCS, volume 1672 of Lecture Notes in Computer Science, pages 70–80. Springer,\r\n1999.\r\n[29] Peter D. Mosses. Modular structural operational semantics. Journal of Logic and Algebraic Program\u0002ming, 60-61:195–228, 2004.\r\n[30] Enno Ohlebusch. Transforming conditional rewrite systems with extra variables into unconditional\r\nsystems. In LPAR’99, pages 111–130, 1999.\r\n[31] Gordon D. Plotkin. A structural approach to operational semantics. Journal of Logic and Algebraic\r\nProgramming, 60-61:17–139, 2004. Original version: University of Aarhus Technical Report DAIMI\r\nFN-19, 1981.\r\n[32] Grigore Rosu. Cs322, fall 2003 - programming language design: Lecture notes. Technical Report\r\nUIUCDCS-R-2003-2897, University of Illinois at Urbana-Champaign, Department of Computer Science,\r\n2003.\r\n89\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/066f4d91-805b-4118-bfad-6c2e5cfe2aa4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1854a31309fb5e5f9ed38112daabde31ca69bdadaf37c403a2887b2323013e4b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 437
      },
      {
        "segments": [
          {
            "segment_id": "7c4f2182-b211-4344-911c-52b1243e0290",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 90,
            "page_width": 612,
            "page_height": 792,
            "content": "[33] Grigore Rosu. K: a Rewrite-based Framework for Modular Language Design, Semantics, Analysis and\r\nImplementation. Technical Report UIUCDCS-R-2006-2802, Computer Science Department, University\r\nof Illinois at Urbana-Champaign, 2006. A previous version of this work has been published as technical\r\nreport UIUCDCS-R-2005-2672 in 2005. K was first introduced in 2003, in the technical report UIUCDCS\u0002R-2003-2897: lecture notes of CS322 (programming language design).\r\n[34] Hartley Rogers Jr. Theory of Recursive Functions and Effective Computability. MIT press, Cambridge,\r\nMA, 1987.\r\n[35] Traian Florin Serb˘anut˘a and Grigore Rosu. Computationally equivalent elimination of conditions -\r\nextended abstract. In Proceedings of Rewriting Techniques and Applications (RTA’06), volume 4098 of\r\nLecture Notes in Computer Science, pages 19–34. Springer, 2006. also appeared as Technical Report\r\nUIUCDCS-R-2006-2693, February 2006.\r\n[36] Traian Florin Serbanuta, Grigore Rosu, and Jose Meseguer. A rewriting logic approach to operational\r\nsemantics. Information and Computation, 2007. to appear.\r\n[37] Christopher Strachey and Christopher P. Wadsworth. Continuations: A Mathematical Semantics for\r\nHandling Full Jumps. Higher-Order and Symb. Computation, 13(1/2):135–152, 2000.\r\n[38] Mark G. J. van den Brand, J. Heering, P. Klint, and P. A. Olivier. Compiling language definitions: the\r\nASF+SDF compiler. ACM TOPLAS, 24(4):334–368, 2002.\r\n[39] Eelco Visser. Program Transf. with Stratego/XT: Rules, Strategies, Tools, and Systems. In Domain\u0002Specific Program Generation, pages 216–238, 2003.\r\n[40] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information and\r\nComputation, 115(1):38–94, 1994.\r\n90\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/7c4f2182-b211-4344-911c-52b1243e0290.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f7eb574a48e11a527a76974eb05f07cc59a70298e6337d1b9aa3b37baccd67f3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 240
      },
      {
        "segments": [
          {
            "segment_id": "e3a82c52-84e5-4fab-b8be-88b6fc441ac2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "A On K Computation Adequacy\r\nSome subtleties. Let us consider a division operator, / , intended to also be strict, that is, to evaluate its\r\narguments following the same non-deterministic strategy as + . Its heating/cooling equations are:\r\na1/a2 \n a1 y \u0003/a2\r\na1/a2 \n a2 y a1/\u0003\r\nTo keep the intuitive discussions simple, so far we purposely avoided imposing any restrictions, or side\r\nconditions, on the heated sub-computations a1 and a2, respectively. In other words, one could in principle\r\ndo reasoning using the equations above in any direction and for any a1, a2 ∈ K. We next show that that\r\nis not entirely correct, so in heating/cooling equations like above we’ll need to impose some (acceptable)\r\nside conditions on the “heated” sub-computations. There is no problem with using these equations from\r\nleft-to-right, but there are two problems with using them from right-to-left, namely when the heated sub\u0002computations (a1 in the first and a2 in the second) are empty or do not correspond to some actual fragment\r\nof program. Both problems are artifacts of the desired AI matching for the K constructor y. Let us first\r\ndiscuss an example reflecting the first problem (we use parentheses to avoid parsing confusion):\r\na1/a2 = a1 y (\u0003/a2) (by the first equation above applied left-to-right)\r\n= a1 y (· y (\u0003/a2)) (by the AI equations for y)\r\n= a1 y (·/a2) (by the first equation above applied right-to-left)\r\n= a1 y a2 y (·/\u0003) (by the second equation above applied left-to-right)\r\n= a1 y a2 y (· y (·/\u0003)) (by the AI equations for y)\r\n= a1 y a2 y (·/·) (by the second equation above applied right-to-left)\r\n= a1 y a2 y (· y (\u0003/·)) (by the first equation above applied left-to-right)\r\n= a1 y a2 y (\u0003/·) (by the AI equations for y)\r\n= a1 y (a2/·) (by the first equation above applied right-to-left)\r\n= a1 y (· y (a2/\u0003)) (by the second equation above applied left-to-right)\r\n= a1 y (a2/\u0003) (by the AI equations for y)\r\n= a2/a1 (by the second equation above applied right-to-left)\r\nTherefore, we derived an obviously undesired equality about division using only its heating/cooling equations,\r\nso the heating/cooling equations as given above are not sound in their full generality (i.e., for all a1, a2 ∈ K).\r\nOne may think that matching modulo the identity “·” is the only problem. The equational proof below\r\nshows that matching modulo associativity is also problematic:\r\n(a1/a2)/(a3/a4) = (a1/a2) y (\u0003/(a3/a4))\r\n= a1 y (\u0003/a2) y (\u0003/(a3/a4))\r\n= a1 y ((\u0003/a2)/(a3/a4))\r\n= a1 y (a3/a4) y ((\u0003/a2)/\u0003)\r\n= a1 y a3 y (\u0003/a4) y ((\u0003/a2)/\u0003)\r\n= a1 y a3 y ((\u0003/a2)/(\u0003/a4))\r\n= a1 y a3 y (\u0003/a2) y (\u0003/(\u0003/a4))\r\n= a1 y (a3/a2) y (\u0003/(\u0003/a4))\r\n= a1 y ((a3/a2)/(\u0003/a4))\r\n= a1 y (\u0003/a4) y ((a3/a2)/\u0003)\r\n= (a1/a4) y ((a3/a2)/\u0003)\r\n= (a3/a2)/(a1/a4)\r\nFormal definitions and computation adequacy. We next give the formal definition of heating/cooling\r\nequations and state their computation (structural) adequacy, saying that no two different “syntactic com\u0002putations” in K can be proved equal to each other using only the heating/cooling equations; syntactic\r\ncomputations are defined below as ones corresponding to AST’s of programs or fragments of programs in\r\nthe language under consideration (formally, they contain only non-freezer labels and contain no computation\r\nsequencing construct “ y ”).\r\n91\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e3a82c52-84e5-4fab-b8be-88b6fc441ac2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=87331492ddfca51d0d69bca907d780fed99690a968a32e2cef7c16133c1b91da",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 561
      },
      {
        "segments": [
          {
            "segment_id": "e3a82c52-84e5-4fab-b8be-88b6fc441ac2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "A On K Computation Adequacy\r\nSome subtleties. Let us consider a division operator, / , intended to also be strict, that is, to evaluate its\r\narguments following the same non-deterministic strategy as + . Its heating/cooling equations are:\r\na1/a2 \n a1 y \u0003/a2\r\na1/a2 \n a2 y a1/\u0003\r\nTo keep the intuitive discussions simple, so far we purposely avoided imposing any restrictions, or side\r\nconditions, on the heated sub-computations a1 and a2, respectively. In other words, one could in principle\r\ndo reasoning using the equations above in any direction and for any a1, a2 ∈ K. We next show that that\r\nis not entirely correct, so in heating/cooling equations like above we’ll need to impose some (acceptable)\r\nside conditions on the “heated” sub-computations. There is no problem with using these equations from\r\nleft-to-right, but there are two problems with using them from right-to-left, namely when the heated sub\u0002computations (a1 in the first and a2 in the second) are empty or do not correspond to some actual fragment\r\nof program. Both problems are artifacts of the desired AI matching for the K constructor y. Let us first\r\ndiscuss an example reflecting the first problem (we use parentheses to avoid parsing confusion):\r\na1/a2 = a1 y (\u0003/a2) (by the first equation above applied left-to-right)\r\n= a1 y (· y (\u0003/a2)) (by the AI equations for y)\r\n= a1 y (·/a2) (by the first equation above applied right-to-left)\r\n= a1 y a2 y (·/\u0003) (by the second equation above applied left-to-right)\r\n= a1 y a2 y (· y (·/\u0003)) (by the AI equations for y)\r\n= a1 y a2 y (·/·) (by the second equation above applied right-to-left)\r\n= a1 y a2 y (· y (\u0003/·)) (by the first equation above applied left-to-right)\r\n= a1 y a2 y (\u0003/·) (by the AI equations for y)\r\n= a1 y (a2/·) (by the first equation above applied right-to-left)\r\n= a1 y (· y (a2/\u0003)) (by the second equation above applied left-to-right)\r\n= a1 y (a2/\u0003) (by the AI equations for y)\r\n= a2/a1 (by the second equation above applied right-to-left)\r\nTherefore, we derived an obviously undesired equality about division using only its heating/cooling equations,\r\nso the heating/cooling equations as given above are not sound in their full generality (i.e., for all a1, a2 ∈ K).\r\nOne may think that matching modulo the identity “·” is the only problem. The equational proof below\r\nshows that matching modulo associativity is also problematic:\r\n(a1/a2)/(a3/a4) = (a1/a2) y (\u0003/(a3/a4))\r\n= a1 y (\u0003/a2) y (\u0003/(a3/a4))\r\n= a1 y ((\u0003/a2)/(a3/a4))\r\n= a1 y (a3/a4) y ((\u0003/a2)/\u0003)\r\n= a1 y a3 y (\u0003/a4) y ((\u0003/a2)/\u0003)\r\n= a1 y a3 y ((\u0003/a2)/(\u0003/a4))\r\n= a1 y a3 y (\u0003/a2) y (\u0003/(\u0003/a4))\r\n= a1 y (a3/a2) y (\u0003/(\u0003/a4))\r\n= a1 y ((a3/a2)/(\u0003/a4))\r\n= a1 y (\u0003/a4) y ((a3/a2)/\u0003)\r\n= (a1/a4) y ((a3/a2)/\u0003)\r\n= (a3/a2)/(a1/a4)\r\nFormal definitions and computation adequacy. We next give the formal definition of heating/cooling\r\nequations and state their computation (structural) adequacy, saying that no two different “syntactic com\u0002putations” in K can be proved equal to each other using only the heating/cooling equations; syntactic\r\ncomputations are defined below as ones corresponding to AST’s of programs or fragments of programs in\r\nthe language under consideration (formally, they contain only non-freezer labels and contain no computation\r\nsequencing construct “ y ”).\r\n91\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e3a82c52-84e5-4fab-b8be-88b6fc441ac2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=87331492ddfca51d0d69bca907d780fed99690a968a32e2cef7c16133c1b91da",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 561
      },
      {
        "segments": [
          {
            "segment_id": "24726ac8-ce4d-4399-9da7-203411b86bd6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "Definition 1. Let us consider the following syntactic categories:\r\nSyntax ⊆ KLabel (labels corresponding to the language syntax),\r\nKSyntax ::= Syntax(List[KSyntax]) (computations corresponding to programs or fragments of programs),\r\nK◦::= KSyntax y K (computations starting with a program or a fragment of program).\r\nThe K labels in Syntax are called syntactic labels, or simply syntax, and the remaining ones (i.e., those\r\nin KLabel\\Syntax) are called freezers. Computations in KSyntax correspond to (AST’s of fragments of )\r\nprograms and are called syntactic computations. Computations in K◦correspond to potentially “heated”\r\nsyntactic computations and we call them weak syntactic computations; note that KSyntax ⊆ K◦.\r\nA heating/cooling, or computation structural equation is one of the form (note the side condition)\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwhere c is some KSyntax multi-context. If HC is a set of heating/cooling equations, then we let ≡ be the\r\nequational derivability relation induced by HC on K, i.e., for any k, k0 ∈ K, we write k ≡ k\r\n0\r\niff HC |= k = k\r\n0\r\n.\r\nFor k ∈ K, we let ˆk denote its equivalence class wrt ≡, called its computational equivalence class.\r\nThe definition above deserves some discussion. Syntax contains those labels intended to be the syntax\r\nof the language under consideration. The syntactic computations in KSyntax are those computations in K\r\ncorresponding to programs or fragments of programs over Syntax, and the weak syntactic computations in\r\nK◦ are those starting with a syntactic computation. The intuition for the weak syntactic computations is\r\nthat they can be transformed into ones in KSyntax after a series of applications of “cooling” steps (heat\u0002ing/cooling equations applied from right-to-left). Both KSyntax and K◦ may contain more computations\r\nthan intended; for example, the former may contain programs or fragments of programs which are not well\u0002formed, while the latter may contain computations which cannot be necessarily transformed into ones in\r\nKSyntax by applications of heating/cooling equations. Also, there could be several heating/cooling equations\r\nover the same multi-context c; for example, we above had two heating/cooling equations for addition (+).\r\nNevertheless, with all these “inconveniences”, the following holds:\r\nProposition 1. For any k ∈ K, its computation equivalence class ˆk is a finite set.\r\nWhen defining languages or language analyses in K, we are only concerned with ≡-equivalence classes of\r\nwell-formed programs or fragments of programs. For example, in the context of a language definition with\r\nbinary +, ∗ ∈ Syntax having the heating/cooling equations corresponding to their usual (non-deterministic)\r\nstrictness but augmented with side conditions as in Definition 1, if p = x ∗ (y + 2) then ˆp is the set:\r\nx ∗ (y + 2)\r\nx y (\u0003 ∗ (y + 2))\r\nx y (\u0003 ∗ (y y (\u0003 + 2)))\r\nx y (\u0003 ∗ (2 y (y + \u0003)))\r\n(y + 2) y (x ∗ \u0003)\r\ny y (\u0003 + 2) y (x ∗ \u0003)\r\n2 y (y + \u0003) y (x ∗ \u0003)\r\nx ∗ (y y (\u0003 + 2))\r\nx ∗ (2 y (y + \u0003))\r\nNote that there is only one syntactic computation in the computation equivalence class of p above, namely\r\np itself. This is a crucial desired property of K, and is formally stated shortly. Without the side condition\r\nin the definition of heating/cooling equations that the scheduled computation must be in K◦, the following\r\n92\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/24726ac8-ce4d-4399-9da7-203411b86bd6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5a01c85e9e8c3cf72efafc3276e0ac02fb5d169f73f802dd31632aab587292e9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 585
      },
      {
        "segments": [
          {
            "segment_id": "24726ac8-ce4d-4399-9da7-203411b86bd6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "Definition 1. Let us consider the following syntactic categories:\r\nSyntax ⊆ KLabel (labels corresponding to the language syntax),\r\nKSyntax ::= Syntax(List[KSyntax]) (computations corresponding to programs or fragments of programs),\r\nK◦::= KSyntax y K (computations starting with a program or a fragment of program).\r\nThe K labels in Syntax are called syntactic labels, or simply syntax, and the remaining ones (i.e., those\r\nin KLabel\\Syntax) are called freezers. Computations in KSyntax correspond to (AST’s of fragments of )\r\nprograms and are called syntactic computations. Computations in K◦correspond to potentially “heated”\r\nsyntactic computations and we call them weak syntactic computations; note that KSyntax ⊆ K◦.\r\nA heating/cooling, or computation structural equation is one of the form (note the side condition)\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwhere c is some KSyntax multi-context. If HC is a set of heating/cooling equations, then we let ≡ be the\r\nequational derivability relation induced by HC on K, i.e., for any k, k0 ∈ K, we write k ≡ k\r\n0\r\niff HC |= k = k\r\n0\r\n.\r\nFor k ∈ K, we let ˆk denote its equivalence class wrt ≡, called its computational equivalence class.\r\nThe definition above deserves some discussion. Syntax contains those labels intended to be the syntax\r\nof the language under consideration. The syntactic computations in KSyntax are those computations in K\r\ncorresponding to programs or fragments of programs over Syntax, and the weak syntactic computations in\r\nK◦ are those starting with a syntactic computation. The intuition for the weak syntactic computations is\r\nthat they can be transformed into ones in KSyntax after a series of applications of “cooling” steps (heat\u0002ing/cooling equations applied from right-to-left). Both KSyntax and K◦ may contain more computations\r\nthan intended; for example, the former may contain programs or fragments of programs which are not well\u0002formed, while the latter may contain computations which cannot be necessarily transformed into ones in\r\nKSyntax by applications of heating/cooling equations. Also, there could be several heating/cooling equations\r\nover the same multi-context c; for example, we above had two heating/cooling equations for addition (+).\r\nNevertheless, with all these “inconveniences”, the following holds:\r\nProposition 1. For any k ∈ K, its computation equivalence class ˆk is a finite set.\r\nWhen defining languages or language analyses in K, we are only concerned with ≡-equivalence classes of\r\nwell-formed programs or fragments of programs. For example, in the context of a language definition with\r\nbinary +, ∗ ∈ Syntax having the heating/cooling equations corresponding to their usual (non-deterministic)\r\nstrictness but augmented with side conditions as in Definition 1, if p = x ∗ (y + 2) then ˆp is the set:\r\nx ∗ (y + 2)\r\nx y (\u0003 ∗ (y + 2))\r\nx y (\u0003 ∗ (y y (\u0003 + 2)))\r\nx y (\u0003 ∗ (2 y (y + \u0003)))\r\n(y + 2) y (x ∗ \u0003)\r\ny y (\u0003 + 2) y (x ∗ \u0003)\r\n2 y (y + \u0003) y (x ∗ \u0003)\r\nx ∗ (y y (\u0003 + 2))\r\nx ∗ (2 y (y + \u0003))\r\nNote that there is only one syntactic computation in the computation equivalence class of p above, namely\r\np itself. This is a crucial desired property of K, and is formally stated shortly. Without the side condition\r\nin the definition of heating/cooling equations that the scheduled computation must be in K◦, the following\r\n92\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/24726ac8-ce4d-4399-9da7-203411b86bd6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5a01c85e9e8c3cf72efafc3276e0ac02fb5d169f73f802dd31632aab587292e9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 585
      },
      {
        "segments": [
          {
            "segment_id": "b37a5ff1-2893-465d-a02e-fcb128de7704",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "computations could have also been derivable equationally:\r\ny y x ∗ (\u0003 + 2)\r\n2 y x ∗ (y + \u0003)\r\ny y x y \u0003 ∗ (\u0003 + 2)\r\n2 y x y \u0003 ∗ (y + \u0003)\r\n(y y x) ∗ (\u0003 + 2)\r\n(2 y x) ∗ (y + \u0003)\r\n\u0003 + 2 y (y y x) ∗ \u0003\r\ny + \u0003 y (2 y x) ∗ \u0003\r\nWhile one could say that these alternative computations still make sense, especially the first two, we prefer to\r\nregard them as junk computations, because, as seen in the examples before Definition 1, they can be the root\r\nof undesired problems in which two distinct fragments of program get collapsed as identical via equational\r\nreasoning. The following result states that the heating/cooling equations with the reasonable and easy to\r\ncheck side conditions in Definition 1 are indeed adequate:\r\nTheorem 14. Computation (structural) adequacy. For any p, p0 ∈ KSyntax, if pˆ = pˆ0then p = p\r\n0\r\n.\r\nOne can show that precisely the same computation structural equivalence classes could be obtained if one\r\nrestricted the side conditions of the heating/cooling equations even further, for example requiring k2, ..., kn\r\nto be in K◦like k, or even requiring all the involved computations, namely k, k2, ..., kn, to be in KSyntax!\r\nHowever, we prefer to keep the side conditions of the heating/cooling equations as weak as possible, so\r\nthat one is given more flexibility in applying them (when executing or when verifying K definitions). For\r\nexample, when executing K definitions on rewrite engines, the heating/cooling equations are first applied\r\nas heating rewrite rules (these are defined shortly; for now, just recall that most equations are applied as\r\nrewrite rules when rewrite theories are executed), and then applied as cooling rewrite rules only when the\r\nunplugged computation becomes a result. If we required that all the computations involved in the side\r\nconditions of heating/cooling rules be in KSyntax, then we could only apply the resulting heating rewrite\r\nrules following an outermost rewrite strategy. Most rewrite engines provide support for user-configurable\r\nstrategies, in particular for outermost rewriting, but they typically slow down the rewriting process and,\r\nmore importantly, their use would inhibit the potential parallelism inherent in the heating/cooling rules of\r\na K definition. Therefore, we prefer to keep the side conditions as general as possible.\r\nOn orienting the heating/cooling equations into rewrite rules. Heating/cooling equations therefore\r\ngive computation equivalence classes for programs or fragments of programs. Subsequent semantic rules and\r\nequations can apply by matching computations in such equivalence classes. From a theoretical perspective,\r\nthere is no need to define “representative” or “canonical” computations in computation equivalence classes;\r\nfrom a practical point of view though, it is quite useful to have techniques that can systematically generate\r\nthe elements of such computation equivalence classes, or even to automatically calculate representative\r\ncomputations in these equivalence classes. Let us next focus on the first part, namely on how to systematically\r\nreach all the computations in a computation equivalence class.\r\nDefinition 2. For each heating/cooling equation\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwe associate a heating (rewrite) rule (note that there is no side condition)\r\nc[k, k2, ..., kn] * k y c[\u0003, k2, ..., kn]\r\nand a cooling (rewrite) rule (note that it has the same side condition as the heating/cooling equation)\r\nk y c[\u0003, k2, ..., kn] + c[k, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K.\r\nWe used the arrows “*” and “+” for heating and cooling rules, respectively, to easily distinguish them from\r\nother rules. As usual, we let *∗ and +∗ denote the transitive and reflexive closures of * and +.\r\n93\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b37a5ff1-2893-465d-a02e-fcb128de7704.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0046a5ee532ba61664ab7a8879f3e01950f72ef1a5ff7d4ac14cc74fc16d198f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 646
      },
      {
        "segments": [
          {
            "segment_id": "b37a5ff1-2893-465d-a02e-fcb128de7704",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "computations could have also been derivable equationally:\r\ny y x ∗ (\u0003 + 2)\r\n2 y x ∗ (y + \u0003)\r\ny y x y \u0003 ∗ (\u0003 + 2)\r\n2 y x y \u0003 ∗ (y + \u0003)\r\n(y y x) ∗ (\u0003 + 2)\r\n(2 y x) ∗ (y + \u0003)\r\n\u0003 + 2 y (y y x) ∗ \u0003\r\ny + \u0003 y (2 y x) ∗ \u0003\r\nWhile one could say that these alternative computations still make sense, especially the first two, we prefer to\r\nregard them as junk computations, because, as seen in the examples before Definition 1, they can be the root\r\nof undesired problems in which two distinct fragments of program get collapsed as identical via equational\r\nreasoning. The following result states that the heating/cooling equations with the reasonable and easy to\r\ncheck side conditions in Definition 1 are indeed adequate:\r\nTheorem 14. Computation (structural) adequacy. For any p, p0 ∈ KSyntax, if pˆ = pˆ0then p = p\r\n0\r\n.\r\nOne can show that precisely the same computation structural equivalence classes could be obtained if one\r\nrestricted the side conditions of the heating/cooling equations even further, for example requiring k2, ..., kn\r\nto be in K◦like k, or even requiring all the involved computations, namely k, k2, ..., kn, to be in KSyntax!\r\nHowever, we prefer to keep the side conditions of the heating/cooling equations as weak as possible, so\r\nthat one is given more flexibility in applying them (when executing or when verifying K definitions). For\r\nexample, when executing K definitions on rewrite engines, the heating/cooling equations are first applied\r\nas heating rewrite rules (these are defined shortly; for now, just recall that most equations are applied as\r\nrewrite rules when rewrite theories are executed), and then applied as cooling rewrite rules only when the\r\nunplugged computation becomes a result. If we required that all the computations involved in the side\r\nconditions of heating/cooling rules be in KSyntax, then we could only apply the resulting heating rewrite\r\nrules following an outermost rewrite strategy. Most rewrite engines provide support for user-configurable\r\nstrategies, in particular for outermost rewriting, but they typically slow down the rewriting process and,\r\nmore importantly, their use would inhibit the potential parallelism inherent in the heating/cooling rules of\r\na K definition. Therefore, we prefer to keep the side conditions as general as possible.\r\nOn orienting the heating/cooling equations into rewrite rules. Heating/cooling equations therefore\r\ngive computation equivalence classes for programs or fragments of programs. Subsequent semantic rules and\r\nequations can apply by matching computations in such equivalence classes. From a theoretical perspective,\r\nthere is no need to define “representative” or “canonical” computations in computation equivalence classes;\r\nfrom a practical point of view though, it is quite useful to have techniques that can systematically generate\r\nthe elements of such computation equivalence classes, or even to automatically calculate representative\r\ncomputations in these equivalence classes. Let us next focus on the first part, namely on how to systematically\r\nreach all the computations in a computation equivalence class.\r\nDefinition 2. For each heating/cooling equation\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwe associate a heating (rewrite) rule (note that there is no side condition)\r\nc[k, k2, ..., kn] * k y c[\u0003, k2, ..., kn]\r\nand a cooling (rewrite) rule (note that it has the same side condition as the heating/cooling equation)\r\nk y c[\u0003, k2, ..., kn] + c[k, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K.\r\nWe used the arrows “*” and “+” for heating and cooling rules, respectively, to easily distinguish them from\r\nother rules. As usual, we let *∗ and +∗ denote the transitive and reflexive closures of * and +.\r\n93\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/b37a5ff1-2893-465d-a02e-fcb128de7704.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0046a5ee532ba61664ab7a8879f3e01950f72ef1a5ff7d4ac14cc74fc16d198f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 646
      },
      {
        "segments": [
          {
            "segment_id": "6b5fd56b-e8cd-4ddc-8242-4ad35ac84568",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "The side condition “k ∈ K◦” has been drooped for heating rules, because one can easily show that the\r\nleft-hand-sides of heating rules can match a term in a computation equivalence class ˆp only when k ∈ K◦.\r\nLike for the side conditions of heating/cooling equations, we prefer to keep the side conditions as general as\r\npossible. The heating rules can be iteratively applied scheduling for processing any allowed subexpressions;\r\nonce processed, they can be plugged back into context using the cooling rules. Since each heating rule\r\ndecreases the depth of the heated term (freezers and y do not count in the depth measure, because they\r\ncannot match the top of a heating rule), the heating rules terminate as a rewrite system. Moreover, the\r\nheating rules are sufficient to reach the entire computational equivalence class of a program or fragment of\r\nprogram, and their effect can be “undone” with cooling rules:\r\nProposition 2. If p ∈ KSyntax and k ∈ K, then k ∈ pˆ iff p *∗ k iff k +∗ p.\r\nHence, there is a simple and systematic way to generate the computational equivalence class of any\r\nprogram or fragment of program: apply exhaustively all the heating rules and collect all computations that\r\nare encountered this way (there is only a finite number of such reachable computations). Also, for any k ∈ K,\r\nthere is a simple and systematic way to obtain its corresponding syntactic computation: apply all the cooling\r\nrules until a normal form is obtained; since the cooling rules form a canonical rewrite system (it terminates\r\nbecause the number of freezers decreases by each application of cooling rules, and is confluent because it\r\nis orthogonal) and since each computation equivalence class admits precisely one syntactic computation\r\nwhich is a normal form, it follows that the normal forms obtained by applications of cooling rules are the\r\ncorresponding syntactic computations. If one wants to generate the complete computation equivalence class\r\ncorresponding to some k ∈ pˆ, then all one needs to do is to apply cooling rules on k until one obtains the\r\nnormal form p, and then generate ˆp by exhaustively applying heating rules on p. In other words, the relation\r\n+∗; *∗connects any two computations in ˆp with p ∈ KSyntax, that is, +∗; *∗= ˆp × pˆ.\r\nAn analogy in terms of evaluation contexts may be worthwhile here. The computation equivalence class\r\npˆ obtained systematically by applying the heating rules on a program or fragment of program p captures all\r\npossible ways in which p, as well as any of its sub-programs, can be split into an “evaluation context” and a\r\n“redex”. For example, if k1 y k2 ∈ pˆ then k1 can be regarded as the redex and k2 as the evaluation context;\r\nto be more precise, ˆk1 is the redex and ˆk2 is the evaluation context. This observation is the basis for our\r\nfaithful translation of context reduction into K discussed in Section 5.4.6. Therefore, it is not surprising\r\nthat the computation equivalence class approach above is suitable for theoretical developments of K and\r\nin particular for proving properties about K definitions, but less suitable for efficient executability. The\r\nreason is simple: thinking “modulo” computation equivalence classes is an elegant abstraction, same way as\r\nthinking “modulo” splitting a term into an evaluation context and a redex is an elegant abstraction in context\r\nreduction, but calculating these equivalence classes at each step before applying a semantic equation or rule\r\nis very expensive, same way as calculating the actual decompositions of a term into evaluation contexts and\r\nredexes before applying each reduction step in context reduction is very expensive.\r\nIn context reduction, unfortunately, there is little to do in general to avoid considering all the splits of\r\na term into an evaluation context and a redex. Refocusing [?] may help compute incrementally “the next\r\ncontext/redex split” after each reduction, but it works only in very special cases when there is a unique\r\nsuch split at any moment. Unfortunately, this is not the case when defining complex concurrent languages\r\n(if one considers only one split regardless of the desired non-determinism, then one may, obviously, lose\r\nbehaviors, thus making the definition incorrect). There are two inherent problems in reduction semantics\r\nwith evaluation contexts that, together, make considering all the expensive context/redex splits unavoidable\r\nin the presence of concurrency: (1) its monolithic “everything is syntax” approach, and (2) its interleaving\r\napproach to concurrency. Because of (1), there is only one way to get access to a subterm t to reduce it:\r\nto find a top-level evaluation context, say c, such that the global, potentially huge syntactic term can be\r\nregarded as c[t]. In practice, c may contain items that were not part of the original syntax of the language\r\nunder consideration, such as stores, environments, other resources, etc., but in context reduction these are\r\nall “swallowed” by syntax. Because of (2), concurrency is modeled by its resulting non-determinism in\r\nreduction semantics, which can only be captured via non-deterministic decomposition/parsing of terms into\r\nevaluation contexts and redexes. Therefore, in context reduction one must be ready to pick any possible\r\n94\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6b5fd56b-e8cd-4ddc-8242-4ad35ac84568.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aec8f2b938b78e5b3b70decd7aa489dd2fbbab6db6e674834ab03d4ba2504df6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 866
      },
      {
        "segments": [
          {
            "segment_id": "6b5fd56b-e8cd-4ddc-8242-4ad35ac84568",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "The side condition “k ∈ K◦” has been drooped for heating rules, because one can easily show that the\r\nleft-hand-sides of heating rules can match a term in a computation equivalence class ˆp only when k ∈ K◦.\r\nLike for the side conditions of heating/cooling equations, we prefer to keep the side conditions as general as\r\npossible. The heating rules can be iteratively applied scheduling for processing any allowed subexpressions;\r\nonce processed, they can be plugged back into context using the cooling rules. Since each heating rule\r\ndecreases the depth of the heated term (freezers and y do not count in the depth measure, because they\r\ncannot match the top of a heating rule), the heating rules terminate as a rewrite system. Moreover, the\r\nheating rules are sufficient to reach the entire computational equivalence class of a program or fragment of\r\nprogram, and their effect can be “undone” with cooling rules:\r\nProposition 2. If p ∈ KSyntax and k ∈ K, then k ∈ pˆ iff p *∗ k iff k +∗ p.\r\nHence, there is a simple and systematic way to generate the computational equivalence class of any\r\nprogram or fragment of program: apply exhaustively all the heating rules and collect all computations that\r\nare encountered this way (there is only a finite number of such reachable computations). Also, for any k ∈ K,\r\nthere is a simple and systematic way to obtain its corresponding syntactic computation: apply all the cooling\r\nrules until a normal form is obtained; since the cooling rules form a canonical rewrite system (it terminates\r\nbecause the number of freezers decreases by each application of cooling rules, and is confluent because it\r\nis orthogonal) and since each computation equivalence class admits precisely one syntactic computation\r\nwhich is a normal form, it follows that the normal forms obtained by applications of cooling rules are the\r\ncorresponding syntactic computations. If one wants to generate the complete computation equivalence class\r\ncorresponding to some k ∈ pˆ, then all one needs to do is to apply cooling rules on k until one obtains the\r\nnormal form p, and then generate ˆp by exhaustively applying heating rules on p. In other words, the relation\r\n+∗; *∗connects any two computations in ˆp with p ∈ KSyntax, that is, +∗; *∗= ˆp × pˆ.\r\nAn analogy in terms of evaluation contexts may be worthwhile here. The computation equivalence class\r\npˆ obtained systematically by applying the heating rules on a program or fragment of program p captures all\r\npossible ways in which p, as well as any of its sub-programs, can be split into an “evaluation context” and a\r\n“redex”. For example, if k1 y k2 ∈ pˆ then k1 can be regarded as the redex and k2 as the evaluation context;\r\nto be more precise, ˆk1 is the redex and ˆk2 is the evaluation context. This observation is the basis for our\r\nfaithful translation of context reduction into K discussed in Section 5.4.6. Therefore, it is not surprising\r\nthat the computation equivalence class approach above is suitable for theoretical developments of K and\r\nin particular for proving properties about K definitions, but less suitable for efficient executability. The\r\nreason is simple: thinking “modulo” computation equivalence classes is an elegant abstraction, same way as\r\nthinking “modulo” splitting a term into an evaluation context and a redex is an elegant abstraction in context\r\nreduction, but calculating these equivalence classes at each step before applying a semantic equation or rule\r\nis very expensive, same way as calculating the actual decompositions of a term into evaluation contexts and\r\nredexes before applying each reduction step in context reduction is very expensive.\r\nIn context reduction, unfortunately, there is little to do in general to avoid considering all the splits of\r\na term into an evaluation context and a redex. Refocusing [?] may help compute incrementally “the next\r\ncontext/redex split” after each reduction, but it works only in very special cases when there is a unique\r\nsuch split at any moment. Unfortunately, this is not the case when defining complex concurrent languages\r\n(if one considers only one split regardless of the desired non-determinism, then one may, obviously, lose\r\nbehaviors, thus making the definition incorrect). There are two inherent problems in reduction semantics\r\nwith evaluation contexts that, together, make considering all the expensive context/redex splits unavoidable\r\nin the presence of concurrency: (1) its monolithic “everything is syntax” approach, and (2) its interleaving\r\napproach to concurrency. Because of (1), there is only one way to get access to a subterm t to reduce it:\r\nto find a top-level evaluation context, say c, such that the global, potentially huge syntactic term can be\r\nregarded as c[t]. In practice, c may contain items that were not part of the original syntax of the language\r\nunder consideration, such as stores, environments, other resources, etc., but in context reduction these are\r\nall “swallowed” by syntax. Because of (2), concurrency is modeled by its resulting non-determinism in\r\nreduction semantics, which can only be captured via non-deterministic decomposition/parsing of terms into\r\nevaluation contexts and redexes. Therefore, in context reduction one must be ready to pick any possible\r\n94\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/6b5fd56b-e8cd-4ddc-8242-4ad35ac84568.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aec8f2b938b78e5b3b70decd7aa489dd2fbbab6db6e674834ab03d4ba2504df6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 866
      },
      {
        "segments": [
          {
            "segment_id": "da89b07f-3a08-4757-998a-c193504ff13e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "decomposition of a term into an evaluation context and a redex, so in our terminology, one should have the\r\ncomplete computation equivalence class available at each reduction step.\r\nThere is no way to avoid the very same problem in K if one follows the context reduction style of\r\ndefining languages (explained in Section 5.4.6). However, K promotes a different definitional style, namely\r\none in which the “syntax is kept minimal”, by migrating as many items as possible into the configuration\r\n“soup”. For example, threads or other concurrent processes are kept as special configuration structures, each\r\nwrapping, among many other things, a computation. The rewriting logic underlying operational and model\u0002theoretical mechanism will ensure that threads or processes get their expected true concurrency semantics,\r\nwithout ever having to define any evaluation contexts or heating/cooling rules for that purpose. The actual\r\ncomputations, which correspond exclusively to the original syntax of the language under consideration with\r\nno artificial enrichments, can be then kept in canonical forms as explained below.\r\nOne problem with the current general heating/cooling rules is that they are inverse to each other. There\u0002fore, if one puts them together in one rewrite system then that rewrite system will not terminate; in particular,\r\nit cannot be freely used to execute language definitions and thus get an interpreter for the defined languages.\r\nMotivated by purely pragmatic reasons, we next describe a subset of heating and cooling rules, more pre\u0002cisely proper heating and minimal cooling rules, which turned out to be sufficient for many concrete language\r\ndefinitions (in fact, for all we encountered so far), and which can be used together in one rewrite system,\r\nbecause they are not inverse to each other.\r\nDefinition 3. For each heating/cooling equation in a K definition where KResult 6= ∅\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwe associate a proper heating (rewrite) rule\r\nc[k, k2, ..., kn] * k y c[\u0003, k2, ..., kn] when k ∈ K\\KResult and k2, ..., kn ∈ K\r\nand a minimal cooling (rewrite) rule\r\nr y c[\u0003, k2, ..., kn] + c[r, k2, ..., kn] when r ∈ KResult and k2, ..., kn ∈ K.\r\nTo avoid inventing new arrows, we ambiguously used the same arrows “*” and “+” as for unrestricted\r\nheating and cooling rules; unless otherwise specified, when we write these arrows from here on we understand\r\nproper heating and/or minimal cooling.\r\nFirst of all, note that these special heating/cooling rules make sense only when KResult is non-empty.\r\nMany K definitions do not need to define KResults, especially if one is not interested in executing them.\r\nHowever, when the results of processing programs or fragments of program are known and defined as part\r\nof the K definition, then typically the role of the heating rules is to schedule subcomputations for complete\r\nprocessing, while the role of the cooling rules is to plug their results back into context after processing. This\r\nis precisely what the above restricted variants of heating and cooling rules capture. Note that there is no risk\r\nto violate soundness in considering restricted heating/cooling rules as above, in the sense that one cannot\r\nobtain rewriting sequences corresponding to undesired program behaviors when the heating/cooling rules\r\nare too restricted; nevertheless, one may not be able to get all the desired behaviors if one’s rules are too\r\nrestricted, in particular, the rewriting process may get “stuck” with a computation on which the existing\r\nsemantic equations or rewrite rules cannot apply anymore. However, that tends to be a problem more of\r\na theoretical than practical nature. As already mentioned, all our K definitions so far, including all those\r\ndiscussed in this paper, work well with this restricted type of heating/cooling rules when executed.\r\nSince the proper heating and minimal cooling rules are now complementary to each other (rather than\r\ninverse to each other), one needs not work with computation equivalence classes anymore. The process of\r\nrewriting a program or a fragment of program with heating rules to a normal form can also be regarded\r\nas a kind of non-deterministic compilation (static or dynamic, depending upon how/when one applies the\r\nheating rules) of the program or fragment of program. The source of non-determinism is the potential\r\nnon-confluence of the heating rules. For example, recall that the addition (+) was defined to be strict but\r\n95\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/da89b07f-3a08-4757-998a-c193504ff13e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dec08214232578d9280a789df80bc3fdf9a50aa6d85615aac136fdaf7a022052",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 742
      },
      {
        "segments": [
          {
            "segment_id": "da89b07f-3a08-4757-998a-c193504ff13e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "decomposition of a term into an evaluation context and a redex, so in our terminology, one should have the\r\ncomplete computation equivalence class available at each reduction step.\r\nThere is no way to avoid the very same problem in K if one follows the context reduction style of\r\ndefining languages (explained in Section 5.4.6). However, K promotes a different definitional style, namely\r\none in which the “syntax is kept minimal”, by migrating as many items as possible into the configuration\r\n“soup”. For example, threads or other concurrent processes are kept as special configuration structures, each\r\nwrapping, among many other things, a computation. The rewriting logic underlying operational and model\u0002theoretical mechanism will ensure that threads or processes get their expected true concurrency semantics,\r\nwithout ever having to define any evaluation contexts or heating/cooling rules for that purpose. The actual\r\ncomputations, which correspond exclusively to the original syntax of the language under consideration with\r\nno artificial enrichments, can be then kept in canonical forms as explained below.\r\nOne problem with the current general heating/cooling rules is that they are inverse to each other. There\u0002fore, if one puts them together in one rewrite system then that rewrite system will not terminate; in particular,\r\nit cannot be freely used to execute language definitions and thus get an interpreter for the defined languages.\r\nMotivated by purely pragmatic reasons, we next describe a subset of heating and cooling rules, more pre\u0002cisely proper heating and minimal cooling rules, which turned out to be sufficient for many concrete language\r\ndefinitions (in fact, for all we encountered so far), and which can be used together in one rewrite system,\r\nbecause they are not inverse to each other.\r\nDefinition 3. For each heating/cooling equation in a K definition where KResult 6= ∅\r\nc[k, k2, ..., kn] \n k y c[\u0003, k2, ..., kn] when k ∈ K◦ and k2, ..., kn ∈ K,\r\nwe associate a proper heating (rewrite) rule\r\nc[k, k2, ..., kn] * k y c[\u0003, k2, ..., kn] when k ∈ K\\KResult and k2, ..., kn ∈ K\r\nand a minimal cooling (rewrite) rule\r\nr y c[\u0003, k2, ..., kn] + c[r, k2, ..., kn] when r ∈ KResult and k2, ..., kn ∈ K.\r\nTo avoid inventing new arrows, we ambiguously used the same arrows “*” and “+” as for unrestricted\r\nheating and cooling rules; unless otherwise specified, when we write these arrows from here on we understand\r\nproper heating and/or minimal cooling.\r\nFirst of all, note that these special heating/cooling rules make sense only when KResult is non-empty.\r\nMany K definitions do not need to define KResults, especially if one is not interested in executing them.\r\nHowever, when the results of processing programs or fragments of program are known and defined as part\r\nof the K definition, then typically the role of the heating rules is to schedule subcomputations for complete\r\nprocessing, while the role of the cooling rules is to plug their results back into context after processing. This\r\nis precisely what the above restricted variants of heating and cooling rules capture. Note that there is no risk\r\nto violate soundness in considering restricted heating/cooling rules as above, in the sense that one cannot\r\nobtain rewriting sequences corresponding to undesired program behaviors when the heating/cooling rules\r\nare too restricted; nevertheless, one may not be able to get all the desired behaviors if one’s rules are too\r\nrestricted, in particular, the rewriting process may get “stuck” with a computation on which the existing\r\nsemantic equations or rewrite rules cannot apply anymore. However, that tends to be a problem more of\r\na theoretical than practical nature. As already mentioned, all our K definitions so far, including all those\r\ndiscussed in this paper, work well with this restricted type of heating/cooling rules when executed.\r\nSince the proper heating and minimal cooling rules are now complementary to each other (rather than\r\ninverse to each other), one needs not work with computation equivalence classes anymore. The process of\r\nrewriting a program or a fragment of program with heating rules to a normal form can also be regarded\r\nas a kind of non-deterministic compilation (static or dynamic, depending upon how/when one applies the\r\nheating rules) of the program or fragment of program. The source of non-determinism is the potential\r\nnon-confluence of the heating rules. For example, recall that the addition (+) was defined to be strict but\r\n95\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/da89b07f-3a08-4757-998a-c193504ff13e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dec08214232578d9280a789df80bc3fdf9a50aa6d85615aac136fdaf7a022052",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 742
      },
      {
        "segments": [
          {
            "segment_id": "9c05839b-54ea-49db-a289-14d7d7a7e524",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "non-deterministic in our examples above; thus, depending upon which of the two corresponding heating rules\r\none chooses at a certain moment during the evaluation of a program, one may get two different behaviors of\r\nthe program. Using our implementation of K in Maude (see Section ??), for example, one can now either get\r\ninterpreters for defined languages by executing their K definitions as are, without worrying about rewriting\r\ncomputation equivalence classes, or even search the state-space for all the behaviors when the language has\r\nconcurrency or non-determinism. There is a catch, though, in the latter case: if one’s language has strict but\r\nnon-deterministic operators such as the + above and one does not want to give it a thread-like semantics\r\n(explained later in the paper), then one still has to consider computation equivalence classes! The reason\r\nis the following: Maude’s search command tries all possible matches of rules, but once a rule is picked and\r\napplied, it is never undone; for example, if one has the non-deterministic heating rules\r\na1/a2 * a1 y \u0003/a2\r\na1/a2 * a2 y a1/\u0003,\r\nthen during its rewriting or search process Maude non-deterministically picks one of these, in which case\r\nthe other will never be picked anymore on that expression unless appropriate cooling rules are available. In\r\nother words, in our Maude implementation, the two heating rules above define a “non-deterministic choice”\r\nevaluation strategy for + (i.e., non-deterministically pick a1 or a2 and evaluate it all the way, as opposed\r\nto pick any one of them and evaluate it one step, then pick again any one of them and evaluate one step,\r\netc.). The morale here is the following: if one is interested in non-deterministic strict operators in ones\r\nlanguage and one wants to explore all possible behaviors of a program, then one should use all the cooling\r\nrules instead of the minimal ones; one should be aware then that the heating and cooling rules are inverse to\r\neach other, so one should not attempt to use such a definition as an interpreter, because its execution may\r\nnot terminate; instead, if an interpreter is desired, then one should use minimal cooling rules.\r\nStrictness inference. Chucky Ellison, a PhD student at the University of Illinois, observed that in almost\r\nall existing K definitions, both of languages and of analyses such as type checkers or inferencers, the strictness\r\nattributes of language constructs can be automatically inferred from the rest of the K semantics in a rather\r\nstraightforward way: if a language construct admits some K semantic sentence (discussed below) in which\r\none of its arguments is a result, then it means that that language construct was intended to be strict in that\r\nargument. This strictness inference procedure/convention is simple to implement. There appear to be a few\r\nminor issues that need to be well understood before strictness inference is adopted: (1) in some rare cases,\r\none may not want an operation using a value on one of its arguments in the semantics to become strict in\r\nthat argument (for example, in standard λ-calculus, one may want to apply β-reduction anywhere without\r\nobeying any rewriting strategy like in call-by-value or call-by-name); (2) K definitions will be harder to\r\ndebug and test incrementally, because the strictness information can be inferred only after all the semantics\r\nis given; (3) (due to Traian Florin Serbanuta, also a PhD student at the University of Illinois) it would not be\r\npossible to distinguish between non-deterministically strict and sequentially strict attributes, unless another\r\nannotation/attribute is adopted. Additionally, one may want to specify strictness anyway, just for clarity.\r\n96\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9c05839b-54ea-49db-a289-14d7d7a7e524.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c70bdb65221d612ae178bedd0077d21701c7e264c4abf424351298df281bf49e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 609
      },
      {
        "segments": [
          {
            "segment_id": "9c05839b-54ea-49db-a289-14d7d7a7e524",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "non-deterministic in our examples above; thus, depending upon which of the two corresponding heating rules\r\none chooses at a certain moment during the evaluation of a program, one may get two different behaviors of\r\nthe program. Using our implementation of K in Maude (see Section ??), for example, one can now either get\r\ninterpreters for defined languages by executing their K definitions as are, without worrying about rewriting\r\ncomputation equivalence classes, or even search the state-space for all the behaviors when the language has\r\nconcurrency or non-determinism. There is a catch, though, in the latter case: if one’s language has strict but\r\nnon-deterministic operators such as the + above and one does not want to give it a thread-like semantics\r\n(explained later in the paper), then one still has to consider computation equivalence classes! The reason\r\nis the following: Maude’s search command tries all possible matches of rules, but once a rule is picked and\r\napplied, it is never undone; for example, if one has the non-deterministic heating rules\r\na1/a2 * a1 y \u0003/a2\r\na1/a2 * a2 y a1/\u0003,\r\nthen during its rewriting or search process Maude non-deterministically picks one of these, in which case\r\nthe other will never be picked anymore on that expression unless appropriate cooling rules are available. In\r\nother words, in our Maude implementation, the two heating rules above define a “non-deterministic choice”\r\nevaluation strategy for + (i.e., non-deterministically pick a1 or a2 and evaluate it all the way, as opposed\r\nto pick any one of them and evaluate it one step, then pick again any one of them and evaluate one step,\r\netc.). The morale here is the following: if one is interested in non-deterministic strict operators in ones\r\nlanguage and one wants to explore all possible behaviors of a program, then one should use all the cooling\r\nrules instead of the minimal ones; one should be aware then that the heating and cooling rules are inverse to\r\neach other, so one should not attempt to use such a definition as an interpreter, because its execution may\r\nnot terminate; instead, if an interpreter is desired, then one should use minimal cooling rules.\r\nStrictness inference. Chucky Ellison, a PhD student at the University of Illinois, observed that in almost\r\nall existing K definitions, both of languages and of analyses such as type checkers or inferencers, the strictness\r\nattributes of language constructs can be automatically inferred from the rest of the K semantics in a rather\r\nstraightforward way: if a language construct admits some K semantic sentence (discussed below) in which\r\none of its arguments is a result, then it means that that language construct was intended to be strict in that\r\nargument. This strictness inference procedure/convention is simple to implement. There appear to be a few\r\nminor issues that need to be well understood before strictness inference is adopted: (1) in some rare cases,\r\none may not want an operation using a value on one of its arguments in the semantics to become strict in\r\nthat argument (for example, in standard λ-calculus, one may want to apply β-reduction anywhere without\r\nobeying any rewriting strategy like in call-by-value or call-by-name); (2) K definitions will be harder to\r\ndebug and test incrementally, because the strictness information can be inferred only after all the semantics\r\nis given; (3) (due to Traian Florin Serbanuta, also a PhD student at the University of Illinois) it would not be\r\npossible to distinguish between non-deterministically strict and sequentially strict attributes, unless another\r\nannotation/attribute is adopted. Additionally, one may want to specify strictness anyway, just for clarity.\r\n96\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9c05839b-54ea-49db-a289-14d7d7a7e524.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c70bdb65221d612ae178bedd0077d21701c7e264c4abf424351298df281bf49e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 609
      },
      {
        "segments": [
          {
            "segment_id": "47581d77-0a86-4284-b64f-a0f47e5609f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "B Defining SILF in K\r\nSILF is a simple imperative language with functions. It is a C-like language, but a lot simpler in many aspects.\r\nFor example, SILF has no structures and no pointers. A program consists of a “;”-separated sequence of\r\nglobal variable declarations, followed by a sequence of function declarations, one of them expected to be\r\ncalled main. Nested function declarations are not accepted. The program is executed by calling the function\r\nmain(). Scoping is static, or lexical, and functions see each other and also the global variables. In particular,\r\na function can recursively call itself. Statements can be grouped in blocks with local variable declarations.\r\nThe names of the variables that appear in a sequence of declarations are expected to be different, and so are\r\nthe function names. Additionally, the function names are expected to be different from the global variable\r\nnames and not to be used for anything else but function invocations. Finally, each function must return\r\nexplicitly, using a “return v” statement, for some value v. These conditions can be easily checked statically.\r\nAn untyped version of SILF is presented in Appendix B.1, that is, one in which variables and functions\r\nare are not declared any types. Values in SILF can have two basic types, integer and boolean; in our Maude\r\nimplementation of K definitions, both boolean and integer values are, by convention, prefixed with a “#”\r\nto keep language arithmetic and boolean constructs distinct from Maude builtin operators that happen to\r\nhave the same name. Even in its untyped version, SILF is still partly dynamically typed, in the sense\r\nthat, when executed, a program “gets stuck” if certain inappropriate operations are encountered during its\r\nexecution, such as adding an integer with a boolean, or calling a function with a wrong number of arguments,\r\nand so on. By a stuck program we mean one that cannot be advanced anymore due to the fact that no\r\nrewrite rule matches. No advanced dynamic type checking is performed by the untyped SILF; in particular,\r\na variable can be assigned values of different types during its lifetime, and no type checking is performed\r\nwhen functions are invoked, because no typing information is available for them. Appendix B.2 discusses an\r\nactual dynamically typed variant of SILF, in which more advanced dynamic typing is performed. Note that,\r\nfor uniformity reasons, we prefer to store the declared functions as lambda-like expressions in the store; that\r\nis not necessary (functions could have been stored in a function environment), but it eases the definition of\r\nname lookup; indeed, in our current definitions of SILF discussed in this section, function names and variable\r\nnames are looked up similarly. To give the reader a better feel for the untyped version of the SILF language,\r\nhere is a heap sort program that can be executed by our semantics (written in SILF by Pat Meredith):\r\nvar numbers[100] ;\r\nfunction siftDown(root, bottom) {\r\nvar done ; var maxChild ; var temp ;\r\ndone = false ;\r\nwhile (root * 2 <= bottom and not done) do {\r\nif (root * 2 == bottom) then {\r\nmaxChild = root * 2\r\n}\r\nelse if (numbers[root * 2] > numbers[root * 2 + 1]) then { maxChild = root * 2 }\r\nelse { maxChild = root * 2 + 1 }\r\nif (numbers[root] < numbers[maxChild]) then {\r\ntemp = numbers[root] ;\r\nnumbers[root] = numbers[maxChild] ;\r\nnumbers[maxChild] = temp ;\r\nroot = maxChild\r\n}\r\nelse { done = true }\r\n}\r\nreturn 0\r\n}\r\nfunction heapSort(size) {\r\nvar temp ; var i ;\r\ni = (size / 2) - 1 ;\r\nwhile (i >= 0) do {\r\ncall siftDown(i, size - 1) ;\r\ni = i - 1\r\n97\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/47581d77-0a86-4284-b64f-a0f47e5609f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ffba8b10f68ca1f625d905bd8093c9351b6ed580d8f55be12c45fe0696ba2d09",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 633
      },
      {
        "segments": [
          {
            "segment_id": "47581d77-0a86-4284-b64f-a0f47e5609f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "B Defining SILF in K\r\nSILF is a simple imperative language with functions. It is a C-like language, but a lot simpler in many aspects.\r\nFor example, SILF has no structures and no pointers. A program consists of a “;”-separated sequence of\r\nglobal variable declarations, followed by a sequence of function declarations, one of them expected to be\r\ncalled main. Nested function declarations are not accepted. The program is executed by calling the function\r\nmain(). Scoping is static, or lexical, and functions see each other and also the global variables. In particular,\r\na function can recursively call itself. Statements can be grouped in blocks with local variable declarations.\r\nThe names of the variables that appear in a sequence of declarations are expected to be different, and so are\r\nthe function names. Additionally, the function names are expected to be different from the global variable\r\nnames and not to be used for anything else but function invocations. Finally, each function must return\r\nexplicitly, using a “return v” statement, for some value v. These conditions can be easily checked statically.\r\nAn untyped version of SILF is presented in Appendix B.1, that is, one in which variables and functions\r\nare are not declared any types. Values in SILF can have two basic types, integer and boolean; in our Maude\r\nimplementation of K definitions, both boolean and integer values are, by convention, prefixed with a “#”\r\nto keep language arithmetic and boolean constructs distinct from Maude builtin operators that happen to\r\nhave the same name. Even in its untyped version, SILF is still partly dynamically typed, in the sense\r\nthat, when executed, a program “gets stuck” if certain inappropriate operations are encountered during its\r\nexecution, such as adding an integer with a boolean, or calling a function with a wrong number of arguments,\r\nand so on. By a stuck program we mean one that cannot be advanced anymore due to the fact that no\r\nrewrite rule matches. No advanced dynamic type checking is performed by the untyped SILF; in particular,\r\na variable can be assigned values of different types during its lifetime, and no type checking is performed\r\nwhen functions are invoked, because no typing information is available for them. Appendix B.2 discusses an\r\nactual dynamically typed variant of SILF, in which more advanced dynamic typing is performed. Note that,\r\nfor uniformity reasons, we prefer to store the declared functions as lambda-like expressions in the store; that\r\nis not necessary (functions could have been stored in a function environment), but it eases the definition of\r\nname lookup; indeed, in our current definitions of SILF discussed in this section, function names and variable\r\nnames are looked up similarly. To give the reader a better feel for the untyped version of the SILF language,\r\nhere is a heap sort program that can be executed by our semantics (written in SILF by Pat Meredith):\r\nvar numbers[100] ;\r\nfunction siftDown(root, bottom) {\r\nvar done ; var maxChild ; var temp ;\r\ndone = false ;\r\nwhile (root * 2 <= bottom and not done) do {\r\nif (root * 2 == bottom) then {\r\nmaxChild = root * 2\r\n}\r\nelse if (numbers[root * 2] > numbers[root * 2 + 1]) then { maxChild = root * 2 }\r\nelse { maxChild = root * 2 + 1 }\r\nif (numbers[root] < numbers[maxChild]) then {\r\ntemp = numbers[root] ;\r\nnumbers[root] = numbers[maxChild] ;\r\nnumbers[maxChild] = temp ;\r\nroot = maxChild\r\n}\r\nelse { done = true }\r\n}\r\nreturn 0\r\n}\r\nfunction heapSort(size) {\r\nvar temp ; var i ;\r\ni = (size / 2) - 1 ;\r\nwhile (i >= 0) do {\r\ncall siftDown(i, size - 1) ;\r\ni = i - 1\r\n97\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/47581d77-0a86-4284-b64f-a0f47e5609f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ffba8b10f68ca1f625d905bd8093c9351b6ed580d8f55be12c45fe0696ba2d09",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 633
      },
      {
        "segments": [
          {
            "segment_id": "be040cfd-218b-4856-b14b-64e24fd4a419",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "}\r\ni = size - 1 ;\r\nwhile (i >= 1 ) do {\r\ntemp = numbers[0] ;\r\nnumbers[0] = numbers[i] ;\r\nnumbers[i] = temp ;\r\ncall siftDown(0, i - 1) ;\r\ni = i - 1\r\n}\r\nreturn 0\r\n}\r\nfunction main() {\r\nvar x ;\r\nx = read() ;\r\nfor i = 0 to (x - 1) do {\r\nnumbers[i] = read()\r\n}\r\ncall heapSort(x) ;\r\nfor i = 0 to (x - 1) do {\r\nwrite(numbers[i])\r\n}\r\nreturn 0\r\n}\r\nAppendix B.2 adds type declarations to SILF, for both variables and functions. Type declarations are\r\nregarded as rigid “contracts”, or “specifications”, so they cannot be violated and cannot be changed at\r\nruntime. The definition in Appendix B.2 modifies the one in Appendix B.1 to check type declarations\r\ndynamically. Only the executed path is checked, so there could be other executions possible (under a\r\ndifferent input, for example) that violate the typing policy. Values are not tagged with their types in the\r\nstore; we assume instead a function typeOf on integer and boolean values returning their corresponding type.\r\nThe declared type of a variable is stored in the environment, together with the location of that variable.\r\nIn the case of arrays, the declared length of the array is incorporated as part of its type, so that runtime\r\narray accesses can be checked to fall within the specified boundaries; languages like Java also perform such\r\nboundary checks dynamically. Dynamic checking of types, safety policies, contracts, or specifications is\r\ncommon and instructive in its own way. The purpose of Appendix B.2 is to show that runtime verification\r\nof safety policies/properties can be very easily achieved in K, by slightly adjusting the existing definition.\r\nAppendix B.3 defines a static type checker for SILF, following the same K framework as the other\r\ndefinitions. The major difference is that the domain of interpretation for the language syntax is now one\r\nof types (instead of concrete values), that is, programs or fragments of program, as well as computations\r\nin general, now evolve into types; types are therefore the results of computations. Most operations are now\r\nstrict in all their arguments, including the conditionals and the loops. The program is first traversed and\r\nall the global variable and function declarations are collected in the global environment, while the function\r\nbodies are scheduled for typing in toType. This step is sub-linear in complexity, because the bodies of the\r\nfunctions are not traversed. Then each function body is processed separately, traversing all its code; in the\r\nworst case, assuming no concurrent capabilities of the underlying rewrite engine, the complexity of checking\r\neach function is linear in its size. Complexity-wise, our approach to type checking using K is therefore as\r\ngood as, or better, than defining/implementing type checking algorithms. It has the additional benefit of\r\nbeing formal and using the same logical framework as the definition of the concrete semantics, so it should\r\nfacilitate formal verification and proofs of correctness (such as, for example, type preservation and progress).\r\nWhen reading the subsequent sections, recall that the “K-annotated syntax” of a language defines more\r\nthan the actual syntax of the language: it defines the syntax of that language’s computations, including\r\ntheir structural identities (using the “strict” or default attributes; structurally equivalent computations are\r\nidentical entities), as well as some straightforward reduction rules (using the “extends” attribute). Even\r\nthough we use variable names such as d for “declarations” or s for “statements”, in K definitions there is\r\nonly one syntactic category, K, of computations. In fact, the different equations for sequential composition\r\n“;” are given only for clarity; one would suffice. The K annotations to syntax capture local, syntax driven,\r\n98\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/be040cfd-218b-4856-b14b-64e24fd4a419.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e26c9e7a2c7bb4c61d8d255365f21fa63d236e26bf3841d81375959a5e0b0a9e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 626
      },
      {
        "segments": [
          {
            "segment_id": "be040cfd-218b-4856-b14b-64e24fd4a419",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "}\r\ni = size - 1 ;\r\nwhile (i >= 1 ) do {\r\ntemp = numbers[0] ;\r\nnumbers[0] = numbers[i] ;\r\nnumbers[i] = temp ;\r\ncall siftDown(0, i - 1) ;\r\ni = i - 1\r\n}\r\nreturn 0\r\n}\r\nfunction main() {\r\nvar x ;\r\nx = read() ;\r\nfor i = 0 to (x - 1) do {\r\nnumbers[i] = read()\r\n}\r\ncall heapSort(x) ;\r\nfor i = 0 to (x - 1) do {\r\nwrite(numbers[i])\r\n}\r\nreturn 0\r\n}\r\nAppendix B.2 adds type declarations to SILF, for both variables and functions. Type declarations are\r\nregarded as rigid “contracts”, or “specifications”, so they cannot be violated and cannot be changed at\r\nruntime. The definition in Appendix B.2 modifies the one in Appendix B.1 to check type declarations\r\ndynamically. Only the executed path is checked, so there could be other executions possible (under a\r\ndifferent input, for example) that violate the typing policy. Values are not tagged with their types in the\r\nstore; we assume instead a function typeOf on integer and boolean values returning their corresponding type.\r\nThe declared type of a variable is stored in the environment, together with the location of that variable.\r\nIn the case of arrays, the declared length of the array is incorporated as part of its type, so that runtime\r\narray accesses can be checked to fall within the specified boundaries; languages like Java also perform such\r\nboundary checks dynamically. Dynamic checking of types, safety policies, contracts, or specifications is\r\ncommon and instructive in its own way. The purpose of Appendix B.2 is to show that runtime verification\r\nof safety policies/properties can be very easily achieved in K, by slightly adjusting the existing definition.\r\nAppendix B.3 defines a static type checker for SILF, following the same K framework as the other\r\ndefinitions. The major difference is that the domain of interpretation for the language syntax is now one\r\nof types (instead of concrete values), that is, programs or fragments of program, as well as computations\r\nin general, now evolve into types; types are therefore the results of computations. Most operations are now\r\nstrict in all their arguments, including the conditionals and the loops. The program is first traversed and\r\nall the global variable and function declarations are collected in the global environment, while the function\r\nbodies are scheduled for typing in toType. This step is sub-linear in complexity, because the bodies of the\r\nfunctions are not traversed. Then each function body is processed separately, traversing all its code; in the\r\nworst case, assuming no concurrent capabilities of the underlying rewrite engine, the complexity of checking\r\neach function is linear in its size. Complexity-wise, our approach to type checking using K is therefore as\r\ngood as, or better, than defining/implementing type checking algorithms. It has the additional benefit of\r\nbeing formal and using the same logical framework as the definition of the concrete semantics, so it should\r\nfacilitate formal verification and proofs of correctness (such as, for example, type preservation and progress).\r\nWhen reading the subsequent sections, recall that the “K-annotated syntax” of a language defines more\r\nthan the actual syntax of the language: it defines the syntax of that language’s computations, including\r\ntheir structural identities (using the “strict” or default attributes; structurally equivalent computations are\r\nidentical entities), as well as some straightforward reduction rules (using the “extends” attribute). Even\r\nthough we use variable names such as d for “declarations” or s for “statements”, in K definitions there is\r\nonly one syntactic category, K, of computations. In fact, the different equations for sequential composition\r\n“;” are given only for clarity; one would suffice. The K annotations to syntax capture local, syntax driven,\r\n98\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/be040cfd-218b-4856-b14b-64e24fd4a419.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e26c9e7a2c7bb4c61d8d255365f21fa63d236e26bf3841d81375959a5e0b0a9e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 626
      },
      {
        "segments": [
          {
            "segment_id": "5b783038-f00e-43f7-8859-0a8ad36420b3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 99,
            "page_width": 612,
            "page_height": 792,
            "content": "typically uninteresting and rather trivial and boring parts of a language definition. The remaining rules and\r\nequations are grouped into the “K configuration and semantics” part of the definition.\r\nB.1 Untyped SILF\r\nK-Annotated Syntax of Untyped SILF\r\nNat ::= 0 | 1 | 2 | . . . all natural numbers\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables and functions\r\nExp ::= Int | Bool | Name\r\n| Name[Exp] [strict(2)]\r\n| read()\r\n| Name(List[Exp]) [strict(1), f(el1, e, el2) \n e y f(el1, \u0003, el2)]\r\n| Exp + Exp [strict, extends +Int×Int→Int]\r\n| Exp − Exp [strict, extends −Int×Int→Int]\r\n| Exp ∗ Exp [strict, extends ∗Int×Int→Int]\r\n| Exp /Exp [strict, extends quotientInt×Int→Int]\r\n| Exp %Exp [strict, extends remainderInt×Int→Int]\r\n| −Exp [strict, extends −Int→Int]\r\n| Exp < Exp [strict, extends <Int×Int→Bool]\r\n| Exp <= Exp [strict, extends ≤Int×Int→Bool]\r\n| Exp > Exp [strict, extends >Int×Int→Bool]\r\n| Exp >= Exp [strict, extends ≥Int×Int→Bool]\r\n| Exp == Exp [strict, extends =Int×Int→Bool]\r\n| Exp != Exp [strict, extends 6=Int×Int→Bool]\r\n| Exp and Exp [strict, extends ∧Bool×Bool→Bool]\r\n| Exp or Exp [strict, extends ∨Bool×Bool→Bool]\r\n| not Exp [strict, extends ¬Bool→Bool]\r\nDecl ::= var Name | var Name[Nat]\r\n| Decl; Decl [d1; d2 = d1 y d2]\r\nStmt ::= {} [{} = ·]\r\n| {Stmt} [{s} = s]\r\n| {Decl; Stmt}\r\n| Stmt; Stmt [s1; s2 = s1 y s2]\r\n| write(Exp) [strict]\r\n| Name = Exp [strict(2)]\r\n| Name[Exp] = Exp [strict(2, 3)]\r\n| if Exp then Stmt else Stmt [strict(1)]\r\n| if Exp then Stmt [if e then s = if e then s else ·]\r\n| while Exp do Stmt\r\n| for Name = Exp to Exp do Stmt\r\n[for i = e1 to e2 do s = {var i; i = e1; while (i <= e2) do {s;i = i + 1}}]\r\n| call Exp [strict]\r\n| return Exp [strict]\r\nFunDecl ::= function Name(List[Name]) Stmt\r\n| FunDecl FunDecl [fd1fd2 = fd1 y fd2]\r\nPgm ::= FunDecl\r\n| Decl; FunDecl [d; fd = d y fd]\r\n99\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/5b783038-f00e-43f7-8859-0a8ad36420b3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5303e66fba133fd641d7d0cd12f26bb1d0e108352e96ac6799b2806109fc1347",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 364
      },
      {
        "segments": [
          {
            "segment_id": "359535ce-e6d2-477a-a2e3-45f875b679b1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 100,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of Untyped SILF\r\nVal ::= Int | Bool | λList[Name].K\r\nKResult ::= Val\r\nEnv ::= Map[Name, Loc]\r\nStore ::= Map[Loc, Val]\r\nFStack ::= List[Env × K]\r\nConfigItem ::= k(K) | fstack(FStack) | env(Env) | genv(Env)\r\n| in(List[Int]) | out(List[Int]) | store(Store) | nextLoc(Loc)\r\nConfig ::= List[Int] | JK, List[Int]K | JSet[ConfigItem]K\r\n| JKK [JkK = Jk, ·K]\r\nK ::= . . . | run | restore(Env)\r\nJp, ilK = Jk(p y run) fstack(·) env(·) genv(·) in(il) out(·) store(·) nextLoc(loc(0))K\r\nh|k(·) out(il)|i> = il\r\nL run\r\ncall main()\r\nMk env(ρ) genv(·\r\nρ\r\n)\r\nL x\r\nσ[ρ[x]]\r\n|ikenv(ρ) store(σ)\r\nL x[n]\r\nσ[ρ[x] +Loc n]\r\n|ikenv(ρ) store(σ)\r\nLread()\r\ni\r\n|ikLi\r\n·\r\n|iin\r\nk((λxl.s)(vl) y k\r\ns\r\n) L ·\r\n(ρ, k)\r\n|i\r\nfstack env( ρ\r\nρ\r\n0\r\n[ll0/xl]\r\n) genv(ρ\r\n0\r\n) store( σ\r\nσ[vl/ll\r\n0\r\n]\r\n) nextLoc(l\r\nl\r\n0\r\n) where l\r\n0\r\nis l +Loc |xl|, and\r\nll0is l . . .(l\r\n0 +Loc −1)\r\nLvar x\r\n·\r\n|ikenv( ρ\r\nρ[l/x]\r\n) nextLoc( l\r\nl +Loc 1\r\n)\r\nLvar x[n]\r\n·\r\n|ikenv( ρ\r\nρ[l/x]\r\n) nextLoc( l\r\nl +Loc n\r\n)\r\nL {d; s}\r\nd y s y restore(ρ)\r\n|ikenv(ρ)\r\nLrestore(ρ)\r\n·\r\n|ikenv(\r\nρ\r\n)\r\nLwrite i\r\n·\r\n|ikh|·\r\ni\r\nMout\r\nLx = v\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[v/ρ[x]]\r\n)\r\nLx[n] = v\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[v/ρ[x] +Loc n]\r\n)\r\nif true then s1 else s2 → s1\r\nif false then s1 else s2 → s2\r\nLwhile b do s|ik = Lif b then (s;while b do s)|ik\r\ncall v → .\r\nk(return v y\r\nv y k\r\n) L(ρ, k)\r\n·\r\n|ifstack env(\r\nρ\r\n)\r\nLfunction f(xl) s\r\n·\r\n|ikenv( ρ\r\nρ[l/f]\r\n) store( σ\r\nσ[λxl.s/l]\r\n) nextLoc( l\r\nl +Loc 1\r\n)\r\n100\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/359535ce-e6d2-477a-a2e3-45f875b679b1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=74b2a7b0498fa5ee27f6d517a4876670ec4620474287959394dd5d79beae05c7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "9e8ca953-beb4-4650-bd42-b2dd352e22be",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "B.2 Type Checking SILF Dynamically\r\nK-Annotated Syntax of Dynamically Type-Checked SILF\r\nNat ::= 0 | 1 | 2 | . . . all natural numbers\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables and functions\r\nType ::= int | bool (one may add more types if one extends the language)\r\nExp ::= Int | Bool\r\n| Name\r\n| Name[Exp] [strict(2)]\r\n| read()\r\n| Name(List[Exp]) [strict(1), f(el1, e, el2) \n e y f(el1, \u0003, el2)]\r\n| Exp + Exp [strict, extends +Int×Int→Int]\r\n| Exp − Exp [strict, extends −Int×Int→Int]\r\n| Exp ∗ Exp [strict, extends ∗Int×Int→Int]\r\n| Exp /Exp [strict, extends quotientInt×Int→Int]\r\n| Exp %Exp [strict, extends remainderInt×Int→Int]\r\n| −Exp [strict, extends −Int→Int]\r\n| Exp < Exp [strict, extends <Int×Int→Bool]\r\n| Exp <= Exp [strict, extends ≤Int×Int→Bool]\r\n| Exp > Exp [strict, extends >Int×Int→Bool]\r\n| Exp >= Exp [strict, extends ≥Int×Int→Bool]\r\n| Exp == Exp [strict, extends =Int×Int→Bool]\r\n| Exp != Exp [strict, extends 6=Int×Int→Bool]\r\n| Exp and Exp [strict, extends ∧Bool×Bool→Bool]\r\n| Exp or Exp [strict, extends ∨Bool×Bool→Bool]\r\n| not Exp [strict, extends ¬Bool→Bool]\r\nDecl ::= var Type Name | var Type Name[Nat]\r\n| Decl; Decl [d1; d2 = d1 y d2]\r\nStmt ::= {} [{} = ·]\r\n| {Stmt} [{s} = s]\r\n| {Decl; Stmt}\r\n| Stmt; Stmt [s1; s2 = s1 y s2]\r\n| write(Exp) [strict]\r\n| Name = Exp [strict(2)]\r\n| Name[Exp] = Exp [strict(2, 3)]\r\n| if Exp then Stmt else Stmt [strict(1)]\r\n| if Exp then Stmt [if e then s = if e then s else ·]\r\n| while Exp do Stmt\r\n| for Name = Exp to Exp do Stmt\r\n[for i = e1 to e2 do s = {var int i; i = e1; while (i <= e2) do {s;i = i + 1}}]\r\n| call Exp [strict]\r\n| return Exp [strict]\r\nFunDecl ::= function Type Name(List[Type] List[Name]) Stmt\r\n| FunDecl FunDecl [fd1fd2 = fd1 y fd2]\r\nPgm ::= FunDecl\r\n| Decl; FunDecl [d; fd = d y fd]\r\n101\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/9e8ca953-beb4-4650-bd42-b2dd352e22be.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d2cbe47aa9787d0854281d405d604001b64b32864b9cbc6fa08ea80a34ad78a9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 358
      },
      {
        "segments": [
          {
            "segment_id": "0a6f45ec-5009-45ff-955c-c6981cdb0770",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 102,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of Dynamically Type-Checked SILF\r\nVal ::= Int | Bool | Type λList[Type] List[Name].K\r\nKResult ::= Val\r\nEnv ::= Map[Name, Loc × Type] (let ρ[x] be (loc(ρ[x]), type(ρ[x])) for each ρ ∈ Env, x ∈ Name)\r\nStore ::= Map[Loc, Val]\r\nFStack ::= List[Env × K × Type]\r\nConfigItem ::= k(K) | fstack(FStack) | env(Env) | genv(Env)\r\n| in(List[Int]) | out(List[Int]) | return(Type) | store(Store) | nextLoc(Loc)\r\nConfig ::= List[Int] | JK, List[Int]K | JSet[ConfigItem]K\r\n| JKK [JkK = Jk, ·K]\r\nK ::= . . . | run | restore(Env)\r\nType ::= . . . |? | Type[Nat]\r\nJp, ilK = Jk(p y run) fstack(·) env(·) genv(·) in(il) out(·) return(?) store(·) nextLoc(loc(0))K\r\nh|k(·) out(il)|i> = il\r\nk( run\r\ncall main()\r\n) env(ρ) genv(·\r\nρ\r\n)\r\nL x\r\nσ[loc(ρ[x])]\r\n|ikenv(ρ) store(σ)\r\nL x[n]\r\nσ[loc(ρ[x]) +Loc n]\r\n|ikenv(ρ) store(σ) where type(ρ[x]) = t[n\r\n0\r\n] with n < n0\r\nLread()\r\ni\r\n|ikLi\r\n·\r\n|iin\r\nk((t λtl xl.s)(vl) y k\r\ns\r\n) L ·\r\n(ρ, k, t0)\r\n|i\r\nfstack env( ρ\r\nρ\r\n0\r\n[(ll\r\n0\r\n, tl)/xl]\r\n) genv(ρ\r\n0\r\n) return(t\r\n0\r\nt\r\n) store( σ\r\nσ[vl/ll0]\r\n) nextLoc(l\r\nl\r\n0\r\n)\r\nwhere l\r\n0\r\nis l +Loc |xl|, ll0is l . . .(l +Loc −1), and typeOf (vl)=tl\r\nLvar t x\r\n·\r\n|ikenv( ρ\r\nρ[(l, t)/x]\r\n) nextLoc( l\r\nl +Loc 1\r\n)\r\nLvar t x[n]\r\n·\r\n|ikenv( ρ\r\nρ[(l, t[n])/x]\r\n) nextLoc( l\r\nl +Loc n\r\n)\r\nL {d; s}\r\nd y s y restore(ρ)\r\n|ikenv(ρ)\r\nLrestore(ρ)\r\n·\r\n|ikenv(\r\nρ\r\n)\r\nLwrite i\r\n·\r\n|ikh|·\r\ni\r\nMout\r\nLx = v\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[v/loc(ρ[x])]\r\n) where type(ρ[x]) = typeOf(v)\r\nLx[n] = v\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[v/loc(ρ[x]) +Loc n]\r\n) where type(ρ[x]) = typeOf(v)[n\r\n0\r\n] with n < n0\r\nif true then s1 else s2 → s1\r\nif false then s1 else s2 → s2\r\nLwhile b do s|ik = Lif b then (s;while b do s)|ik\r\ncall v → .\r\nk(return v y\r\nv y k\r\n) L(ρ, k, t)\r\n·\r\n|ifstack env(\r\nρ\r\n) return(t\r\n0\r\nt\r\n) if typeOf(v) = t\r\n0\r\nLfunction t f(tl xl) s\r\n·\r\n|ikenv( ρ\r\nρ[(l, ?)/f]\r\n) store( σ\r\nσ[t λtl xl.s/l]\r\n) nextLoc( l\r\nl +Loc 1\r\n)\r\n102\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0a6f45ec-5009-45ff-955c-c6981cdb0770.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e92be536df059594fccf8e2a3085a2d20c62cd175b4b25af10d226c726b396aa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 388
      },
      {
        "segments": [
          {
            "segment_id": "0c8141e1-0486-41de-8600-a9ec23389b34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 103,
            "page_width": 612,
            "page_height": 792,
            "content": "B.3 Type Checking SILF Statically\r\nK-Annotated Syntax of a Static Type Checker for SILF\r\nNat ::= 0 | 1 | 2 | . . . all natural numbers\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables and functions\r\nType ::= int | bool (one may add more types if one extends the language)\r\nExp ::= Int | Bool\r\n| Name\r\n| Name[Exp] [strict]\r\n| read()\r\n| Name(List[Exp]) [strict(1), f(el1, e, el2) \n e y f(el1, \u0003, el2)]\r\n| Exp + Exp [strict]\r\n| Exp − Exp [strict]\r\n| Exp ∗ Exp [strict]\r\n| Exp /Exp [strict]\r\n| Exp %Exp [strict]\r\n| −Exp [strict]\r\n| Exp < Exp [strict]\r\n| Exp <= Exp [strict]\r\n| Exp > Exp [strict]\r\n| Exp >= Exp [strict]\r\n| Exp == Exp [strict]\r\n| Exp != Exp [strict]\r\n| Exp and Exp [strict]\r\n| Exp or Exp [strict]\r\n| not Exp [strict]\r\nDecl ::= var Type Name | var Type Name[Nat]\r\n| Decl; Decl [strict]\r\nStmt ::= {} (typing of blocks counts as reduction steps, so they are defined in the semantics part)\r\n| {Stmt} [strict]\r\n| {Decl; Stmt}\r\n| Stmt; Stmt [strict]\r\n| write(Exp) [strict]\r\n| Name = Exp [strict]\r\n| Name[Exp] = Exp [strict]\r\n| if Exp then Stmt else Stmt [strict]\r\n| if Exp then Stmt [strict]\r\n| while Exp do Stmt [strict]\r\n| for Name = Exp to Exp do Stmt\r\n[for i = e1 to e2 do s = {var int i; i = e1; while (i <= e2) do {s;i = i + 1}}]\r\n| call Exp [strict]\r\n| return Exp [strict]\r\nFunDecl ::= function Type Name(List[Type] List[Name]) Stmt\r\n| FunDecl FunDecl [strict]\r\nPgm ::= FunDecl\r\n| Decl; FunDecl [strict]\r\n103\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/0c8141e1-0486-41de-8600-a9ec23389b34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=25bfc7031f1622c3f250600ff7a11151da6745ce39776b968a45ce375b36475b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 312
      },
      {
        "segments": [
          {
            "segment_id": "bfedb8dd-8d3d-4ccb-8ee6-35b5b609aed8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of a Static Type Checker for SILF\r\nType ::= . . . |? | decl | stmt | fundecl | pgm | Type[] | List[Type] → Type\r\nKResult ::= Type\r\nTEnv ::= Map[Name, Type]\r\nConfigItem ::= k(K) | tenv(TEnv) | gtenv(TEnv) | return(Type) | toType(·)\r\nConfig ::= done | JKK | JSet[ConfigItem]K\r\nK ::= . . . | restore(TEnv) | Type λList[Type] List[Name].K\r\nJpK = Jk(p) tenv(·) gtenv(·) return(?) toType(·)K\r\nh|k(·) toType(·)|i> = done\r\ni → int, b → bool\r\nL x\r\nρ[x]\r\n|iktenv(ρ)\r\n(t[])[int] → t\r\nread() → int\r\n(tl → t)(tl) → t\r\nint + int → int, int − int → int, int ∗ int → int, int / int → int, int % int → int, −int → int\r\nint <int → bool, int <= int → bool, int >int → bool, int >= int → bool, int == int → bool, int != int → bool\r\nbool and bool → bool, bool or bool → bool, not bool → bool\r\nLvar t x\r\ndecl\r\n|iktenv( ρ\r\nρ[t/x]\r\n)\r\nLvar t x[int]\r\ndecl\r\n|iktenv( ρ\r\nρ[t[]/x]\r\n)\r\ndecl; decl → decl\r\n{} → stmt\r\n{stmt} → stmt\r\nL {d; s}\r\nd; s y restore(ρ)\r\n|iktenv(ρ) (this and the two above are rules now, because they count as reduction steps)\r\ndecl; stmt → stmt\r\nLt y restore(ρ)\r\n·\r\n|iktenv(\r\nρ\r\n)\r\nwrite int → stmt\r\n(t = t) → stmt\r\n((t[])[int] = t) → stmt\r\nif bool then stmt else stmt → stmt\r\nif bool then stmt → stmt\r\nwhile bool do stmt → stmt\r\ncall t → stmt\r\nk(return t y\r\n·\r\n) return(t\r\n?\r\n)\r\nLfunction t f(tl xl) s\r\nfundecl\r\n|iktenv( ρ\r\nρ[(tl → t)/f]\r\n) h| ·\r\nt λtl xl.s\r\nMtoType\r\nfundecl fundecl → fundecl\r\ndecl; fundecl → pgm\r\nk(t\r\n·\r\n) tenv(ρ) gtenv(·\r\nρ\r\n) if t is pgm or fundecl\r\nk(·\r\ns\r\n) tenv( ρ\r\nρ\r\n0\r\n[xl ← tl]\r\n) gtenv(ρ\r\n0\r\n) return(t\r\n0\r\nt\r\n) Lt λtl xl.s\r\n·\r\n|itoType\r\n104\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/bfedb8dd-8d3d-4ccb-8ee6-35b5b609aed8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ceed191be179bdbafcbeb8209431d139e5e569753ff57c764d5d1fe8d23c24b6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 352
      },
      {
        "segments": [
          {
            "segment_id": "dcc4e8e5-6089-46be-b9cb-aa6cc0013f0c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "C Defining FUN in K\r\nThis section is concerned with the definition of FUN, a simple call-by-value functional language, and of\r\nextensions of FUN with different parameter-passing styles (call-by-name, call-by-need), as well as with the\r\ndefinitions of a polymorphic type checker and of a polymorphic type inferencer for FUN. Generally speaking,\r\nFUN is much simpler than most existing functional languages. For example, it has no user defined data-types,\r\nno modularization constructs such as functors, and no object-oriented or other paradigm features. It does\r\nallow, however, a series of interesting functional language features, such as: functions defined via currying\r\nas well as tuple arguments (however, tuples are not values, they can only be used in function definitions\r\nand function invocations); let and letrec bindings; lists together with basic operations on them; referencing\r\n(“ref e”), dereferencing of references (“∗ r”) and of variables (“& x”), and side effects through assignment\r\nto references (“r := e”). The following are valid FUN programs that can be executed in our semantics:\r\n-----\r\nP1:\r\n-----\r\nlet f x = x := (* x) + 1\r\nand x = 7\r\nin list(x, (f(& x) ; x), (f(& x) ; x))\r\n-----\r\nP2:\r\n-----\r\nletrec max l (x, y) = if (* x) != y then -1\r\nelse if null?(cdr l) then (car l)\r\nelse let x = max (cdr l) ((x := (* x) + 1 ; x), y + 1)\r\nin if (x <= car l) then (car l)\r\nelse x\r\nand map f l = if null? l then list()\r\nelse cons (f (car l)) (map f (cdr l))\r\nand factorial x = if x <= 0 then 1\r\nelse x * factorial(x - 1)\r\nin max (map factorial list(1, 2, 3, 4, 5, factorial 5)) (ref 1, 1)\r\nWhen executing these program with our Maude formalization of the K definition of FUN discussed below,\r\nwe got the following results in about 2 seconds:\r\n-----\r\nP1:\r\n-----\r\nlist(int(7),int(8),int(9))\r\n-----\r\nP2:\r\n-----\r\n668950291344912705758811805409037258675274633313802981029567135230163355724496298936687416527198498\r\n1308157637893214090552534408589408121859898481114389650005964960521256960000000000000000000000000000\r\n105\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/dcc4e8e5-6089-46be-b9cb-aa6cc0013f0c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3e8cf4ca79a5462a559ed59dfb5d22b2c549b4cb43856d68dd4add357e546986",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 344
      },
      {
        "segments": [
          {
            "segment_id": "24385aa7-1fbb-4b06-b5e4-66e8c16e82f2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "C.1 Untyped FUN\r\nK-Annotated Syntax of Untyped FUN\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables and functions\r\nExp ::= Int | Bool | Name\r\n| Exp + Exp [strict, extends +Int×Int→Int]\r\n| Exp − Exp [strict, extends −Int×Int→Int]\r\n| Exp ∗ Exp [strict, extends ∗Int×Int→Int]\r\n| Exp /Exp [strict, extends quotientInt×Int→Int]\r\n| Exp %Exp [strict, extends remainderInt×Int→Int]\r\n| −Exp [strict, extends −Int→Int]\r\n| Exp < Exp [strict, extends <Int×Int→Bool]\r\n| Exp <= Exp [strict, extends ≤Int×Int→Bool]\r\n| Exp > Exp [strict, extends >Int×Int→Bool]\r\n| Exp >= Exp [strict, extends ≥Int×Int→Bool]\r\n| Exp == Exp [strict, extends =Int×Int→Bool]\r\n| Exp != Exp [strict, extends 6=Int×Int→Bool]\r\n| Exp and Exp [strict, extends ∧Bool×Bool→Bool]\r\n| Exp or Exp [strict, extends ∨Bool×Bool→Bool]\r\n| not Exp [strict, extends ¬Bool→Bool]\r\n| fun ExpList -> Exp [fun e el -> e\r\n0 = fun e -> fun el -> e0\r\n]\r\n| Exp ExpList [strict]\r\n| let Binding in Exp\r\n| letrec Binding in Exp\r\n| if Exp then Exp else Exp [strict(1)]\r\n| ref Exp [strict]\r\n| & Name\r\n| ∗ Exp [strict]\r\n| Exp := Exp [strict]\r\n| list ExpList [strict]\r\n| car Exp [strict]\r\n| cdr Exp [strict]\r\n| null? Exp [strict]\r\n| cons Exp Exp [strict]\r\n| Exp ;Exp [strict]\r\nExpList ::= List()\r\n,\r\n[Exp]\r\nBinding ::= ExpList = ExpList [(e el = e\r\n0\r\n) = (e = fun el -> e\r\n0\r\n)]\r\n| List and [Binding] [(el = el1 and el0 = el0\r\n1\r\n) = (el, el0 = el1, el0\r\n1\r\n)]\r\n106\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/24385aa7-1fbb-4b06-b5e4-66e8c16e82f2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f474202dfa41aab66e9f6cf722d7c2301197770f85e357e3d4f782e137987076",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d22d7e80-9227-4f0a-a584-6e26288b34a9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of Untyped FUN\r\nVal ::= Int | Bool | unit | closure(Name, K,Env)\r\nKResult ::= Val\r\nEnv ::= Map[Name, Loc]\r\nStore ::= Map[Loc, Val]\r\nConfigItem ::= k(K) | env(Env) | store(Store) | nextLoc(Loc)\r\nConfig ::= Val | JKK | JSet[ConfigItem]K\r\nJeK = Jk(e) env(·) store(·) nextLoc(loc(0))K\r\nh|k(v)|i> = v\r\nL x\r\nσ[ρ[x]]\r\n|ikenv(ρ) store(σ)\r\nL let xl = el in e\r\nstrict(el) y bindTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\nL letrec xl = el in e\r\nbind(xl) y strict(el) y writeTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\nL fun xl -> e\r\nclosure(xl, e, ρ)\r\n|ikenv(ρ)\r\nL closure(xl, e, ρ) vl\r\nresults(vl) y bindTo(xl) y e y restore(ρ\r\n0\r\n)\r\n|ikenv(ρ\r\n0\r\nρ\r\n)\r\nLref v\r\nl\r\n|ikstore( σ\r\nσ[v/l]\r\n) nextLoc( l\r\nl +Int 1\r\n)\r\nL& x\r\nρ[x]\r\n|ikenv(ρ)\r\nL ∗ l\r\nσ[l]\r\n|ikstore(σ)\r\nLl := v\r\nunit\r\n|ikstore( σ\r\nσ[v/l]\r\n)\r\nif true then e1 else e2 → e1\r\nif false then e1 else e2 → e2\r\ncar list(v, vl) → v\r\ncdr list(v, vl) → list(vl)\r\nnull? list() → true\r\nnull? list(v, vl) → false\r\ncons v list(vl) → list(v, vl)\r\nunit; v → v\r\n107\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d22d7e80-9227-4f0a-a584-6e26288b34a9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ce5bd6523f5ef92f35af3ad3b35c19ef5e99fec63051bf3206790e855c766cc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 494
      },
      {
        "segments": [
          {
            "segment_id": "356f64be-bf5e-4a42-941b-732f576c3ae6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "C.2 Untyped FUN Extended with Call-By-Name and Call-By-Need\r\nK-Annotated Syntax of Untyped FUN Extended with Call-By-Name and Call-By-Need\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables and functions\r\nExp ::= Int | Bool | Name\r\n| Exp + Exp [strict, extends +Int×Int→Int]\r\n| Exp − Exp [strict, extends −Int×Int→Int]\r\n| Exp ∗ Exp [strict, extends ∗Int×Int→Int]\r\n| Exp /Exp [strict, extends quotientInt×Int→Int]\r\n| Exp %Exp [strict, extends remainderInt×Int→Int]\r\n| −Exp [strict, extends −Int→Int]\r\n| Exp < Exp [strict, extends <Int×Int→Bool]\r\n| Exp <= Exp [strict, extends ≤Int×Int→Bool]\r\n| Exp > Exp [strict, extends >Int×Int→Bool]\r\n| Exp >= Exp [strict, extends ≥Int×Int→Bool]\r\n| Exp == Exp [strict, extends =Int×Int→Bool]\r\n| Exp != Exp [strict, extends 6=Int×Int→Bool]\r\n| Exp and Exp [strict, extends ∧Bool×Bool→Bool]\r\n| Exp or Exp [strict, extends ∨Bool×Bool→Bool]\r\n| not Exp [strict, extends ¬Bool→Bool]\r\n| fun Params -> Exp [fun ps p -> e = fun ps -> fun p -> e]\r\n| Exp ExpList [strict(1)]\r\n| let Binding in Exp\r\n| letrec Binding in Exp\r\n| if Exp then Exp else Exp [strict(1)]\r\n| ref Exp [strict]\r\n| &Name\r\n| ∗Exp [strict]\r\n| Exp := Exp [strict]\r\n| list ExpList [strict]\r\n| car Exp [strict]\r\n| cdr Exp [strict]\r\n| null? Exp [strict]\r\n| cons Exp Exp [strict]\r\n| Exp ;Exp [strict]\r\nExpList ::= List()\r\n,\r\n[Exp]\r\nParams ::= Name{ParamPassStyle}\r\nParamPassStyle ::= val | name | need\r\nParams ::= List()\r\n,\r\n[Params]\r\nParamsSeq ::= ParamsSeq Params\r\nBinding ::= Params = ExpList [(ps p = e) = (ps = fun p -> e)]\r\n| List and [Binding] [(p = el and p\r\n0 = el0\r\n) = (p, p0 = el, el0)]\r\n108\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/356f64be-bf5e-4a42-941b-732f576c3ae6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=052b0cc6b5023ad775fe497faa8444897c89559d5620c73d5b247cc820427825",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "d6b0a3b4-83e5-4edb-b705-d2604aa1a4b2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 109,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of Untyped FUN Extended with Call-By-Name and Call-By-Need\r\nVal ::= Int | Bool | Loc | unit\r\n| closure(List[K], K,Env) | frozen(K,Env) | unfreeze(K, Env) | list(List[Val])\r\nKResult ::= Val\r\nKProper ::= ‡List[K]‡List[K]‡List[Name]‡List[K]‡\r\n| mkFrozenVal(K) | mkUnfreezeVal(K)\r\nKLabel ::= @let | @letrec | @closure\r\nEnv ::= Map[Name, Loc]\r\nStore ::= Map[Loc, Val]\r\nConfigItem ::= k(K) | env(Env) | store(Store) | nextLoc(Loc)\r\nConfig ::= Val | JKK | JSet[ConfigItem]K\r\nJeK = Jk(e) env(·) store(·) nextLoc(loc(0))K\r\nh|k(v)|i> = v\r\nfunctions & application\r\n\r\n\r\n\r\nL fun pl -> e\r\nclosure(pl, e, ρ)\r\n|ikenv(ρ)\r\nclosure(pl, e, ρ) el = ‡pl‡el‡·‡·‡ y @closure(e, restore(ρ))\r\nL ‡·‡·‡xl‡el‡ y @closure(e, k)\r\nstrict(el) y k y bindTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\nlet\r\n\r\n\r\n\r\nlet pl = el in e = ‡pl‡el‡·‡·‡ y @let(e)\r\nL ‡·‡·‡xl‡el‡ y @let(e)\r\nstrict(el) y bindTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\nletrec\r\n\r\n\r\n\r\nletrec pl = el in e = ‡pl‡el‡·‡·‡ y @letrec(e)\r\nL ‡·‡·‡xl‡el‡ y @letrec(e)\r\nbind(xl) y strict(el) y writeTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\ncall-by-value\r\n\r\n\r\n\r\n‡Lx{val}\r\n·\r\n|i???‡Le\r\n·\r\n|i???‡h| ·\r\nx\r\nM???‡h|·\r\ne\r\nM???‡\r\nL x\r\nσ[ρ[x]]\r\n|ikenv(ρ) store(σ) when σ[x] is not of the form frozen(e, ρ0) or unfreeze(e, ρ0)\r\ncall-by-name\r\n\r\n\r\n\r\n‡Lx{name}\r\n·\r\n|i???‡Le\r\n·\r\n|i???‡h| ·\r\nx\r\nM???‡h| ·\r\nmkFrozenVal(e)\r\nM???‡\r\nLmkFrozenVal(e)\r\nfrozen(e, ρ)\r\n|ikenv(ρ)\r\nL x\r\ne y restore(ρ)\r\n|ikenv( ρ\r\nρ\r\n0\r\n) store(σ) when σ[x] is frozen(e, ρ0\r\n)\r\ncall-by-need\r\n\r\n\r\n\r\n‡Lx{need}\r\n·\r\n|i???‡Le\r\n·\r\n|i???‡h| ·\r\nx\r\nM???‡h| ·\r\nmkUnfreezeVal(e)\r\nM???‡\r\nLmkUnfreezeVal(e)\r\nunfreeze(e, ρ)\r\n|ikenv(ρ)\r\nL x\r\ne y writeTo ρ[x] andKeep y restore(ρ)\r\n|ikenv( ρ\r\nρ\r\n0\r\n) store(σ) when σ[x] is unfreeze(e, ρ0)\r\nreferences\r\n\r\n\r\n\r\nLref v\r\nl\r\n|ikstore( σ\r\nσ[v/l]\r\n) nextLoc( l\r\nl +Int 1\r\n)\r\nL& x\r\nρ[x]\r\n|ikenv(ρ)\r\nL ∗ l\r\nσ[l]\r\n|ikstore(σ)\r\nLl := v\r\nunit\r\n|ikstore( σ\r\nσ[v/l]\r\n)\r\nif true then e1 else e2 → e1, if false then e1 else e2 → e2\r\ncar list(v, vl) → v, cdr list(v, vl) → list(vl), null? list() → true, null? list(v, vl) → false, cons v list(vl) → list(v, vl)\r\nunit; v → v\r\n109\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/d6b0a3b4-83e5-4edb-b705-d2604aa1a4b2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f4cc7f2df0c49526fd9183447bba546faa03cad6a2ace49f380d1b5ec045c5e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 375
      },
      {
        "segments": [
          {
            "segment_id": "259e4195-3923-4d12-8f79-78c74cdadf5e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 110,
            "page_width": 612,
            "page_height": 792,
            "content": "C.3 Polymorphic FUN with Type Declarations\r\nK-Annotated Syntax of Polymorphic FUN with Type Declarations\r\nInt ::= . . . all integer numbers\r\nBool ::= true | false\r\nName ::= all identifiers; to be used as names of variables, functions, and types\r\nType ::= int | bool | unit | Name | List()[Type] → Type | ref Type | list Type\r\nExp ::= Int | Bool | Name\r\n| Exp + Exp [strict]\r\n| Exp − Exp [strict]\r\n| Exp ∗ Exp [strict]\r\n| Exp /Exp [strict]\r\n| Exp %Exp [strict]\r\n| −Exp [strict]\r\n| Exp < Exp [strict]\r\n| Exp <= Exp [strict]\r\n| Exp > Exp [strict]\r\n| Exp >= Exp [strict]\r\n| Exp == Exp [strict]\r\n| Exp != Exp [strict]\r\n| Exp and Exp [strict]\r\n| Exp or Exp [strict]\r\n| not Exp [strict]\r\n| fun Params -> Exp [fun ps p -> e = fun ps -> fun p -> e]\r\n| Exp ExpList [strict]\r\n| let Binding in Exp\r\n| letrec Binding in Exp\r\n| if Exp then Exp else Exp [strict]\r\n| ref Exp [strict]\r\n| ∗Exp [strict]\r\n| Exp := Exp [strict]\r\n| &Name [strict]\r\n| list ExpList [strict]\r\n| list() : list(Type)\r\n| car Exp [strict]\r\n| cdr Exp [strict]\r\n| null? Exp [strict]\r\n| cons Exp Exp [strict]\r\n| Exp ;Exp [strict]\r\nExpList ::= List()\r\n,\r\n[Exp]\r\nParams ::= List()[Name] : List()[T ] | Params,Params [(xl : tl),(xl0: tl0) = (xl, xl0) : (tl, tl0)]\r\nParamsSeq ::= Params | ParamsSeq Params\r\nBinding ::= Params = ExpList [(ps p = e) = (ps = fun p -> e)]\r\n| List and [Binding] [(p = el and p\r\n0 = el0\r\n) = (p, p0 = el, el0)]\r\n110\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/259e4195-3923-4d12-8f79-78c74cdadf5e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cab91c5ea5bbbfce0726bb06669a193a17a65ce33170e7603751ba2260d3a122",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 301
      },
      {
        "segments": [
          {
            "segment_id": "68357739-b2dd-43a1-ba32-27cac0106236",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 111,
            "page_width": 612,
            "page_height": 792,
            "content": "K Configuration and Semantics of Polymorphic FUN with Type Declarations\r\nKResult ::= Type\r\nTEnv ::= Map[Name, Type]\r\nConfigItem ::= k(K) | tenv(TEnv)\r\nConfig ::= Type | JKK | JSet[ConfigItem]K\r\nJeK = Jk(e) tenv(·)K\r\nh|k(t)|i> = t\r\nlookup \u001a\r\nL x\r\nρ[x]\r\n|iktenv(ρ)\r\nfun & app\r\n\r\n\r\n\r\nL fun xl : tl -> e\r\n(tl → e) y restore(ρ)\r\n|ikenv( ρ\r\nρ[tl/xl]\r\n)\r\nK ::= · · · | List[Type] → K [strict(2)]\r\n(tl → t)tl0 = applySubst(getSubst(tl, tl0), t)\r\nlet \u001a\r\nL let xl : tl = el in e\r\nstrict(el) y checkEqualTo tl andKeep y bindTo(xl) y e y restore(ρ)\r\n|ikenv(ρ)\r\nletrec \u001a\r\nL letrec xl : tl = el in e\r\nstrict(el) y checkEqualTo tl andDiscard y e y restore(ρ)\r\n|ikenv( ρ\r\nρ[tl/xl]\r\n)\r\nord ops\r\n\r\n\r\n\r\nint + int → int, int − int → int, int ∗ int → int,\r\nint / int → int, int % int → int, −int → int,\r\nint <int → bool, int <= int → bool, int >int → bool,\r\nint >= int → bool, int == int → bool, int != int → bool,\r\nbool and bool → bool, bool or bool → bool, not bool → bool\r\nreferences\r\n\r\n\r\n\r\n& t → ref t\r\n∗ ref t → t\r\nref t := t → unit\r\nconditional \b\r\nif true then t else t → t\r\nlists\r\n\r\n\r\n\r\nlist() : (list(t)) → list(t)\r\nlist(t, t, tl) → list(t, tl)\r\ncar list(t) → t\r\ncdr list(t) → list(t)\r\nnull? list(t) → bool\r\ncons t list(t) → list(t)\r\nseq comp \b\r\nunit;t → t\r\n111\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/68357739-b2dd-43a1-ba32-27cac0106236.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dda4be0d05a1aff2a4a37e3afbb02f734ba11f8f99ddfa3b06c19887c4b0d066",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 287
      },
      {
        "segments": [
          {
            "segment_id": "00bd1342-566a-464c-bee5-0d97e8d184e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "D Defining SKOOL in K\r\nSKOOL is a simple object-oriented language. It is defined as an extension of SILF with classes and objects.\r\nSKOOL is single-inheritance: except for the topmost builtin class object, each user-definable class in SKOOL\r\nextends precisely one other existing class; if an extends clause is not specified for a class, then it is assumed\r\nthat that class extends object. Classes contain fields and methods. Objects can be created as instances\r\nof classes and messages can be send to objects under the form of method calls. Fields of an object are\r\nnot visible directly from the outside of the object, but only by means of method calls. A self construct\r\ncan be used as an object; it refers to the current object and it is particularly useful to achieve recursion.\r\nMethod invocations can be preceded by the keyword super, which redirects the call to the superclass; this\r\nis particularly useful when methods are overridden, to have access to methods in the superclass in case they\r\nwere overridden by the current class. Object can be inspected for their type with an “instanceOf” language\r\nconstruct. SKOOL’s methods have static scoping and dynamic dispatch. A SKOOL program consists of a\r\nset of classes. One class must be called main and must have a method called main. A program execution\r\nstarts by creating an instance of the class main and then invoking the method main on that instance.\r\nAn untyped version of SKOOL is presented in Appendix D.1. Like in the case of untyped SILF, that\r\nmeans that variables and functions are are not declared any types. Nevertheless, the execution of programs\r\ngets stuck if certain incorrect operations are attempted, such as calling an inexistent method on an object,\r\nor adding an integer with a Boolean, etc. Appendix D.2 defines a dynamically typed variant of SKOOL,\r\nand Appendix D.3 discusses a static type checker for SKOOL taking into account subtype polymorphism.\r\nHere is a SKOOL program that can be executed by our semantics (both columns); the Maude output after\r\nexecuting this program is 2 2 3 11 3 3 11 111 111:\r\nclass a {\r\nvar i ; var j ;\r\nmethod a() {\r\ni = 1 ;\r\nj = i + 1 ;\r\nreturn j\r\n}\r\nmethod f() { return self . a() }\r\nmethod g() { return self . f() }\r\nmethod h() { return (i + j) }\r\n}\r\nclass b extends a {\r\nvar j ; var k ;\r\nmethod a() {\r\nreturn self . b()\r\n}\r\nmethod b() {\r\ncall super a() ;\r\nj = 10 ;\r\nk = j + 1 ;\r\nreturn k\r\n}\r\nmethod g() { return super h() }\r\nmethod h() { return self . g() }\r\n}\r\nclass c extends b {\r\nmethod a() { return super a() }\r\nmethod b() { return super b() }\r\nmethod c() {\r\ni = 100 ;\r\nj = i + 1 ;\r\nk = j + 1 ;\r\nreturn k\r\n}\r\nmethod g() { return (i + k * j) }\r\n}\r\nclass main {\r\nmethod p(o) {\r\nwrite(o . f()) ;\r\nwrite(o . g()) ;\r\nwrite(o . h()) ;\r\nreturn 0\r\n}\r\nmethod main() {\r\ncall self . p(new a()) ;\r\ncall self . p(new b()) ;\r\ncall self . p(new c()) ;\r\nreturn 0\r\n}\r\n}\r\nD.1 Untyped SKOOL\r\nAs mentioned above, we define SKOOL as an extension of SILF. We start by importing the K annotated\r\nsyntax of untyped SILF as is, except for the syntax of function declaration and invocation constructs; we\r\nneed to exclude the latter because we want functions to become methods and unrestricted function calls to\r\nbecome method invocation messages sent to individual objects. In some sense, a SKOOL program can be\r\n112\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/00bd1342-566a-464c-bee5-0d97e8d184e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7688e32f3189998b831058b0deb0327453a590e185e9929aac590aba2f084a06",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 641
      },
      {
        "segments": [
          {
            "segment_id": "00bd1342-566a-464c-bee5-0d97e8d184e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "D Defining SKOOL in K\r\nSKOOL is a simple object-oriented language. It is defined as an extension of SILF with classes and objects.\r\nSKOOL is single-inheritance: except for the topmost builtin class object, each user-definable class in SKOOL\r\nextends precisely one other existing class; if an extends clause is not specified for a class, then it is assumed\r\nthat that class extends object. Classes contain fields and methods. Objects can be created as instances\r\nof classes and messages can be send to objects under the form of method calls. Fields of an object are\r\nnot visible directly from the outside of the object, but only by means of method calls. A self construct\r\ncan be used as an object; it refers to the current object and it is particularly useful to achieve recursion.\r\nMethod invocations can be preceded by the keyword super, which redirects the call to the superclass; this\r\nis particularly useful when methods are overridden, to have access to methods in the superclass in case they\r\nwere overridden by the current class. Object can be inspected for their type with an “instanceOf” language\r\nconstruct. SKOOL’s methods have static scoping and dynamic dispatch. A SKOOL program consists of a\r\nset of classes. One class must be called main and must have a method called main. A program execution\r\nstarts by creating an instance of the class main and then invoking the method main on that instance.\r\nAn untyped version of SKOOL is presented in Appendix D.1. Like in the case of untyped SILF, that\r\nmeans that variables and functions are are not declared any types. Nevertheless, the execution of programs\r\ngets stuck if certain incorrect operations are attempted, such as calling an inexistent method on an object,\r\nor adding an integer with a Boolean, etc. Appendix D.2 defines a dynamically typed variant of SKOOL,\r\nand Appendix D.3 discusses a static type checker for SKOOL taking into account subtype polymorphism.\r\nHere is a SKOOL program that can be executed by our semantics (both columns); the Maude output after\r\nexecuting this program is 2 2 3 11 3 3 11 111 111:\r\nclass a {\r\nvar i ; var j ;\r\nmethod a() {\r\ni = 1 ;\r\nj = i + 1 ;\r\nreturn j\r\n}\r\nmethod f() { return self . a() }\r\nmethod g() { return self . f() }\r\nmethod h() { return (i + j) }\r\n}\r\nclass b extends a {\r\nvar j ; var k ;\r\nmethod a() {\r\nreturn self . b()\r\n}\r\nmethod b() {\r\ncall super a() ;\r\nj = 10 ;\r\nk = j + 1 ;\r\nreturn k\r\n}\r\nmethod g() { return super h() }\r\nmethod h() { return self . g() }\r\n}\r\nclass c extends b {\r\nmethod a() { return super a() }\r\nmethod b() { return super b() }\r\nmethod c() {\r\ni = 100 ;\r\nj = i + 1 ;\r\nk = j + 1 ;\r\nreturn k\r\n}\r\nmethod g() { return (i + k * j) }\r\n}\r\nclass main {\r\nmethod p(o) {\r\nwrite(o . f()) ;\r\nwrite(o . g()) ;\r\nwrite(o . h()) ;\r\nreturn 0\r\n}\r\nmethod main() {\r\ncall self . p(new a()) ;\r\ncall self . p(new b()) ;\r\ncall self . p(new c()) ;\r\nreturn 0\r\n}\r\n}\r\nD.1 Untyped SKOOL\r\nAs mentioned above, we define SKOOL as an extension of SILF. We start by importing the K annotated\r\nsyntax of untyped SILF as is, except for the syntax of function declaration and invocation constructs; we\r\nneed to exclude the latter because we want functions to become methods and unrestricted function calls to\r\nbecome method invocation messages sent to individual objects. In some sense, a SKOOL program can be\r\n112\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/00bd1342-566a-464c-bee5-0d97e8d184e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7688e32f3189998b831058b0deb0327453a590e185e9929aac590aba2f084a06",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 641
      },
      {
        "segments": [
          {
            "segment_id": "969f0eb4-0574-4bb8-94be-6ffc3845a3ea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "regarded as a set of SILF programs, one per class, which can “communicate” with each other by means of\r\nmethod invocation messages sent to objects. We then add the following SKOOL-specific syntax:\r\nK-Annotated Syntax of Untyped SKOOL\r\n(include all syntax from SILF, except constructs for function declaration and invocation)\r\nExp ::= ...\r\n| new Name(List[Exp]) [strict(2)]\r\n| self\r\n| Exp.Name(List[Exp]) [strict(1, 3)]\r\n| super Name(List[Exp]) [strict(2)]\r\n| Exp instanceOf Name [strict(1)]\r\nMethDecl ::= method Name(List[Name]) Stmt\r\n| MethDecl MethDecl [md1 md2 = md1 y md2]\r\nClsDecl ::= class Name extends Name {VarDecl ; MethDecl}\r\n| class Name extends Name {MethDecl} [class c extends c\r\n0 {md} = class c extends c0 {· ; md}]\r\n| class Name {VarDecl ; MethDecl} [class c {vd; md} = class c extends object {vd; md}]\r\n| class Name {MethDecl} [class c {md} = class c extends object {md}]\r\n| ClsDecl ClsDecl [cd1 cd2 = cd1 y cd2]\r\nTo define the K semantics of SKOOL, we also proceed by extending SILF’s. However, in addition to\r\nthe rules corresponding to the syntactic constructs for function declaration and invocation that have been\r\nreplaced by method declaration and invocation, we also need to change a few other rules in SILF:\r\n• The rules for variable (indexed or not) lookup and update need to change, because of the name\r\nresolution policy in object-oriented languages: if a name is not in the current environment (case in\r\nwhich the program would get stuck in SILF), then one should search for that name’s location in the\r\ncurrent class’ layer in the current object; if not there, then one should move with the search up in the\r\nclass hierarchy of that object, and so on until either the name is found or otherwise the topmost layer,\r\nobject, is reached (in the latter case, the execution would get stuck).\r\n• The rule for return also needs to change, because the structure of the stack needs to change. Indeed, the\r\nnew stack will also push/pop the current class (in addition to the current environment and computation\r\nalready considered in SILF).\r\nNote that an object is a list of layers, each layer being an environment tagged with a class name. There\r\nis layer for each superclass of that object, as well as for its class; in other words, there is a layer for each class\r\nthat the object can be regarded as an instance of. The semantics of object creation, as well as that of object\r\nand super method invocation, are all defined in terms of an auxiliary invoke computation item. When the\r\nfirst item in the computation, invoke(m, vl) starts searching for the method m with the current class. As\r\nit traverses the class hierarchy, the current class is also changed. This is very important, because we want\r\nstatic scoping in our language; therefore, once the method m is found and invoked, any variable should be\r\nlookup first in the current environment, and then in the class hierarchy of the current object starting with\r\nthe class where the method was found! Note that that is indeed what our new definition for variable lookup\r\ndoes (using the auxiliary and easy to define operation getLoc).\r\nThe new c(vl) construct first creates an object instance of class c and then calls the constructor method\r\nof c with arguments vl; constructor methods have the same name as their corresponding classes and are\r\ntypically intended to initialize the values of the fields. The object creation process allocates to values in the\r\nstore; it only creates an object layered environment, mapping each field in each layer to a fresh location.\r\nNote that the needed computation when returning from the construct invocation is stored in the stacked\r\ncomputation in anticipation: the return value of the construct is discarded (constructs are called for their side\r\neffects), then the current object is placed in the computation, and then the current object and computation\r\nare restored. As in SILF, methods are expected to return explicitly (using return statements). Objects and\r\n113\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/969f0eb4-0574-4bb8-94be-6ffc3845a3ea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=34f1c33dd75e5974b5587c6d42c2461ba4a86dd283c3cc240c03ab8299b784a8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 681
      },
      {
        "segments": [
          {
            "segment_id": "969f0eb4-0574-4bb8-94be-6ffc3845a3ea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "regarded as a set of SILF programs, one per class, which can “communicate” with each other by means of\r\nmethod invocation messages sent to objects. We then add the following SKOOL-specific syntax:\r\nK-Annotated Syntax of Untyped SKOOL\r\n(include all syntax from SILF, except constructs for function declaration and invocation)\r\nExp ::= ...\r\n| new Name(List[Exp]) [strict(2)]\r\n| self\r\n| Exp.Name(List[Exp]) [strict(1, 3)]\r\n| super Name(List[Exp]) [strict(2)]\r\n| Exp instanceOf Name [strict(1)]\r\nMethDecl ::= method Name(List[Name]) Stmt\r\n| MethDecl MethDecl [md1 md2 = md1 y md2]\r\nClsDecl ::= class Name extends Name {VarDecl ; MethDecl}\r\n| class Name extends Name {MethDecl} [class c extends c\r\n0 {md} = class c extends c0 {· ; md}]\r\n| class Name {VarDecl ; MethDecl} [class c {vd; md} = class c extends object {vd; md}]\r\n| class Name {MethDecl} [class c {md} = class c extends object {md}]\r\n| ClsDecl ClsDecl [cd1 cd2 = cd1 y cd2]\r\nTo define the K semantics of SKOOL, we also proceed by extending SILF’s. However, in addition to\r\nthe rules corresponding to the syntactic constructs for function declaration and invocation that have been\r\nreplaced by method declaration and invocation, we also need to change a few other rules in SILF:\r\n• The rules for variable (indexed or not) lookup and update need to change, because of the name\r\nresolution policy in object-oriented languages: if a name is not in the current environment (case in\r\nwhich the program would get stuck in SILF), then one should search for that name’s location in the\r\ncurrent class’ layer in the current object; if not there, then one should move with the search up in the\r\nclass hierarchy of that object, and so on until either the name is found or otherwise the topmost layer,\r\nobject, is reached (in the latter case, the execution would get stuck).\r\n• The rule for return also needs to change, because the structure of the stack needs to change. Indeed, the\r\nnew stack will also push/pop the current class (in addition to the current environment and computation\r\nalready considered in SILF).\r\nNote that an object is a list of layers, each layer being an environment tagged with a class name. There\r\nis layer for each superclass of that object, as well as for its class; in other words, there is a layer for each class\r\nthat the object can be regarded as an instance of. The semantics of object creation, as well as that of object\r\nand super method invocation, are all defined in terms of an auxiliary invoke computation item. When the\r\nfirst item in the computation, invoke(m, vl) starts searching for the method m with the current class. As\r\nit traverses the class hierarchy, the current class is also changed. This is very important, because we want\r\nstatic scoping in our language; therefore, once the method m is found and invoked, any variable should be\r\nlookup first in the current environment, and then in the class hierarchy of the current object starting with\r\nthe class where the method was found! Note that that is indeed what our new definition for variable lookup\r\ndoes (using the auxiliary and easy to define operation getLoc).\r\nThe new c(vl) construct first creates an object instance of class c and then calls the constructor method\r\nof c with arguments vl; constructor methods have the same name as their corresponding classes and are\r\ntypically intended to initialize the values of the fields. The object creation process allocates to values in the\r\nstore; it only creates an object layered environment, mapping each field in each layer to a fresh location.\r\nNote that the needed computation when returning from the construct invocation is stored in the stacked\r\ncomputation in anticipation: the return value of the construct is discarded (constructs are called for their side\r\neffects), then the current object is placed in the computation, and then the current object and computation\r\nare restored. As in SILF, methods are expected to return explicitly (using return statements). Objects and\r\n113\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/969f0eb4-0574-4bb8-94be-6ffc3845a3ea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=34f1c33dd75e5974b5587c6d42c2461ba4a86dd283c3cc240c03ab8299b784a8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 681
      },
      {
        "segments": [
          {
            "segment_id": "94c6e114-2d81-4b0b-b9c2-bde511511564",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 114,
            "page_width": 612,
            "page_height": 792,
            "content": "super method invocations are easier to define than new. We prefer not to stack the current object because\r\nsuper does not change the current object, so it does not need to stack it.\r\nK Configuration and Semantics of Untyped SKOOL\r\nVal ::= ... | Object\r\nObject ::= List[Name : Env]\r\nStack ::= List[Name × Env × K]\r\nConfigItem ::= k(K) | stack(Stack) | env(Env) | in(List[Int]) | out(List[Int]) | store(Store) | nextLoc(Loc)\r\n| obj(Object) | class(Name) | pgm(K)\r\nConfig ::= List[Int] | JK, List[Int]K | JSet[ConfigItem]K\r\n| JKK [JkK = Jk, ·K]\r\nKLabel ::= ... | create | addOEnvLayer | invoke\r\nKConstant ::= ... | restore(Object) [Lv y restore(o)\r\n·\r\n|ikobj(\r\no\r\n)]\r\nJcls, ilK = Jk(new main()) stack(·) env(·) obj(·) class(main) pgm(cls) in(il) out(·) store(·) nextLoc(loc(0))K\r\nh|k(o) out(il)|i> = il\r\nLself\r\no\r\n|ikobj(o)\r\nh|c : |i???instanceOf c = true\r\no instanceOf c = false, otherwise (i.e., when o has no layer labeled c)\r\nk( new c(vl) y k\r\ncreate(c) y invoke(c, vl)\r\n) env(ρ\r\n·\r\n) obj(o\r\n·\r\n) class(c\r\n0\r\nc\r\n) L ·\r\n(c\r\n0\r\n, ρ, discard y self y restore(o) y k)\r\n|istack\r\nk((c : η, ω).m(vl) y k\r\ninvoke(m, vl)\r\n) env(ρ\r\n·\r\n) obj( o\r\n(c : η, ω)\r\n) class(c\r\n0\r\nc\r\n) L ·\r\n(c\r\n0\r\n, ρ, restore(o) y k)\r\n|istack\r\nk(super m(vl) y k\r\ninvoke(m, vl)\r\n) env(ρ\r\n·\r\n) class( c\r\nc\r\n0\r\n) L ·\r\n(c, ρ, k)\r\n|i\r\nstack pgmh|class c extends c\r\n0 { ; }|i???\r\nL create(c)\r\nvd y addOEnvLayer y create(c\r\n0\r\n)\r\n|ikpgmh|class c extends c\r\n0 {vd; md}|i???\r\ncreate(object) = ·\r\nk( invoke(m, vl)\r\nbind xl to vl y s\r\n) class(c) pgmh|class c extends { ;h|method m(xl) s|i???}|i???\r\nLinvoke(m, vl)|ikclass( c\r\nc\r\n0\r\n) pgmh|class c extends c\r\n0 { ; }|i???\r\n, otherwise (i.e., when c has no method m)\r\nk(return(v) y\r\nv y k\r\n) class(\r\nc\r\n) env(\r\nρ\r\n) L(c, ρ, k)\r\n·\r\n|istack\r\nL x\r\nσ[getLoc(x,( : ρ, c : η, ω0))]\r\n|ikenv(ρ) class(c) obj(ω, c : η, ω0) store(σ)\r\nL x[n]\r\nσ[getLoc(x,( : ρ, c : η, ω0)) +Loc n]\r\n|ikenv(ρ) class(c) obj(ω, c : η, ω0) store(σ)\r\nLx = v\r\n·\r\n|ikenv(ρ) class(c) obj(ω, c : η, ω0) store( σ\r\nσ[v/getLoc(x,(env : ρ, c : η, ω0))]\r\n)\r\nLx[n] = v\r\n·\r\n|ikenv(ρ) class(c) obj(ω, c : η, ω0) store( σ\r\nσ[v/getLoc(x,(env : ρ, c : η, ω0)) +Loc n]\r\n)\r\ngetLoc(x,( : η, ω)) = η[x] when η[x] is defined\r\ngetLoc(x,( : η, ω)) = getLoc(x, ω) when η[x] is not defined\r\n114\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/94c6e114-2d81-4b0b-b9c2-bde511511564.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=33008b0430a2840c9135017723597948fc65c890f88db09262631b9df46d5a12",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e656328a-5bb8-432e-b18f-bb4c0b5386ee",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 115,
            "page_width": 612,
            "page_height": 792,
            "content": "D.2 Type Checking SKOOL Dynamically\r\nD.3 Type Checking SKOOL Statically\r\n115\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/e656328a-5bb8-432e-b18f-bb4c0b5386ee.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a974cc604bdfee44b1cc423a1f92472aa99b805a93c25e7b57014ce90013d924",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 472
      },
      {
        "segments": [
          {
            "segment_id": "cd113a0c-9d3d-4aff-a178-4c8ec0a8d4ef",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "E K for the Maude User\r\nIn this section we discuss two approaches that one can use to incorporate K language definitions in Maude.\r\nThe first approach makes plain use of Maude and should be easy to translate and use in the context of any\r\nother rewrite engine. Also, the first approach is slightly easier to understand than the second one. The\r\nsecond approach makes use of Maude’s special reflective capabilities using its provided meta-level; at our\r\nknowledge Maude is the only rewrite engine providing such capabilities. In spite of the apparently heavier\r\nsyntax notation that it involves and its slightly lower performance (when executed) in Maude, the second\r\napproach has a series of advantages over the first one, explained in Appendix ??, which currently make it our\r\npreferred approach. Nevertheless, if the language that one wants to define does not include (rather complex)\r\nfeatures that involve code generation or reflection, then the first approach is just as good. In fact, the only\r\nthing one looses when one uses the first approach for such complex language features is modularity: one needs\r\nto change its definition when moving the feature from one language to another, because the syntax to be\r\nused in the generated code of the language changes. This non-trivial sort of modularity can be achieved very\r\nelegantly in K, thanks to its uniform representation of computations and because of its deliberate decision\r\nto disobey the syntax. Both approaches are relatively straightforward and mechanical.\r\nWe discuss the two approaches separately, using for concreteness’ sake the simple imperative language\r\nin Figure ??. We have developed, for each of the approaches, a little “library”, or “prelude”, of K-related\r\ndefinitions that turned out to be useful in our experiments. These libraries include definitions for lists, sets,\r\nmappings, locations, environments and stores, etc. Before starting a new language definition, one should\r\ninclude the specific prelude file. Both our current prelude files, which may change in the future, are discussed\r\nin Appendix ??; however, one needs not understand all the details of how they are defined in order to use\r\nthem. All one needs to know is what one can use from them. For example, they both provide a sort K,\r\ntogether with sub-sorts KResult and KProper; the former corresponds to computations that are finished and\r\ntherefore contain no further computational tasks (such as values, or types, or results of analysis, etc.), while\r\nthe latter corresponds to proper (and well-formed!) computations that still contain computational tasks to\r\nbe processed. In both approaches, proper computations can be further “heated”, while results are used for\r\ncooling and for matching purposes in order to apply the actual, irreversible rewrite rules.\r\nE.1 Using Plain Maude\r\nStep 1 Load the provided prelude file for K definitions using plain Maude, called “k-plain-prelude.maude”:\r\nin k-plain-prelude\r\nStep 2 Define the syntax of the desired programming language as an algebraic signature, making sure that\r\nyou include the module K-PLAIN. Here is, for example, the syntax of our simple language:\r\nfmod IMP-SYNTAX is including INT + BOOL + NAME + K-PLAIN .\r\nsorts #Int #Bool #Name .\r\nop #int : Int -> #Int .\r\nop #bool : Bool -> #Bool .\r\nop #name : Name -> #Name .\r\nsubsorts #Int #Bool < K .\r\nsubsort #Name < KProper .\r\nop _+_ : K K -> KProper [prec 33] .\r\nop _<=_ : K K -> KProper [prec 37] .\r\nop _and_ : K K -> KProper [prec 55] .\r\nop not_ : K -> KProper [prec 53] .\r\nop skip : -> KProper .\r\nop _:=_ : K K -> KProper .\r\nop _;_ : K K -> KProper [prec 100 gather(e E)] .\r\nop if___ : K K K -> KProper .\r\nop while__ : K K -> KProper .\r\nop halt_ : K -> KProper .\r\n--- kept only one ‘‘_;_’’, because the two have the same computational meaning\r\nendfm\r\n116\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cd113a0c-9d3d-4aff-a178-4c8ec0a8d4ef.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=55c16d6053619da6765dfe89a4335e05b5b1c35354d95b41e1c63e52732508e7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 663
      },
      {
        "segments": [
          {
            "segment_id": "cd113a0c-9d3d-4aff-a178-4c8ec0a8d4ef",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "E K for the Maude User\r\nIn this section we discuss two approaches that one can use to incorporate K language definitions in Maude.\r\nThe first approach makes plain use of Maude and should be easy to translate and use in the context of any\r\nother rewrite engine. Also, the first approach is slightly easier to understand than the second one. The\r\nsecond approach makes use of Maude’s special reflective capabilities using its provided meta-level; at our\r\nknowledge Maude is the only rewrite engine providing such capabilities. In spite of the apparently heavier\r\nsyntax notation that it involves and its slightly lower performance (when executed) in Maude, the second\r\napproach has a series of advantages over the first one, explained in Appendix ??, which currently make it our\r\npreferred approach. Nevertheless, if the language that one wants to define does not include (rather complex)\r\nfeatures that involve code generation or reflection, then the first approach is just as good. In fact, the only\r\nthing one looses when one uses the first approach for such complex language features is modularity: one needs\r\nto change its definition when moving the feature from one language to another, because the syntax to be\r\nused in the generated code of the language changes. This non-trivial sort of modularity can be achieved very\r\nelegantly in K, thanks to its uniform representation of computations and because of its deliberate decision\r\nto disobey the syntax. Both approaches are relatively straightforward and mechanical.\r\nWe discuss the two approaches separately, using for concreteness’ sake the simple imperative language\r\nin Figure ??. We have developed, for each of the approaches, a little “library”, or “prelude”, of K-related\r\ndefinitions that turned out to be useful in our experiments. These libraries include definitions for lists, sets,\r\nmappings, locations, environments and stores, etc. Before starting a new language definition, one should\r\ninclude the specific prelude file. Both our current prelude files, which may change in the future, are discussed\r\nin Appendix ??; however, one needs not understand all the details of how they are defined in order to use\r\nthem. All one needs to know is what one can use from them. For example, they both provide a sort K,\r\ntogether with sub-sorts KResult and KProper; the former corresponds to computations that are finished and\r\ntherefore contain no further computational tasks (such as values, or types, or results of analysis, etc.), while\r\nthe latter corresponds to proper (and well-formed!) computations that still contain computational tasks to\r\nbe processed. In both approaches, proper computations can be further “heated”, while results are used for\r\ncooling and for matching purposes in order to apply the actual, irreversible rewrite rules.\r\nE.1 Using Plain Maude\r\nStep 1 Load the provided prelude file for K definitions using plain Maude, called “k-plain-prelude.maude”:\r\nin k-plain-prelude\r\nStep 2 Define the syntax of the desired programming language as an algebraic signature, making sure that\r\nyou include the module K-PLAIN. Here is, for example, the syntax of our simple language:\r\nfmod IMP-SYNTAX is including INT + BOOL + NAME + K-PLAIN .\r\nsorts #Int #Bool #Name .\r\nop #int : Int -> #Int .\r\nop #bool : Bool -> #Bool .\r\nop #name : Name -> #Name .\r\nsubsorts #Int #Bool < K .\r\nsubsort #Name < KProper .\r\nop _+_ : K K -> KProper [prec 33] .\r\nop _<=_ : K K -> KProper [prec 37] .\r\nop _and_ : K K -> KProper [prec 55] .\r\nop not_ : K -> KProper [prec 53] .\r\nop skip : -> KProper .\r\nop _:=_ : K K -> KProper .\r\nop _;_ : K K -> KProper [prec 100 gather(e E)] .\r\nop if___ : K K K -> KProper .\r\nop while__ : K K -> KProper .\r\nop halt_ : K -> KProper .\r\n--- kept only one ‘‘_;_’’, because the two have the same computational meaning\r\nendfm\r\n116\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/cd113a0c-9d3d-4aff-a178-4c8ec0a8d4ef.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=55c16d6053619da6765dfe89a4335e05b5b1c35354d95b41e1c63e52732508e7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 663
      },
      {
        "segments": [
          {
            "segment_id": "67763542-e016-4c9a-a274-3e522c70dcd9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "One should be aware of several requirements and guidelines here:\r\n• Most importantly, one should use only one language syntactic category, K. The sort K is already\r\nprovided in “k-plain-prelude.maude”, so one does not need to redeclare it. In other words, for\r\nour language in Figure ??, we collapse AExp, BExp, Stmt and Pgm into only one sort K, which will be\r\nthe only one visible from here on. As already mentioned, the sort K comes with an important sub\u0002sort, KProper, which, intuitively, stays for those computations that need to be further processed\r\nto become results. It is important to declare all the result sorts of language constructs which\r\nare not already values as KProper. No computation constructs need to be declared as constructs\r\nfor KResult when defining the language syntax. The sort collapsing process described above\r\nmay certainly appear to be very inconvenient because one can now write programs which are not\r\nwell formed, such as “3 + true”. Nevertheless, at this moment one should think of the syntax of\r\nthe language as a syntax for its abstract syntax tree (AST). In other words, its syntax at this\r\nstage is nothing but a list of AST node labels. When defining real languages for research or\r\nprototyping purposes, one may want to implement an external parser, using the state of the art\r\nparsing technology, which takes as input a program following the desired user-friendly syntax and\r\ngenerates as output an AST following the simplified syntax that we define in Maude. As seen in\r\nSection ??, one can also define type-checkers using the same K technique, in which case one can\r\nreject programs which are regarded as inappropriate (for typing or other safety reasons).\r\n• A good practice is to wrap the built-in sorts imported in the syntax of the language, as well as\r\nthose that one may use as an intrinsic part of the semantics later on. For example, we import\r\nboth integers and booleans in our language. Since we collapsed the different language syntactic\r\ncategories into just K, then, without an appropriate separation, the various imported sorts would\r\nalso collapse, which may lead to many Maude warnings and errors. For example, one cannot\r\neven put together integers and booleans under a common sort in Maude, because it just happens\r\nthat the two modules have operators sharing the same name and number of arguments. Maude\r\nrightfully complains, because one cannot always know from context which operator one refers to.\r\nOur convention is to use a wrapper name “#sort” for each sort that one wants “protected” from\r\nhere on. We protect three such sorts in our language syntax: Int, Bool, and Name. Names are\r\nalso protected in almost all our language definitions, because we are going to manipulate them as\r\npart of the semantics (save in environments, states, etc.). For clarity, though not strictly needed,\r\none may define sub-sorts of K corresponding to the imported sorts, such as #Int, #Bool, etc.\r\n• Since there is only one syntactic category, one may have to either remove or redeclare some\r\noriginal language constructs. For example, in our original syntax we had two semicolon constructs,\r\nStmt; Stmt and Stmt; AExp, one for statements and the other for programs. Fortunately, these\r\ntwo constructs have the same semantics as computations: process the first computation and then\r\nthe second. Therefore, we only need to add one operation “_;_ : K K -> KProper”. If the two\r\nsemicolon constructs had different semantics as computations, then one would have had to define\r\nthem with different names as computation constructs.\r\nNote that we also added precedence and gathering attributes to some of the language/computation\r\nconstructs. Those attributes are used by Maude’s internal parser and are given exclusively for sim\u0002plifying the reading of programs by not having to write some obvious parentheses. The lower the\r\nprecedence the tighter the binding of that operator. Gathering attributes can specify, among other\r\nthings, left or right associativity of operators; fore example, we defined the sequential composition to\r\nbe right associative (left associativity would have also worked).\r\nStep 3 Test the syntax by asking Maude to parse several programs. For example, the program below\r\ncalculates the sum of all the numbers between 1 and 1000:\r\nparse (\r\n#name(n) := #int(1000) ;\r\n#name(s) := #int(0) ;\r\n117\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/67763542-e016-4c9a-a274-3e522c70dcd9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d6da6e9fd3c7654796f889daeddd9005dc7c4243df3413ef7c7f4fa607e497ca",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 726
      },
      {
        "segments": [
          {
            "segment_id": "67763542-e016-4c9a-a274-3e522c70dcd9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "One should be aware of several requirements and guidelines here:\r\n• Most importantly, one should use only one language syntactic category, K. The sort K is already\r\nprovided in “k-plain-prelude.maude”, so one does not need to redeclare it. In other words, for\r\nour language in Figure ??, we collapse AExp, BExp, Stmt and Pgm into only one sort K, which will be\r\nthe only one visible from here on. As already mentioned, the sort K comes with an important sub\u0002sort, KProper, which, intuitively, stays for those computations that need to be further processed\r\nto become results. It is important to declare all the result sorts of language constructs which\r\nare not already values as KProper. No computation constructs need to be declared as constructs\r\nfor KResult when defining the language syntax. The sort collapsing process described above\r\nmay certainly appear to be very inconvenient because one can now write programs which are not\r\nwell formed, such as “3 + true”. Nevertheless, at this moment one should think of the syntax of\r\nthe language as a syntax for its abstract syntax tree (AST). In other words, its syntax at this\r\nstage is nothing but a list of AST node labels. When defining real languages for research or\r\nprototyping purposes, one may want to implement an external parser, using the state of the art\r\nparsing technology, which takes as input a program following the desired user-friendly syntax and\r\ngenerates as output an AST following the simplified syntax that we define in Maude. As seen in\r\nSection ??, one can also define type-checkers using the same K technique, in which case one can\r\nreject programs which are regarded as inappropriate (for typing or other safety reasons).\r\n• A good practice is to wrap the built-in sorts imported in the syntax of the language, as well as\r\nthose that one may use as an intrinsic part of the semantics later on. For example, we import\r\nboth integers and booleans in our language. Since we collapsed the different language syntactic\r\ncategories into just K, then, without an appropriate separation, the various imported sorts would\r\nalso collapse, which may lead to many Maude warnings and errors. For example, one cannot\r\neven put together integers and booleans under a common sort in Maude, because it just happens\r\nthat the two modules have operators sharing the same name and number of arguments. Maude\r\nrightfully complains, because one cannot always know from context which operator one refers to.\r\nOur convention is to use a wrapper name “#sort” for each sort that one wants “protected” from\r\nhere on. We protect three such sorts in our language syntax: Int, Bool, and Name. Names are\r\nalso protected in almost all our language definitions, because we are going to manipulate them as\r\npart of the semantics (save in environments, states, etc.). For clarity, though not strictly needed,\r\none may define sub-sorts of K corresponding to the imported sorts, such as #Int, #Bool, etc.\r\n• Since there is only one syntactic category, one may have to either remove or redeclare some\r\noriginal language constructs. For example, in our original syntax we had two semicolon constructs,\r\nStmt; Stmt and Stmt; AExp, one for statements and the other for programs. Fortunately, these\r\ntwo constructs have the same semantics as computations: process the first computation and then\r\nthe second. Therefore, we only need to add one operation “_;_ : K K -> KProper”. If the two\r\nsemicolon constructs had different semantics as computations, then one would have had to define\r\nthem with different names as computation constructs.\r\nNote that we also added precedence and gathering attributes to some of the language/computation\r\nconstructs. Those attributes are used by Maude’s internal parser and are given exclusively for sim\u0002plifying the reading of programs by not having to write some obvious parentheses. The lower the\r\nprecedence the tighter the binding of that operator. Gathering attributes can specify, among other\r\nthings, left or right associativity of operators; fore example, we defined the sequential composition to\r\nbe right associative (left associativity would have also worked).\r\nStep 3 Test the syntax by asking Maude to parse several programs. For example, the program below\r\ncalculates the sum of all the numbers between 1 and 1000:\r\nparse (\r\n#name(n) := #int(1000) ;\r\n#name(s) := #int(0) ;\r\n117\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/67763542-e016-4c9a-a274-3e522c70dcd9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d6da6e9fd3c7654796f889daeddd9005dc7c4243df3413ef7c7f4fa607e497ca",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 726
      },
      {
        "segments": [
          {
            "segment_id": "f56e7439-2071-4037-945c-c21427ab6dcf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "#name(i) := #name(n) ;\r\nwhile (not(#name(i) <= #int(0))) (\r\n#name(s) := #name(s) + #name(i) ;\r\n#name(i) := #name(i) + #int(-1)\r\n) ;\r\n#name(s)\r\n) .\r\nThis is a good moment to write up many interesting programs that one would like to eventually run\r\nin the defined language, because at this moment one shoots two rabbits with one stone doing it: (1)\r\ncomprehensively tests the syntax, and (2) prepares a benchmark to test the subsequent semantics. It\r\nis very convenient to properly “divide-and-conquer” the task of defining a language between defining\r\nits syntax and defining its semantics. Once the syntax is done, one can move on to the semantics\r\nwithout having to worry about syntactic details anymore. In our experience with designing languages\r\nusing K, we found fewer aspects that were more annoying than having to go back and modify the\r\nsyntax while testing the semantics, just because we were not able to parse certain desirable programs\r\nin order to execute them; each change of syntax will almost unavoidably trigger corresponding changes\r\nof semantics. It is therefore very important to get the syntax right once and for all at this stage.\r\nStep 4 Define all the structural computation equations corresponding to the strictness attributes. These\r\nequations can be derived automatically, but we assume no particular translation or implementation of\r\nK in Maude here; we simply use Maude to write K language definitions and, obviously, Maude is not\r\naware of K’s particularities. The structural computation equations for our language are given below:\r\nfmod IMP-K-STRICTNESS is including IMP-SYNTAX .\r\nvars k k1 k2 : K . vars pk pk1 pk2 : KProper . vars r r1 r2 : KResult .\r\nops (_+[]) ([]+_) : K -> K .\r\neq pk1 + k2 = pk1 -> [] + k2 .\r\neq r1 -> [] + k2 = r1 + k2 .\r\neq k1 + pk2 = pk2 -> k1 + [] .\r\neq r2 -> k1 + [] = k1 + r2 .\r\nops (_<=[]) ([]<=_) : K -> K .\r\neq pk1 <= k2 = pk1 -> [] <= k2 .\r\neq r1 -> [] <= k2 = r1 <= k2 .\r\neq r1 <= pk2 = pk2 -> r1 <= [] .\r\neq r2 -> r1 <= [] = r1 <= r2 .\r\nop []and_ : K -> K .\r\neq pk1 and k2 = pk1 -> [] and k2 .\r\neq r1 -> [] and k2 = r1 and k2 .\r\nop not[] : -> K .\r\neq not pk = pk -> not [] .\r\neq r -> (not []) = not r .\r\nop _:=[] : K -> K .\r\neq k1 := pk2 = pk2 -> k1 := [] .\r\neq r2 -> k1 := [] = k1 := r2 .\r\nop if[]__ : K K -> K .\r\neq if pk k1 k2 = pk -> if [] k1 k2 .\r\neq r -> if [] k1 k2 = if r k1 k2 .\r\nop halt[] : -> K .\r\neq halt pk = pk -> halt [] .\r\neq r -> halt [] = halt r .\r\nendfm\r\n118\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f56e7439-2071-4037-945c-c21427ab6dcf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f9549622c44f6b3fe630512eeb2bab530d19fefc98825d42304c22c47f3d8ef",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 538
      },
      {
        "segments": [
          {
            "segment_id": "f56e7439-2071-4037-945c-c21427ab6dcf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "#name(i) := #name(n) ;\r\nwhile (not(#name(i) <= #int(0))) (\r\n#name(s) := #name(s) + #name(i) ;\r\n#name(i) := #name(i) + #int(-1)\r\n) ;\r\n#name(s)\r\n) .\r\nThis is a good moment to write up many interesting programs that one would like to eventually run\r\nin the defined language, because at this moment one shoots two rabbits with one stone doing it: (1)\r\ncomprehensively tests the syntax, and (2) prepares a benchmark to test the subsequent semantics. It\r\nis very convenient to properly “divide-and-conquer” the task of defining a language between defining\r\nits syntax and defining its semantics. Once the syntax is done, one can move on to the semantics\r\nwithout having to worry about syntactic details anymore. In our experience with designing languages\r\nusing K, we found fewer aspects that were more annoying than having to go back and modify the\r\nsyntax while testing the semantics, just because we were not able to parse certain desirable programs\r\nin order to execute them; each change of syntax will almost unavoidably trigger corresponding changes\r\nof semantics. It is therefore very important to get the syntax right once and for all at this stage.\r\nStep 4 Define all the structural computation equations corresponding to the strictness attributes. These\r\nequations can be derived automatically, but we assume no particular translation or implementation of\r\nK in Maude here; we simply use Maude to write K language definitions and, obviously, Maude is not\r\naware of K’s particularities. The structural computation equations for our language are given below:\r\nfmod IMP-K-STRICTNESS is including IMP-SYNTAX .\r\nvars k k1 k2 : K . vars pk pk1 pk2 : KProper . vars r r1 r2 : KResult .\r\nops (_+[]) ([]+_) : K -> K .\r\neq pk1 + k2 = pk1 -> [] + k2 .\r\neq r1 -> [] + k2 = r1 + k2 .\r\neq k1 + pk2 = pk2 -> k1 + [] .\r\neq r2 -> k1 + [] = k1 + r2 .\r\nops (_<=[]) ([]<=_) : K -> K .\r\neq pk1 <= k2 = pk1 -> [] <= k2 .\r\neq r1 -> [] <= k2 = r1 <= k2 .\r\neq r1 <= pk2 = pk2 -> r1 <= [] .\r\neq r2 -> r1 <= [] = r1 <= r2 .\r\nop []and_ : K -> K .\r\neq pk1 and k2 = pk1 -> [] and k2 .\r\neq r1 -> [] and k2 = r1 and k2 .\r\nop not[] : -> K .\r\neq not pk = pk -> not [] .\r\neq r -> (not []) = not r .\r\nop _:=[] : K -> K .\r\neq k1 := pk2 = pk2 -> k1 := [] .\r\neq r2 -> k1 := [] = k1 := r2 .\r\nop if[]__ : K K -> K .\r\neq if pk k1 k2 = pk -> if [] k1 k2 .\r\neq r -> if [] k1 k2 = if r k1 k2 .\r\nop halt[] : -> K .\r\neq halt pk = pk -> halt [] .\r\neq r -> halt [] = halt r .\r\nendfm\r\n118\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/f56e7439-2071-4037-945c-c21427ab6dcf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f9549622c44f6b3fe630512eeb2bab530d19fefc98825d42304c22c47f3d8ef",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 538
      },
      {
        "segments": [
          {
            "segment_id": "aad56482-b069-451b-a30b-cc590fd39d84",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that only proper computations are “heated”, while only results are “cooled”. As mentioned, the\r\nsort KResult is a built-in sub-sort of K, disjoint from KProper. The subsequent semantic definitions\r\nare going to tell precisely how results are generated and propagated. Also, note that for each strict\r\nargument of each language construct we declared a new operation, whose name was that of the original\r\nlanguage construct with an apparent “hole” replacing the strict argument. As mentioned, there is\r\nno hole in K, but just an intuitive name convention: that’s a result “placeholder” for the scheduled\r\nsubcomputation. The reader is warned that defining the structural computation equations is perhaps\r\nthe most boring and error prone part of a K language definition. Implementations of K should generate\r\nall these automatically from higher-level and compact strictness information.\r\nStep 5 Define the configuration, if needed. With very few exceptions (one example being the truly concur\u0002rent semantics of CCS in Section ??), a K language definition will include some conveniently chosen\r\nconfiguration which will include a set of configuration items. The prelude already defines the sorts\r\nConfig and ConfigItem, as well as an operation [[_]] : KSet{ConfigItem} -> Config. The sort\r\nKSet{ConfigItem} is also defined in the prelude; in fact, a parametric module KSET is defined for\r\nmulti-sets (defined using a binary associative and commutative operator), which provides a paramet\u0002ric sort KSet{X}, that in this case we instantiate for configuration items. One is free not to use our\r\nconstructs for configurations if one prefers one’s own way to organize them. Here is a configuration\r\ndefinition for our language:\r\nfmod IMP-K-CONFIGURATION is including STATE + IMP-SYNTAX + CONFIG .\r\nop k : K -> ConfigItem .\r\nop state : State -> ConfigItem .\r\nsubsort Val < Config KResult .\r\nop [[_]] : K -> Config .\r\nvar p : K . var v : Val . var c : KSet{ConfigItem} .\r\neq [[p]] = [[k(p) state(.State)]] .\r\neq [[k(v) c]] = v .\r\nendfm\r\nOne should make sure that the language syntax module is included, as well as other modules necessary\r\nfor the configuration; in our case, we only need to include the modules STATE and CONFIG, both provided\r\nin the prelude. One may need to define new modules if they are not provided in the prelude. STATE\r\nis defined as an instance of a parametric module KMAP, more precisely as KMAP{Name,Val}; therefore,\r\nvalues are also automatically included. At this stage in the language definition values are generic, in\r\nthe sense that we have no constructors for them yet; those will be added when we define the actual\r\nsemantics of the language. Since values are intended to be results of initial configurations as well as\r\nresults of computations, this is a good place to state that fact explicitly with the sub-sort declaration\r\nVal < Config KResult. To distinguish among the various empty lists or sets for which we generically\r\nused a central dot in the K notation, as well as to avoid Maude ambiguous parsing, we suffixed the\r\nvarious “dots” with their corresponding sorts in our prelude (e.g., .State, .K, etc.) The two equations\r\ninitiate and terminate the computation process, respectively.\r\nStep 6 Define the actual semantics. The very first step is to “initialize the semantics” by establishing the\r\nconnection between “terminals” in the syntax, i.e., leaves in the abstract syntax tree, and computa\u0002tions. Recall that our convention was to wrap those terminals with corresponding operator names,\r\nsuch as #int, #bool, and #name. Our next convention is to use similar wrapper operator names, but\r\ndropping the # character, for terminals into the computational world; more precisely, we use wrapper\r\noperations like “int : Int -> Val”, “bool : Bool -> Val”, and “name : Name -> KProper”. Re\u0002call that values are also result computations in KResult. The reason for which we declare the first two\r\nvalue wrappers as constructors for values as opposed to constructors for K results is because we want\r\nto allow them to be used as values, in particular to be stored in our state structure, for example (in\r\nthis particular language only integers can be stored, but in general one can store any type of values\r\nin a language). The third wrapper is a construct for KProper, because names still need to be heated\r\n119\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/aad56482-b069-451b-a30b-cc590fd39d84.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a16b2dceeab8001fa6ed581a9dd88fc85ce45e845895b5c760fa13fa1547317c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 728
      },
      {
        "segments": [
          {
            "segment_id": "aad56482-b069-451b-a30b-cc590fd39d84",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Note that only proper computations are “heated”, while only results are “cooled”. As mentioned, the\r\nsort KResult is a built-in sub-sort of K, disjoint from KProper. The subsequent semantic definitions\r\nare going to tell precisely how results are generated and propagated. Also, note that for each strict\r\nargument of each language construct we declared a new operation, whose name was that of the original\r\nlanguage construct with an apparent “hole” replacing the strict argument. As mentioned, there is\r\nno hole in K, but just an intuitive name convention: that’s a result “placeholder” for the scheduled\r\nsubcomputation. The reader is warned that defining the structural computation equations is perhaps\r\nthe most boring and error prone part of a K language definition. Implementations of K should generate\r\nall these automatically from higher-level and compact strictness information.\r\nStep 5 Define the configuration, if needed. With very few exceptions (one example being the truly concur\u0002rent semantics of CCS in Section ??), a K language definition will include some conveniently chosen\r\nconfiguration which will include a set of configuration items. The prelude already defines the sorts\r\nConfig and ConfigItem, as well as an operation [[_]] : KSet{ConfigItem} -> Config. The sort\r\nKSet{ConfigItem} is also defined in the prelude; in fact, a parametric module KSET is defined for\r\nmulti-sets (defined using a binary associative and commutative operator), which provides a paramet\u0002ric sort KSet{X}, that in this case we instantiate for configuration items. One is free not to use our\r\nconstructs for configurations if one prefers one’s own way to organize them. Here is a configuration\r\ndefinition for our language:\r\nfmod IMP-K-CONFIGURATION is including STATE + IMP-SYNTAX + CONFIG .\r\nop k : K -> ConfigItem .\r\nop state : State -> ConfigItem .\r\nsubsort Val < Config KResult .\r\nop [[_]] : K -> Config .\r\nvar p : K . var v : Val . var c : KSet{ConfigItem} .\r\neq [[p]] = [[k(p) state(.State)]] .\r\neq [[k(v) c]] = v .\r\nendfm\r\nOne should make sure that the language syntax module is included, as well as other modules necessary\r\nfor the configuration; in our case, we only need to include the modules STATE and CONFIG, both provided\r\nin the prelude. One may need to define new modules if they are not provided in the prelude. STATE\r\nis defined as an instance of a parametric module KMAP, more precisely as KMAP{Name,Val}; therefore,\r\nvalues are also automatically included. At this stage in the language definition values are generic, in\r\nthe sense that we have no constructors for them yet; those will be added when we define the actual\r\nsemantics of the language. Since values are intended to be results of initial configurations as well as\r\nresults of computations, this is a good place to state that fact explicitly with the sub-sort declaration\r\nVal < Config KResult. To distinguish among the various empty lists or sets for which we generically\r\nused a central dot in the K notation, as well as to avoid Maude ambiguous parsing, we suffixed the\r\nvarious “dots” with their corresponding sorts in our prelude (e.g., .State, .K, etc.) The two equations\r\ninitiate and terminate the computation process, respectively.\r\nStep 6 Define the actual semantics. The very first step is to “initialize the semantics” by establishing the\r\nconnection between “terminals” in the syntax, i.e., leaves in the abstract syntax tree, and computa\u0002tions. Recall that our convention was to wrap those terminals with corresponding operator names,\r\nsuch as #int, #bool, and #name. Our next convention is to use similar wrapper operator names, but\r\ndropping the # character, for terminals into the computational world; more precisely, we use wrapper\r\noperations like “int : Int -> Val”, “bool : Bool -> Val”, and “name : Name -> KProper”. Re\u0002call that values are also result computations in KResult. The reason for which we declare the first two\r\nvalue wrappers as constructors for values as opposed to constructors for K results is because we want\r\nto allow them to be used as values, in particular to be stored in our state structure, for example (in\r\nthis particular language only integers can be stored, but in general one can store any type of values\r\nin a language). The third wrapper is a construct for KProper, because names still need to be heated\r\n119\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/aad56482-b069-451b-a30b-cc590fd39d84.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a16b2dceeab8001fa6ed581a9dd88fc85ce45e845895b5c760fa13fa1547317c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 728
      },
      {
        "segments": [
          {
            "segment_id": "94778f9f-d246-4955-acd4-d428f38de735",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "in order to be computed. Expected equations of the form “#int(i)=int(i)” establish the desired\r\n“bottom-AST” relationship between syntax and computation semantics. This step was not necessary\r\nin our “paper” K definitions because there we did not need to wrap AST-terminals at all on paper.\r\nThe Maude module below shows the complete K semantics of our simple language:\r\nmod IMP-K-SEMANTICS is including IMP-K-CONFIGURATION + IMP-K-STRICTNESS .\r\nvars k1 k2 rest : K . var x : Name . var v : Val . vars i i1 i2 : Int . var b : Bool . var sigma : State .\r\nop int : Int -> Val . op bool : Bool -> Val . op name : Name -> KProper .\r\neq #int(i) = int(i) . eq #bool(b) = bool(b) . eq #name(x) = name(x) .\r\nrl k(name(x) -> rest) state(sigma) => k(sigma[x] -> rest) state(sigma) .\r\nrl int(i1) + int(i2) => int(i1 + i2) .\r\nrl int(i1) <= int(i2) => bool(i1 <= i2) .\r\nrl bool(true) and k2 => k2 .\r\nrl bool(false) and k2 => bool(false) .\r\nrl not bool(b) => bool(not b) .\r\nrl k(name(x) := v -> rest) state(sigma) => k(rest) state(sigma[x <- v]) .\r\nrl k1 ; k2 => k1 -> k2 .\r\nrl skip => .K .\r\nrl if bool(true) k1 k2 => k1 .\r\nrl if bool(false) k1 k2 => k2 .\r\neq k(while k1 k2 -> rest) => k(if k1 (k2 -> while k1 k2) .K -> rest) .\r\nrl k(halt int(i) -> rest) => k(int(i)) .\r\nendm\r\nNote that rules use the rule “rl left => right .” Maude syntax, denoting the fact that they are,\r\nsemantically speaking, irreversible rewrite rules and not equations. The type of the module is mod\r\ninstead of fmod, saying that it may contain rewrite rules and thus is not a functional module anymore.\r\nSince this particular language happens to be deterministic, nothing would be lost if all the rules above\r\nwere equations. However, since we also want to capture the intended computational granularity of each\r\nlanguage construct as part of the semantics, in particular that halt stops the entire program in one\r\nstep, we prefer to keep them rules.\r\nStep 7 Test the semantics using several programs:\r\nrewrite [[\r\n#name(n) := #int(1000) ;\r\n#name(s) := #int(0) ;\r\n#name(i) := #name(n) ;\r\nwhile (not(#name(i) <= #int(0))) (\r\n#name(s) := #name(s) + #name(i) ;\r\n#name(i) := #name(i) + #int(-1)\r\n) ;\r\n#name(s)\r\n]] .\r\nThe Maude output for the above reduction, on a 1GH/1GB tablet PC running Windows XP, is:\r\nrewrites: 33048 in ... cpu (371ms real) (~ rewrites/second)\r\nresult Val: int(500500)\r\nFortunately, when writing the semantic rules above one needs not worry much about forgetting any\r\nparticular rule. If the benchmarks of collected programs cover all the language constructs, which\r\nshould always be the case, then one will easily notice the missing rule(s), because the normal-form\r\ncomputation returned by Maude will have the corresponding unreduced language construct at its top.\r\nFor example, if one omits the first rule, then reducing the term above will give a normal form of the\r\nform “[[k(name(x) -> ...) state(...)]]”, which almost suggests what was forgotten.\r\n120\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/94778f9f-d246-4955-acd4-d428f38de735.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7b83a0fee53301a37fc319d2cd43e2bda8a1e77e363fa8e59c54616035505898",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 540
      },
      {
        "segments": [
          {
            "segment_id": "94778f9f-d246-4955-acd4-d428f38de735",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "in order to be computed. Expected equations of the form “#int(i)=int(i)” establish the desired\r\n“bottom-AST” relationship between syntax and computation semantics. This step was not necessary\r\nin our “paper” K definitions because there we did not need to wrap AST-terminals at all on paper.\r\nThe Maude module below shows the complete K semantics of our simple language:\r\nmod IMP-K-SEMANTICS is including IMP-K-CONFIGURATION + IMP-K-STRICTNESS .\r\nvars k1 k2 rest : K . var x : Name . var v : Val . vars i i1 i2 : Int . var b : Bool . var sigma : State .\r\nop int : Int -> Val . op bool : Bool -> Val . op name : Name -> KProper .\r\neq #int(i) = int(i) . eq #bool(b) = bool(b) . eq #name(x) = name(x) .\r\nrl k(name(x) -> rest) state(sigma) => k(sigma[x] -> rest) state(sigma) .\r\nrl int(i1) + int(i2) => int(i1 + i2) .\r\nrl int(i1) <= int(i2) => bool(i1 <= i2) .\r\nrl bool(true) and k2 => k2 .\r\nrl bool(false) and k2 => bool(false) .\r\nrl not bool(b) => bool(not b) .\r\nrl k(name(x) := v -> rest) state(sigma) => k(rest) state(sigma[x <- v]) .\r\nrl k1 ; k2 => k1 -> k2 .\r\nrl skip => .K .\r\nrl if bool(true) k1 k2 => k1 .\r\nrl if bool(false) k1 k2 => k2 .\r\neq k(while k1 k2 -> rest) => k(if k1 (k2 -> while k1 k2) .K -> rest) .\r\nrl k(halt int(i) -> rest) => k(int(i)) .\r\nendm\r\nNote that rules use the rule “rl left => right .” Maude syntax, denoting the fact that they are,\r\nsemantically speaking, irreversible rewrite rules and not equations. The type of the module is mod\r\ninstead of fmod, saying that it may contain rewrite rules and thus is not a functional module anymore.\r\nSince this particular language happens to be deterministic, nothing would be lost if all the rules above\r\nwere equations. However, since we also want to capture the intended computational granularity of each\r\nlanguage construct as part of the semantics, in particular that halt stops the entire program in one\r\nstep, we prefer to keep them rules.\r\nStep 7 Test the semantics using several programs:\r\nrewrite [[\r\n#name(n) := #int(1000) ;\r\n#name(s) := #int(0) ;\r\n#name(i) := #name(n) ;\r\nwhile (not(#name(i) <= #int(0))) (\r\n#name(s) := #name(s) + #name(i) ;\r\n#name(i) := #name(i) + #int(-1)\r\n) ;\r\n#name(s)\r\n]] .\r\nThe Maude output for the above reduction, on a 1GH/1GB tablet PC running Windows XP, is:\r\nrewrites: 33048 in ... cpu (371ms real) (~ rewrites/second)\r\nresult Val: int(500500)\r\nFortunately, when writing the semantic rules above one needs not worry much about forgetting any\r\nparticular rule. If the benchmarks of collected programs cover all the language constructs, which\r\nshould always be the case, then one will easily notice the missing rule(s), because the normal-form\r\ncomputation returned by Maude will have the corresponding unreduced language construct at its top.\r\nFor example, if one omits the first rule, then reducing the term above will give a normal form of the\r\nform “[[k(name(x) -> ...) state(...)]]”, which almost suggests what was forgotten.\r\n120\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/94778f9f-d246-4955-acd4-d428f38de735.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7b83a0fee53301a37fc319d2cd43e2bda8a1e77e363fa8e59c54616035505898",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 540
      },
      {
        "segments": [
          {
            "segment_id": "70423e80-4d68-42bd-9103-ba595f13fa2e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "E.2 Using Maude’s Meta-Level\r\nStep 1 Load the provided K prelude file for definitions using Maude’ meta-level capabilities:\r\nin k-meta-prelude.maude\r\nStep 2 Define the syntax of the desired programming language as an algebraic signature. Unlike in the\r\nprevious approach, there is no need to include any K module. K will “swallow” the entire language\r\nsyntax later at the meta-level. Therefore, we define the language syntax in isolation, as if there was\r\nno K:\r\nfmod IMP-SYNTAX is including INT + BOOL + NAME .\r\nsorts #Int #Bool #Name AExp BExp Stmt Pgm .\r\nop #int : Int -> #Int .\r\nop #bool : Bool -> #Bool .\r\nop #name : Name -> #Name .\r\nsubsorts #Name #Int < AExp .\r\nop _+_ : AExp AExp -> AExp [prec 33] .\r\nsubsort #Bool < BExp .\r\nop _<=_ : AExp AExp -> BExp [prec 37] .\r\nop _and_ : BExp BExp -> BExp [prec 55] .\r\nop not_ : BExp -> BExp [prec 53] .\r\nop skip : -> Stmt .\r\nop _:=_ : #Name AExp -> Stmt .\r\nop _;_ : Stmt Stmt -> Stmt [prec 100 gather(e E)] .\r\nop if___ : BExp Stmt Stmt -> Stmt .\r\nop while__ : BExp Stmt -> Stmt .\r\nop halt_ : AExp -> Stmt .\r\nop _;_ : Stmt AExp -> Pgm [prec 110] .\r\nendfm\r\nAs before, one should be aware of several requirements and guidelines here:\r\n• There is no need to collapse the syntactic categories into only one like before, because that will\r\nbe done automatically at the meta-level when we define the semantics. Even though Maude’s\r\nparser can reject many ill-formed programs now using its internal parser, one should not expect\r\nMaude’s parser to parse arbitrarily complex language syntax. Like in the plain Maude approach,\r\nif a language designer wants a syntax more complex than what Maude can parse, then she should\r\nimplement an external parser for the desired syntax, using state of the art parsing technology, to\r\ntranslate it into one that Maude can parse.\r\n• As before, one should also wrap the built-in sorts imported in the syntax of the language, as well\r\nas those that one may be used as an intrinsic part of the semantics later on. That will make it\r\neasier to recognize these important elements after the program will be lifted at the meta-level.\r\nWe follow the same wrapper naming conventions like in the plain Maude approach.\r\n• Once the language syntax will be lifted at the meta-level, the operator declarations in the syntax\r\nmodule will be forgotten and their names will be used as node labels in the meta-term (as plain\r\nquited identifiers). The sort information of all the language constructs will be discarded; conse\u0002quently, it is important to rename constructs with the same name but with different sorts in case\r\nthey have different computational semantics. In our case, we do not need to rename the semicolon\r\nconstructs Stmt; Stmt and Stmt; AExp, because they have the same semantics as computations.\r\nStep 3 Like in the previous approach using plain Maude, test the syntax by parsing several programs. This\r\ntime, the result sort of well-formed programs will be Pgm instead of KProper.\r\nStep 4 Define all the structural computation equations corresponding to the strictness attributes. As before,\r\nthese equations can and should be derived automatically in implementations of K in Maude, but we\r\nassume no particular translation or implementation of K in Maude. Some discussion on our meta-term\r\n121\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/70423e80-4d68-42bd-9103-ba595f13fa2e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b1f4908e268853102fbd9efdde416dd076763f761267db4a0e3cdb54dbcf7ec",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 593
      },
      {
        "segments": [
          {
            "segment_id": "70423e80-4d68-42bd-9103-ba595f13fa2e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "E.2 Using Maude’s Meta-Level\r\nStep 1 Load the provided K prelude file for definitions using Maude’ meta-level capabilities:\r\nin k-meta-prelude.maude\r\nStep 2 Define the syntax of the desired programming language as an algebraic signature. Unlike in the\r\nprevious approach, there is no need to include any K module. K will “swallow” the entire language\r\nsyntax later at the meta-level. Therefore, we define the language syntax in isolation, as if there was\r\nno K:\r\nfmod IMP-SYNTAX is including INT + BOOL + NAME .\r\nsorts #Int #Bool #Name AExp BExp Stmt Pgm .\r\nop #int : Int -> #Int .\r\nop #bool : Bool -> #Bool .\r\nop #name : Name -> #Name .\r\nsubsorts #Name #Int < AExp .\r\nop _+_ : AExp AExp -> AExp [prec 33] .\r\nsubsort #Bool < BExp .\r\nop _<=_ : AExp AExp -> BExp [prec 37] .\r\nop _and_ : BExp BExp -> BExp [prec 55] .\r\nop not_ : BExp -> BExp [prec 53] .\r\nop skip : -> Stmt .\r\nop _:=_ : #Name AExp -> Stmt .\r\nop _;_ : Stmt Stmt -> Stmt [prec 100 gather(e E)] .\r\nop if___ : BExp Stmt Stmt -> Stmt .\r\nop while__ : BExp Stmt -> Stmt .\r\nop halt_ : AExp -> Stmt .\r\nop _;_ : Stmt AExp -> Pgm [prec 110] .\r\nendfm\r\nAs before, one should be aware of several requirements and guidelines here:\r\n• There is no need to collapse the syntactic categories into only one like before, because that will\r\nbe done automatically at the meta-level when we define the semantics. Even though Maude’s\r\nparser can reject many ill-formed programs now using its internal parser, one should not expect\r\nMaude’s parser to parse arbitrarily complex language syntax. Like in the plain Maude approach,\r\nif a language designer wants a syntax more complex than what Maude can parse, then she should\r\nimplement an external parser for the desired syntax, using state of the art parsing technology, to\r\ntranslate it into one that Maude can parse.\r\n• As before, one should also wrap the built-in sorts imported in the syntax of the language, as well\r\nas those that one may be used as an intrinsic part of the semantics later on. That will make it\r\neasier to recognize these important elements after the program will be lifted at the meta-level.\r\nWe follow the same wrapper naming conventions like in the plain Maude approach.\r\n• Once the language syntax will be lifted at the meta-level, the operator declarations in the syntax\r\nmodule will be forgotten and their names will be used as node labels in the meta-term (as plain\r\nquited identifiers). The sort information of all the language constructs will be discarded; conse\u0002quently, it is important to rename constructs with the same name but with different sorts in case\r\nthey have different computational semantics. In our case, we do not need to rename the semicolon\r\nconstructs Stmt; Stmt and Stmt; AExp, because they have the same semantics as computations.\r\nStep 3 Like in the previous approach using plain Maude, test the syntax by parsing several programs. This\r\ntime, the result sort of well-formed programs will be Pgm instead of KProper.\r\nStep 4 Define all the structural computation equations corresponding to the strictness attributes. As before,\r\nthese equations can and should be derived automatically in implementations of K in Maude, but we\r\nassume no particular translation or implementation of K in Maude. Some discussion on our meta-term\r\n121\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/70423e80-4d68-42bd-9103-ba595f13fa2e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b1f4908e268853102fbd9efdde416dd076763f761267db4a0e3cdb54dbcf7ec",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 593
      },
      {
        "segments": [
          {
            "segment_id": "8db72e43-ba1c-49b7-8024-359060d21940",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 122,
            "page_width": 612,
            "page_height": 792,
            "content": "representation is necessary before we can show the structural computation equations for our simple\r\nlanguage. The provided module K-META imports the module K-PLAIN and “hooks” the Maude internal\r\nrepresentation for terms into computations. More precisely, computations can now be constructed\r\nwith the usual task sequentialization operator _->_ (corresponding to y), with label constants of sort\r\nKLabel, and with terms of the form L(K1, K2, ..., Kn), where L is a label and K1, K2, ..., Kn are\r\nsubcomputations. We prefer constants instead of labeled terms with an empty list of children to stay\r\nconsistent with Maude’s meta-term representation conventions. Labels include all the quoted identifiers\r\nand can be added more constructs if needed. One built-in label construct, f : String -> Freezer, is\r\nalready provided, the one for “freezers” (Freezer is a sub-sort of Label) . A freezer label has therefore\r\nthe form f(\"any sequence of characters\"); the string will most likely include holes, written [].\r\nTo ease reading of meta-terms with holes, we renamed the Maude’s square brackets enclosing meta\u0002subterms to normal parentheses. Here are the structural computation equations for our language:\r\nfmod IMP-K-STRICTNESS is including K-META .\r\nvars k k1 k2 : K . vars r r1 r2 : KResult . vars pk pk1 pk2 : KProper .\r\neq ’_+_(pk1,k2) = pk1 -> f(’‘[‘]+_)(k2) .\r\neq r1 -> f(’‘[‘]+_)(k2) = ’_+_(r1,k2) .\r\neq ’_+_(k1,pk2) = pk2 -> f(’_+‘[‘])(k1) .\r\neq r2 -> f(’_+‘[‘])(k1) = ’_+_(k1,r2) .\r\neq ’_<=_(pk1,k2) = pk1 -> f(’‘[‘]<=_)(k2) .\r\neq r1 -> f(’‘[‘]<=_)(k2) = ’_<=_(r1,k2) .\r\neq ’_<=_(r1,pk2) = pk2 -> f(’_<=‘[‘])(r1) .\r\neq r2 -> f(’_<=‘[‘])(r1) = ’_<=_(r1,r2) .\r\neq ’_and_(pk1,k2) = pk1 -> f(’‘[‘]and_)(k2) .\r\neq r1 -> f(’‘[‘]and_)(k2) = ’_and_(r1,k2) .\r\neq ’not_(pk) = pk -> f(’not‘[‘]) .\r\neq r -> f(’not‘[‘]) = ’not_(r) .\r\neq ’_:=_(k1,pk2) = pk2 -> f(’_:=‘[‘])(k1) .\r\neq r2 -> f(’_:=‘[‘])(k1) = ’_:=_(k1,r2) .\r\neq ’if___(pk,k1,k2) = pk -> f(’if‘[‘]__)(k1,k2) .\r\neq r -> f(’if‘[‘]__)(k1,k2) = ’if___(r,k1,k2) .\r\neq ’halt_(pk) = pk -> f(’halt‘[‘]) .\r\neq r -> f(’halt‘[‘]) = ’halt_(r) .\r\nendfm\r\nThe KResult and KProper computations have precisely the same meaning as in the plain Maude\r\napproach. We use the Qid labels for K nodes corresponding to the original language syntax, and frozen\r\nlabels for auxiliary freezers. Note that the module above did not need to import the language syntax,\r\nbecause it only refers to quoted identifier and frozen string labels.\r\nStep 5 Define the configuration, if needed:\r\nfmod IMP-K-CONFIGURATION is including STATE + K-META + IMP-SYNTAX + CONFIG .\r\nop k : K -> ConfigItem .\r\nop state : State -> ConfigItem .\r\nsubsort Val < Config KResult .\r\nop [[_]] : Pgm -> Config .\r\nvar p : Pgm . var v : Val . var c : KSet{ConfigItem} .\r\neq [[p]] = [[k(mkK(p)) state(.State)]] .\r\neq [[k(v) c]] = v .\r\nendfm\r\n122\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/8db72e43-ba1c-49b7-8024-359060d21940.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=679587989fa51323e757d647365bda4fb72609718d78a0d5d956833253595b3d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 487
      },
      {
        "segments": [
          {
            "segment_id": "8c34a459-78fc-4391-a0cd-7f42c3fbc6a0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 123,
            "page_width": 612,
            "page_height": 792,
            "content": "The only difference between the module above and its corresponding one in the plain Maude approach\r\nis that the evaluation operator takes a program now instead of a computation, but lifts it with the\r\nprovided operator mkK into a KProper computation when placing it into the configuration.\r\nStep 6 Define the actual semantics. Like before, we should first “initialize the semantics” by establishing\r\nthe connection between “terminals” in the syntax, i.e., meta-subterms with Qid labels starting with\r\n’#, and computations. One easy way to achieve that is to use downK, also provided as part of the\r\nprelude, as shown in the module below, which completes the semantics of our language using the\r\nK-meta approach:\r\nmod IMP-K-SEMANTICS is including IMP-K-CONFIGURATION + IMP-K-STRICTNESS .\r\nvars k k1 k2 rest : K . var x : Name . var v : Val . vars i i1 i2 : Int . var b : Bool . var sigma : State .\r\nop int : Int -> Val . op bool : Bool -> Val . op name : Name -> KProper .\r\neq ’#int(k) = int(downTerm(k,errInt)) . op errInt : -> [Int] .\r\neq ’#bool(k) = bool(downTerm(k,errBool)) . op errBool : -> [Bool] .\r\neq ’#name(k) = name(downTerm(k,errName)) . op errName : -> [Name] .\r\nrl k(name(x) -> rest) state(sigma) => k(sigma[x] -> rest) state(sigma) .\r\nrl ’_+_(int(i1),int(i2)) => int(i1 + i2) .\r\nrl ’_<=_(int(i1),int(i2)) => bool(i1 <= i2) .\r\nrl ’_and_(bool(true),k2) => k2 .\r\nrl ’_and_(bool(false),k2) => bool(false) .\r\nrl ’not_(bool(b)) => bool(not b) .\r\nrl k(’_:=_(name(x),v) -> rest) state(sigma) => k(rest) state(sigma[x <- v]) .\r\nrl ’_;_(k1,k2) => k1 -> k2 .\r\nrl ’skip.Stmt => .K .\r\nrl ’if___(bool(true),k1,k2) => k1 .\r\nrl ’if___(bool(false),k1,k2) => k2 .\r\neq (k(’while__(k1,k2) -> rest)).ConfigItem = k(’if___(k1, (k2 -> ’while__(k1,k2)), .K) -> rest) .\r\nrl (k(’halt_(int(i)) -> rest)).ConfigItem => k(int(i)) .\r\nendm\r\nStep 7 Test the semantics using several programs.\r\nmod IMP-K-RUN is\r\nincluding IMP-PROGRAMS + IMP-K-SEMANTICS .\r\nendm\r\nrew [[pSum]] .\r\nE.3 Comparing the Plain and Meta Approaches\r\nNote that the one using the meta-level has several advantages: - it works directly with the syntax of the PL,\r\nso one does not need to first collapse everything into computations - it is slightly more compact, at least\r\nin number of lines and of operators defined. - it is more modular, in that one can add new features like\r\nself-generation of code, etc., without worrying of the actual language syntax.\r\nThe only advantage the core-level one has is that its rules look more readable.\r\n123\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/8c34a459-78fc-4391-a0cd-7f42c3fbc6a0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a8a6b5384ee2420b2bbeb091440f9be25fa6a0f90b47fbc45754668add8d6175",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 434
      },
      {
        "segments": [
          {
            "segment_id": "295f5e3f-0b40-417a-9978-56dc983abd39",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 124,
            "page_width": 612,
            "page_height": 792,
            "content": "F The K Prelude\r\nLv y restore(ρ)\r\n·\r\n|ikenv(\r\nρ\r\n)\r\nstrict(kl1, k, kl2) \n k y strict(kl1, \u0003, kl2)\r\nstrict(rl) = results(rl)\r\nLresults(vl) y bindTo(xl)\r\n·\r\n|ikenv( ρ\r\nρ[ll0/xl]\r\n) store( σ\r\nσ[vl/ll\r\n0\r\n]\r\n) nextLoc(l\r\nl\r\n0\r\n) where l\r\n0\r\nis l +Loc |xl|, and\r\nll0is l . . .(l\r\n0 +Loc −1)\r\nLbindTo(xl)\r\n·\r\n|ikenv( ρ\r\nρ[ll0/xl]\r\n) nextLoc(l\r\nl\r\n0\r\n) where l\r\n0\r\nis l +Loc |xl|, and ll0is l . . .(l\r\n0 +Loc −1)\r\nLresults(vl) y writeTo(xl)\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[vl/ρ[xl]]\r\n)\r\nThe following definitions of the auxiliary computation items restore, strict, bindTo and writeTo are so\r\nuseful in language definitions, that, in our Maude implementation of K, they are part of the prelude file\r\nwhich is included in all K definitions:\r\nLv y restore(ρ)\r\n·\r\n|ikenv(\r\nρ\r\n)\r\nstrict(kl1, k, kl2) \n k y strict(kl1, \u0003, kl2)\r\nstrict(rl) = results(rl)\r\nLresults(vl) y bindTo(xl)\r\n·\r\n|ikenv( ρ\r\nρ[ll0/xl]\r\n) store( σ\r\nσ[vl/ll\r\n0\r\n]\r\n) nextLoc(l\r\nl\r\n0\r\n) where l\r\n0\r\nis l +Loc |xl|, and\r\nll0is l . . .(l\r\n0 +Loc −1)\r\nLbindTo(xl)\r\n·\r\n|ikenv( ρ\r\nρ[ll0/xl]\r\n) nextLoc(l\r\nl\r\n0\r\n) where l\r\n0\r\nis l +Loc |xl|, and ll0is l . . .(l\r\n0 +Loc −1)\r\nLresults(vl) y writeTo(xl)\r\n·\r\n|ikenv(ρ) store( σ\r\nσ[vl/ρ[xl]]\r\n)\r\n124\r\nUniversity of Illinois at Urbana-Champaign \r\nDepartment of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007-1827",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/451fa1bf-8626-47d7-931d-e09277312ff4/images/295f5e3f-0b40-417a-9978-56dc983abd39.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041418Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8dc79a996dcb41d681696efb488c976fa02c726cc5734e192cb4634ebbfce8ac",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 234
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No response"
        }
      ]
    }
  }
}