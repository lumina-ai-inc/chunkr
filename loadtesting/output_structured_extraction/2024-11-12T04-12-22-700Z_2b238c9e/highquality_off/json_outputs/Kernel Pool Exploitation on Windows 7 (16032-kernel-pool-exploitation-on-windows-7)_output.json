{
  "file_name": "Kernel Pool Exploitation on Windows 7 (16032-kernel-pool-exploitation-on-windows-7).pdf",
  "task_id": "f870398a-4be2-4922-bb6c-418f4bf33d9d",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "35412b84-7582-4dc9-b3db-395f94636dfe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Kernel Pool Exploitation on Windows 7\r\nTarjei Mandt\r\nkernelpool@gmail.com\r\nAbstract. In Windows 7, Microsoft introduced safe unlinking to ad\u0002dress the growing number of security bulletins affecting the Windows\r\nkernel. Prior to removing an entry from a doubly-linked list, safe un\u0002linking aims to detect memory corruption by validating the pointers to\r\nadjacent list entries. Hence, an attacker cannot easily leverage generic\r\ntechniques in exploiting pool overflows or other pool corruption vulner\u0002abilities. In this paper, we show that in spite of the security measures\r\nintroduced, Windows 7 is still susceptible to generic kernel pool attacks.\r\nIn particular, we show that the pool allocator may under certain condi\u0002tions fail to safely unlink free list entries, thus allowing an attacker to\r\ncorrupt arbitrary memory. In order to thwart the presented attacks, we\r\npropose ways to further harden and enhance the security of the kernel\r\npool.\r\nKeywords: kernel pool, safe unlinking, exploitation\r\n1 Introduction\r\nAs software bugs are hard to completely eliminate due to the complexity of\r\nmodern day computing, vendors are doing their best to isolate and prevent ex\u0002ploitation of security vulnerabilities. Mitigations such as DEP and ASLR have\r\nbeen introduced in contemporary operating systems to address a variety of com\u0002monly used exploitation techniques. However, as exploit mitigations do not ad\u0002dress the root cause of security vulnerabilities, there will always be edge case\r\nscenarios where they fall short. For instance, DEP alone is easily circumvented\r\nusing return-oriented programming (ROP) [15]. Furthermore, novel techniques\r\nleveraging the capabilities of powerful application-embedded scripting engines\r\nmay bypass DEP and ASLR completely [4].\r\nA complementary approach to exploit mitigations is privilege isolation. By\r\nimposing restrictions on users and processes using the operating system’s built\u0002in security mechanisms, an attacker cannot easily access and manipulate system\r\nfiles and registry information in a compromised system. Since the introduction\r\nof user account control (UAC) in Vista, users no longer run regular applications\r\nwith administrative privileges by default. Additionally, modern browsers [2] and\r\ndocument readers [13][12] use ”sandboxed” render processes to lessen the impact\r\nof security vulnerabilities in parsing libraries and layout engines. In turn, this\r\nhas motivated attackers (as well as researchers) to focus their efforts on privilege\r\nescalation attacks. By executing arbitrary code in the highest privileged ring,\r\noperating system security is undermined.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/35412b84-7582-4dc9-b3db-395f94636dfe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be2833264e5b5f77ea6498be59ad970c2c48894d5949b502f2309a788d68eca6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "36cb2ed9-41ff-4730-8072-5953ec632dda",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Privilege escalation vulnerabilities are in most cases caused by bugs in the\r\noperating system kernel or third party drivers. Many of the flaws originate in\r\nthe handling of dynamically allocated kernel pool memory. The kernel pool is\r\nanalogous to the user-mode heap and was for many years susceptible to generic\r\nwrite-4 attacks abusing the unlink operation of doubly-linked lists [8][16]. In\r\nresponse to the growing number of kernel vulnerabilities, Microsoft introduced\r\nsafe unlinking in Windows 7 [3]. Safe unlinking ensures that the pointers to\r\nadjacent pool chunks on doubly-linked free lists are validated before a chunk is\r\nunlinked.\r\nAn attacker’s goal in exploiting pool corruption vulnerabilities is to ulti\u0002mately execute arbitrary code in ring 0. This often starts with an arbitrary\r\nmemory write or n-byte corruption at a chosen location. In this paper, we show\r\nthat in spite of the security measures introduced, the kernel pool in Windows 7\r\nis still susceptible to generic1 attacks. In turn, these attacks may allow an at\u0002tacker to fully compromise the operating system kernel. We also show that safe\r\nunlinking, designed to remediate write-4 attacks, may under certain conditions\r\nfail to achieve its goals and allow an attacker to corrupt arbitrary memory. In\r\norder to thwart the presented attacks, we conclusively propose ways to further\r\nharden and enhance the security of the kernel pool.\r\nThe rest of the paper is organized as follows. In Section 2 we elaborate on\r\nthe internal structures and changes made to the Windows 7 (and Vista) kernel\r\npool. In Section 3 and 4 we discuss and demonstrate practical kernel pool attacks\r\naffecting Windows 7. In Section 5 we discuss counter-measures and propose ways\r\nto harden the kernel pool. Finally, in Section 6 we provide a conclusion of the\r\npaper.\r\n2 Kernel Pool Internals\r\nIn this section, we elaborate on the kernel pool management structures and algo\u0002rithms involved in the allocation and deallocation of pool memory. Understand\u0002ing kernel pool behavior is vital in properly assessing its security and robustness.\r\nFor brevity, we assume the x86 architecture (32-bit). However, most structures\r\nare applicable to AMD64/x64 (64-bit). Notable differences in the kernel pool\r\nbetween x86 and x64 architectures are discussed in Section 2.9.\r\n2.1 Non-Uniform Memory Architecture\r\nFor every new version of Windows, the memory manager is enhanced to bet\u0002ter support the Non-Uniform Memory Architecture (NUMA), a memory design\r\narchitecture used in modern multi-processor systems. NUMA dedicates differ\u0002ent memory banks to different processors, allowing local memory to be accessed\r\nmore quickly, while remote memory is accessed more slowly. The processors and\r\nmemory are grouped together in smaller units called nodes, defined by the KNODE\r\nstructure in the executive kernel.\r\n1 Applicable to any n-byte pool corruption vulnerability.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/36cb2ed9-41ff-4730-8072-5953ec632dda.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0814994722e2ab0fc8c325be5d1a4ba71e15d1de43a882ba353e539301e7ded2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 445
      },
      {
        "segments": [
          {
            "segment_id": "50086e56-18cb-4e4c-8add-b359313c07ca",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "typedef struct _KNODE\r\n{\r\n/*0x000*/ union _SLIST_HEADER PagedPoolSListHead;\r\n/*0x008*/ union _SLIST_HEADER NonPagedPoolSListHead[3];\r\n/*0x020*/ struct _GROUP_AFFINITY Affinity;\r\n/*0x02C*/ ULONG32 ProximityId;\r\n/*0x030*/ UINT16 NodeNumber;\r\n/*0x032*/ UINT16 PrimaryNodeNumber;\r\n/*0x034*/ UINT8 MaximumProcessors;\r\n/*0x035*/ UINT8 Color;\r\n/*0x036*/ struct _flags Flags;\r\n/*0x037*/ UINT8 NodePad0;\r\n/*0x038*/ ULONG32 Seed;\r\n/*0x03C*/ ULONG32 MmShiftedColor;\r\n/*0x040*/ ULONG32 FreeCount[2];\r\n/*0x048*/ struct _CACHED_KSTACK_LIST CachedKernelStacks;\r\n/*0x060*/ LONG32 ParkLock;\r\n/*0x064*/ ULONG32 NodePad1;\r\n/*0x068*/ UINT8 _PADDING0_[0x18];\r\n} KNODE, *PKNODE;\r\nOn multi-node systems (nt!KeNumberNodes > 1), the memory manager will\r\nalways try to allocate from the ideal node. As such, KNODE provides information\r\nas to where local memory is found in the Color field. This value is an array index\r\nused by the allocation and free algorithms to associate nodes with its preferred\r\npool. Additionally, KNODE defines four singly-linked per-node lookaside lists for\r\nfree pool pages (discussed in Section 2.6).\r\n2.2 System Memory Pools\r\nAt system initialization, the memory manager creates dynamically sized mem\u0002ory pools according to the number of system nodes. Each pool is defined by a\r\npool descriptor (discussed in Section 2.3), a management structure that tracks\r\npool usage and defines pool properties such as the memory type. There are two\r\ndistinct types of pool memory: paged and non-paged.\r\nPaged pool memory can be allocated and accessed from any process con\u0002text, but only at IRQL < DPC/dispatch level. The number of paged pools\r\nin use is given by nt!ExpNumberOfPagedPools. On uniprocessor systems, four\r\n(4) paged pool descriptors are defined, denoted by indices 1 through 4 in the\r\nnt!ExpPagedPoolDescriptor array. On multiprocessor systems, one (1) paged\r\npool descriptor is defined per node. In both cases, an additional paged pool de\u0002scriptor is defined for prototype pools / full page allocations, denoted by index 0\r\nin nt!ExpPagedPoolDescriptor. Hence, in most desktop systems five (5) paged\r\npool descriptors are defined.\r\nNon-paged pool memory is guaranteed to reside in physical memory at all\r\ntimes. This is required by threads executing at IRQL >= DPC/dispatch level\r\n(such as interrupt handlers), as page faults cannot be timely satisfied. The num\u0002ber of non-paged pools currently in use is given by nt!ExpNumberOfNonPagedPools.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/50086e56-18cb-4e4c-8add-b359313c07ca.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd908913b4cd85888ab62938116307ad8419b6feeede4594833df1caaea22108",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 338
      },
      {
        "segments": [
          {
            "segment_id": "86010772-2a6a-4ba4-9221-722016a26308",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "On uniprocessor systems, the first index of the nt!PoolVector array points to\r\nthe non-paged pool descriptor. On multiprocessor systems, each node has its own\r\nnon-paged pool descriptor, indexed by the nt!ExpNonPagedPoolDescriptor ar\u0002ray.\r\nAdditionally, session pool memory (used by win32k) is used for session space\r\nallocations and is unique to each user session. While non-paged session memory\r\nuse the global non-paged pool descriptor(s), paged session pool memory has\r\nits own pool descriptor defined in nt!MM SESSION SPACE. To obtain the session\r\npool descriptor, Windows 7 parses the associated nt!EPROCESS structure (of the\r\ncurrently executing thread) for the session space structure, and subsequently\r\nfinds the embedded paged pool descriptor.\r\n2.3 Pool Descriptor\r\nMuch like the user-mode heap, every kernel pool requires a management struc\u0002ture. The pool descriptor is responsible for tracking the number of running allo\u0002cations, pages in use, and other information regarding pool usage. It also helps\r\nthe system to keep track of reusable pool chunks. The pool descriptor is defined\r\nby the following structure (nt!POOL DESCRIPTOR).\r\ntypedef struct _POOL_DESCRIPTOR\r\n{\r\n/*0x000*/ enum _POOL_TYPE PoolType;\r\nunion {\r\n/*0x004*/ struct _KGUARDED_MUTEX PagedLock;\r\n/*0x004*/ ULONG32 NonPagedLock;\r\n};\r\n/*0x040*/ LONG32 RunningAllocs;\r\n/*0x044*/ LONG32 RunningDeAllocs;\r\n/*0x048*/ LONG32 TotalBigPages;\r\n/*0x04C*/ LONG32 ThreadsProcessingDeferrals;\r\n/*0x050*/ ULONG32 TotalBytes;\r\n/*0x054*/ UINT8 _PADDING0_[0x2C];\r\n/*0x080*/ ULONG32 PoolIndex;\r\n/*0x084*/ UINT8 _PADDING1_[0x3C];\r\n/*0x0C0*/ LONG32 TotalPages;\r\n/*0x0C4*/ UINT8 _PADDING2_[0x3C];\r\n/*0x100*/ VOID** PendingFrees;\r\n/*0x104*/ LONG32 PendingFreeDepth;\r\n/*0x108*/ UINT8 _PADDING3_[0x38];\r\n/*0x140*/ struct _LIST_ENTRY ListHeads[512];\r\n} POOL_DESCRIPTOR, *PPOOL_DESCRIPTOR;\r\nThe pool descriptor holds several important lists used by the memory man\u0002ager. The delayed free list, pointed to by PendingFrees, is a singly-linked list\r\nof pool chunks waiting to be freed. It is explained in detail in Section 2.8. The\r\nListHeads is an array of doubly-linked lists of free pool chunks of the same\r\nsize. Unlike the delayed free list, the chunks in the ListHeads lists have been",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/86010772-2a6a-4ba4-9221-722016a26308.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b0d84116ba4213ad94c32448f584ebbb9470e0bd995f35ed70dfa1a40d4fb3f6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 298
      },
      {
        "segments": [
          {
            "segment_id": "1fae3b03-5a78-4c7b-b96a-a22248ef3598",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "freed and can be allocated by the memory manager at any time. We discuss the\r\nListHeads in the following section.\r\n2.4 ListHeads Lists (Free Lists)\r\nThe ListHeads lists, or free lists, are ordered in size of 8-byte granularity and\r\nused for allocations up to 4080 bytes2. The free chunks are indexed into the List\u0002Heads array by block size, computed as the requested number of bytes rounded\r\nup to a multiple of 8 and divided by 8, or BlockSize = (NumberOfBytes+0xF)\r\n>> 3. The rounding is performed to reserve space for the pool header, a structure\r\npreceding all pool chunks. The pool header is defined as follows on x86 Windows.\r\ntypedef struct _POOL_HEADER\r\n{\r\nunion {\r\nstruct {\r\n/*0x000*/ UINT16 PreviousSize : 9;\r\n/*0x000*/ UINT16 PoolIndex : 7;\r\n/*0x002*/ UINT16 BlockSize : 9;\r\n/*0x002*/ UINT16 PoolType : 7;\r\n};\r\n/*0x000*/ ULONG32 Ulong1;\r\n};\r\nunion {\r\n/*0x004*/ ULONG32 PoolTag;\r\nstruct {\r\n/*0x004*/ UINT16 AllocatorBackTraceIndex;\r\n/*0x006*/ UINT16 PoolTagHash;\r\n};\r\n};\r\n} POOL_HEADER, *PPOOL_HEADER;\r\nThe pool header holds information necessary for the allocation and free algo\u0002rithms to operate properly. PreviousSize indicates the block size of the preced\u0002ing pool chunk. As the memory manager always tries to reduce fragmentation\r\nby merging bordering free chunks, it is typically used to locate the pool header\r\nof the previous chunk. PreviousSize may also be zero, in which case the pool\r\nchunk is located at the beginning of a pool page.\r\nPoolIndex provides the index into the associated pool descriptor array, such\r\nas nt!ExpPagedPoolDescriptor. It is used by the free algorithm to make sure\r\nthe pool chunk is freed to the proper pool descriptor ListHeads. In Section 3.4,\r\nwe show how an attacker may corrupt this value in order to extend a pool header\r\ncorruption (such as a pool overflow) into an arbitrary memory corruption.\r\nAs its name suggests, PoolType defines a chunk’s pool type. However, it also\r\nindicates if a chunk is busy or free. If a chunk is free, PoolType is set to zero. On\r\nthe other hand, if a chunk is busy, PoolType is set to its descriptor’s pool type (a\r\n2 The remaining page fragment cannot be used if requested bytes exceed 4080.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/1fae3b03-5a78-4c7b-b96a-a22248ef3598.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=49115bf933f55719c8aad4c4eb0f3ebadce8706db8b9ffab6f751275675ee50b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 358
      },
      {
        "segments": [
          {
            "segment_id": "55057bd3-9922-43f0-8968-6fc2a292af6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "value in POOL TYPE enum, shown below) OR’ed with a pool-in-use bitmask. This\r\nbitmask is set to 2 on Vista and later, while it is set to 4 on XP/2003. E.g. for a\r\nbusy paged pool chunk on Vista and Windows 7, PoolType = PagedPool|2 =\r\n3.\r\ntypedef enum _POOL_TYPE\r\n{\r\nNonPagedPool = 0 /*0x0*/,\r\nPagedPool = 1 /*0x1*/,\r\nNonPagedPoolMustSucceed = 2 /*0x2*/,\r\nDontUseThisType = 3 /*0x3*/,\r\nNonPagedPoolCacheAligned = 4 /*0x4*/,\r\nPagedPoolCacheAligned = 5 /*0x5*/,\r\nNonPagedPoolCacheAlignedMustS = 6 /*0x6*/,\r\nMaxPoolType = 7 /*0x7*/,\r\nNonPagedPoolSession = 32 /*0x20*/,\r\nPagedPoolSession = 33 /*0x21*/,\r\nNonPagedPoolMustSucceedSession = 34 /*0x22*/,\r\nDontUseThisTypeSession = 35 /*0x23*/,\r\nNonPagedPoolCacheAlignedSession = 36 /*0x24*/,\r\nPagedPoolCacheAlignedSession = 37 /*0x25*/,\r\nNonPagedPoolCacheAlignedMustSSession = 38 /*0x26*/\r\n} POOL_TYPE, *PPOOL_TYPE;\r\nIf a pool chunk is free and is on a ListHeads list, its pool header is imme\u0002diately followed by a LIST ENTRY structure. For this reason, chunks of a single\r\nblock size (8 bytes) are not maintained by the ListHeads as they are not large\r\nenough to hold the structure.\r\ntypedef struct _LIST_ENTRY\r\n{\r\n/*0x000*/ struct _LIST_ENTRY* Flink;\r\n/*0x004*/ struct _LIST_ENTRY* Blink;\r\n} LIST_ENTRY, *PLIST_ENTRY;\r\nThe LIST ENTRY structure is used to join pool chunks on doubly linked lists.\r\nHistorically, it has been the target in exploiting memory corruption vulnerabili\u0002ties in both the user-mode heap [5] and the kernel pool [8][16], primarily due to\r\nwell-known ”write-4” exploitation techniques.3 Microsoft addressed LIST ENTRY\r\nattacks in the user-mode heap with the release of Windows XP SP2 [5], and\r\nsimilarly in the kernel pool with Windows 7 [3].\r\n2.5 Lookaside Lists\r\nThe kernel uses singly-linked lookaside (LIFO) lists for faster allocation and\r\ndeallocation of small pool chunks. They are designed to operate in highly con\u0002current code and use an atomic compare-and-exchange instruction in adding and\r\n3 Overwriting the LIST ENTRY structure may cause an arbitrary value (pointer) to be\r\nwritten at an arbitrary location in memory in the unlinking process.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/55057bd3-9922-43f0-8968-6fc2a292af6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f86c52e85db2a413565efce2939118caec7fd91a3dbe2101812a448fe8b9046",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "113d886c-a5ae-4918-a8d7-1bdebd3facb2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "removing entries. In order to better make use of CPU caching, lookaside lists\r\nare defined per processor in the Processor Control Block (KPRCB). The KPRCB\r\nstructure holds lookaside lists for both paged (PPPagedLookasideList) and\r\nnon-paged (PPNPagedLookasideList) allocations, as well as special dedicated\r\nlookaside lists (PPLookasideList) for frequently requested fixed size allocations\r\n(such as for I/O request packets and memory descriptor lists).\r\ntypedef struct _KPRCB\r\n{\r\n...\r\n/*0x5A0*/ struct _PP_LOOKASIDE_LIST PPLookasideList[16];\r\n/*0x620*/ struct _GENERAL_LOOKASIDE_POOL PPNPagedLookasideList[32];\r\n/*0xF20*/ struct _GENERAL_LOOKASIDE_POOL PPPagedLookasideList[32];\r\n...\r\n} KPRCB, *PKPRCB;\r\nFor the paged and non-paged lookaside lists, maximum block size is 0x20.\r\nHence, there are 32 unique lookaside lists per type. Each lookaside list is defined\r\nby the GENERAL LOOKASIDE POOL structure, shown below.\r\ntypedef struct _GENERAL_LOOKASIDE_POOL\r\n{\r\nunion\r\n{\r\n/*0x000*/ union _SLIST_HEADER ListHead;\r\n/*0x000*/ struct _SINGLE_LIST_ENTRY SingleListHead;\r\n};\r\n/*0x008*/ UINT16 Depth;\r\n/*0x00A*/ UINT16 MaximumDepth;\r\n/*0x00C*/ ULONG32 TotalAllocates;\r\nunion\r\n{\r\n/*0x010*/ ULONG32 AllocateMisses;\r\n/*0x010*/ ULONG32 AllocateHits;\r\n};\r\n/*0x014*/ ULONG32 TotalFrees;\r\nunion\r\n{\r\n/*0x018*/ ULONG32 FreeMisses;\r\n/*0x018*/ ULONG32 FreeHits;\r\n};\r\n/*0x01C*/ enum _POOL_TYPE Type;\r\n/*0x020*/ ULONG32 Tag;\r\n/*0x024*/ ULONG32 Size;\r\nunion\r\n{\r\n/*0x028*/ PVOID AllocateEx;\r\n/*0x028*/ PVOID Allocate;\r\n};\r\nunion",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/113d886c-a5ae-4918-a8d7-1bdebd3facb2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cb725be8b73e36284f775f6f5cd76a78aaa93af1c90456c8c8a7adf5d2d0aafe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 492
      },
      {
        "segments": [
          {
            "segment_id": "4ccd2031-de5f-45f5-97d7-6714b37fb06b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "{\r\n/*0x02C*/ PVOID FreeEx;\r\n/*0x02C*/ PVOID Free;\r\n};\r\n/*0x030*/ struct _LIST_ENTRY ListEntry;\r\n/*0x038*/ ULONG32 LastTotalAllocates;\r\nunion\r\n{\r\n/*0x03C*/ ULONG32 LastAllocateMisses;\r\n/*0x03C*/ ULONG32 LastAllocateHits;\r\n};\r\n/*0x040*/ ULONG32 Future[2];\r\n} GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;\r\nIn this structure, SingleListHead.Next points to the first free pool chunk\r\non the singly-linked lookaside list. The size of the lookaside list is limited by\r\nthe value of Depth, periodically adjusted by the balance set manager4 accord\u0002ing to the number of hits and misses on the lookaside list. Hence, a frequently\r\nused lookaside list will have a larger Depth value than an infrequently used list.\r\nThe intial Depth is 4 (nt!ExMinimumLookasideDepth), with maximum being\r\nMaximumDepth (256). If a lookaside list is full, the pool chunk is freed to the\r\nappropriate ListHeads list instead.\r\nLookaside lists are also defined for the session pool. Paged session pool allo\u0002cations use separate lookaside lists (nt!ExpSessionPoolLookaside) defined in\r\nsession space. The maximum block size for the per-session lookaside lists is 0x19,\r\nas set by nt!ExpSessionPoolSmallLists. Session pool lookaside lists use the\r\nGENERAL LOOKASIDE structure, identical to GENERAL LOOKASIDE POOL but with\r\nadditional padding. For non-paged session pool allocations, the formerly dis\u0002cussed non-paged per-processor lookaside lists are used.\r\nLookaside lists for pool chunks are disabled if the hot/cold page separa\u0002tion pool flag is set (nt!ExpPoolFlags & 0x100). The flag is set during sys\u0002tem boot-up to increase speed and reduce memory footprint. A timer (set in\r\nnt!ExpBootFinishedTimer) turns off hot/cold page separation 2 minutes after\r\nboot.\r\n2.6 Large Pool Allocations\r\nThe pool descriptor ListHeads maintains chunks less than a page. Pool al\u0002locations greater than 4080 bytes (requiring a page or more) are handled by\r\nnt!ExpAllocateBigPool. In turn, this function calls nt!MiAllocatePoolPages,\r\nthe pool page allocator, which rounds the requested size up to the nearest page\r\nsize. A ”frag” chunk of block size 1 and previous size 0 is placed immediately\r\nafter the large pool allocation such that the pool allocator can make use of the\r\nremaining page fragment. The excess bytes are then put back at the tail of the\r\nappropriate pool descriptor ListHeads list.\r\n4 The balance set manager is a system thread executing nt!KeBalanceSetManager\r\nwhich periodically processes work items and resizes lookaside lists.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/4ccd2031-de5f-45f5-97d7-6714b37fb06b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=363a36a7ac5b76c075592d85f049322681688dad3a5e7b241745a9df5ba46037",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 358
      },
      {
        "segments": [
          {
            "segment_id": "8bbf603d-a42b-4cab-bf66-3bb6a64c6a4a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Recall from Section 2.1 that each node (defined by KNODE) has 4 singly-linked\r\nlookaside lists associated with them. These lists are used by the pool page al\u0002locator in rapidly servicing requests for small page counts. For paged memory,\r\nKNODE defines one lookaside list (PagedPoolSListHead) for single page alloca\u0002tions. For non-paged allocations, lookaside lists (NonPagedPoolSListHead[3])\r\nfor page counts 1, 2, and 3 are defined. The size of the pool page lookaside lists\r\nis determined by the number of physical pages present in the system.\r\nIf lookaside lists cannot be used, an allocation bitmap is used to obtain the re\u0002quested pool pages. The bitmap (defined in RTL BITMAP) is an array of bits that\r\nindicate which memory pages are in use and is created for every major pool type.\r\nIt is searched for the first index that holds the requested number of unused pages.\r\nFor the paged pool, the bitmap is defined in the MM PAGED POOL INFO struc\u0002ture, pointed to by nt!MmPagedPoolInfo. For the non-paged pool, the bitmap\r\nis pointed to by nt!MiNonPagedPoolBitMap. For the session pool, the bitmap is\r\ndefined in the MM SESSION SPACE structure.\r\nFor most large pool allocations, nt!ExAllocatePoolWithTag will request\r\nan additional 4 bytes (8 on x64) to store the allocation size at the end of the\r\npool body. This value is subsequently checked when the allocation is freed (in\r\nExFreePoolWithTag) to catch possible pool overflows.\r\n2.7 Allocation Algorithm\r\nIn order to allocate pool memory, kernel modules and third-party drivers call\r\nExAllocatePoolWithTag (or any of its wrapper functions), exported by the ex\u0002ecutive kernel. This function will first attempt to use the lookaside lists, followed\r\nby the ListHeads lists, and if no pool chunk could be returned, request a page\r\nfrom the pool page allocator. The following pseudocode roughly outlines its im\u0002plementation.\r\nPVOID\r\nExAllocatePoolWithTag( POOL_TYPE PoolType,\r\nSIZE_T NumberOfBytes,\r\nULONG Tag)\r\n// call pool page allocator if size is above 4080 bytes\r\nif (NumberOfBytes > 0xff0) {\r\n// call nt!ExpAllocateBigPool\r\n}\r\n// attempt to use lookaside lists\r\nif (PoolType & PagedPool) {\r\nif (PoolType & SessionPool && BlockSize <= 0x19) {\r\n// try the session paged lookaside list\r\n// return on success\r\n}\r\nelse if (BlockSize <= 0x20) {\r\n// try the per-processor paged lookaside list",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/8bbf603d-a42b-4cab-bf66-3bb6a64c6a4a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0092956f05f643cadefd55f08af74e7b099cba613461c681de30b2deae21a094",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 368
      },
      {
        "segments": [
          {
            "segment_id": "7145b67c-3b0f-4732-a619-be71f3cfde24",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "// return on success\r\n}\r\n// lock paged pool descriptor (round robin or local node)\r\n}\r\nelse { // NonPagedPool\r\nif (BlockSize <= 0x20) {\r\n// try the per-processor non-paged lookaside list\r\n// return on success\r\n}\r\n// lock non-paged pool descriptor (local node)\r\n}\r\n// attempt to use listheads lists\r\nfor (n = BlockSize-1; n < 512; n++) {\r\nif (ListHeads[n].Flink == &ListHeads[n]) { // empty\r\ncontinue; // try next block size\r\n}\r\n// safe unlink ListHeads[n].Flink\r\n// split if larger than needed\r\n// return chunk\r\n}\r\n// no chunk found, call nt!MiAllocatePoolPages\r\n// split page and return chunk\r\nIf a chunk larger than the size requested is returned from the ListHeads[n]\r\nlist, the chunk is split. In order to reduce fragmentation, the part of the oversized\r\nchunk returned by the allocator depends on its relative page position. If the\r\nchunk is page aligned, the requested size is allocated from the front of the chunk.\r\nIf the chunk is not page aligned, the requested size is allocated from the back\r\nof the chunk. Either way, the remaining (unused) fragment of the split chunk is\r\nput at the tail of the appropriate ListHeads list.\r\n2.8 Free Algorithm\r\nThe free algorithm, implemented by ExFreePoolWithTag, inspects the pool\r\nheader of the chunk to be freed and frees it to the appropriate list. In order\r\nto reduce fragmentation, it also attempts to coalesce bordering free chunks. The\r\nfollowing pseudocode shows how the algorithm works.\r\nVOID\r\nExFreePoolWithTag( PVOID Entry,\r\nULONG Tag)\r\nif (PAGE_ALIGNED(Entry)) {\r\n// call nt!MiFreePoolPages\r\n// return on success\r\n}",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/7145b67c-3b0f-4732-a619-be71f3cfde24.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13c5fc9e100c27b5a51a498649bfa4db18e9f2c1d28a8ae3819b80fb5f1d7b04",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3db970f2-72cc-428a-a382-175743567436",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "if (Entry->BlockSize != NextEntry->PreviousSize)\r\nBugCheckEx(BAD_POOL_HEADER);\r\nif (Entry->PoolType & SessionPagedPool && Entry->BlockSize <= 0x19) {\r\n// put in session pool lookaside list\r\n// return on success\r\n}\r\nelse if (Entry->BlockSize <= 0x20) {\r\nif (Entry->PoolType & PagedPool) {\r\n// put in per-processor paged lookaside list\r\n// return on success\r\n}\r\nelse { // NonPagedPool\r\n// put in per-processor non-paged lookaside list\r\n// return on success\r\n}\r\n}\r\nif (ExpPoolFlags & DELAY_FREE) { // 0x200\r\nif (PendingFreeDepth >= 0x20) {\r\n// call nt!ExDeferredFreePool\r\n}\r\n// add Entry to PendingFrees list\r\n}\r\nelse {\r\nif (IS_FREE(NextEntry) && !PAGE_ALIGNED(NextEntry)) {\r\n// safe unlink next entry\r\n// merge next with current chunk\r\n}\r\nif (IS_FREE(PreviousEntry)) {\r\n// safe unlink previous entry\r\n// merge previous with current chunk\r\n}\r\nif (IS_FULL_PAGE(Entry))\r\n// call nt!MiFreePoolPages\r\nelse {\r\n// insert Entry to ListHeads[BlockSize - 1]\r\n}\r\n}\r\nThe DELAY FREE pool flag (nt!ExpPoolFlags & 0x200) enables a perfor\u0002mance optimization that frees several pool allocations at once to amortize pool\r\nacquisition and release. This mechanism was briefly mentioned in [11] and is\r\nenabled on Windows XP SP2 or higher if the number of available physical\r\npages (nt!MmNumberOfPhysicalPages) is greater or equal to 0x1fc00.5 When\r\nused, every new call to ExFreePoolWithTag appends the chunk to be freed to\r\nthe PendingFrees list, specific to each pool descriptor. If the list holds 32 or\r\nmore chunks (determined by PendingFreeDepth), it is processed in a call to\r\n5 Roughly translates to 508 megabytes of RAM on IA-32 and AMD64 architectures.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/3db970f2-72cc-428a-a382-175743567436.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1067be6a52a1076967264559233e514fe579fa7468ebd31f2865a545d6284984",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 505
      },
      {
        "segments": [
          {
            "segment_id": "f1969edd-fbba-479f-a252-dba5265a61c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "ExDeferredFreePool. This function iterates over each entry and frees it to the\r\nappropriate ListHeads list, as illustrated by the following pseudocode.\r\nVOID\r\nExDeferredFreePool( PPOOL_DESCRIPTOR PoolDesc,\r\nBOOLEAN bMultipleThreads)\r\nfor each (Entry in PendingFrees) {\r\nif (IS_FREE(NextEntry) && !PAGE_ALIGNED(NextEntry)) {\r\n// safe unlink next entry\r\n// merge next with current chunk\r\n}\r\nif (IS_FREE(PreviousEntry)) {\r\n// safe unlink previous entry\r\n// merge previous with current chunk\r\n}\r\nif (IS_FULL_PAGE(Entry))\r\n// add to full page list\r\nelse {\r\n// insert Entry to ListHeads[BlockSize - 1]\r\n}\r\n}\r\nfor each (page in full page list) {\r\n// call nt!MiFreePoolPages\r\n}\r\nFrees to the lookaside and pool descriptor ListHeads are always put in the\r\nfront of the appropriate list. Exceptions to this rule are remaining fragments of\r\nsplit blocks which are put at the tail of the list. Blocks are split when the memory\r\nmanager returns chunks larger than the requested size (as explained in Section\r\n2.7), such as full pages split in ExpBigPoolAllocation and ListHeads entries\r\nsplit in ExAllocatePoolWithTag. In order to use the CPU cache as frequently\r\nas possible, allocations are always made from the most recently used chunks,\r\nfrom the front of the appropriate list.\r\n2.9 AMD64/x64 Kernel Pool Changes\r\nDespite supporting a larger physical address space, x64 Windows does not in\u0002troduce any significant changes to the kernel pool. However, to accommodate\r\nthe change in pointer width, block size granularity is increased to 16 bytes, cal\u0002culated as BlockSize = (NumberOfBytes+0x1F) >> 4. To reflect this change,\r\nthe pool header is updated accordingly.\r\ntypedef struct _POOL_HEADER\r\n{\r\nunion\r\n{\r\nstruct",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/f1969edd-fbba-479f-a252-dba5265a61c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2792b14a2a7ab4de80da1f98864971037f44bc5448b0a62cc6c7248cda6eb3eb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 257
      },
      {
        "segments": [
          {
            "segment_id": "edb3bcd6-d509-4826-82d7-62e61a0c28f6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "{\r\n/*0x000*/ ULONG32 PreviousSize : 8;\r\n/*0x000*/ ULONG32 PoolIndex : 8;\r\n/*0x000*/ ULONG32 BlockSize : 8;\r\n/*0x000*/ ULONG32 PoolType : 8;\r\n};\r\n/*0x000*/ ULONG32 Ulong1;\r\n};\r\n/*0x004*/ ULONG32 PoolTag;\r\nunion\r\n{\r\n/*0x008*/ struct _EPROCESS* ProcessBilled;\r\nstruct\r\n{\r\n/*0x008*/ UINT16 AllocatorBackTraceIndex;\r\n/*0x00A*/ UINT16 PoolTagHash;\r\n/*0x00C*/ UINT8 _PADDING0_[0x4];\r\n};\r\n};\r\n} POOL_HEADER, *PPOOL_HEADER;\r\nDue to the change in block size granularity, PreviousSize and BlockSize\r\nare both reduced to eight bits. Thus, the pool descriptor ListHeads holds 256\r\ndoubly-linked lists, and not 512 as on x86. This also allows for an additional\r\nbit to be assigned to PoolIndex, hence 256 nodes (pool descriptors) may be\r\nsupported on x64, over 128 on x86. Furthermore, the pool header is expanded to\r\n16 bytes, and includes the ProcessBilled pointer used in quota management\r\nto identify the process charged for an allocation. On x86, this pointer is stored\r\nin the last four bytes of the pool body. We discuss attacks leveraging the quota\r\nprocess pointer in Section 3.5.\r\n3 Kernel Pool Attacks\r\nIn this section, we discuss several practical attacks on the Windows 7 kernel\r\npool. First, in Section 3.1, we show an attack on the LIST ENTRY structure in the\r\n(un)safe unlinking of ListHeads pool chunks. In Section 3.2 and Section 3.3 we\r\nshow attacks on the singly-linked lookaside and deferred free lists respectively.\r\nIn Section 3.4 we present an attack on the pool header of allocated chunks\r\nbeing freed, and finally, in Section 3.5 we show an attack on quota charged pool\r\nallocations.\r\n3.1 ListEntry Flink Overwrite\r\nIn order to address generic exploitation of kernel pool overflows, Windows 7\r\nperforms safe unlinking to validate the LIST ENTRY pointers of pool chunks\r\non ListHeads lists. However, in allocating a pool chunk from ListHeads[n]\r\n(for a given block size), the algorithm validates the LIST ENTRY structure of",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/edb3bcd6-d509-4826-82d7-62e61a0c28f6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0372412d7de4e37d23e9d0e4564255ee279eb86c3d64b3fa70134eef88c7a737",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 300
      },
      {
        "segments": [
          {
            "segment_id": "5edf3d29-5ca8-4652-90f2-ef9124e43ccb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "ListHeads[n] and not the structure of the actual chunk being unlinked. Con\u0002sequently, overwriting the forward link in a free chunk may cause the address of\r\nListHeads[n] to be written to an attacker controlled address (Figure 1). ListEntry\r\nFlink\r\nBlink\r\nPool Header\r\nFlink\r\nPool Header\r\nFlink\r\nFakeEntry\r\nBlink\r\nBlink\r\nPool Descriptor ListHeads\r\nListHeads[n].Blink\r\n(validated in safe unlink)\r\nListHeads[n].Flink\r\n(validated in safe unlink)\r\nPool overflow\r\nNextEntry.Blink\r\n(validated in safe unlink)\r\nPreviousEntry.Flink\r\n(validated in safe unlink)\r\nChunk to be unlinked\r\nAfter unlink\r\n• FakeEntry.Blink = ListHeads[n]\r\n• ListHeads[n].Flink = FakeEntry\r\nFig. 1. ListEntry Flink Overwrite\r\nThis attack requires at least two free chunks to be present on the target\r\nListHeads[n] list. Otherwise, ListHeads[n].Blink will validate the unlinked\r\nchunk’s forward link. In Example 1, the forward link of a pool chunk on a\r\nListHeads list has been corrupted with an address chosen by the attacker. In\r\nturn, when this chunk is allocated in ExAllocatePoolWithTag, the algorithm\r\nattempts to write the address of ListHeads[n] (esi) at the backward link of\r\nthe LIST ENTRY structure at the attacker controlled address (eax).\r\neax=80808080 ebx=829848c0 ecx=8cc15768 edx=8cc43298 esi=82984a18 edi=[..]\r\neip=8296f067 esp=82974c00 ebp=82974c48 iopl=0 nv up ei pl zr na pe nc\r\ncs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010246\r\nnt!ExAllocatePoolWithTag+0x4b7:\r\n8296f067 897004 mov dword ptr [eax+4],esi ds:0023:80808084=????????\r\nExample 1: ListEntry Flink overwrite\r\nAlthough the value of esi cannot easily be determined from a user-mode\r\ncontext, it is sometimes possible to infer its value. For instance, if only a single",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/5edf3d29-5ca8-4652-90f2-ef9124e43ccb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f660ae08bf2c7c82955c9c71b72bee5203e071c335642c764117de8176d47eb9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 240
      },
      {
        "segments": [
          {
            "segment_id": "91cc8f83-2407-430a-873c-2197f84ae3de",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "non-paged pool is defined (as discussed in 2.2), esi will point to a fixed loca\u0002tion (nt!NonPagedPoolDescriptor) in the data segment of ntoskrnl. If the\r\npool descriptor was allocated from memory, an assumption can be made about\r\nits whereabouts from the defined pool memory range. Thus, an attacker could\r\noverwrite important global variables [14] or kernel object pointers [6] (e.g. via a\r\npartial pointer overwrite) in order to gain arbitrary code execution.\r\nThe attacker can also extend the arbitrary write into a fully controlled kernel\r\nallocation using a user-mode pointer in the overwrite. This follows from the\r\nfact that ListHeads[n].Flink is updated to point to the next free chunk (the\r\nattacker controlled pointer) after unlinking the corrupted chunk. Because the\r\nbackward link at the attacker supplied address was updated to point back to\r\nListHeads[n], the pool allocator has no problems in safely unlinking the user\u0002mode pointer from the free list.\r\n3.2 Lookaside Next Pointer Overwrite\r\nLookaside lists are designed to be fast and lightweight, hence do not introduce the\r\nsame consistency checking as the doubly-linked ListHeads lists. Being singly\u0002linked, each entry on a lookaside list holds a pointer to the next entry. As there\r\nare no checks asserting the validity of these pointers, an attacker may, using a\r\npool corruption vulnerability, coerce the pool allocator into returning an arbi\u0002trary address in retrieving the next free lookaside chunk. In turn, this may allow\r\nthe attacker to corrupt arbitrary kernel memory.\r\nHeader\r\nNext\r\narbitrary \r\naddress\r\nPPNPagedLookasideList[0]\r\nPPNPagedLookasideList[1] ListHead\r\nNext\r\nDepth\r\nPPNPagedLookasideList[2]\r\nPer-Processor Non\u0002Paged Lookaside Lists\r\nPool overflow\r\nPool overflow into a \r\nlookaside list chunk\r\nPPNPagedLookasideList[0]\r\nPPNPagedLookasideList[1] ListHead\r\nNext\r\nDepth\r\nPPNPagedLookasideList[2]\r\nAfter an allocation has been \r\nmade for BlockSize 2, the \r\nNext pointer points to the \r\nattacker supplied address \r\narbitrary \r\naddress\r\nFig. 2. Lookaside Pool Chunk Pointer Overwrite",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/91cc8f83-2407-430a-873c-2197f84ae3de.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8b01d207bc34acf6375f07ed11762940e78e7f74897fd69bbb2dfbe46db1b773",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 294
      },
      {
        "segments": [
          {
            "segment_id": "a81d8ce3-aad1-49a7-87ea-2db8571d418b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "As discussed in Section 2.5, the memory manager uses lookaside lists both\r\nfor pool chunks and pool pages. For lookaside pool chunks, the Next pointer\r\ndirectly follows the 8-byte pool header (POOL HEADER). Thus, overwriting the\r\nNext pointer requires at most a 12-byte overflow on x86. In order for a pool\r\nchunk to be freed to a lookaside list, the following must hold:\r\n– BlockSize <= 0x20 for (paged/non-paged) pool chunks\r\n– BlockSize <= 0x19 for paged session pool chunks\r\n– Lookaside list for target BlockSize is not full\r\n– Hot/cold page separation is not used (ExpPoolFlags & 0x100)\r\nIn order to extend a lookaside Next pointer corruption into an n-byte arbi\u0002trary memory overwrite, allocations of the target block size must be made until\r\nthe corrupted pointer is returned (Figure 2). Furthermore, the contents of the\r\nallocated chunk must be controlled to some degree in order to influence the data\r\nused to overwrite. For paged pool allocations, native APIs that allocate unicode\r\nstrings such as NtCreateSymbolicLinkObject provide a convenient way for fill\u0002ing any sized chunk with almost any combination of bytes. Such APIs can also be\r\nused in defragmenting and manipulating the pool memory layout for controlling\r\nexploitable primitives such as uninitialized pointers and double frees.\r\nPagedPoolSListHead\r\nNonPagedPool\r\nSListHead[0]\r\nNext\r\nDepth\r\nNonPagedPoolSListHead[1]\r\nNonPagedPoolSListHead[2]\r\nNode (KNODE)\r\nPool page\r\n(0x1000 \r\nbytes)\r\nNext Pool overflow\r\nPage-aligned pointer to \r\nnext lookaside pool page\r\nPagedPoolSListHead\r\nNonPagedPool\r\nSListHead[0]\r\nNext\r\nDepth\r\nNonPagedPoolSListHead[1]\r\nNonPagedPoolSListHead[2]\r\narbitrary \r\naddress\r\nMiAllocatePoolPages\r\nreturns a page with an \r\naddress we control\r\narbitrary \r\naddress\r\nFig. 3. Lookaside Pool Page Pointer Overwrite",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/a81d8ce3-aad1-49a7-87ea-2db8571d418b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4ae571db30f2ce15f1b11eea0f5d7d09bf2420426dc5662cf87a20bc501eb236",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 256
      },
      {
        "segments": [
          {
            "segment_id": "a21dcb65-a3e2-47c2-9466-20f896a07f93",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Unlike lookaside pool chunks, lookaside pool pages (Figure 3) store the Next\r\npointer at offset null as there are no pool headers associated with them. An\r\nallocated pool page is freed to a lookaside list if the following hold:\r\n– NumberOfPages = 1 for paged pool pages\r\n– NumberOfPages <= 3 for non-paged pool pages\r\n– Lookaside list for target page count is not full\r\nPool pages are returned by nt!MiAllocatePoolPages whenever the mem\u0002ory manager has to request additional pool memory, not available from the\r\nListHeads or lookaside lists. As this is commonly performed by many concur\u0002rent system threads, manipulating the kernel pool layout in order to position\r\nan overflow next to a free pool page on a lookaside list is obviously easier said\r\nthan done. When working with lookaside pool chunks, on the other hand, it\r\nis possible to use infrequently requested block size values in order to get more\r\nfine-grained control of the memory layout. This can be done by examining the\r\nTotalAllocates value in the lookaside management structures.\r\n3.3 PendingFrees Next Pointer Overwrite\r\nRecall from Section 2.8 that pool entries waiting to be freed are stored on singly\u0002linked PendingFrees lists. As no checks are performed in traversing these lists,\r\nan attacker could leverage a pool corruption vulnerability to corrupt the Next\r\npointer of a PendingFrees list entry. In turn, this would allow the attacker to\r\nfree an arbitrary address to a chosen pool descriptor ListHeads list and possibly\r\ncontrol the memory of subsequent pool allocations (Figure 4).\r\n0x0 PoolType\r\n0x4 PagedLock\r\n…\r\n0x100 PendingFrees\r\n0x104 PendingFreesDepth\r\n0x140 ListHeads[512]\r\n0x140\r\n+ N*8\r\nAttacker controlled address is \r\nreturned in requesting memory \r\nfrom ListHeads[n]\r\nPaged Pool Descriptor\r\nData\r\nPool Header\r\nNext\r\nFlink\r\nBlink\r\nPool Header\r\nFlink\r\nBlink\r\narbitrary \r\naddress\r\nPool overflow\r\nPut in front of \r\nListHeads[n] on free\r\nFig. 4. PendingFrees Pointer Overwrite",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/a21dcb65-a3e2-47c2-9466-20f896a07f93.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d07c0dd0fac45a19d0649a1a5c4078c637d253cd1b44232026c7f7c7705051a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "7065c92f-ec4c-4418-a6d2-961521cac6d0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "One notable caveat to attacking the deferred free list is that the kernel pool\r\nprocesses this list very often (once every 32nd free). Hundreds of threads could\r\nin fact be scheduled to the same kernel pool, and also be processed in parallel6\r\non multi-core machines. Thus, it is very likely that a chunk targeted by a pool\r\noverflow already has been removed from the deferred free list and put on a\r\nListHeads list. For this reason, we can hardly consider this attack practical.\r\nHowever, as some pool descriptors are used less frequently than others (such as\r\nthe session pool descriptor), attacks on the deferred free list may be feasible in\r\ncertain situations.\r\n3.4 PoolIndex Overwrite\r\nIf more than one pool descriptor is defined for a given pool type, a pool chunk’s\r\nPoolIndex denotes the index into the associated pool descriptor array. Hence,\r\nupon working with ListHeads entries, a pool chunk is always freed to its proper\r\npool descriptor. However, due to insufficient validation, a malformed PoolIndex\r\nmay trigger an out-of-bounds array dereference and subsequently allow an at\u0002tacker to overwrite arbitrary kernel memory.\r\n8b1ac000\r\n8b1ad140\r\n8b1ae280\r\n8b1af3c0\r\n8b1b0500\r\n0\r\n0\r\n0\r\n0\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n…\r\n15\r\nPool Header PreviousSize PoolIndex BlockSize PoolType\r\nData\r\n0x0 PoolType\r\n0x4 PagedLock\r\n…\r\n0x100 PendingFrees\r\n0x104 PendingFreesDepth\r\n0x140 ListHeads[512]\r\nIndex Virtual Address\r\nFlink\r\nPool Header\r\nBlink\r\n0x140\r\n+ N*8\r\nFlink\r\nBlink\r\nUser-controlled \r\npointers\r\nUpdated with pointer \r\nto our freed chunk \r\nWe allocate the virtual \r\nnull memory page to \r\ncontrol the contents of \r\nthe paged pool \r\ndescriptor\r\nFreed pool chunk\r\nnt!ExpPagedPoolDescriptor\r\nNULL Paged Pool Descriptor\r\nPoolIndex set to 5\r\nFig. 5. PoolIndex Overwrite on Free\r\nFor paged pools, PoolIndex always denotes an index into the paged pool\r\ndescriptor array (nt!ExpPagedPoolDescriptor). On checked builds, the index\r\n6 Each pool descriptor implements a lock, so two threads will never actually operate\r\non the same free list simultaneously.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/7065c92f-ec4c-4418-a6d2-961521cac6d0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c43adbb84afda6e4645f657024e2e1d6507edd23149d8c3c99d1e28dc1caf0d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 313
      },
      {
        "segments": [
          {
            "segment_id": "ba686817-69ab-405d-b3a2-abd90e2a17c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "value is validated in a compare against nt!ExpNumberOfPagedPools to pre\u0002vent any out-of-bounds array access. However, on free (retail) builds, the in\u0002dex is not validated. For non-paged pools, PoolIndex denotes an index into\r\nnt!ExpNonPagedPoolDescriptor only when there are multiple nodes present in\r\na NUMA-aware system. Again, on free builds, PoolIndex is not validated.\r\nA malformed PoolIndex (requiring only a 2-byte pool overflow) may cause an\r\nallocated pool chunk to be freed to a null-pointer pool descriptor (Figure 5). By\r\nmapping the virtual null-page, an attacker may fully control the pool descriptor\r\nand its ListHeads entries. In turn, this may allow the attacker to write the\r\naddress of a pool chunk to an arbitrary address when linking in to a list. This is\r\nbecause the Blink of the chunk currently in front is updated with the address\r\nof the freed chunk, such that ListHeads[n].Flink->Blink = FreedChunk. Of\r\nnote, as the freed chunk is not returned to any real pool descriptor, there is no\r\nneed to clean up (remove stale entries, etc.) the kernel pool.\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n…\r\nPool Header PreviousSize PoolIndex BlockSize PoolType\r\nData\r\n0x0 PoolType\r\n0x4 PagedLock\r\n…\r\n0x100 PendingFrees\r\n0x104 PendingFreesDepth\r\n0x140 ListHeads[512]\r\nVirtual \r\nAddress\r\nIndex\r\n0x140\r\n+ N*8\r\nFreed chunks are put in front of the \r\nlinked list, hence the blink of the block \r\npreviously in front is updated\r\nWe allocate the virtual null \r\nmemory page to control \r\nthe contents of the ”null” \r\npaged pool descriptor\r\n15\r\nFreed pool chunk Paged Pool Descriptor\r\nData\r\nPool Header\r\nNext\r\nnt!ExpPagedPoolDescriptor\r\n1\r\nst chunk to be \r\nlinked into \r\nListHeads[n]\r\nFlink\r\nBlink\r\n8b1ac000\r\n8b1ad140\r\n8b1ae280\r\n8b1af3c0\r\n8b1b0500\r\n0\r\n0\r\n0\r\nPool Header\r\nFlink\r\nBlink\r\nPool Header\r\nFlink\r\nBlink\r\nPut in front of ListHeads[n]\r\nFig. 6. PoolIndex Overwrite on Delayed Free\r\nIf delayed pool frees (as described in Section 2.8) is enabled, a similar effect\r\ncan be achieved by creating a fake PendingFrees list (Figure 6). In this case, the\r\nfirst entry on the list would point to an attacker controlled address. Additionally,\r\nthe value of PendingFreeDepth in the pool descriptor would be greater or equal\r\nto 0x20 to trigger processing of the PendingFrees list.\r\nExample 2 demonstrates how a PoolIndex overwrite could potentially cause\r\na user-controlled page address (eax) to be written to an arbitrary destination\r\naddress (esi). In order to execute arbitrary code, an attacker could leverage",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/ba686817-69ab-405d-b3a2-abd90e2a17c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd83b7c333ae6891e6058d9063197e25caaf23b33fa0b5ab0289bcbc611ec45b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 389
      },
      {
        "segments": [
          {
            "segment_id": "a59787f5-7470-4afc-9ad1-809abf9e9625",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "this method to overwrite an infrequently used kernel function pointer with the\r\nuser-mode page address, and trigger its execution from the same process context.\r\neax=20000008 ebx=000001ff ecx=000001ff edx=00000538 esi=80808080 edi=[..]\r\neip=8293c943 esp=9c05fb20 ebp=9c05fb58 iopl=0 nv up ei pl nz na po nc\r\ncs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010202\r\nnt!ExDeferredFreePool+0x2e3:\r\n8293c943 894604 mov dword ptr [esi+4],eax ds:0023:80808084=????????\r\nExample 2: PoolIndex overwrite on delayed free\r\nThe PoolIndex overwrite attack can be applied to any pool type if also\r\nthe chunk’s PoolType is overwritten (e.g. by setting it to PagedPool). As this\r\nrequires the BlockSize to be overwritten as well, the attacker must either know\r\nthe size of the overflown chunk or create a fake bordering chunk embedded inside\r\nit. This is required as FreedBlock->BlockSize = NextBlock->PreviousSize\r\nmust hold, as checked by the free algorithm. Additionally, the block size should\r\nbe greater than 0x20 to avoid lookaside lists (which ignore the PoolIndex). Note,\r\nhowever, that embedded pool chunks may potentially corrupt important fields\r\nor pointers in the chunk data.\r\n3.5 Quota Process Pointer Overwrite\r\nAs processes can be charged for allocated pool memory, pool allocations must\r\nprovide sufficient information for the pool algorithms to return the charged quota\r\nto the right process. For this reason, pool chunks may optionally store a pointer\r\nto the associated process object. On x64, the process object pointer is stored in\r\nthe last eight bytes of the pool header as described in Section 2.9, while on x86,\r\nthe pointer is appended to the pool body. Overwriting this pointer (Figure 7) in\r\na pool corruption vulnerability could allow an attacker to free an in-use process\r\nobject or corrupt arbitrary memory in returning the charged quota.\r\nPool Header\r\nPool Header\r\nPreviousSize\r\nPoolIndexBlockSize\r\nPoolType\r\nData Process \r\nPointer Pool overflow …\r\nPool \r\nHeader\r\nFig. 7. Quota Process Pointer Overwrite (x64)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/a59787f5-7470-4afc-9ad1-809abf9e9625.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f9330c5c9d23f7f72ae45f4ee3870536f19e59e5176d6c4852c4253193af8f0e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 299
      },
      {
        "segments": [
          {
            "segment_id": "f569649b-c80d-4e75-91fb-061363664a28",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Whenever a pool allocation is freed, the free algorithm inspects the pool type\r\nfor the quota bit (0x8) before actually returning the memory to the proper free\r\nlist or lookaside. If the bit is set, it will attempt to return the charged quota\r\nby calling nt!PspReturnQuota and then dereference the associated process ob\u0002ject. Thus, overwriting the process object pointer could allow an attacker to\r\ndecrement the reference (pointer) count of an arbitrary process object. Refer\u0002ence count inconsistencies could subsequently lead to use-after-frees if the right\r\nconditions are met (such as the handle count being zero when the reference count\r\nis lowered to zero).\r\nPool Header Process \r\nPointer Pool overflow Pool Header\r\nEPROCESS EPROCESS_QUOTA_BLOCK\r\nAddress of executive process object \r\ncontrolled by the attacker\r\nUsage counter decremented \r\non free, for which the address \r\nis controlled by the attacker\r\nQuota charged pool allocation (x86)\r\nFig. 8. Quota Process Pointer Overwrite (x86)\r\nIf the process object pointer is replaced with a pointer to user-mode mem\u0002ory, the attacker could create a fake EPROCESS object to control the pointer to\r\nthe EPROCESS QUOTA BLOCK structure (Figure 8), in which quota information is\r\nstored. On free, the value indicating the quota used in this structure is updated,\r\nby subtracting the size of the allocation. Thus, an attacker could decrement the\r\nvalue of an arbitrary address upon returning the charged quota. An attacker\r\ncan mount both attacks on any pool allocation as long as the quota bit and the\r\nquota process object pointer are both set.\r\n4 Case Study: CVE-2010-1893\r\nIn this section, we apply the PoolIndex overwrite technique described in Section\r\n3.4 to exploit a pool overflow in the Windows TCP/IP kernel module (CVE-2010-\r\n1893), addressed in MS10-058 [10]. The described attack operates solely on pool\r\nmanagement structures, hences does not rely on the data held within any of the\r\ninvolved pool chunks.\r\n4.1 About the Vulnerability\r\nThe Windows TCP/IP kernel module, or tcpip.sys, implements several functions\r\nfor controlling the mode of a socket. These functions are for the most part reach\u0002able from user-mode by calling WSAIoctl and providing the I/O control code for",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/f569649b-c80d-4e75-91fb-061363664a28.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=39e88a061567f85b314ce1e91c8bec6583811bd6b56d4fe88f4744f32e476a21",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 347
      },
      {
        "segments": [
          {
            "segment_id": "f52bb943-0a44-402c-a3e0-7e3befb541e9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "the desired operation. In specifying the SIO ADDRESS LIST SORT ioctl, tcpip.sys\r\ncalls IppSortDestinationAddresses() to sort a list of IPv6 and IPv4 destina\u0002tion addresses to determine the best available address for making a connection.\r\nThis function was found vulnerable [17] to an integer overflow on Windows\r\n7/Windows 2008 R2 and Windows Vista/Windows 2008 as it did not use safe\r\ninteger functions consistently. Consequently, specifying a large number of ad\u0002dresses for an address list could result in an undersized buffer allocation, leading\r\nto a pool overflow in IppFlattenAddressList().\r\nThe vulnerability essentially allows an attacker to corrupt adjacent pool\r\nmemory using any combination of bytes, in SOCKADDR IN6 sized records (0x1c\r\nbytes). The memory copy stops at the point where the sin6 family member\r\nof the structure no longer equals 0x17 (AF INET6). However, as this check is\r\nmade after the copy has taken place, the attacker is not required to set this field\r\nwhen overflowing only a single address record.\r\n4.2 Preparing Pool Memory\r\nAn important aspect of kernel pool exploitation is being able to consistently\r\noverwrite the desired memory. As the fragmented state of the kernel pool make\r\nthe locality of allocations unpredictable, the attacker must first defragment the\r\nkernel pool using kernel objects or other controllable memory allocations. The\r\ngoal in this respect is to allocate all the free chunks such that the pool allocator\r\nreturns a fresh page. Filling newly allocated pages with same sized allocations\r\nand freeing every second allocation allows the attacker to create holes for the\r\nvulnerable buffer to fall into. This would in turn enable the attacker to overflow\r\nthe object or memory allocation used to fill the kernel pool.\r\nkd> !pool @eax\r\nPool page 976e34c8 region is Nonpaged pool\r\n976e32e0 size: 60 previous size: 60 (Allocated) IoCo (Protected)\r\n976e3340 size: 60 previous size: 60 (Free) IoCo\r\n976e33a0 size: 60 previous size: 60 (Allocated) IoCo (Protected)\r\n976e3400 size: 60 previous size: 60 (Free) IoCo\r\n976e3460 size: 60 previous size: 60 (Allocated) IoCo (Protected)\r\n*976e34c0 size: 60 previous size: 60 (Allocated) *Ipas\r\nPooltag Ipas : IP Buffers for Address Sort, Binary : tcpip.sys\r\n976e3520 size: 60 previous size: 60 (Allocated) IoCo (Protected)\r\n976e3580 size: 60 previous size: 60 (Free) IoCo\r\n976e35e0 size: 60 previous size: 60 (Allocated) IoCo (Protected)\r\n976e3640 size: 60 previous size: 60 (Free) IoCo\r\nExample 3: Address sort buffer allocated in user fragmented pool",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/f52bb943-0a44-402c-a3e0-7e3befb541e9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0ee4b6a9e9cb1f8c4c695953f8ec88149b81bf54d1029afd3ee55ee628172940",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 392
      },
      {
        "segments": [
          {
            "segment_id": "4fce6e91-d739-4ab4-9e1e-41adcd26aefd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "In Example 3, the kernel pool has been filled with IoCompletionReserve\r\nobjects (using NtAllocateReserveObject [7]), for which every second alloca\u0002tion has been subsequently freed. Thus, when an address sort buffer match\u0002ing the size (three SOCKADDR IN6 entries) of the freed chunks is allocated in\r\nIppSortDestinationAddresses(), chances are that it will fall into one of the\r\nholes created.\r\n4.3 Using PoolIndex Overwrite\r\nIn order to leverage the PoolIndex attack, the attacker must overflow the pool\r\nheader of the following pool chunk and set its PoolType to PagedPool|InUse (3),\r\nand its PoolIndex to an out-of-bounds index (e.g. 5 on most single processor\r\nsystems), as shown in Example 4. This would cause a null-pointer pool descriptor\r\nto be referenced upon freeing the corrupted pool chunk.\r\nkd> dt nt!_POOL_HEADER 976e3520\r\n+0x000 PreviousSize : 0y000001100 (0xc)\r\n+0x000 PoolIndex : 0y0000101 (0x5) <-- out-of-bounds index\r\n+0x002 BlockSize : 0y000001100 (0xc)\r\n+0x002 PoolType : 0y0000011 (0x3) <-- PagedPool|InUse\r\n+0x000 Ulong1 : 0x60c0a0c\r\n+0x004 PoolTag : 0xef436f49\r\n+0x004 AllocatorBackTraceIndex : 0x6f49\r\n+0x006 PoolTagHash : 0xef43\r\nExample 4: Pool header after overflow - corrupting PoolIndex\r\nIn the function of Listing 1, we initialize the necessary pool descriptor values\r\nto carry out the attack. In this function, PoolAddress points to a user-controlled\r\npool chunk (e.g. allocated on a user-mode page), and WriteAddress sets the\r\naddress where the PoolAddress pointer is written.\r\nVOID\r\nInitPoolDescriptor ( PPOOL_DESCRIPTOR PoolDescriptor ,\r\nPPOOL_HEADER PoolAddress ,\r\nPVOID WriteAddress )\r\n{\r\nULONG i ;\r\nRtlZeroMemory ( PoolDescriptor , sizeof ( POOL_DESCRIPTOR ) ) ;\r\nPoolDescriptor - > PoolType = PagedPool ;\r\nPoolDescriptor - > PagedLock . Count = 1;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/4fce6e91-d739-4ab4-9e1e-41adcd26aefd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f04ba4a204d1f6b62d3d12eb2fb87ffd3a2f8bc8b73a642cb9247ff02bd6a4f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 262
      },
      {
        "segments": [
          {
            "segment_id": "64f6a128-b804-46e9-bfe6-cc609ad93b66",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "// create pending frees list\r\nPoolDescriptor - > PendingFreeDepth = 0 x20 ;\r\nPoolDescriptor - > PendingFrees = ( VOID **) ( PoolAddress +1) ;\r\n// create ListHeads entries with target address\r\nfor ( i =0; i <512; i ++) {\r\nPoolDescriptor - > ListHeads [ i ]. Flink = ( PCHAR )\r\nWriteAddress - sizeof ( PVOID ) ;\r\nPoolDescriptor - > ListHeads [ i ]. Blink = ( PCHAR )\r\nWriteAddress - sizeof ( PVOID ) ;\r\n}\r\n}\r\nListing 1. Function initializing a crafted pool descriptor\r\nWe assume the pending frees list to be used as most systems have 512MBs\r\nRAM or more. Thus, the address of the user-controlled pool chunk will end\r\nup being written to the address indicated by WriteAddress in the process of\r\nlinking in. This can be leveraged to overwrite a kernel function pointer, making\r\nexploitation trivial. If the pending frees list was not used, the address of the\r\nfreed kernel pool chunk (a kernel address) would end up being written to the\r\naddress specified, in which case other means such as partial pointer overwrites\r\nwould be required to execute arbitrary code.\r\nThe final task before triggering the overflow is to initialize the memory\r\npointed to by PoolAddress such that the fake pool chunk (on the pending frees\r\nlist) is properly returned to the crafted ListHeads lists (triggering the arbitrary\r\nwrite). In the function of Listing 2 we create a layout of two bordering pool\r\nchunks for which PoolIndex again references an out-of-bounds index into the\r\nassociated pool descriptor array. Additionally, BlockSize must be large enough\r\nto avoid lookaside lists from being used.\r\n# define BASE_POOL_TYPE_MASK 1\r\n# define POOL_IN_USE_MASK 2\r\n# define BLOCK_SHIFT 3 // 4 on x64\r\nVOID\r\nInitPoolChunks ( PVOID PoolAddress , USHORT BlockSize )\r\n{\r\nPOOL_HEADER * pool ;\r\nSLIST_ENTRY * entry ;\r\n// chunk to be freed\r\npool = ( POOL_HEADER *) PoolAddress ;\r\npool - > PreviousSize = 0;\r\npool - > PoolIndex = 5; // out - of - bounds pool index\r\npool - > BlockSize = BlockSize ;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/64f6a128-b804-46e9-bfe6-cc609ad93b66.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9fcfcc28d3544adc8ef3fa83f9a8d9d89752547c6993f3df0aa17d4379ce9991",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 343
      },
      {
        "segments": [
          {
            "segment_id": "8bd9401c-950a-4326-b32a-e3c4b60f6aeb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "pool - > PoolType = POOL_IN_USE_MASK | ( PagedPool &\r\nBASE_POOL_TYPE_MASK ) ;\r\n// last chunk on the pending frees list\r\nentry = ( SLIST_ENTRY *) (( PCHAR ) PoolAddress + sizeof (\r\nPOOL_HEADER ) ) ) ;\r\nentry - > Next = NULL ;\r\n// bordering chunk ( busy to avoid coalescing )\r\npool = ( POOL_HEADER *) (( PCHAR ) PoolAddress + ( BlockSize\r\n<< BLOCK_SHIFT ) ) ;\r\npool - > PreviousSize = BlockSize ;\r\npool - > PoolIndex = 0;\r\npool - > BlockSize = BlockSize ;\r\npool - > PoolType = POOL_IN_USE_MASK | ( PagedPool &\r\nBASE_POOL_TYPE_MASK ) ;\r\n}\r\nListing 2. Function initializing a crafted pool layout\r\n5 Kernel Pool Hardening\r\nWhile the introduction of safe unlinking is a step in the right direction, kernel\r\npool exploitation prevention still has a long way to go in terms of matching up\r\nagainst the robustness of the userland heap. In this section, we propose ways\r\nto address the attacks discussed in Section 3, as well as suggestions on how to\r\nfurther improve the kernel pool.\r\n5.1 ListEntry Flink Overwrite\r\nSafe unlinking was introduced in the kernel pool to prevent generic exploitation\r\nof pool overflows. However, as shown in Section 3.1, insufficient validation may\r\nallow an attacker to corrupt arbitrary memory while allocating an entry from a\r\nfree list (ListHeads). As previously pointed out, this is caused by safe unlinking\r\nnot being performed on the actual chunk being unlinked, but rather on the\r\nLIST ENTRY structure of the target ListHeads array entry. Thus, an easy fix\r\nwould be to properly validate the forward and backward link of the chunk being\r\nunlinked.\r\nA prime concern in introducing additional mitigations to the already highly\r\noptimized pool management algorithms is whether these changes could signifi\u0002cantly impact performance [3]. The biggest concern is not the number of addi\u0002tional instructions introduced, but rather if the change requires additional paging\r\noperations, which are very expensive in terms of performance. Addressing the\r\nattack in Section 3.1 could possibly impact performance as the address of the\r\nunlinked chunk’s forward link is not guaranteed to be paged into memory, hence\r\ncould trigger a page-fault upon safe unlinking.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/8bd9401c-950a-4326-b32a-e3c4b60f6aeb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c5630472e44755f94d1b06ec2f4e3645da08cbf5d0eddcb1e308a3a5609c9fc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 361
      },
      {
        "segments": [
          {
            "segment_id": "eb3ddbbe-cedd-4690-a501-682ceecec017",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "5.2 Lookaside Next Pointer Overwrite\r\nAs lookaside lists are inherently insecure, addressing their shortcomings without\r\nmaking significant changes to the kernel pool is clearly a challenging task. In\r\nthe Vista and Windows 7 heap, lookaside lists have been removed in favor of the\r\nlow fragmentation heap [9]. The LFH avoids the use of embedded pointers and\r\ndramatically reduces an attacker’s ability to accurately manipulate the heap.\r\nThus, a similar approach could be used in the kernel. However, removing the\r\nhighly optimized lookaside lists would probably impact performance to some\r\ndegree.\r\nHeader PPNPagedLookasideList[0]\r\nPPNPagedLookasideList[1] ListHead\r\nNext\r\nDepth\r\nPPNPagedLookasideList[2]\r\nPer-Processor Non\u0002Paged Lookaside Lists\r\nCookie\r\nNext Pool overflow\r\nHeader\r\nCookie\r\nNext\r\nExAllocatePoolWithTag verifies \r\nCookie before returning the chunk\r\nFig. 9. Lookside pool chunk cookie\r\nAlternatively, pool chunk integrity checks could be added to help prevent\r\nexploitation of lookaside list pointers. As all pool chunks must reserve space\r\nfor the LIST ENTRY structure and lookaside pointers only require half the size\r\n(SLIST ENTRY), pool chunks on lookaside lists could store a 4 byte (or 8 on x64)\r\ncookie before the Next pointer (Figure 9). This cookie should be non-trivial to\r\ndetermine from user-mode and could be a random value (e.g. defined by the\r\nlookaside list structure or the processor control block) XOR’ed with the address\r\nof the chunk. Note, however, that this would not necessarily prevent exploitation\r\nin situations where an attacker can write to a chosen offset from an allocated\r\nchunk (array indexing vulnerabilities).\r\n5.3 PendingFrees Next Pointer Overwrite\r\nAs PendingFrees lists are singly-linked, they obviously share the same problems\r\nas the aforementioned lookaside lists. Thus, PendingFrees lists could also benefit\r\nfrom an embedded pool chunk cookie in order to prevent exploitation of pool\r\noverflows. Although a doubly-linked list could be used instead, this would require\r\nadditional locking in ExFreePoolWithTag (upon inserting entries to the list)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/eb3ddbbe-cedd-4690-a501-682ceecec017.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d8712bb87e81144d8b7fcf2db5571bc007c1990d2d108d5e699a5443c5930a8d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "0ce21285-147a-4ab7-b7b9-ac5ebe2612f0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "which would be computationally expensive and defeat the purpose of the deferred\r\nfree list.\r\n5.4 PoolIndex Overwrite\r\nAs PoolIndex is used as a pool descriptor array index, the proper way of ad\u0002dressing the attack is to validate its value against the total number of array\r\nentries before freeing a chunk. In turn, this would prevent an attacker from ref\u0002erencing an out-of-bounds array index and controlling the pool descriptor. The\r\nPoolIndex overwrite, as demonstrated in Section 4, could also be prevented if\r\nthe kernel pool performed validation on bordering chunks before linking in.\r\nNote that this technique was also another clear case of null-pointer abuse.\r\nThus, denying mapping of virtual address null (0) in non-system processes could\r\nbe a solution not only to address this particular attack, but many other ex\u0002ploitable null-pointer kernel vulnerabilities as well. Currently, the null page is\r\nprimarily used for backwards compatibility, such as by the Virtual Dos Machine\r\n(VDM) for addressing 16-bit memory in WOW applications. Hence, an attacker\r\ncould circumvent a null page mapping restriction by injecting into a WOW pro\u0002cess.\r\n5.5 Quota Process Pointer Overwrite\r\nIn Section 3.5 we showed how an attacker could leverage a pool corruption\r\nvulnerability to dereference an arbitrary process object pointer. This was par\u0002ticularly easy to perform on x64 systems as the pointer was being stored in the\r\npool header, and not at the end of the pool chunk as the case was with x86 sys\u0002tems. In order to prevent exploitation involving the use of this pointer, simple\r\nencoding (using a constant unknown to the attacker) could be used to obfuscate\r\nits actual value. However, an obvious problem with this approach is that pool\r\ncorruptions could be significantly more difficult to debug as improperly decoded\r\npointers would likely reference data unrelated to the crash. Still, there are cer\u0002tain checks that can be made to validate a decoded pointer, such as ensuring\r\nthat it is properly aligned and within expected bounds.\r\n6 Conclusion\r\nIn this paper we’ve shown that in spite of safe unlinking, the Windows 7 kernel\r\npool is still susceptible to generic attacks. However, most of the identified attack\r\nvectors can be addressed by adding simple checks or adopting exploit prevention\r\nfeatures from the userland heap. Thus, in future Windows releases and service\r\npacks, we are likely to see additional hardening of the kernel pool. In particular,\r\nthe kernel pool would benefit greatly from a pool header checksum or cookie in\r\norder to thwart exploitation involving pool header corruption or malicious pool\r\ncrafting.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/0ce21285-147a-4ab7-b7b9-ac5ebe2612f0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5ea80eeb4bd5801e2b0958e3fc719bdc0bfb27d26856ae448012d27441534e49",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 415
      },
      {
        "segments": [
          {
            "segment_id": "1976a6ca-fc13-4d4f-9e40-8c11903c1044",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "References\r\n[1] Alexander Anisimov: Defeating Microsoft Windows XP SP2 Heap\r\nProtection and DEP Bypass. http://www.ptsecurity.com/download/\r\ndefeating-xpsp2-heap-protection.pdf\r\n[2] Adam Barth, Collin Jackson, Charles Reis: The Security Architecture\r\nof the Chromium Browser. http://crypto.stanford.edu/websec/chromium/\r\nchromium-security-architecture.pdf\r\n[3] Pete Beck: Safe Unlinking in the Kernel Pool. Microsoft Security Re\u0002search and Defense. http://blogs.technet.com/srd/archive/2009/05/26/\r\nsafe-unlinking-in-the-kernel-pool.aspx\r\n[4] Dion Blazakis: Interpreter Exploitation: Pointer Inference and JIT Spraying. Black\r\nHat DC 2010. http://www.semantiscope.com/research/BHDC2010\r\n[5] Matt Conover & Oded Horovitz: Windows Heap Exploitation. CanSecWest 2004.\r\n[6] Matthew Jurczyk: Windows Objects in Kernel Vulnerability Exploita\u0002tion. Hack-in-the-Box Magazine 002. http://www.hackinthebox.org/misc/\r\nHITB-Ezine-Issue-002.pdf\r\n[7] Matthew Jurczyk: Reserve Objects in Windows 7. Hack-in-the-Box Magazine 003.\r\nhttp://www.hackinthebox.org/misc/HITB-Ezine-Issue-003.pdf\r\n[8] Kostya Kortchinsky: Real World Kernel Pool Exploitation. SyScan 2008. http:\r\n//www.immunitysec.com/downloads/KernelPool.odp\r\n[9] Adrian Marinescu: Windows Vista Heap Management Enhancements. Black\r\nHat USA 2006. http://www.blackhat.com/presentations/bh-usa-06/\r\nBH-US-06-Marinescu.pdf\r\n[10] Microsoft Security Bulletin MS10-058: Vulnerabilities in TCP/IP Could Allow\r\nElevation of Privilege. http://www.microsoft.com/technet/security/Bulletin/\r\nMS10-058.mspx\r\n[11] mxatone: Analyzing Local Privilege Escalation in win32k. Uninformed Journal,\r\nvol. 10, article 2. http://www.uninformed.org/?v=10&a=2\r\n[12] Office Team: Protected View in Office 2010. Microsoft Office 2010 Engi\u0002neering. http://blogs.technet.com/b/office2010/archive/2009/08/13/\r\nprotected-view-in-office-2010.aspx\r\n[13] Kyle Randolph: Inside Adobe Reader Protected Mode - Part 1 - Design. Adobe Se\u0002cure Software Engineering Team (ASSET) Blog. http://blogs.adobe.com/asset/\r\n2010/10/inside-adobe-reader-protected-mode-part-1-design.html\r\n[14] Ruben Santamarta: Exploiting Common Flaws in Drivers. http://reversemode.\r\ncom/index.php?option=com_remository&Itemid=2&func=fileinfo&id=51\r\n[15] Hovav Shacham: The Geometry of Innocent Flesh on the Bone: Return-into-libc\r\nwithout Function Calls (on the x86). In Proceedings of CCS 2007, pages 552561.\r\nACM Press, Oct. 2007.\r\n[16] SoBeIt: How To Exploit Windows Kernel Memory Pool. Xcon 2005. http:\r\n//packetstormsecurity.nl/Xcon2005/Xcon2005_SoBeIt.pdf\r\n[17] Matthieu Suiche: Microsoft Security Bulletin (August). http://moonsols.com/\r\nblog/14-august-security-bulletin",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/f870398a-4be2-4922-bb6c-418f4bf33d9d/images/1976a6ca-fc13-4d4f-9e40-8c11903c1044.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041604Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b7be1514a16b95460e1b56bcba88ad2e8c33548ae4859451ebebafd7dae9488",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 253
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\"title\": \"Kernel Pool Exploitation on Windows 7\"}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "```json\n{\"author\": \"Tarjei Mandt\"}\n```"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "2011\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": \"data segment of ntoskrnl\"}\n```"
        }
      ]
    }
  }
}