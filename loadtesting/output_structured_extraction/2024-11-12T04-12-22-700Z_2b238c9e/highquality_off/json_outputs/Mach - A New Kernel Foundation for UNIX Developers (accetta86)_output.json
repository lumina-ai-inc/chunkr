{
  "file_name": "Mach - A New Kernel Foundation for UNIX Developers (accetta86).pdf",
  "task_id": "7817e7be-efbe-4195-b457-fda6f43f16e6",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "a3e369a6-ff19-47ef-a26a-36b24efbe546",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Mach: A New Kernel Foundation For UNIX\r\nDevelopment\r\nMike Accetta, Robert Baron, William Bolosky, David Golub,\r\nRichard Rashid, Avadis Tevanian and Michael Young\r\nComputer Science Department\r\nCarnegie Mellon University\r\nPittsburgh, Pa. 15213\r\nAbstract\r\nMach is a multiprocessor operating system kernel and environment\r\nunder development at Carnegie Mellon University. Mach provides a new\r\nfoundation for UNIX development that spans networks of uniprocessors\r\nand multiprocessors. This paper describes Mach and the motivations that\r\nled to its design. Also described are some of the details of its implemen\u0002tation and current status.\r\n1 Introduction\r\nMach1is a multiprocessor operating system kernel currently under development\r\nat Carnegie-Mellon University. In addition to binary compatibility with Berke\u0002ley’s current UNIX2 4.3BSD release, Mach provides a number of new facilities\r\nnot available in 4.3:\r\n• Support for multiprocessors including:\r\n– provision for both tightly-coupled and loosely-coupled general pur\u0002pose multiprocessors and\r\n– separation of the process abstraction into tasks and threads, with the\r\nability to execute multiple threads within a task simultaneously.\r\n• A new virtual memory design which provides:\r\n– large, sparse virtual address spaces,\r\n0This research was sponsored by the Defense Advanced Research Projects Agency (DOD),\r\nARPA Order No. 4864, monitored by the Space and Naval Warfare Systems Command under\r\ncontract N00039-85-C-1034.\r\n1Mach is not a trademark of AT&T Bell Laboratories (so far as we know).\r\n2UNIX, however, is a trademark of AT&T Bell Laboratories.\r\n1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/a3e369a6-ff19-47ef-a26a-36b24efbe546.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=36bca83fdc44ff35e5f86b607ee5006d01c43b0a3057f35b116281c0ab5bee20",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 227
      },
      {
        "segments": [
          {
            "segment_id": "68910423-4b31-480a-9d9b-a39ccc9364bd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "– copy-on-write virtual copy operations,\r\n– copy-on-write and read-write memory sharing between tasks,\r\n– memory mapped files and\r\n– user-provided backing store objects and pagers.\r\n• A capability-based interprocess communication facility:\r\n– transparently extensible across network boundaries with preservation\r\nof capability protection and\r\n– integrated with the virtual memory system and capable of transfer\u0002ring large amounts of data up to the size of an address space via\r\ncopy-on-write techniques.\r\n• A number of basic system support facilities, including:\r\n– an internal adb-like kernel debugger,\r\n– support for transparent remote file access between autonomous sys\u0002tems,\r\n– language support for remote-procedure call style interfaces between\r\ntasks written in C, Pascal, and CommonLisp.\r\nThe basic Mach abstractions are intended not simply as extensions to the\r\nnormal UNIX facilities but as a new foundation upon which UNIX facilities can\r\nbe built and future development of UNIX-like systems for new architectures\r\ncan continue. The computing environment for which Mach is targeted spans a\r\nwide class of systems, providing basic support for large, general purpose mul\u0002tiprocessors, smaller multiprocessor networks and individual workstations (see\r\nfigure 1. As of April 1986, all Mach facilities, with the exception of threads,\r\nare operational and in production use on uniprocessors and multiprocessors by\r\nboth individuals and research projects at CMU. In this paper we describe the\r\nMach design, some details of its implementation and its current status.\r\n2 Design: an extensible kernel\r\nEarly in its development, UNIX supported the notion of objects represented as\r\nfile descriptors with a small set of basic operations on those objects (e.g., read,\r\nwrite and seek) [9]. With pipes serving as a program composition tool, UNIX\r\noffered the advantages of simple implementation and extensibility to a variety of\r\nproblems. Under the weight of changing needs and technology, UNIX has been\r\nmodified to provide a staggering number of different mechanisms for managing\r\nobjects and resources. In addition to pipes, UNIX versions now support facilities\r\nsuch as System V streams, 4.2 BSD sockets, pty’s, various forms of semaphores,\r\nshared memory and a mind-boggling array of ioctl operations on special files\r\nand devices. The result has been scores of additional system calls and options\r\n2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/68910423-4b31-480a-9d9b-a39ccc9364bd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6f2c529d8f55d625b394f660219ecc4d93475bc6fe62289c63c6d0f302fef429",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "3b8b8de0-450d-4065-9a22-c75c31c5cf0d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Large-scale\r\nMultiprocessor\r\nO(100) CPUs\r\nWorkstation … Workstation\r\nSmall-scale\r\nMicroprocessor\r\nSmall-scale\r\nMicroprocessor\r\n…\r\nLocal area net\r\nHigh\r\nspeed\r\nnet\r\nFigure 1: The Mach computing environment\r\nwith less than uniform access to different resources within a single UNIX system\r\nand within a network of UNIX machines.\r\nAs the complexity of distributed environments and multiprocessor archi\u0002tectures increases, it becomes increasingly important to return to the original\r\nUNIX model of consistent interfaces to system facilities. Moreover, there is a\r\nclear need to allow the underlying system to be transparently extended to allow\r\nuser-state processes to provide services which in the past could only be fully\r\nintegrated into UNIX by adding code to the operating system kernel.\r\nMach takes an essentially object-oriented approach to extensibility. It pro\u0002vides a small set of primitive functions designed to allow more complex services\r\nand resources to be represented as references to objects. The indirection thus\r\nprovided allows objects to be arbitrarily placed in the network (either within a\r\nmultiprocessor or a workstation) without regard to programming details. The\r\nMach kernel abstractions, in effect, provide a base upon which complete system\r\nenvironments may be built. By providing these basic functions in the kernel,\r\nit is possible to run varying system configurations on different classes of ma\u0002chines while providing a consistent interface to all resources. The actual system\r\nrunning on any particular machine is a function of its servers rather than its\r\nkernel.\r\nThe Mach kernel supports four basic abstractions:\r\n1. A task is an execution environment in which threads may run. It is the\r\nbasic unit of resource allocation. A task includes a paged virtual address\r\nspace and protected access to system resources (such as processors, port\r\ncapabilities and virtual memory). The UNIX notion of a process is , in\r\nMach, represented by a task with a single thread of control.\r\n2. A thread is the basic unit of CPU utilization. It is roughly equivalent\r\nto an independent program counter operating within a task. All threads\r\n3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/3b8b8de0-450d-4065-9a22-c75c31c5cf0d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1b4058193e6820c07ba57a21e4ba2f3e47ec8b2d3f5fdc76f20cdf197c108e02",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 327
      },
      {
        "segments": [
          {
            "segment_id": "29182064-2706-4050-9b7e-ce582eaaf037",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "within a task share access to all task resources.\r\n3. A port is a communication channel – logically a queue for messages pro\u0002tected by the kernel. Ports are the reference objects of the Mach design.\r\nThey are used in much the same way that object references could be\r\nused in an object oriented system. Send and Receive are the fundamental\r\nprimitive operations on ports.\r\n4. A message is a typed collection of data objects used in communication\r\nbetween threads. Messages may be of any size and may contain pointers\r\nand typed capabilities for ports.\r\nOperations on objects other than messages are performed by sending mes\u0002sages to ports which are used to represent them. The act of creating a task or\r\nthread, for example, returns access rights to the port which represents the new\r\nobject and which can be used to manipulate it. The Mach kernel acts in that\r\ncase as a server which implements task and thread objects. It receives incoming\r\nmessages on task and thread ports and performs the requested operation on the\r\nappropriate object. This allows a thread to suspend another thread by sending\r\na suspend message to that thread’s thread port even if the requesting thread is\r\non another node in a network.\r\nThe design of Mach draws heavily on CMU’s previous experience with the\r\nAccent [8] network operating system, extending that system’s facilities into the\r\nmultiprocessor domain:\r\n• the underlying port mechanism for communication provides support for\r\nobject-style access to resources and capability based protection as well as\r\nnetwork transparency,\r\n• all systems abstractions allow extensibility both to multiprocessors and to\r\nnetworks of uniprocessor or multiprocessor nodes,\r\n• support for parallelism (in the form of tasks with shared memory and\r\nthreads) allows for a wide range of tightly coupled and loosely coupled\r\nmultiprocessors and\r\n• access to virtual memory is simple, integrated with message passing, and\r\nintroduces no arbitrary restrictions on allocation, deallocation and virtual\r\ncopy operations and yet allows both copy-on-write and read-write sharing.\r\nThe Mach abstractions were chosen not only for their simplicity but also for\r\nperformance reasons. A performance evaluation study done on Accent demon\u0002strated the substantial performance benefits gained by integrating virtual mem\u0002ory management and interprocess communication. Using similar virtual mem\u0002ory and IPC primitives, Accent was able to achieve performance comparable to\r\nUNIX systems on equivalent hardware [3].\r\n4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/29182064-2706-4050-9b7e-ce582eaaf037.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f81ffb7ae158792e2080a53c9865aaa9a811145882150f4e83a5ae1096b6d4bd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 387
      },
      {
        "segments": [
          {
            "segment_id": "80bd64cb-2480-4475-a69c-154e3244f33b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "3 Tasks and Threads\r\nIt has been clear for some time that the UNIX process abstraction is insufficient\r\nto meet the needs of modern applications. The definition of a UNIX process\r\nresults in high overhead on the part of the operating system. Typical server ap\u0002plications, which use the fork operation to create a server for each client, tend to\r\nuse far more system resources than are required. In UNIX this includes process\r\nslots, file descriptor slots and page tables. To overcome this problem, many\r\napplication programmers make use of coroutine packages to manage multiple\r\ncontexts within a single process (see, for example, [2]).\r\nWith the introduction of general purpose shared memory multiprocessors,\r\nthe problem is intensified due to a need for many processes to implement a\r\nsingle parallel application. On a machine with N processors, for example, an\r\napplication will need at least N processes to utilize all of the processors. A\r\ncoroutine package is of no help in this case, as the kernel has no knowledge of\r\nsuch coroutines and can not schedule them.\r\nMach addresses this problem by dividing the process abstraction into two\r\northogonal abstractions: the task and thread. A task is a collection of system\r\nresources. These include a virtual address space and a set of port rights. A\r\nthread is the basic unit of computation. It is the specification of an execution\r\nstate within a task. A task is generally a high overhead object (much like a\r\nprocess), whereas a thread is a relatively low overhead object.\r\nTo overcome the previously mentioned problems with the process abstrac\u0002tion, Mach allows multiple threads to exist (execute) within a single task. On\r\ntightly coupled shared memory multiprocessors, multiple threads may execute\r\nin parallel. Thus, an application can use the full parallelism available, while\r\nincurring only a modest overhead on the part of the kernel.\r\nOperations on tasks and threads are invoked by sending a message to a port\r\nrepresenting the task or thread. Threads may be created (within a specified\r\ntask), destroyed, suspended and resumed. The suspend and resume operations,\r\nwhen applied to a task, affect all threads within that task. In addition, tasks\r\nmay be created (effectively forked), and destroyed.\r\nTasks are related to each other in a tree structure by task creation operations.\r\nRegions of virtual memory may be marked as inheritable read-write, copy-on\u0002write or not at all by future child tasks. A standard UNIX fork operation takes\r\nthe form of a task with one thread creating a child task with a single thread of\r\ncontrol and all memory shared copy-on-write.\r\nApplication parallelism in Mach can thus be achieved in any of three ways:\r\n• through the creation of a single task with many threads of control execut\u0002ing in a shared address space, using shared memory for communication\r\nand synchronization,\r\n• through the creation of many tasks related by task creation which share\r\nrestricted regions of memory or\r\n• through the creation of many tasks communicating via messages\r\n5",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/80bd64cb-2480-4475-a69c-154e3244f33b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c02fdc710819fd80fec0a355c450f06aada6fba60b217942555d019bd4d12018",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 493
      },
      {
        "segments": [
          {
            "segment_id": "e3c7bcf6-1c5c-4c72-87a6-34554c3e520c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "These alternatives reflect as well the different multiprocessor architectures\r\nto which Mach is targeted:\r\n• uniform access, shared memory multiprocessors such as the VAX3 11/784,\r\nVAX 8300 and Encore MultiMax4,\r\n• differential access shared memory machines such as the BBN Butterfly\r\nand IBM RP3,\r\n• loosely-coupled networks of computers.\r\nIn fact, the Mach abstractions of task, thread and port correspond to the\r\nphysical realization of many multiprocessors as nodes with shared memory, one\r\nor more processors and external communication ports.\r\n4 Virtual Memory Management\r\nThe Mach virtual memory design allows tasks to:\r\n• allocate regions of virtual memory,\r\n• deallocate regions of virtual memory,\r\n• set the protections on regions of virtual memory,\r\n• specify the inheritance of regions of virtual memory.\r\nIt allows for both copy-on-write and read/write sharing of memory between\r\ntasks. Copy-on-write virtual memory often is the result of form operations or\r\nlarge message transfers. Shared memory is created in a controlled fashion via\r\nan inheritance mechanism. Virtual memory related functions, such as pagein\r\nand pageout, may be performed by non-kernel tasks. Mach does not impose\r\nrestrictions on what regions may be specified for these operations, except that\r\nthey be aligned on system page boundaries (where the definition of the page\r\nsize is a boot-time parameter of the system).\r\nThe way Mach implements the UNIX fork is an example of Mach’s virtual\r\nmemory operations. When a fork operation is invoked, a new (child) address\r\nmap is created based on the old (parent) address map’s inheritance values.\r\nInheritance may be specified as shared, copy or none, and may be specified\r\non a per-page basis. Pages specified are shared, are shared for read and write\r\naccess by both the parent and child address maps. Those pages specified as\r\ncopy are effectively copied in the child map, however; for efficiency, copy-on\u0002write techniques are typically employed. An inheritance specification of none\r\nsignifies that the page is not passed to the child at all. In this case, the child’s\r\ncorresponding address is left unallocated. By default, newly allocated memory\r\nis inherited copy-on-write.\r\n3VAX is a trademark of Digital Equipment Corporation.\r\n4MultiMax is a trademark of Encore Computer.\r\n6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/e3c7bcf6-1c5c-4c72-87a6-34554c3e520c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=482d13bc6bdc269e3ffab9e39d0a8fb14ac34a1c6f3be39dc0111eca841fc956",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "31a69e00-c46c-4de0-9f74-f9ad5f578d70",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Like inheritance, protection may be specified on a per-page basis. For each\r\ngroup of pages there exist two protection values: the current and maximum\r\nprotection. The current protection controls actual hardware permissions. The\r\nmaximum protection specifies the maximum value that the current protection\r\nmay take. The maximum protection may never be raised, it may only be low\u0002ered. If the maximum protection is lowered to a level below the current pro\u0002tection, the current protection is also lowered to that level. Either protection\r\nis a combination of read, write, and execute permissions. Enforcement of these\r\npermissions is dependent on hardware support (for example, many machines do\r\nnot allow for explicit execute permissions, but those that do will be properly\r\nenforced).\r\nConsider the following example: Assume that a task with an empty address\r\nspace has the following operations applied to it:\r\nOperation Arguments Comments\r\nallocate 0-0x100000 allocate from 0 to 1 megabyte\r\nprotect 0-0x10000 read/current make 0-64K read only\r\ninherit 0x8000-0x20000 share make 32K - 128K shared on fork\r\nThe resulting address map will be a one megabyte address space, with the\r\nfirst 64K read-only and the range from 32K to 128K will be shared by children\r\ncreated with the fork operation.\r\nAn important feature of Mach’s virtual memory is the ability to handle page\r\nfaults and page-out data requests outside of the kernel. When virtual memory\r\nis created, special paging tasks may be specified to handle paging requests. For\r\nexample, to implement a memory mapped file, virtual memory is created with\r\nits pager specified as the file system. When a page fault occurs, the kernel will\r\ntranslate the fault into a request for data from the file system.\r\nMach provides some basic paging services inside the kernel. Memory with\r\nno pager is automatically zero filled, and page-out is done to a default pager.\r\nThe current default pager utilizes normal file systems, eliminating the need for\r\nseparate paging partitions.\r\n5 Virtual Memory Implementation\r\nGiven the wide range of virtual memory management built by hardware engi\u0002neers, it was important to separate machine dependent and machine indepen\u0002dent data structures and algorithms in the Mach virtual memory implemen\u0002tation. In addition, the complexity of potential sharing relationships between\r\ntasks dictated clean separation between kernel data structures which manage\r\nphysical resources and those which manage backing store objects.\r\nThe basic data structures used in the virtual memory implementation are:\r\naddress maps: doubly linked lists of map entries, each entry describing the\r\nproperties of a region of virtual memory. There is a single address map\r\nassociated with each task.\r\n7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/31a69e00-c46c-4de0-9f74-f9ad5f578d70.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=56b5374464d0f53fc308d7e80f60c0b5fe38a410ed51b697a4ef128ad6190da8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "445baef0-1a56-4f10-b1e3-75817cdc3aab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "Address Map 1 Address Map 2\r\nSharing Map\r\nBacking Store Options\r\nFigure 2: Task address maps\r\nVAX Page Tables RT/PC Inverted Page Table\r\nMachine Dependent Machine Inependent\r\nResident Memory VM Objects Address Maps\r\nFigure 3: Task address maps\r\n8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/445baef0-1a56-4f10-b1e3-75817cdc3aab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=85623a2c13992a3542fbb3d30079410de557deadee7734b26797327c7cacb629",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 460
      },
      {
        "segments": [
          {
            "segment_id": "23f1a000-9f9d-4cbb-a184-e4490a5ba941",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "share maps: special address maps that describe regions of memory that are\r\nshared between tasks. A sharing map provides a level of indirection from\r\naddress maps, allowing operations that affect shared memory to affect all\r\nmaps without back pointers.\r\nVM objects: units of backing storage. A VM object specifies resident pages\r\nas well as where to find non-resident pages. VM objects are pointed at\r\nby address maps. Shadow objects are used to hold pages that have been\r\ncopied after a copy-on-write fault.\r\npage structures: specify the current attributes for physical pages in the system\r\n(e.g., mapped in what object, active/reclaimable/free).\r\nThe virtual memory implementation is split between machine independent\r\nand machine dependent sections. The machine independent portion of the im\u0002plementation has full knowledge of all virtual memory related information.\r\nThe machine dependent portion, on the other hand, has a simple page vali\u0002date/invalidate/protect interface, and has no outside knowledge of other machine\u0002independent related data structures.\r\nOne advantage of this separation is the fact that the “page size” for different\r\nsections of the implementation need not be the same. For example, the machine\r\ndependent page size on a VAX is 512 bytes. The machine independent page size\r\nis a boot time variable that is a power of two of the machine dependent size.\r\nThe backing storage page size may vary with the backing store object.\r\nThe actual data structures used in a machine dependent implementation de\u0002pend on the target machine. For example, the VAX implementation maintains\r\nVAX page tables, whereas the RT/PC implementation maintains an Inverted\r\nPage Table. Since the machine independent section maintains all data struc\u0002tures, it is possible for a machine dependent implementation to garbage collect\r\nis mappings (e.g. throw away page tables on a VAX). The machine independent\r\nsection will then request the machine dependent section to map these pages\r\nagain when the mappings are once again needed.\r\nIn addition to the normal demand paging of tasks, the Mach virtual memory\r\nimplementation allows portions of the kernel to be paged. In particular, address\r\nmap entries are pageable in the current implementation.\r\n6 Interprocess Communication\r\nInterprocess communication in 4.3BSD can occur through a variety of mecha\u0002nisms: pipes, pty’s, signals, and sockets [7]. The primary mechanism for network\r\ncommunication, internet domain sockets, has the disadvantage of using global\r\nmachine specific names (IP based addresses) with no location independence and\r\nno protection. Data is passed uninterpreted by the kernel as streams of bytes.\r\nThe Mach interprocess communication facility is defined in terms of ports and\r\nmessages and provides both location independence, security and data type tag\u0002ging.\r\n9",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/23f1a000-9f9d-4cbb-a184-e4490a5ba941.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=105a77d8a05f31c50a56079dab583a2dd636e735b4f6d3499c21525a35a9227d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 425
      },
      {
        "segments": [
          {
            "segment_id": "5376fe7a-e431-4775-83ee-88b539877156",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "The port is the basic transport abstraction provided by Mach. A port is a\r\nprotected kernel object into which messages may be placed by tasks and from\r\nwhich messages may be removed. A port is logically a finite length queue of\r\nmessages sent by a task. Ports may have any number of senders but only one\r\nreceiver. Access to a port is granted by receiving a message containing a port\r\ncapability (to either send or receive).\r\nPorts are used by tasks to represent services or data structures. For exam\u0002ple, Flamingo [11], a window manager running under Mach on the MicroVAX II,\r\nuses a port to represent a window on a bitmap display. Operations on a window\r\nare requested by a client task by sending a message to the port representing that\r\nwindow. The window manager task then receives that message and handles the\r\nrequest. Ports used in this way can be thought of as though they were capabil\u0002ities to objects in an object oriented system [4]. The act of sending a message\r\n(and perhaps receiving a reply) corresponds to a cross-domain procedure call in\r\na capability based system such as Hydra [12] or StarOS [5].\r\nA message consists of a fixed length header and a variable size collection\r\nof typed data objects. Messages may contain both port capabilities and/or\r\nembedded pointers as long as both are properly typed. A single message may\r\ntransfer up to the entire address space of a task.\r\nMessages may be sent and received either synchronously or asynchronously.\r\nCurrently, signals can be used to handle incoming messages outside the flow of\r\ncontrol of a normal UNIX style process. A task could create or assign separate\r\nthreads to handle asynchronous events.\r\nTime t0\r\nA B\r\nP1 P2\r\nReceiver = A\r\nSenders = A\r\nMessages = 0\r\nReceiver = B\r\nSenders = A,B\r\nMessages = 1\r\nTime t1\r\nA B\r\nP1 P2\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 0\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 0\r\nTime t2\r\nA B\r\nP1 P2\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 1\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 0\r\nTime t3\r\nA B\r\nP1 P2\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 0\r\nReceiver = A\r\nSenders = A,B\r\nMessages = 0\r\nFigure 4: Typical message exchange\r\nFigure 4 shows a typical message interaction. A task A sends a message to a\r\nport P2. Task A has send rights to P2 and receive rights to a port P1. At some\r\nlater time, task B which has receive rights to port P2 receives that message\r\nwhich may in turn contain send rights to port P1 (for the purposes of sending\r\na reply message back to task A). Task B then (optionally) replies by sending a\r\nmessage to P1.\r\n10",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/5376fe7a-e431-4775-83ee-88b539877156.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=15d09fada0d629027bd50d7e14f7b8dfba0e351afe7a42d4ad19c322f26c383e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "6a5ae92e-ef0a-47c4-a26b-69a5c27a3f30",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Should port P2 have been full, task A would have had the option at the\r\npoint of sending the message to: (1) be suspended until the port was no longer\r\nfull, (2) have the message send operation return a port full error code, or (3)\r\nhave the kernel accept the message for future transmission to port P2 with the\r\nproviso that no further message can be sent by that task to port P2 until the\r\nkernel sends a message to A telling it the current message has been posted.\r\nSend Operation\r\nA B\r\nP1\r\nA Map Kernel Map B Map\r\nReceive Operation\r\nA B\r\nP1\r\nA Map Kernel Map B Map\r\nFigure 5: Memory mapping operations during message transfer\r\nFigure 5 shows Task A sending a large (for example, 24 megabyte) message to\r\na port P1. At the point the message is posted to P1, the part of A’s address space\r\ncontaining the message is marked copy-on-write – meaning any page referenced\r\nfor writing will be copied and the copy placed instead into A’s virtual memory\r\ntable. The copy-on-write data then resides in a temporary kernel address map\r\nuntil task B receives the message. At that point the data is removed from\r\nthe temporary address map. The operating system kernel determines where in\r\nthe address space of B the newly received message data is placed, allowing the\r\nkernel to minimize memory mapping overhead. Any attempt by either A or B\r\nto change a page of this copy-on-write data results in a copy of that page being\r\nmade and placed into that task’s address space.\r\n6.1 Defining interprocess interfaces\r\nInterprocess interfaces, including the interface to the Mach kernel, are defined\r\nusing an interface definition language called Matchmaker [6]. Matchmaker com\u0002piles these interface definition into remote procedure call stubs for various pro\u0002gramming languages including C, CommonLisp and a CMU variant of PAS\u0002CAL. These stubs use the Mach message system as their basic transport fa\u0002cility. Matchmaker interfaces can perform runtime type-checking and provide\r\n11",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/6a5ae92e-ef0a-47c4-a26b-69a5c27a3f30.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=784a50e44f3a58852a1cbb5e55ec3e3fef0490d506b86d946bf97e761ebbe97f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 331
      },
      {
        "segments": [
          {
            "segment_id": "c64b890a-aa35-4206-bf47-5a5ce403329d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "sufficient information in messages for network communication servers to per\u0002form routine data-type conversion and data re-alignment between machines of\r\ndifferent architectural types.\r\n6.2 Network communication and security\r\nBy itself, the Mach kernel does not provide any mechanisms to support inter\u0002process communication over the network. However, the definition of Mach IPC\r\nallows for communication to be transparently extended by user-level tasks called\r\nnetwork servers. A network server effectively acts as a local representative for\r\ntasks on remote nodes. Messages designed for ports with remote receivers are\r\nactually sent to the local network server.\r\nWhen a task sends a message to a destination port on another node, the\r\nforwarding of the message is transparent to the sender. The sender has no\r\ndirect means of determining whether the eventual destination port is local to its\r\nnode or is actually on a remote node. The security guarantees of the Mach port\r\ncapabilities can be extended into the network environment by network servers\r\nthrough the use of encryption [10].\r\nNetwork servers collectively implement the abstraction of network ports. A\r\nnetwork port is the network representation of a port to which tasks on more\r\nthan one node have access rights. Each network port is known by its network\r\nport identifier. A network server maintains a mapping between network ports\r\n(accessible to tasks on its node) and their corresponding local ports.\r\nIn operation, when a network server receives a message from a task trying\r\nto send a message to a remote destination port, it maps the local destination\r\nport into a destination network port identifier. The network server then derives\r\nthe address of the destination node from the network port identifier and sends\r\nthe message over the network to this node. The destination network server,\r\non receiving the network message, maps the network port identifier into a local\r\ndestination port and forwards the message to its ultimate destination. Each\r\nnetwork server holds receive rights to those network ports for which the receive\r\nrights to the corresponding local ports are held by local tasks. Send and owner\u0002ship rights to network ports are handled in the same way except that send rights\r\nto a network port may be held by many network servers. Messages are typed\r\ncollections of data objects and any message may contain port access rights. Net\u0002work servers must examine the type tags of data sent or received in messages\r\nover the network to recognize the transmission of such access rights and take\r\nappropriate action. Currently Mach’s network servers handle data-type conver\u0002sion and re-alignment for three different machine architectures: the DEC VAX,\r\nIBM RT/PC5, and PERQ Systems PERQ6.\r\n5RT/PC is a trademark of International Business Machines.\r\n6PERQ is a trademark of PERQ Systems Corporation.\r\n12",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/c64b890a-aa35-4206-bf47-5a5ce403329d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ce874df212f6476dc18befb16386d30a7800d3b4a4ff744790ce569c9faae4ee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 448
      },
      {
        "segments": [
          {
            "segment_id": "ac80ad68-d199-450d-bf7e-1c309c140b1f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "7 System Support Facilities\r\nIn addition to the basic system support facilities provided by 4.3, Mach provides\r\na kernel debugger and a transparent remote file system.\r\n7.1 Kernel Debugger\r\nKernel debugging has always been a tedious undertaking. UNIX systems tra\u0002ditionally have no support for kernel debugging, requiring kernel implementors\r\nto “debug with printfs” or other ad hoc methods. The Mach kernel has a built\u0002in kernel debugger (kdb) based on adb7\r\n. All adb commands are implemented\r\nincluding support for breakpoints, single instruction step, stack tracing and\r\nsymbol table translation.\r\nIn order to aid debugging, as well as study the performance of the kernel,\r\nthe Mach debugger also supports functions not available in adb. For example:\r\nenhanced stack traces: stack traces may contain the values of local variables\r\nand registers for each stack frame.\r\ncall/return trace support: single stepping may continue without intervention\r\nuntil the next call or return instruction.\r\ninstruction counting: the number of instructions executed between regions of\r\ncode may be counted.\r\nDuring the implementation of the system these features have proved invalu\u0002able in both debugging and performance tuning.\r\n7.2 Transparent Remote Filesystem\r\nThe remote filesystem available in Mach was originally available in 1982 as part\r\nof CMU’s locally maintained version of 4.1 UNIX. At that time, it supported\r\nonly a small set of the functions required of a file system: it could read and/or\r\nwrite publicly accessible files. Over the years, the remote filesystem has under\u0002gone a steady increase in functionality. Currently, all UNIX functions, such as\r\nremote current directories and execution of remote files, are supported.\r\nThe remote filesystem is completely transparent to the user. Users may\r\neffectively login to a remote filesystem connection to receive all of their normal\r\nprivileges on the remote filesystem, or they may elect to not login, and receive\r\nonly “anonymous” access to the remote filesystem.\r\nA small set of kernel hooks redirects remote file operations to remote servers\r\ntransparently. Each machine wishing to allow remote requests runs a user\u0002mode server process. The kernel sends requests corresponding to operations\r\nsuch as read, write, open and close. The client then performs the appropriate\r\noperation, and returns with a reply code and/or data. Data is not cached with\r\none exception: remote execution of files causes a cached copy of the entire file\r\n7This version currently only works on Vaxen.\r\n13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/ac80ad68-d199-450d-bf7e-1c309c140b1f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9db2c1b1a6d631c441e3e48c8ef3e4180679110ba5d5f8b3a7a087e77e61c2af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 386
      },
      {
        "segments": [
          {
            "segment_id": "3dc03a37-edfe-4652-89c1-9638ea81f8f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "to be read into an inode on a local disk. Subsequent executions of this file cause\r\nthe kernel to check for a modification of the remote file; if no such modification\r\nhas been made, then the locally cached copy is executed.\r\nLinks to remote filesystems are created using a special file type. While mount\r\npoints have been used for this purpose in other remote filesystems [1, 2], it was\r\nfelt that the restriction on the number of mount points (and the need to actually\r\nmount such a filesystem) made this option inappropriate. Using special links\r\nallows a machine to connect to an arbitrary number of other machines without\r\nthe need for mounting all possible remote filesystems, and the fear of the mount\r\ntable overflowing.\r\n8 Implementation: a new foundation for UNIX\r\nThe Mach kernel currently supplants most of the basic system interface func\u0002tions of the UNIX 4.3BSD kernel: trap handling, scheduling, multiprocessor\r\nsynchronization, virtual memory management and interprocess communication.\r\n4.3BSD functions are provided by kernel-state threads which are scheduled by\r\nthe Mach kernel and share communication queues with it.\r\nThe spectacular growth in size of the Berkeley UNIX kernel over the last\r\nfew years has made it apparent that continued expansion of UNIX functionality\r\nthreatens to undercut the advantages of simplicity and modifiability which mad\r\nUNIX an attractive operating system alternative for research and development.\r\nWork is underway to remove non-Mach UNIX functionality from kernel-state\r\nand provide these services through user-state tasks. The goal of this effort is\r\nto “kernelize” UNIX is a substantially less complex and more easily modifiable\r\nbasic operating system. This system would be better adapted to new uniproces\u0002sor and multiprocessor architectures as well as the demands of a large network\r\nenvironment. The success of this transition will depend heavily on the fact that\r\nthe basic Mach abstractions allow kernel facilities such as memory object man\u0002agement and interprocess communication to be transparently extended. Figure\r\n6 shows the eventual relationship between the Mach kernel and UNIX.\r\n9 Current status: Mach-1\r\nMach is still under development and extensive performance comparisons with\r\nother systems have not yet been done. Although the system has yet to be tuned,\r\ncurrent performance appears to be in line with 4.3BSD. Some early simplistic\r\nmeasures of virtual memory performance are encouraging. The MicroVAX II\r\ncost of touching newly allocated memory is less than 0.7 milliseconds per 1024\r\nbytes of data (versus approximately 1.2 milliseconds for 4.3BSD). Operations\r\ntypically expensive in UNIX, e.g. fork, are substantially faster with the new vir\u0002tual memory support. Mach is currently in production use by CMU researchers\r\non a number of projects including a multiprocessor speech recognition system\r\ncalled Agora and a project to build parallel production systems.\r\n14",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/3dc03a37-edfe-4652-89c1-9638ea81f8f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9e692a1984d13a6226c8b6cb1e05c2ed140fb97bc9c0fe5bda9fce3544bd667e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 448
      },
      {
        "segments": [
          {
            "segment_id": "2c79ad77-d8c4-4d66-9a4a-2a8d4dc7d7fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "User processes\r\nMach Network\r\nOS UNIX Compatibility Functionality:\r\n Secure network IPC\r\n Distributed file system\r\n Authentication\r\n Authorization\r\n Network resource\r\n management\r\n Network paging\r\n etc.\r\nFunctionality:\r\n UNIX File System\r\n UNIX Process Management\r\n etc.\r\n…\r\nMach-1 Kernel Layer\r\nFunctionality:\r\n Virtual memory management\r\n Interprocess communication\r\n Low-level device drivers\r\n Multiprocessor scheduling\r\n Redirection of UNIX traps\r\nFigure 6: Mach with UNIX functionality in user-state tasks. As of April 1986\r\nthe box labeled “UNIX compatibility” still executes in kernel state and commu\u0002nicates with the Mach kernel layer through a shared communication queue.\r\nAs of April 1986, Mach runs on most VAX architecture machines: VAX\r\n11/750, 11/780, 11/785, 8600, MicroVAX I, and MicroVAX II. In addition,\r\nMach runs on four (11/780 or 11/785) processor VAX 11/784 with 8 MB of\r\nshared memory and the IBM RT/PC. The same binary kernel image runs on\r\nall VAX uniprocessors and multiprocessors. The same kernel source is used for\r\nboth VAX and RT/PC systems. Work has begun on ports to the uniprocessor\r\nSUN 3, multiprocessor Encore MultiMax and VAX 8300. Implementation of\r\nthe Mach thread mechanism is expected by Summer 1986.\r\nReferences\r\n[1] D. R. Brownbridge, L.F. Marshall, and B. Randell. The newcastle connec\u0002tion, or UNIXes of the world unite! Software - Practice and Experience,\r\n20, 1982.\r\n15",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/2c79ad77-d8c4-4d66-9a4a-2a8d4dc7d7fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e893ee2b37b745485cf5be14e90d686031c2fd596b2a8b04f6915fa6ad90cc33",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "0c4af0c8-4d66-4a8d-a453-b3c42c03df76",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "[2] M. Satyanarayanan et al. The ITC distributed file ssystem: Principles and\r\ndesign. pages 35–50. ACM, December 1985.\r\n[3] R. Fitzgerald and R. F. Rashid. The integration of virtual memory man\u0002agement and interprocess communication in accent. ACM Transactions on\r\nComputer Systems, 4(2), May 1986.\r\n[4] A. K. Jones. The object model: A conceptual tool for structuring systems.\r\nOperating Systems: An Advanced Course, pages 7–16, 1978.\r\n[5] A. K. Jones, R. J. Cahnsler, I. E. Durham, K. Schwans, and S. Vegdahl.\r\nStaros, a multiprocessor operating system for the support of task forces.\r\npages 117–129. ACM, December 1979.\r\n[6] M. B. Jones, R. F. Rashid, and M. Thompson. Matchmaker: An interpro\u0002cess specification language. ACM, January 1985.\r\n[7] W. Joy. 4.2BSD system manual. Technical report, Computer Systems Re\u0002search Group, Computer Science Division, University of California, Berke\u0002ley, Berkeley, CA, July 1983.\r\n[8] R. F. Rashid and G. Robertson. Accent: A communication oriented net\u0002work operating system kernel. pages 64–75. ACM, December 1981.\r\n[9] D. M. Ritchie and K. Thompson. The Unix time sharing system. Commu\u0002nications of the ACM, 17(7):365–375, July 1974.\r\n[10] R. Sansom, D. Julin, and R. Rashid. Extending a capability based system\r\ninto a network environment. Technical report, Department of Computer\r\nScience, Carnegie-Mellon University, April 1986.\r\n[11] E. T. Smith and D. B. Anderson. Flamingo: Object-oriented abstractions\r\nfor user interface management. pages 72–78, January 1986.\r\n[12] W. A. Wulf, R. Levin, and S. P. Harbison. Hydra/C.mmp: An Experimental\r\nComputer System. McGraw-Hill, 1981.\r\n16",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/7817e7be-efbe-4195-b457-fda6f43f16e6/images/0c4af0c8-4d66-4a8d-a453-b3c42c03df76.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041821Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2ac4b9ab0709cb86ab522925eecad5cd8aa5344b73a9a5c1680b39a23ccf5b13",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 445
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Mach: A New Kernel Foundation For UNIX Development\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "```json\n{\"date_published\": \"April 1986\"}\n```"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "Carnegie-Mellon University\nPittsburgh, Pa.\nBerkeley\nCMU\nDEC VAX\nIBM RT/PC\nPERQ Systems PERQ\nVAX\nMicroVAX II\nNewcastle\nUniversity of California, Berkeley, Berkeley, CA"
        }
      ]
    }
  }
}