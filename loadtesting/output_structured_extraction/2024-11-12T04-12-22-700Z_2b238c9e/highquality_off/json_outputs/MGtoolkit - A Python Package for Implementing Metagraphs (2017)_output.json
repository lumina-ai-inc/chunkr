{
  "file_name": "MGtoolkit - A Python Package for Implementing Metagraphs (2017).pdf",
  "task_id": "a0273fe1-fe53-4f9b-a392-74464ed102e3",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "d6fb245c-7b31-4f7b-9e4d-212df5ca57c7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 1,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "SoftwareX 6 (2017) 91–93\r\nContents lists available at ScienceDirect\r\nSoftwareX\r\njournal homepage: www.elsevier.com/locate/softx\r\nMGtoolkit: A python package for implementing metagraphs\r\nD. Ranathunga a,*, H. Nguyen a, M. Roughan b\r\na\r\nTeletraffic Research Centre, University of Adelaide, Australia\r\nb ARC Centre of Excellence for Mathematical and Statistical Frontiers, University of Adelaide, Australia\r\na r t i c l e i n f o\r\nArticle history:\r\nReceived 3 February 2017\r\nReceived in revised form 11 April 2017\r\nAccepted 11 April 2017\r\nKeywords:\r\nMetagraph implementation\r\nComputer-network policy\r\nPolicy analysis\r\na b s t r a c t\r\nIn this paper we present MGtoolkit: an open-source Python package for implementing metagraphs - a\r\nfirst of its kind. Metagraphs are commonly used to specify and analyse business and computer-network\r\npolicies alike. MGtoolkit can help verify such policies and promotes learning and experimentation with\r\nmetagraphs. The package currently provides purely textual output for visualising metagraphs and their\r\nanalysis results.\r\n© 2017 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY license\r\n(http://creativecommons.org/licenses/by/4.0/).\r\nCode metadata\r\nCurrent code version V1.0.1\r\nPermanent link to code/repository used for this code version https://github.com/ElsevierSoftwareX/SOFTX-D-17-00014\r\nLegal Code License MIT\r\nCode versioning system used git\r\nSoftware code languages, tools, and services used Python2.7\r\nCompilation requirements, operating environments & dependencies Mac OS X, Linux\r\nIf available Link to developer documentation/manual https://readthedocs.org/projects/mgtoolkit/badge/?version=latest\r\nSupport email for questions mgtkhelp@gmail.com\r\n1. Motivation\r\nA metagraph is a generalised graph theoretic structure that has\r\nseveral useful applications. They are commonly used to construct\r\nand analyse business policies in decision-support systems and\r\nworkflow-management systems [1]. Metagraphs are also useful\r\nto analyse, optimise and troubleshoot communication-network\r\npolicies [2].\r\nA metagraph is a directed graph between a collection of sets of\r\n‘atomic’ elements. Each set is a node in the graph and each directed\r\nedge represents the relationship between the sets. A simple exam\u0002ple is given in Fig. 1(a) where multiple sets of users (U1, U2, U3) are\r\nrelated to sets of network resources (R1, R2) by the directed edges\r\ne1, e2 and e3 which describes which user uiis allowed to access\r\nresource rj.\r\n*\r\nCorresponding author.\r\nE-mail address: dinesha.ranathunga@adelaide.edu.au (D. Ranathunga).\r\nIn this paper we describe an off-the-shelf tool for implementing\r\nmetagraphs – MGtoolkit – implemented in Python. At the time of\r\nwriting, we are aware of one other metagraph API- ‘Haskell library\r\nfor metagraph data structure’ [3].\r\nDeveloping a metagraph tool faces several key challenges. For\r\ninstance, a metagraph does not use simple edge weights in its\r\nadjacency matrix. Also, metagraphs admit representations other\r\nthan those used for simple graphs, but as in simple graphs, the\r\nrepresentation is important for certain algorithms. In addition,\r\nthere are many operations defined on a metagraph that must be\r\nsupported by such a tool. These operations help analyse useful\r\nproperties such as connectivity, redundancy and allow metagraph\r\ntransformations, but go beyond standard graph operators.\r\nMetagraphs have many uses in general. One in particular is\r\nin specifying and analysing communication-network policies. We\r\nwill demonstrate the use of metagraphs here by taking access\u0002control policies in a computer network as an example. But, meta\u0002graphs can be equally used in other policy contexts (e.g., QoS,\r\nnetwork-service chaining, traffic measurement etc.).\r\nhttp://dx.doi.org/10.1016/j.softx.2017.04.001\r\n2352-7110/© 2017 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/d6fb245c-7b31-4f7b-9e4d-212df5ca57c7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=92212b12545157750153fcb1fa83aa141c37ee732b89c5a66d1065ae87794437",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 548
      },
      {
        "segments": [
          {
            "segment_id": "d6fb245c-7b31-4f7b-9e4d-212df5ca57c7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 1,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "SoftwareX 6 (2017) 91–93\r\nContents lists available at ScienceDirect\r\nSoftwareX\r\njournal homepage: www.elsevier.com/locate/softx\r\nMGtoolkit: A python package for implementing metagraphs\r\nD. Ranathunga a,*, H. Nguyen a, M. Roughan b\r\na\r\nTeletraffic Research Centre, University of Adelaide, Australia\r\nb ARC Centre of Excellence for Mathematical and Statistical Frontiers, University of Adelaide, Australia\r\na r t i c l e i n f o\r\nArticle history:\r\nReceived 3 February 2017\r\nReceived in revised form 11 April 2017\r\nAccepted 11 April 2017\r\nKeywords:\r\nMetagraph implementation\r\nComputer-network policy\r\nPolicy analysis\r\na b s t r a c t\r\nIn this paper we present MGtoolkit: an open-source Python package for implementing metagraphs - a\r\nfirst of its kind. Metagraphs are commonly used to specify and analyse business and computer-network\r\npolicies alike. MGtoolkit can help verify such policies and promotes learning and experimentation with\r\nmetagraphs. The package currently provides purely textual output for visualising metagraphs and their\r\nanalysis results.\r\n© 2017 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY license\r\n(http://creativecommons.org/licenses/by/4.0/).\r\nCode metadata\r\nCurrent code version V1.0.1\r\nPermanent link to code/repository used for this code version https://github.com/ElsevierSoftwareX/SOFTX-D-17-00014\r\nLegal Code License MIT\r\nCode versioning system used git\r\nSoftware code languages, tools, and services used Python2.7\r\nCompilation requirements, operating environments & dependencies Mac OS X, Linux\r\nIf available Link to developer documentation/manual https://readthedocs.org/projects/mgtoolkit/badge/?version=latest\r\nSupport email for questions mgtkhelp@gmail.com\r\n1. Motivation\r\nA metagraph is a generalised graph theoretic structure that has\r\nseveral useful applications. They are commonly used to construct\r\nand analyse business policies in decision-support systems and\r\nworkflow-management systems [1]. Metagraphs are also useful\r\nto analyse, optimise and troubleshoot communication-network\r\npolicies [2].\r\nA metagraph is a directed graph between a collection of sets of\r\n‘atomic’ elements. Each set is a node in the graph and each directed\r\nedge represents the relationship between the sets. A simple exam\u0002ple is given in Fig. 1(a) where multiple sets of users (U1, U2, U3) are\r\nrelated to sets of network resources (R1, R2) by the directed edges\r\ne1, e2 and e3 which describes which user uiis allowed to access\r\nresource rj.\r\n*\r\nCorresponding author.\r\nE-mail address: dinesha.ranathunga@adelaide.edu.au (D. Ranathunga).\r\nIn this paper we describe an off-the-shelf tool for implementing\r\nmetagraphs – MGtoolkit – implemented in Python. At the time of\r\nwriting, we are aware of one other metagraph API- ‘Haskell library\r\nfor metagraph data structure’ [3].\r\nDeveloping a metagraph tool faces several key challenges. For\r\ninstance, a metagraph does not use simple edge weights in its\r\nadjacency matrix. Also, metagraphs admit representations other\r\nthan those used for simple graphs, but as in simple graphs, the\r\nrepresentation is important for certain algorithms. In addition,\r\nthere are many operations defined on a metagraph that must be\r\nsupported by such a tool. These operations help analyse useful\r\nproperties such as connectivity, redundancy and allow metagraph\r\ntransformations, but go beyond standard graph operators.\r\nMetagraphs have many uses in general. One in particular is\r\nin specifying and analysing communication-network policies. We\r\nwill demonstrate the use of metagraphs here by taking access\u0002control policies in a computer network as an example. But, meta\u0002graphs can be equally used in other policy contexts (e.g., QoS,\r\nnetwork-service chaining, traffic measurement etc.).\r\nhttp://dx.doi.org/10.1016/j.softx.2017.04.001\r\n2352-7110/© 2017 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/d6fb245c-7b31-4f7b-9e4d-212df5ca57c7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=92212b12545157750153fcb1fa83aa141c37ee732b89c5a66d1065ae87794437",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 548
      },
      {
        "segments": [
          {
            "segment_id": "ba4668c3-8a44-4a9a-a048-6dc2eec3b754",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 2,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "92 D. Ranathunga et al. / SoftwareX 6 (2017) 91–93\r\n(a) Metagraph consisting of five sets and three\r\nedges.\r\n(b) Metagraph that shows the advantage of a meta\u0002path over simple paths.\r\nFig. 1. Metagraph examples.\r\n2. Background\r\nThe formal structure of a metagraph can be defined as follows:\r\nDefinition 1 (Metagraph). A metagraph S = ⟨X, E⟩ is a graphical\r\nconstruct specified by a generating set X and a set of edges E de\u0002fined on X. A generating set is a set of variables X = {x1, x2, . . . , xn}\r\nand an edge e ∈ E is a pair e = ⟨Ve, We⟩ such that Ve ⊂ X is the\r\ninvertex and We ⊂ X is the outvertex.\r\nThis definition is similar to that of a directed hypergraph, but in\r\naddition metagraphs have several useful operators and properties.\r\nOne in particular is the notion of a metapath [1] which describes\r\nconnectivity between sets of elements in a metagraph, but is some\u0002what different from a path in a graph.\r\nDefinition 2 (Metapath). A metapath from source B ⊂ X to target\r\nC ⊂ X in a metagraph S = ⟨X, E⟩ is set of edges E\r\n′\r\nsuch that every\r\ne\r\n′ ∈ E′\r\nis on a path from an element in B to an element in C. In\r\naddition [\r\n⋃\r\ne\r\n′Ve\r\n′ \\\r\n⋃\r\ne\r\n′We\r\n′] ⊆ B and C ⊆\r\n⋃\r\ne\r\n′We\r\n′ .\r\nA metapath is more useful than a simple path (i.e., a sequence\r\nof edges). Fig. 1(b) illustrates this using two simple paths from x1\r\nto x5: (e1, e3) and (e2, e3). Element x1 can reach x5 without knowing\r\nanything about the intermediate nodes x2, x3, x4 if all three edges\r\ne1, e2, e3 are used but the simple paths do no capture this fact. But\r\n{e1, e2, e3} does not represent a simple path; there is no sequence\r\nof connected edges consisting of these edges. Rather, this metapath\r\nis the union of edges in two simple paths.\r\nReachability between a source node and a target node can\r\nbe determined by finding valid metapaths between the two in a\r\nmetagraph [1] (e.g., the metapath from x1 to x5 in Fig. 1(b) is\r\n{e1, e2, e3}).\r\nMetagraphs have a property called dominance which allows to\r\ndetermine whether a metapath has any redundant components\r\n(edges or elements) [1]. A metapath is input-dominant if no proper\r\nsubset of its source connects to the target; edge-dominant if no\r\nproper subset of its edges is also a metapath from the source to the\r\ntarget; and dominant if it is both input- and edge-dominant [1].\r\nNon-dominant metapaths indicate redundancies in a metagraph\r\nand hence, redundancies in the policies depicted by the metagraph.\r\nIn metagraph theory, the notion of cutsets and bridges allow\r\none to locate edges that are critical [1]. A cutset is a set of edges\r\nwhich if removed, eliminates all metapaths between a given source\r\nand a target. A singleton cutset is a bridge. In an access-control\r\npolicy context for instance, bridges and cutsets indicate if there\r\nexists a critical policy or a policy set that enable access between\r\ncertain users and resources.\r\nIt is also possible to derive a projection for a given metagraph.\r\nA projection is a simplified metagraph that provides a high-level\r\nview of the original metagraph by concealing certain details [1].\r\nIn a complex metagraph with many edges, a projection helps to\r\nvisualise the important aspects with clarity and ease. For instance,\r\nin a complex access-control policy with many rules, projections\r\nhelp administrators visualise connectivity between a subset of\r\nusers and resources.\r\nMetagraphs can have attributes associated with their edges.\r\nOne such attributed metagraph is a conditional metagraph [1]. A\r\nconditional metagraph includes propositions – statements that\r\nmay be true or false – assigned to their edges as qualitative at\u0002tributes [1]. The generating set of these metagraphs are partitioned\r\ninto a variables set and a propositions set.\r\nConditional metagraphs are particularly useful in specifying\r\naccess-control policies because they allow a policy (such as per\u0002mit user u1 to access resource r1) to be activated conditionally\r\n(e.g., during business hours only).\r\n3. Overview of MGtoolkit\r\nMGtoolkit is implemented in Python 2.7, which is an inter\u0002preted, object-oriented, open-source language. Python has a con\u0002cise but natural syntax for many of its data types, which makes\r\nprograms exceedingly clear and easy to read; as the saying goes,\r\n‘Python is executable pseudocode.’ Dependencies of MGtoolkit in\u0002clude the packages NumPy 1.9 and NetworkX 1.7; both very pop\u0002ular and stable open source Python packages.\r\nFig. 2 depicts the entity model we have employed in the un\u0002derlying framework. Some attributes have been omitted in the\r\nMetagraph entity for simplicity.\r\nA Metagraph entity consists of a set of Node entities and a set\r\nof Edge entities. Each Node contains a subset of elements from the\r\nmetagraph’s generating set. An Edge has the members: invertex\r\nand outvertex, assigned a Node each, and an attributes mem\u0002ber that returns any edge attributes.\r\nA Metagraph entity also has the methods: add_edges_from()\r\nand remove_edges_from(), to add and delete edges as nec\u0002essary. In addition, the entity includes methods to derive\r\nits adjacency matrix, find metapaths, check metapath proper\u0002ties (e.g., is_dominant_ metapath()) and edge properties\r\n(e.g., is_cutset()).\r\nThe source and target members of a Metapath return sub\u0002sets of elements in a metagraph’s generating set. The edge_list\r\nmember returns an edge set between the source and target\r\nwhich satisfy Definition 2.\r\nA ConditionalMetagraph entity extends a Metagraph and\r\nsupports proposition attributes in addition to variables. A Con\u0002ditionalMetagraph inherits the base properties and methods\r\nof a Metagraph and additionally supports methods to derive its\r\ncontext metagraphs (i.e., get_context()), check connectivity\r\nproperties (e.g., is_fully_connected()) and redundancy prop\u0002erties (e.g., is_non_redundant()).\r\nListing 1: MGtoolkit implementation of policy in Figure 1(a).\r\n1 # define policy metagraph\r\n2 variable_set = {’u1’,’u2’,’u3’,’u4’,’u5’,’u6’,’r1’,’r2’,’r3’}\r\n3 propositions_set = {’action=permit’, ’action=deny’}\r\n4 cm = ConditionalMetagraph(variable_set, propositions_set)\r\n5 cm.add_edges_from([",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/ba4668c3-8a44-4a9a-a048-6dc2eec3b754.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=46b21cf7bafa283bb9d61eb719f4ce139dbae51550be8ad845ef4a5a490a7160",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 980
      },
      {
        "segments": [
          {
            "segment_id": "ba4668c3-8a44-4a9a-a048-6dc2eec3b754",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 2,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "92 D. Ranathunga et al. / SoftwareX 6 (2017) 91–93\r\n(a) Metagraph consisting of five sets and three\r\nedges.\r\n(b) Metagraph that shows the advantage of a meta\u0002path over simple paths.\r\nFig. 1. Metagraph examples.\r\n2. Background\r\nThe formal structure of a metagraph can be defined as follows:\r\nDefinition 1 (Metagraph). A metagraph S = ⟨X, E⟩ is a graphical\r\nconstruct specified by a generating set X and a set of edges E de\u0002fined on X. A generating set is a set of variables X = {x1, x2, . . . , xn}\r\nand an edge e ∈ E is a pair e = ⟨Ve, We⟩ such that Ve ⊂ X is the\r\ninvertex and We ⊂ X is the outvertex.\r\nThis definition is similar to that of a directed hypergraph, but in\r\naddition metagraphs have several useful operators and properties.\r\nOne in particular is the notion of a metapath [1] which describes\r\nconnectivity between sets of elements in a metagraph, but is some\u0002what different from a path in a graph.\r\nDefinition 2 (Metapath). A metapath from source B ⊂ X to target\r\nC ⊂ X in a metagraph S = ⟨X, E⟩ is set of edges E\r\n′\r\nsuch that every\r\ne\r\n′ ∈ E′\r\nis on a path from an element in B to an element in C. In\r\naddition [\r\n⋃\r\ne\r\n′Ve\r\n′ \\\r\n⋃\r\ne\r\n′We\r\n′] ⊆ B and C ⊆\r\n⋃\r\ne\r\n′We\r\n′ .\r\nA metapath is more useful than a simple path (i.e., a sequence\r\nof edges). Fig. 1(b) illustrates this using two simple paths from x1\r\nto x5: (e1, e3) and (e2, e3). Element x1 can reach x5 without knowing\r\nanything about the intermediate nodes x2, x3, x4 if all three edges\r\ne1, e2, e3 are used but the simple paths do no capture this fact. But\r\n{e1, e2, e3} does not represent a simple path; there is no sequence\r\nof connected edges consisting of these edges. Rather, this metapath\r\nis the union of edges in two simple paths.\r\nReachability between a source node and a target node can\r\nbe determined by finding valid metapaths between the two in a\r\nmetagraph [1] (e.g., the metapath from x1 to x5 in Fig. 1(b) is\r\n{e1, e2, e3}).\r\nMetagraphs have a property called dominance which allows to\r\ndetermine whether a metapath has any redundant components\r\n(edges or elements) [1]. A metapath is input-dominant if no proper\r\nsubset of its source connects to the target; edge-dominant if no\r\nproper subset of its edges is also a metapath from the source to the\r\ntarget; and dominant if it is both input- and edge-dominant [1].\r\nNon-dominant metapaths indicate redundancies in a metagraph\r\nand hence, redundancies in the policies depicted by the metagraph.\r\nIn metagraph theory, the notion of cutsets and bridges allow\r\none to locate edges that are critical [1]. A cutset is a set of edges\r\nwhich if removed, eliminates all metapaths between a given source\r\nand a target. A singleton cutset is a bridge. In an access-control\r\npolicy context for instance, bridges and cutsets indicate if there\r\nexists a critical policy or a policy set that enable access between\r\ncertain users and resources.\r\nIt is also possible to derive a projection for a given metagraph.\r\nA projection is a simplified metagraph that provides a high-level\r\nview of the original metagraph by concealing certain details [1].\r\nIn a complex metagraph with many edges, a projection helps to\r\nvisualise the important aspects with clarity and ease. For instance,\r\nin a complex access-control policy with many rules, projections\r\nhelp administrators visualise connectivity between a subset of\r\nusers and resources.\r\nMetagraphs can have attributes associated with their edges.\r\nOne such attributed metagraph is a conditional metagraph [1]. A\r\nconditional metagraph includes propositions – statements that\r\nmay be true or false – assigned to their edges as qualitative at\u0002tributes [1]. The generating set of these metagraphs are partitioned\r\ninto a variables set and a propositions set.\r\nConditional metagraphs are particularly useful in specifying\r\naccess-control policies because they allow a policy (such as per\u0002mit user u1 to access resource r1) to be activated conditionally\r\n(e.g., during business hours only).\r\n3. Overview of MGtoolkit\r\nMGtoolkit is implemented in Python 2.7, which is an inter\u0002preted, object-oriented, open-source language. Python has a con\u0002cise but natural syntax for many of its data types, which makes\r\nprograms exceedingly clear and easy to read; as the saying goes,\r\n‘Python is executable pseudocode.’ Dependencies of MGtoolkit in\u0002clude the packages NumPy 1.9 and NetworkX 1.7; both very pop\u0002ular and stable open source Python packages.\r\nFig. 2 depicts the entity model we have employed in the un\u0002derlying framework. Some attributes have been omitted in the\r\nMetagraph entity for simplicity.\r\nA Metagraph entity consists of a set of Node entities and a set\r\nof Edge entities. Each Node contains a subset of elements from the\r\nmetagraph’s generating set. An Edge has the members: invertex\r\nand outvertex, assigned a Node each, and an attributes mem\u0002ber that returns any edge attributes.\r\nA Metagraph entity also has the methods: add_edges_from()\r\nand remove_edges_from(), to add and delete edges as nec\u0002essary. In addition, the entity includes methods to derive\r\nits adjacency matrix, find metapaths, check metapath proper\u0002ties (e.g., is_dominant_ metapath()) and edge properties\r\n(e.g., is_cutset()).\r\nThe source and target members of a Metapath return sub\u0002sets of elements in a metagraph’s generating set. The edge_list\r\nmember returns an edge set between the source and target\r\nwhich satisfy Definition 2.\r\nA ConditionalMetagraph entity extends a Metagraph and\r\nsupports proposition attributes in addition to variables. A Con\u0002ditionalMetagraph inherits the base properties and methods\r\nof a Metagraph and additionally supports methods to derive its\r\ncontext metagraphs (i.e., get_context()), check connectivity\r\nproperties (e.g., is_fully_connected()) and redundancy prop\u0002erties (e.g., is_non_redundant()).\r\nListing 1: MGtoolkit implementation of policy in Figure 1(a).\r\n1 # define policy metagraph\r\n2 variable_set = {’u1’,’u2’,’u3’,’u4’,’u5’,’u6’,’r1’,’r2’,’r3’}\r\n3 propositions_set = {’action=permit’, ’action=deny’}\r\n4 cm = ConditionalMetagraph(variable_set, propositions_set)\r\n5 cm.add_edges_from([",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/ba4668c3-8a44-4a9a-a048-6dc2eec3b754.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=46b21cf7bafa283bb9d61eb719f4ce139dbae51550be8ad845ef4a5a490a7160",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 980
      },
      {
        "segments": [
          {
            "segment_id": "aa627d90-67d1-4a13-873f-2d34ab7bb255",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 3,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "D. Ranathunga et al. / SoftwareX 6 (2017) 91–93 93\r\nFig. 2. MGtoolkit entity relationship model (*–1 denotes a many-to-one relationship and → denotes an extension).\r\n6 Edge({’u1’,’u2’,’u3’}, {’r1’,’r2’}, attributes=[’action=permit’]),\r\n7 Edge({’u3’,’u4’,’u5’}, {’r2’,’r3’}, attributes=[’action=deny’]),\r\n8 Edge({’u2’,’u3’,’u5’,’u6’}, {’r1’,’r2’}, attributes=[’action=permit’])])\r\n9\r\n10 # compute redundancies and conflicts\r\n11 all_metapaths = cm.get_all_metapaths()\r\n12 for metapath in all_metapaths:\r\n13 if cm.has_redundancies(metapath):\r\n14 print(’redundancy detected: \\%s’\\%repr(metapath))\r\n15 if cm.has_conflicts(metapath):\r\n16 print(’conflict detected: \\%s’\\%repr(metapath))\r\nListing 2: Partial output from running code in Listing 1.\r\n1 conflict detected: Metapath({ Edge(set([’u1’,’u2’,’u3’,’action=permit’]),\r\nset([’r1’,’r2’])), Edge({’u3’,’u4’,’u5’}, {’r2’,’r3’}, attributes\r\n=[’action=deny’])})\r\nThe code snippet in Listing 1 instantiates the example access\u0002control policy in Fig. 1(a) using MGtoolkit and then checks pol\u0002icy consistency. It returns a redundancy and two conflicts–one\r\nis shown in Listing 2. The redundancy is due to e1 and e3 both\r\nenabling access to R1 from u2 and u3. The conflicts stem from e3\r\ndenying access to R2. More detailed examples based on business\r\npolicies and workflows can be found on pages 81, 109 and 126 of\r\nthe metagraph text [1].\r\n4. Impact and challenges\r\nThere are many packages available for analysing graphs,\r\ne.g., igraph, NetworkX, Gephi [4–6]. These are being increasingly\r\nutilised. Metagraphs provide a powerful generalisation of simple\r\ngraphs and are particularly suitable for modelling business and\r\ncomputer-network policies [1,2].\r\nMGtoolkit is the first publicly available Python API for imple\u0002menting metagraphs. It serves two key purposes. Firstly, the API\r\nallows users to learn about metagraphs in an interactive manner\r\nby creating metagraph examples, applying metagraph operations\r\nand evaluating the results. The documentation and tutorials asso\u0002ciated with the package simplify the learning curve. Secondly, the\r\nAPI is a building block for developing and analysing metagraph\u0002based applications such as decision-support systems. Developers\r\ncan harness the advantages and power of metagraphs in to their\r\napplications by simply importing MGtoolkit.\r\nWe believe our API is a first step to revisit old questions and\r\ntackle new challenges. For instance, in the specification and anal\u0002ysis of computer network policies: current approaches either lack\r\nhigh-level specification capability or formal semantics. MGtoolkit\r\nis a gateway to harness the best of both of these worlds.\r\nWe have used the GitHub open source code hosting and devel\u0002opment platform to enable user collaboration.\r\nA key drawback in developing MGtoolkit was the fact that\r\nthe only metagraph text available for reference contained several\r\ndiscrepancies. For instance, the inverse metagraph generation al\u0002gorithm given in the text failed to replicate the example output\r\nprovided (Figure 4.9 on page 47 in [1]). Upon clarification with the\r\nauthor, we found that the example was in fact incorrect.\r\nAlso several metapath examples given contradicted the defini\u0002tion of a metapath (e.g., metapath M4 on page 28 in [1]). We strictly\r\nadhered to the definition because the formal metagraph properties\r\nderived were based on the definition.\r\n5. Conclusions and future work\r\nIn this paper, we present MGtoolkit: an open-source Python\r\npackage for implementing metagraphs. The software promotes\r\nlearning and experimentation with metagraphs and can help anal\u0002yse business- and computer-network policies alike.\r\nIn the future, we are planning several applications based on\r\nMGtoolkit, one in particular is a tool for the formal analysis of\r\ncomputer-network policies. Additionally, some of the algorithms\r\nsuggested in [1] are not efficient and we plan to improve on them.\r\nAcknowledgement\r\nThis project was supported by the Australian Govern\u0002ment through the Australian Research Council Linkage Project\r\nLP140100489.\r\nReferences\r\n[1] Basu A, Blanning RW. Metagraphs and their applications. Springer Science &\r\nBusiness Media; 2007.\r\n[2] Nguyen HX, Pham T, Hoang K, Nguyen DD, Parsonage E. A prototype of policy\r\ndefined wireless access networks. In: International Telecommunication Net\u0002works and Applications Conference. 2016. p. 1–5.\r\n[3] Gushcha A, Haskell library for metagraph data structure; 2017. [Online]. Avail\u0002able: https://github.com/Teaspot-Studio/metagraph.\r\n[4] igraph Steering Committee. Get started with python-igraph; 2006. [Online].\r\nAvailable: http://igraph.org/python/.\r\n[5] NetworkX Developer Team. High-productivity software for complex networks;\r\n2004. [Online]. Available: https://networkx.github.io/.\r\n[6] Bastian M, Heymann S, Jacomy M, Gephi: An Open Source Software for Exploring\r\nand Manipulating Networks; (2009) https://gephi.org/.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/aa627d90-67d1-4a13-873f-2d34ab7bb255.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f6747b6f6cbd61e3bdfae2d73cee909ad269651767c371ed02420a2cfc748f61",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 654
      },
      {
        "segments": [
          {
            "segment_id": "aa627d90-67d1-4a13-873f-2d34ab7bb255",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.276,
              "height": 793.701
            },
            "page_number": 3,
            "page_width": 595.276,
            "page_height": 793.701,
            "content": "D. Ranathunga et al. / SoftwareX 6 (2017) 91–93 93\r\nFig. 2. MGtoolkit entity relationship model (*–1 denotes a many-to-one relationship and → denotes an extension).\r\n6 Edge({’u1’,’u2’,’u3’}, {’r1’,’r2’}, attributes=[’action=permit’]),\r\n7 Edge({’u3’,’u4’,’u5’}, {’r2’,’r3’}, attributes=[’action=deny’]),\r\n8 Edge({’u2’,’u3’,’u5’,’u6’}, {’r1’,’r2’}, attributes=[’action=permit’])])\r\n9\r\n10 # compute redundancies and conflicts\r\n11 all_metapaths = cm.get_all_metapaths()\r\n12 for metapath in all_metapaths:\r\n13 if cm.has_redundancies(metapath):\r\n14 print(’redundancy detected: \\%s’\\%repr(metapath))\r\n15 if cm.has_conflicts(metapath):\r\n16 print(’conflict detected: \\%s’\\%repr(metapath))\r\nListing 2: Partial output from running code in Listing 1.\r\n1 conflict detected: Metapath({ Edge(set([’u1’,’u2’,’u3’,’action=permit’]),\r\nset([’r1’,’r2’])), Edge({’u3’,’u4’,’u5’}, {’r2’,’r3’}, attributes\r\n=[’action=deny’])})\r\nThe code snippet in Listing 1 instantiates the example access\u0002control policy in Fig. 1(a) using MGtoolkit and then checks pol\u0002icy consistency. It returns a redundancy and two conflicts–one\r\nis shown in Listing 2. The redundancy is due to e1 and e3 both\r\nenabling access to R1 from u2 and u3. The conflicts stem from e3\r\ndenying access to R2. More detailed examples based on business\r\npolicies and workflows can be found on pages 81, 109 and 126 of\r\nthe metagraph text [1].\r\n4. Impact and challenges\r\nThere are many packages available for analysing graphs,\r\ne.g., igraph, NetworkX, Gephi [4–6]. These are being increasingly\r\nutilised. Metagraphs provide a powerful generalisation of simple\r\ngraphs and are particularly suitable for modelling business and\r\ncomputer-network policies [1,2].\r\nMGtoolkit is the first publicly available Python API for imple\u0002menting metagraphs. It serves two key purposes. Firstly, the API\r\nallows users to learn about metagraphs in an interactive manner\r\nby creating metagraph examples, applying metagraph operations\r\nand evaluating the results. The documentation and tutorials asso\u0002ciated with the package simplify the learning curve. Secondly, the\r\nAPI is a building block for developing and analysing metagraph\u0002based applications such as decision-support systems. Developers\r\ncan harness the advantages and power of metagraphs in to their\r\napplications by simply importing MGtoolkit.\r\nWe believe our API is a first step to revisit old questions and\r\ntackle new challenges. For instance, in the specification and anal\u0002ysis of computer network policies: current approaches either lack\r\nhigh-level specification capability or formal semantics. MGtoolkit\r\nis a gateway to harness the best of both of these worlds.\r\nWe have used the GitHub open source code hosting and devel\u0002opment platform to enable user collaboration.\r\nA key drawback in developing MGtoolkit was the fact that\r\nthe only metagraph text available for reference contained several\r\ndiscrepancies. For instance, the inverse metagraph generation al\u0002gorithm given in the text failed to replicate the example output\r\nprovided (Figure 4.9 on page 47 in [1]). Upon clarification with the\r\nauthor, we found that the example was in fact incorrect.\r\nAlso several metapath examples given contradicted the defini\u0002tion of a metapath (e.g., metapath M4 on page 28 in [1]). We strictly\r\nadhered to the definition because the formal metagraph properties\r\nderived were based on the definition.\r\n5. Conclusions and future work\r\nIn this paper, we present MGtoolkit: an open-source Python\r\npackage for implementing metagraphs. The software promotes\r\nlearning and experimentation with metagraphs and can help anal\u0002yse business- and computer-network policies alike.\r\nIn the future, we are planning several applications based on\r\nMGtoolkit, one in particular is a tool for the formal analysis of\r\ncomputer-network policies. Additionally, some of the algorithms\r\nsuggested in [1] are not efficient and we plan to improve on them.\r\nAcknowledgement\r\nThis project was supported by the Australian Govern\u0002ment through the Australian Research Council Linkage Project\r\nLP140100489.\r\nReferences\r\n[1] Basu A, Blanning RW. Metagraphs and their applications. Springer Science &\r\nBusiness Media; 2007.\r\n[2] Nguyen HX, Pham T, Hoang K, Nguyen DD, Parsonage E. A prototype of policy\r\ndefined wireless access networks. In: International Telecommunication Net\u0002works and Applications Conference. 2016. p. 1–5.\r\n[3] Gushcha A, Haskell library for metagraph data structure; 2017. [Online]. Avail\u0002able: https://github.com/Teaspot-Studio/metagraph.\r\n[4] igraph Steering Committee. Get started with python-igraph; 2006. [Online].\r\nAvailable: http://igraph.org/python/.\r\n[5] NetworkX Developer Team. High-productivity software for complex networks;\r\n2004. [Online]. Available: https://networkx.github.io/.\r\n[6] Bastian M, Heymann S, Jacomy M, Gephi: An Open Source Software for Exploring\r\nand Manipulating Networks; (2009) https://gephi.org/.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a0273fe1-fe53-4f9b-a392-74464ed102e3/images/aa627d90-67d1-4a13-873f-2d34ab7bb255.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041546Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f6747b6f6cbd61e3bdfae2d73cee909ad269651767c371ed02420a2cfc748f61",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 654
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "MGtoolkit: A python package for implementing metagraphs\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "D. Ranathunga, H. Nguyen, M. Roughan\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "2017\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "Australia\n"
        }
      ]
    }
  }
}