{
  "file_name": "Joint Strike Fighter Air Vehicle C++ Coding Standards - Dec 2005 (Doc. 2RDU00001 Rev. C).pdf",
  "task_id": "fa0f35c2-b425-4b1d-9c71-d7146951f919",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "6e865eca-60c8-4eba-871f-20355a598a32",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\nJOINT STRIKE FIGHTER \r\nAIR VEHICLE \r\nC++ CODING STANDARDS \r\nFOR THE SYSTEM DEVELOPMENT AND DEMONSTRATION PROGRAM\r\nDocument Number 2RDU00001 Rev C \r\nDecember 2005\r\nCopyright 2005 by Lockheed Martin Corporation. \r\n DISTRIBUTION STATEMENT A: Approved for public release; distribution is unlimited. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6e865eca-60c8-4eba-871f-20355a598a32.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=71c02d3bbabe66c751a6a3a10bb21ee8f808b019150a19fe0cf5d70699a093fd",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f2b5da58-84ea-4ea8-91b2-4ab5ef2310e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n3\r\nThis page intentionally left blank",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/f2b5da58-84ea-4ea8-91b2-4ab5ef2310e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=36dc94152497c7d9313db869c68593dd65464877e38cfa1df3be2523ae9fe2c6",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "09fced45-6505-48cf-8465-ac0eb4a93d9b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n4\r\nTABLE OF CONTENTS \r\n1 Introduction............................................................................................................................. 7 \r\n2 Referenced Documents........................................................................................................... 8 \r\n3 General Design...................................................................................................................... 10 \r\n3.1 Coupling & Cohesion ................................................................................................... 11 \r\n3.2 Code Size and Complexity............................................................................................ 12 \r\n4 C++ Coding Standards.......................................................................................................... 13 \r\n4.1 Introduction................................................................................................................... 13 \r\n4.2 Rules ............................................................................................................................. 13 \r\n4.2.1 Should, Will, and Shall Rules............................................................................... 13 \r\n4.2.2 Breaking Rules...................................................................................................... 13 \r\n4.2.3 Exceptions to Rules............................................................................................... 14 \r\n4.3 Terminology.................................................................................................................. 14 \r\n4.4 Environment.................................................................................................................. 17 \r\n4.4.1 Language............................................................................................................... 17 \r\n4.4.2 Character Sets ....................................................................................................... 17 \r\n4.4.3 Run-Time Checks................................................................................................. 18 \r\n4.5 Libraries........................................................................................................................ 19 \r\n4.5.1 Standard Libraries................................................................................................. 19 \r\n4.6 Pre-Processing Directives............................................................................................. 20 \r\n4.6.1 #ifndef and #endif Pre-Processing Directives...................................................... 20 \r\n4.6.2 #define Pre-Processing Directive.......................................................................... 21 \r\n4.6.3 #include Pre-Processing Directive........................................................................ 21 \r\n4.7 Header Files.................................................................................................................. 22 \r\n4.8 Implementation Files .................................................................................................... 23 \r\n4.9 Style .............................................................................................................................. 23 \r\n4.9.1 Naming Identifiers................................................................................................ 24 \r\n4.9.1.1 Naming Classes, Structures, Enumerated types and typedefs .......................... 25 \r\n4.9.1.2 Naming Functions, Variables and Parameters.................................................. 26 \r\n4.9.1.3 Naming Constants and Enumerators................................................................. 26 \r\n4.9.2 Naming Files......................................................................................................... 26 \r\n4.9.3 Classes................................................................................................................... 27 \r\n4.9.4 Functions............................................................................................................... 27 \r\n4.9.5 Blocks ................................................................................................................... 28 \r\n4.9.6 Pointers and References........................................................................................ 28 \r\n4.9.7 Miscellaneous ....................................................................................................... 28 \r\n4.10 Classes........................................................................................................................... 29 \r\n4.10.1 Class Interfaces..................................................................................................... 29 \r\n4.10.2 Considerations Regarding Access Rights ............................................................. 29 \r\n4.10.3 Member Functions................................................................................................ 29 \r\n4.10.4 const Member Functions....................................................................................... 30 \r\n4.10.5 Friends................................................................................................................... 30 \r\n4.10.6 Object Lifetime, Constructors, and Destructors ................................................... 30 \r\n4.10.6.1 Object Lifetime ............................................................................................. 30 \r\n4.10.6.2 Constructors.................................................................................................. 31 \r\n4.10.6.3 Destructors.................................................................................................... 32 \r\n4.10.7 Assignment Operators........................................................................................... 33 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/09fced45-6505-48cf-8465-ac0eb4a93d9b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=17bef007437dbe7726fad8d64a72b7bb5f65f3b2c0374b6cdd9df43b2f4d54b8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "fef2844d-7af9-4bbf-b255-de4a2967ccb1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n5\r\n4.10.8 Operator Overloading ........................................................................................... 33 \r\n4.10.9 Inheritance............................................................................................................. 34 \r\n4.10.10 Virtual Member Functions................................................................................ 37 \r\n4.11 Namespaces................................................................................................................... 38 \r\n4.12 Templates...................................................................................................................... 39 \r\n4.13 Functions....................................................................................................................... 40 \r\n4.13.1 Function Declaration, Definition and Arguments................................................. 40 \r\n4.13.2 Return Types and Values...................................................................................... 41 \r\n4.13.3 Function Parameters (Value, Pointer or Reference) ............................................. 42 \r\n4.13.4 Function Invocation .............................................................................................. 42 \r\n4.13.5 Function Overloading ........................................................................................... 43 \r\n4.13.6 Inline Functions .................................................................................................... 43 \r\n4.13.7 Temporary Objects................................................................................................ 44 \r\n4.14 Comments..................................................................................................................... 44 \r\n4.15 Declarations and Definitions......................................................................................... 46 \r\n4.16 Initialization .................................................................................................................. 47 \r\n4.17 Types............................................................................................................................. 48 \r\n4.18 Constants....................................................................................................................... 48 \r\n4.19 Variables....................................................................................................................... 49 \r\n4.20 Unions and Bit Fields.................................................................................................... 50 \r\n4.21 Operators....................................................................................................................... 51 \r\n4.22 Pointers & References................................................................................................... 52 \r\n4.23 Type Conversions......................................................................................................... 54 \r\n4.24 Flow Control Structures................................................................................................ 56 \r\n4.25 Expressions................................................................................................................... 58 \r\n4.26 Memory Allocation....................................................................................................... 59 \r\n4.27 Fault Handling .............................................................................................................. 59 \r\n4.28 Portable Code................................................................................................................ 60 \r\n4.28.1 Data Abstraction ................................................................................................... 60 \r\n4.28.2 Data Representation.............................................................................................. 60 \r\n4.28.3 Underflow/Overflow............................................................................................. 61 \r\n4.28.4 Order of Execution................................................................................................ 61 \r\n4.28.5 Pointer Arithmetic................................................................................................. 61 \r\n4.29 Efficiency Considerations............................................................................................. 62 \r\n4.30 Miscellaneous ............................................................................................................... 62 \r\n5 Testing................................................................................................................................... 63 \r\n5.1.1 Subtypes................................................................................................................ 63 \r\n5.1.2 Structure................................................................................................................ 63 \r\nAppendix A................................................................................................................................... 66 \r\nAppendix B (Compliance).......................................................................................................... 142 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/fef2844d-7af9-4bbf-b255-de4a2967ccb1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=027128b31125bdf1d0d2bcd0f1a0f50fa769ff5cb679f4689b89f02749a3d326",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 458
      },
      {
        "segments": [
          {
            "segment_id": "8b7fe82a-0d99-44a3-88ae-f33ff69d7fcf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n6\r\nTable 1. Change Log \r\nRevision \r\nID \r\nDocument \r\nDate \r\nChange \r\nAuthority \r\nAffected \r\nParagraphs \r\nComments \r\n0001 Rev B Oct 2005 K. Carroll All Original \r\n0001 Rev C Nov 2005 K. Carroll Change log - Added Add change log. \r\nSection 1, point 3 \r\nRule 52 \r\nRule 76 \r\nRule 91 \r\nRule 93 \r\nRule 129 \r\nRule 167 \r\nRule 218 \r\nAppendix A, Rule 3 \r\nTable 2 \r\nCorrected spelling \r\nerrors. \r\nRule 159 - clarify that \r\n\"unary &\" is intended. \r\nBoth binary and unary \r\nforms of \"&\" exist. \r\nClarification is added \r\nto specify that the rule \r\nis concerned with the \r\nunary form. \r\nRule 32 - clarification of \r\nthe scope of the rule. Also, \r\nexample added in appendix \r\nfor rule 32. \r\nThe rule does not \r\napply to a particular \r\npartitioning of \r\ntemplate classes and \r\nfunctions. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8b7fe82a-0d99-44a3-88ae-f33ff69d7fcf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6751d97d1404539c92f803de3d1a6fd50c631239d48652bba1f728be9a92a88e",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c125251b-d31c-407a-a7ab-209d176d476f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n7\r\n \r\n1 INTRODUCTION \r\nThe intent of this document is to provide direction and guidance to C++ programmers that will \r\nenable them to employ good programming style and proven programming practices leading to \r\nsafe, reliable, testable, and maintainable code. Consequently, the rules contained in this \r\ndocument are required for Air Vehicle C++ development1\r\n and recommended for non-Air \r\nVehicle C++ development. \r\nAs indicated above, portions of Air Vehicle (AV) code will be developed in C++. C++ was \r\ndesigned to support data abstraction, object-oriented programming, and generic programming \r\nwhile retaining compatibility with traditional C programming techniques. For this reason, the \r\nAV Coding Standards will focus on the following: \r\n1. Motor Industry Software Reliability Association (MISRA) Guidelines For The Use Of \r\nThe C Language In Vehicle Based Software, \r\n2. Vehicle Systems Safety Critical Coding Standards for C, and \r\n3. C++ language-specific guidelines and standards. \r\nThe MISRA Guidelines were written specifically for use in systems that contain a safety aspect \r\nto them. The guidelines address potentially unsafe C language features, and provide \r\nprogramming rules to avoid those pitfalls. The Vehicle Systems Safety Critical Coding Standards \r\nfor C, which are based on the MISRA C subset, provide a more comprehensive set of language \r\nrestrictions that are applied uniformly across Vehicle Systems safety critical applications. The \r\nAV Coding Standards build on the relevant portions of the previous two documents with an \r\nadditional set of rules specific to the appropriate use C++ language features (e.g. inheritance, \r\ntemplates, namespaces, etc.) in safety-critical environments. \r\nOverall, the philosophy embodied by the rule set is essentially an extension of C++’s philosophy \r\nwith respect to C. That is, by providing “safer” alternatives to “unsafe” facilities, known \r\nproblems with low-level features are avoided. In essence, programs are written in a “safer” \r\nsubset of a superset. \r\n1\r\n TBD: Required for Air Vehicle non-prime teams? ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/c125251b-d31c-407a-a7ab-209d176d476f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f20ee7215b947379af29029ab51d60b27107fd916af753ec4e6d67dd882c3270",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 442
      },
      {
        "segments": [
          {
            "segment_id": "3c24c077-76f8-46f3-a369-7f1972dc4828",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n8\r\n2 REFERENCED DOCUMENTS \r\n1. ANSI/IEEE Std 754, IEEE Standard for Binary Floating-Point Arithmetic, 1985. \r\n2. Bjarne Stroustrup. The C++ Programming Language, 3rd Edition. Addison-Wesley, \r\n2000. \r\n3. Bjarne Stroustrup. Bjarne Stroustrup's C++ Glossary.\r\n4. Bjarne Stroustrup. Bjarne Stroustrup's C++ Style and Technique FAQ. \r\n5. Barbara Liskov. Data Abstraction and Hierarchy, SIGPLAN Notices, 23, 5 (May, 1988). \r\n6. Scott Meyers. Effective C++: 50 Specific Ways to Improve Your Programs and Design, \r\n2nd Edition. Addison-Wesley, 1998. \r\n7. Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and \r\nDesigns. Addison-Wesley, 1996. \r\n8. Motor Industry Software Reliability Association. Guidelines for the Use of the C \r\nLanguage in Vehicle Based Software, April 1998. \r\n9. ISO/IEC 10646-1, Information technology - Universal Multiple-Octet Coded Character \r\nSet (UCS) - Part 1: Architecture and Basic Multilingual Plane, 1993. \r\n10. ISO/IEC 14882:2003(E), Programming Languages – C++. American National Standards \r\nInstitute, New York, New York 10036, 2003. \r\n11. ISO/IEC 9899: 1990, Programming languages - C, ISO, 1990. \r\n12. JSF Mission Systems Software Development Plan.\r\n13. JSF System Safety Program Plan. DOC. No. 2YZA00045-0002. \r\n14. Programming in C++ Rules and Recommendations. \r\nCopyright © by Ellemtel Telecommunication Systems Laboratories \r\nBox 1505, 125 25 Alvsjo, Sweden \r\nDocument: M 90 0118 Uen, Rev. C, 27 April 1992. \r\nUsed with permission supplied via the following statement: \r\nPermission is granted to any individual or institution to use, copy, modify and distribute \r\nthis document, provided that this complete copyright and permission notice is maintained \r\nintact in all copies. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3c24c077-76f8-46f3-a369-7f1972dc4828.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7cae47732370eee727cbef34fd828becbd5178ef88246dc768c1ca1db866579f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3d5ab293-cc68-44e6-90cd-6428d71bdc90",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n9\r\n15. RTCA/DO-178B, Software Considerations in Airborne Systems and Equipment \r\nCertification, December 1992. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3d5ab293-cc68-44e6-90cd-6428d71bdc90.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b8facb3b775ca376bdedf7784664114ce246a1c64f8aaf1e35f8d8d4b0aa059b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 272
      },
      {
        "segments": [
          {
            "segment_id": "9247e322-cb36-422b-a160-db51965cec89",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n10\r\n3 GENERAL DESIGN \r\nThis coding standards document is intended to help programmers develop code that conforms to \r\nsafety-critical software principles, i.e., code that does not contain defects that could lead to \r\ncatastrophic failures resulting in significant harm to individuals and/or equipment. In general, the \r\ncode produced should exhibit the following important qualities: \r\nReliability: Executable code should consistently fulfill all requirements in a predictable manner. \r\nPortability: Source code should be portable (i.e. not compiler or linker dependent). \r\nMaintainability: Source code should be written in a manner that is consistent, readable, simple \r\nin design, and easy to debug. \r\nTestability: Source code should be written to facilitate testability. Minimizing the following \r\ncharacteristics for each software module will facilitate a more testable and maintainable module: \r\n1. code size \r\n2. complexity \r\n3. static path count (number of paths through a piece of code) \r\nReusability: The design of reusable components is encouraged. Component reuse can eliminate \r\nredundant development and test activities (i.e. reduce costs). \r\nExtensibility: Requirements are expected to evolve over the life of a product. Thus, a system \r\nshould be developed in an extensible manner (i.e. perturbations in requirements may be managed \r\nthrough local extensions rather than wholesale modifications). \r\nReadability: Source code should be written in a manner that is easy to read, understand and \r\ncomprehend. \r\nNote that following the guidelines contained within this document will not guarantee the \r\nproduction of an error-free, safe product. However, adherence to these guidelines, as well as the \r\nprocesses defined in the Software Development Plan [12], will help programmers produce clean \r\ndesigns that minimize common sources of mistakes and errors. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9247e322-cb36-422b-a160-db51965cec89.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6e875cb811a68c315cbd650d00e9f49df738723e9028e35a50663b2d296253e4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 270
      },
      {
        "segments": [
          {
            "segment_id": "ddc3f703-f224-4b4d-8f44-7e14fbee7f2a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n11\r\n3.1 Coupling & Cohesion \r\nCoupling and cohesion are properties of a system that has been decomposed into modules. \r\nCohesion is a measure of how well the parts in the same module fit together. Coupling is a \r\nmeasure of the amount of interaction between the different modules in a system. Thus, cohesion \r\ndeals with the elements within a module (how well-suited elements are to be part of the same \r\nmodule) while coupling deals with the relationships among modules (how tightly modules are \r\nglued together). \r\nObject-oriented design and implementation generally support desirable coupling and cohesion \r\ncharacteristics. The design principles behind OO techniques lead to data cohesion within \r\nmodules. Clean interfaces between modules enable the modules to be loosely coupled. \r\nMoreover, data encapsulation and data protection mechanisms provide a means to help enforce \r\nthe coupling and cohesion goals. \r\nSource code should be developed as a set of modules as loosely coupled as is reasonably \r\nfeasible. Note that generic programming (which requires the use of templates) allows source \r\ncode to be written with loose coupling and without runtime overhead. \r\nExamples of tightly coupled software would include the following: \r\n• many functions tied closely to hardware or other external software sources, and \r\n• many functions accessing global data. \r\nThere may be times where tightly coupled software is unavoidable, but its use should be both \r\nminimized and localized as suggested by the following guidelines: \r\n• limit hardware and external software interfaces to a small number of functions, \r\n• minimize the use of global data, and \r\n• minimize the exposure of implementation details. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ddc3f703-f224-4b4d-8f44-7e14fbee7f2a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b6c32f3a8578da87281cf26ac06e396c05cd1db711e6c2dd938bbc7207ccdcc3",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "04a70ab7-8357-43b8-908e-30c895331814",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n12\r\n3.2 Code Size and Complexity \r\nAV Rule 1\r\nAny one function (or method) will contain no more than 200 logical source lines of code (L\u0002SLOCs). \r\nRationale: Long functions tend to be complex and therefore difficult to comprehend and test. \r\nNote: Section 4.2.1 defines should and shall rules as well the conditions under which \r\ndeviations from should or shall rules are allowed. \r\nAV Rule 2\r\nThere shall not be any self-modifying code. \r\nRationale: Self-modifying code is error-prone as well as difficult to read, test, and maintain. \r\nAV Rule 3\r\nAll functions shall have a cyclomatic complexity number of 20 or less. \r\nRationale: Limit function complexity. See AV Rule 3 in Appendix A for additional details.\r\nException: A function containing a switch statement with many case labels may exceed this \r\nlimit. \r\nNote: Section 4.2.1 defines should and shall rules as well the conditions under which \r\ndeviations from should or shall rules are allowed. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/04a70ab7-8357-43b8-908e-30c895331814.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9cf51bbe9ebcf0bbb8d17a6227639a251fa84e6621b354b45a76466089b586cd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 425
      },
      {
        "segments": [
          {
            "segment_id": "d6d63301-745b-449b-8ef4-7290a4edbbda",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n13\r\n4 C++ CODING STANDARDS \r\n4.1 Introduction \r\nThe purpose of the following rules and recommendations is to define a C++ programming style \r\nthat will enable programmers to produce code that is more: \r\n• correct, \r\n• reliable, and \r\n• maintainable. \r\nIn order to achieve these goals, programs should: \r\n• have a consistent style, \r\n• be portable to other architectures, \r\n• be free of common types of errors, and \r\n• be understandable, and hence maintainable, by different programmers. \r\n4.2 Rules \r\n4.2.1 Should, Will, and Shall Rules \r\nThere are three types of rules: should, will, and shall rules. Each rule contains either a \r\n“should”, “will” or a “shall” in bold letters indicating its type. \r\n• Should rules are advisory rules. They strongly suggest the recommended way of \r\ndoing things. \r\n• Will rules are intended to be mandatory requirements. It is expected that they will be \r\nfollowed, but they do not require verification. They are limited to non-safety-critical \r\nrequirements that cannot be easily verified (e.g., naming conventions). \r\n• Shall rules are mandatory requirements. They must be followed and they require \r\nverification (either automatic or manual). \r\n4.2.2 Breaking Rules \r\nAV Rule 4\r\nTo break a “should” rule, the following approval must be received by the developer: \r\n• approval from the software engineering lead (obtained by the unit approval in the \r\ndevelopmental CM tool) \r\nAV Rule 5\r\nTo break a “will” or a “shall” rule, the following approvals must be received by the \r\ndeveloper: \r\n• approval from the software engineering lead (obtained by the unit approval in the \r\ndevelopmental CM tool) \r\n• approval from the software product manager (obtained by the unit approval in the \r\ndevelopmental CM tool) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d6d63301-745b-449b-8ef4-7290a4edbbda.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c649cd980bc04ee0c93e1a2c07af006812f68b4f5008570698c0ed76f63acedd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 280
      },
      {
        "segments": [
          {
            "segment_id": "4309fbc1-39b2-4785-abaa-9030285681ac",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n14\r\nAV Rule 6\r\nEach deviation from a “shall” rule shall be documented in the file that contains the \r\ndeviation). Deviations from this rule shall not be allowed, AV Rule 5 notwithstanding. \r\n4.2.3 Exceptions to Rules \r\nSome rules may contain exceptions. If a rule does contain an exception, then approval is not \r\nrequired for a deviation allowed by that exception \r\nAV Rule 7\r\nApproval will not be required for a deviation from a “shall” or “will” rule that complies \r\nwith an exception specified by that rule. \r\n4.3 Terminology \r\n1. An abstract base class is a class from which no objects may be created; it is only used as \r\na base class for the derivation of other classes. A class is abstract if it includes at least one \r\nmember function that is declared as pure virtual. \r\n2. An abstract data type is a type whose internal form is hidden behind a set of access \r\nfunctions. Objects of the type are created and inspected only by calls to the access \r\nfunctions. This allows the implementation of the type to be changed without requiring \r\nany changes outside the module in which it is defined. \r\n3. An accessor function is a function which returns the value of a data member. \r\n4. A catch clause is code that is executed when an exception of a given type is raised. The \r\ndefinition of an exception handler begins with the keyword catch. \r\n5. A class is a user-defined data type which consists of data elements and functions which \r\noperate on that data. In C++, this may be declared as a class; it may also be declared as a \r\nstruct or a union. Data defined in a class is called member data and functions defined in a \r\nclass are called member functions. \r\n6. A class template defines a family of classes. A new class may be created from a class \r\ntemplate by providing values for a number of arguments. These values may be names of \r\ntypes or constant expressions. \r\n7. A compilation unit is the source code (after preprocessing) that is submitted to a \r\ncompiler for compilation (including syntax checking). \r\n8. A concrete type is a type without virtual functions, so that objects of the type can be \r\nallocated on the stack and manipulated directly (without a need to use pointers or \r\nreferences to allow the possibility for derived classes). Often, small self-contained \r\nclasses. [3] \r\n9. A constant member function is a function which may not modify data members. \r\n10. A constructor is a function which initializes an object. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/4309fbc1-39b2-4785-abaa-9030285681ac.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b6292af5ae6c6f16e867874a740205018f6244039337f7b6d25bbea39c10f91f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 429
      },
      {
        "segments": [
          {
            "segment_id": "af9bd772-f77f-40ec-8ade-809c1c20b70e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n15\r\n11. A copy constructor is a constructor in which the first argument is a reference to an \r\nobject that has the same type as the object to be initialized. \r\n12. Dead code is “executable object code (or data) which, as a result of a design error cannot \r\nbe executed (code) or used (data) in an operational configuration of the target computer \r\nenvironment and is not traceable to a system or software requirement.” [9] \r\n13. A declaration of a variable or function announces the properties of the variable or \r\nfunction; it consists of a type name and then the variable or function name. For \r\nfunctions, it tells the compiler the name, return type and parameters. For variables, it \r\ntells the compiler the name and type. \r\nint32 fahr; \r\nint32 foo (); \r\n14. A default constructor is a constructor which needs no arguments. \r\n15. A definition of a function tells the compiler how the function works. It shows what \r\ninstructions are executed for the function. \r\nint32 foo () \r\n{ \r\n // Statements \r\n} \r\n16. An enumeration type is an explicitly declared set of symbolic integer constants. In C++ \r\nit is declared as an enum. \r\n17. An exception is a run-time program anomaly that is detected in a function or member \r\nfunction. Exception handling provides for the uniform management of exceptions. \r\n18. A forwarding function is a function which does nothing more than call another function. \r\n19. A function template defines a family of functions. A new function may be created from \r\na function template by providing values for a number of arguments. These values may be \r\nnames of types or constant expressions. \r\n20. An identifier is a name which is used to refer to a variable, constant, function or type in \r\nC++. When necessary, an identifier may have an internal structure which consists of a \r\nprefix, a name, and a suffix (in that order). \r\n21. An iterator is an object that con be used to traverse a data structure. \r\n22. A macro is a name for a text string which is defined in a #define statement. When this \r\nname appears in source code, the compiler replaces it with the defined text string. \r\n23. Multiple inheritance is the derivation of a new class from more than one base class. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/af9bd772-f77f-40ec-8ade-809c1c20b70e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8847a449d861336704533bd409348e13bfb9061fb39293106fe8ce12aed2942e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 383
      },
      {
        "segments": [
          {
            "segment_id": "7e522082-5c9d-4a96-963f-10deef732160",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n16\r\n24. A mutator function is a function which sets the value of a data member. \r\n25. The one definition rule - there must be exactly one definition of each entity in a \r\nprogram. If more than one definition appears, say because of replication through header \r\nfiles, the meaning of all such duplicates must be identical. [3] \r\n26. An overloaded function name is a name which is used for two or more functions or \r\nmember functions having different argument types. \r\n27. An overridden member function is a member function in a base class which is re\u0002defined in a derived class. \r\n \r\n28. A built-in data type is a type which is defined in the language itself, such as int. \r\n29. Protected members of a class are member data and member functions which are \r\naccessible by specifying the name within member functions of derived classes. \r\n30. Public members of a class are member data and member functions which are accessible \r\neverywhere by specifying an instance of the class and the name. \r\n31. A pure virtual function is one with an initializer = 0 in its declaration. Making a virtual \r\nfunction pure makes the class abstract. A pure virtual function must be overridden in at \r\nleast one derived class. \r\n32. A reference is another name for a given variable. In C++, the ‘address of’ (&) operator is \r\nused immediately after the data type to indicate that the declared variable, constant, or \r\nfunction argument is a reference. \r\n33. The scope of a name refers to the context in which it is visible. [Context, here, means the \r\nfunctions or blocks in which a given variable name can be used.] \r\n \r\n34. A side effect is the change of a variable as a by-product of an evaluation of an \r\nexpression. \r\n35. A structure is a user-defined type for which all members are public by default. \r\n \r\n36. A typedef is another name for a data type, specified in C++ using a typedef declaration. \r\n37. Unqualified type is a type that does not have const or volatile as a qualifier. \r\n38. A user-defined data type is a type which is defined by a programmer in a class, struct, \r\nunion, or enum definition or as an instantiation of a class template. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7e522082-5c9d-4a96-963f-10deef732160.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20212208f93aa61a07a05ae277c4a7f98646e73f4f73a75fd788efe0ff54b8fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 379
      },
      {
        "segments": [
          {
            "segment_id": "0613bbc5-37b3-4840-8783-bdd4d2ba8752",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n17\r\n4.4 Environment \r\n4.4.1 Language \r\nAV Rule 8\r\nAll code shall conform to ISO/IEC 14882:2002(E) standard C++. [10] \r\nRationale: ISO/IEC 14882 is the international standard that defines the C++ programming \r\nlanguage. Thus all code shall be well-defined with respect to ISO/IEC 14882. Any language \r\nextensions or variations from ISO/IEC 14882 shall not be allowed. \r\n4.4.2 Character Sets \r\nNote that the rules in this section may need to be modified if one or more foreign languages will \r\nbe used for input/output purposes (e.g. displaying information to pilots). \r\nAV Rule 9 (MISRA Rule 5, Revised) \r\nOnly those characters specified in the C++ basic source character set will be used. This set \r\nincludes 96 characters: the space character, the control characters representing horizontal tab, \r\nvertical tab, form feed, and newline, and the following 91 graphical characters: \r\na b c d e f g h i j k l m n o p q r s t u v w x y z \r\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z \r\n0 1 2 3 4 5 6 7 8 9 \r\n_ { } [ ] # ( ) < > % : ; . ? * + - \r\n/ ^ & | ~ ! = , \\ \" ’ \r\nRationale: Minimal required character set. \r\nAV Rule 10 (MISRA Rule 6) \r\nValues of character types will be restricted to a defined and documented subset of ISO \r\n10646-1. [9] \r\nRationale: 10646-1 represents an international standard for character mapping. For the basic \r\nsource character set, the 10646-1 mapping corresponds to the ASCII mapping. \r\nAV Rule 11 (MISRA Rule 7) \r\nTrigraphs will not be used. \r\nTrigraph sequences are three-character sequences that are replaced by a corresponding single \r\ncharacter, as follows: \r\nAlternative Primary alternative primary alternative primary \r\n??= # ??( [ ??< { \r\n??/ \\ ??) ] ??> } \r\n??' ^ ??! | ??- ~ \r\nThe trigraph sequences provide a way to specify characters that are missing on some \r\nterminals, but that the C++ language uses. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/0613bbc5-37b3-4840-8783-bdd4d2ba8752.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=11c342171724032e65bd9569265915fb27dc9a513ed33bfe85834a5d03e61d09",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 354
      },
      {
        "segments": [
          {
            "segment_id": "37a4286e-18a1-4829-9989-d3192ecd38b3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n18\r\nRationale: Readability. See AV Rule 11 in Appendix A. \r\nNote: trigraphs can often be disabled via compiler flags (e.g.–no_alternative_tokens for \r\nthe Green Hills C/C++ compiler suite)\r\nAV Rule 12 (Extension of MISRA Rule 7) \r\nThe following digraphs will not be used: \r\nAlternative Primary alternative Primary\r\n<% { :> ] \r\n%> } %: # \r\n<: [ %:%: ## \r\nThe digraphs listed above provide a way to specify characters that are missing on some \r\nterminals, but that the C++ language uses. \r\nRationale: Readability. See AV Rule 12 in Appendix A. \r\nNote: Digraphs can often be disabled via compiler flags (e.g.–no_alternative_tokens for \r\nthe Green Hills C/C++ compiler suite)\r\nAV Rule 13 (MISRA Rule 8) \r\nMulti-byte characters and wide string literals will not be used. \r\nRationale: Both multi-byte and wide characters may be composed of more than one byte. \r\nHowever, certain aspects of the behavior of multi-byte characters are implementation\u0002defined. [10] \r\nAV Rule 14\r\nLiteral suffixes shall use uppercase rather than lowercase letters. \r\nRationale: Readability. \r\nExample: \r\nconst int64 fs_frame_rate = 64l; // Wrong! Looks too much like 641 \r\nconst int64 fs_frame_rate = 64L; // Okay \r\n4.4.3 Run-Time Checks \r\nAV Rule 15 (MISRA Rule 4, Revised) \r\nProvision shall be made for run-time checking (defensive programming). \r\nRationale: For SEAL 1 or SEAL 2 software [13], provisions shall be made to ensure the \r\nproper operation of software and system function. See AV Rule 15 in Appendix A for \r\nadditional details. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/37a4286e-18a1-4829-9989-d3192ecd38b3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9931b1131202c9651f75787357937887e23d8d2ff9ca1457530e205bc2ab7a09",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 242
      },
      {
        "segments": [
          {
            "segment_id": "74081024-131b-4667-b48f-44b1d74f6df9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n19\r\n4.5 Libraries \r\nAV Rule 16\r\nOnly DO-178B level A [15] certifiable or SEAL 1 C/C++ libraries shall be used with safety\u0002critical (i.e. SEAL 1) code [13]. \r\nRationale: Safety. \r\nNote: All libraries used must be DO-178B level A certifiable or written in house and \r\ndeveloped using the same software development processes required for all other \r\nsafety-critical software. This includes both the run-time library functions as well as \r\nthe C/C++ standard library functions. [10,11] Note that we expect certifiable versions \r\nof the C++ standard libraries to be available at some point in the future. These \r\ncertifiable libraries would be allowed under this rule. \r\n4.5.1 Standard Libraries \r\nAV Rule 17 through AV Rule 25 prohibit the use of a number of features whose behaviors are \r\nlocal-specific, unspecified, undefined, implementation-defined, or otherwise poorly defined and \r\nhence error prone. \r\nAV Rule 17 (MISRA Rule 119) \r\nThe error indicator errno shall not be used. \r\nException: If there is no other reasonable way to communicate an error condition to an \r\napplication, then errno may be used. For example, third party math libraries will often make \r\nuse of errno to inform an application of underflow/overflow or out-of-range/domain \r\nconditions. Even in this case, errno should only be used if its design and implementation are \r\nwell-defined and documented. \r\nAV Rule 18 (MISRA Rule 120) \r\nThe macro offsetof, in library <stddef.h>, shall not be used. \r\nAV Rule 19 (MISRA Rule 121) \r\n<locale.h> and the setlocale function shall not be used. \r\nAV Rule 20 (MISRA Rule 122) \r\nThe setjmp macro and the longjmp function shall not be used. \r\nAV Rule 21 (MISRA Rule 123) \r\nThe signal handling facilities of <signal.h> shall not be used. \r\nAV Rule 22 (MISRA Rule 124, Revised) \r\nThe input/output library <stdio.h> shall not be used. \r\nAV Rule 23 (MISRA Rule 125) \r\nThe library functions atof, atoi and atol from library <stdlib.h> shall not be used. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/74081024-131b-4667-b48f-44b1d74f6df9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9137957f5e931c3a54eff4437e29eaaa00bfcb00bc6ac39121c39e9c9369f5fa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 316
      },
      {
        "segments": [
          {
            "segment_id": "3078dc29-fcbd-45d0-82bd-92d7ab19c204",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n20\r\nException: If required, atof, atoi and atol may be used only after design and implementation \r\nare well-defined and documented, especially in regards to precision and failures in string \r\nconversion attempts. \r\nAV Rule 24 (MISRA Rule 126) \r\nThe library functions abort, exit, getenv and system from library <stdlib.h> shall not be used. \r\nAV Rule 25 (MISRA Rule 127) \r\nThe time handling functions of library <time.h> shall not be used. \r\n4.6 Pre-Processing Directives \r\nSince the pre-processor knows nothing about C++, it should not be used to do what can \r\notherwise be done in C++. \r\nAV Rule 26\r\nOnly the following pre-processor directives shall be used: \r\n1. #ifndef \r\n2. #define \r\n3. #endif \r\n4. #include \r\nRationale: Limit the use of the pre-processor to those cases where it is necessary. \r\nNote: Allowable uses of these directives are specified in the following rules. \r\n4.6.1 #ifndef and #endif Pre-Processing Directives \r\nAV Rule 27\r\n#ifndef, #define and #endif will be used to prevent multiple inclusions of the same header \r\nfile. Other techniques to prevent the multiple inclusions of header files will not be used. \r\nRationale: Eliminate multiple inclusions of the same header file in a standard way. \r\nExample: For SomeHeaderFileName.h \r\n#ifndef Header_filename \r\n#define Header_filename \r\n // Header declarations… \r\n#endif \r\nAV Rule 28\r\nThe #ifndef and #endif pre-processor directives will only be used as defined in AV Rule 27\r\nto prevent multiple inclusions of the same header file. \r\nRationale: Conditional code compilation should be kept to a minimum as it can significantly \r\nobscure testing and maintenance efforts. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3078dc29-fcbd-45d0-82bd-92d7ab19c204.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c1b230d71f7f2e5d487895812d44ca1d3aa6b6a8e243dc14a272365fd1032cce",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 256
      },
      {
        "segments": [
          {
            "segment_id": "6471f038-9c8c-4f96-ae1b-fb15cf766f14",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n21\r\n4.6.2 #define Pre-Processing Directive \r\nAV Rule 29\r\nThe #define pre-processor directive shall not be used to create inline macros. Inline functions \r\nshall be used instead. \r\nRationale: Inline functions do not require text substitutions and behave well when called \r\nwith arguments (e.g. type checking is performed). See AV Rule 29 in Appendix A for an \r\nexample. \r\nSee section 4.13.6 for rules pertaining to inline functions. \r\nAV Rule 30\r\nThe #define pre-processor directive shall not be used to define constant values. Instead, the \r\nconst qualifier shall be applied to variable declarations to specify constant values. \r\nException: The only exception to this rule is for constants that are commonly defined by \r\nthird-party modules. For example, #define is typically used to define NULL in standard \r\nheader files. Consequently, NULL may be treated as a macro for compatibility with third\u0002party tools. \r\nRationale: const variables follow scope rules, are subject to type checking and do not require \r\ntext substitutions (which can be confusing or misleading). See AV Rule 30 in Appendix A \r\nfor an example. \r\nAV Rule 31\r\nThe #define pre-processor directive will only be used as part of the technique to prevent \r\nmultiple inclusions of the same header file. \r\nRationale: #define can be used to specify conditional compilation (AV Rule 27 and AV Rule \r\n28), inline macros (AV Rule 29) and constants (AV Rule 30). This rule specifies that the only \r\nallowable use of #define is to prevent multiple includes of the same header file (AV Rule 27). \r\n4.6.3 #include Pre-Processing Directive \r\nAV Rule 32\r\nThe #include pre-processor directive will only be used to include header (*.h) files. \r\nException: In the case of template class or function definitions, the code may be partitioned \r\ninto separate header and implementation files. In this case, the implementation file may be \r\nincluded as a part of the header file. The implementation file is logically a part of the header \r\nand is not separately compilable. See AV Rule 32 in Appendix A. \r\nRationale: Clarity. The only files included in a .cpp file should be the relevant header (*.h) \r\nfiles. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6471f038-9c8c-4f96-ae1b-fb15cf766f14.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=52cb2123e659e8443733df06cd52a7fa78ead02266f412df1fe231cc6ec8da42",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 348
      },
      {
        "segments": [
          {
            "segment_id": "ea2e90d4-7625-4c8d-b1ad-e84634c8ffe8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n22\r\n4.7 Header Files \r\nAV Rule 33\r\nThe #include directive shall use the <filename.h> notation to include header files. \r\nNote that relative pathnames may also be used. See also AV Rule 53, AV Rule 53.1, and AV \r\nRule 55 for additional information regarding header file names. \r\nRationale: The include form “filename.h” is typically used to include local header files. \r\nHowever, due to the unfortunate divergence in vendor implementations, only the \r\n<filename.h> form will be used. \r\nExamples: \r\n#include <foo.h> // Good \r\n#include <dir1/dir2/foo.h> // Good: relative path used\r\n#include “foo.h” // Bad: “filename.h” form used \r\nAV Rule 34\r\nHeader files should contain logically related declarations only. \r\nRationale: Minimize unnecessary dependencies. \r\nAV Rule 35\r\nA header file will contain a mechanism that prevents multiple inclusions of itself. \r\nRationale: Avoid accidental header file recursion. Note AV Rule 27 specifies the \r\nmechanism by which multiple inclusions are to be eliminated whereas this rule (AV Rule 35) \r\nspecifies that each header file must use that mechanism. \r\nAV Rule 36\r\nCompilation dependencies should be minimized when possible. (Stroustrup [2], Meyers [6], \r\nitem 34) \r\nRationale: Minimize unnecessary recompilation of source files. See AV Rule 36 in \r\nAppendix A for an example. \r\nNote: AV Rule 37 and AV Rule 38 detail several mechanisms by which compilation \r\ndependencies may be minimized. \r\nAV Rule 37\r\nHeader (include) files should include only those header files that are required for them to \r\nsuccessfully compile. Files that are only used by the associated .cpp file should be placed in \r\nthe .cpp file—not the .h file. \r\nRationale: The #include statements in a header file define the dependencies of the file. \r\nFewer dependencies imply looser couplings and hence a smaller ripple-effect when the \r\nheader file is required to change. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ea2e90d4-7625-4c8d-b1ad-e84634c8ffe8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7aa411638fc5ee6c911a9074a2de93c960d4ee260937625d1a738d19f8bb1c7e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 292
      },
      {
        "segments": [
          {
            "segment_id": "ed1b3ad4-67ee-4efc-96ca-270e2ec8b748",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n23\r\nAV Rule 38\r\nDeclarations of classes that are only accessed via pointers (*) or references (&) should be \r\nsupplied by forward headers that contain only forward declarations. \r\nRationale: The header files of classes that are only referenced via pointers or references need \r\nnot be included. Doing so often increases the coupling between classes, leading to increased \r\ncompilation dependencies as well as greater maintenance efforts. Forward declarations of \r\nthe classes in question (supplied by forward headers) can be used to limit implementation \r\ndependencies, maintenance efforts and compile times. See AV Rule 38 in Appendix A for an \r\nexample. Note that this technique is employed in the standard header <iosfwd> to declare \r\nforward references to template classes used throughout <iostreams>. \r\nAV Rule 39\r\nHeader files (*.h) will not contain non-const variable definitions or function definitions. (See \r\nalso AV Rule 139.) \r\nRationale: Header files should typically contain interface declarations—not implementation \r\ndetails. \r\nException: Inline functions and template definitions may be included in header files. See AV \r\nRule 39 in Appendix A for an example. \r\n4.8 Implementation Files \r\nAV Rule 40\r\nEvery implementation file shall include the header files that uniquely define the inline \r\nfunctions, types, and templates used. \r\nRationale: Insures consistency checks. (See AV Rule 40 Appendix in A for additional \r\ndetails) \r\nNote that this rule implies that the definition of a particular inline function, type, or template \r\nwill never occur in multiple header files. \r\n4.9 Style \r\nImposing constraints on the format of syntactic elements makes source code easier to read due to \r\nconsistency in form and appearance. Note that automatic code generators should be configured to \r\nproduce code that conforms to the style guidelines where possible. However, an exception is \r\nmade for code generators that cannot be reasonably configured to comply with should or will\r\nstyle rules (safety-critical shall rules must still be followed). \r\nAV Rule 41\r\nSource lines will be kept to a length of 120 characters or less. \r\nRationale: Readability and style. Very long source lines can be difficult to read and \r\nunderstand. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ed1b3ad4-67ee-4efc-96ca-270e2ec8b748.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=996258d91a8afd13bf368f3a302296d560ce3b5677c8ec2987e1d26fa0ab4529",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 341
      },
      {
        "segments": [
          {
            "segment_id": "6b01fee0-d015-402e-8681-4d199747e105",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n24\r\nAV Rule 42\r\nEach expression-statement will be on a separate line. \r\nRationale: Simplicity, readability, and style. See AV Rule 42 in Appendix A for examples. \r\nAV Rule 43\r\nTabs should be avoided. \r\nRationale: Tabs are interpreted differently across various editors and printers. \r\nNote: many editors can be configured to map the ‘tab’ key to a specified number of spaces. \r\nAV Rule 44\r\nAll indentations will be at least two spaces and be consistent within the same source file. \r\nRationale: Readability and style. \r\n4.9.1 Naming Identifiers \r\nThe choice of identifier names should: \r\n• Suggest the usage of the identifier. \r\n• Consist of a descriptive name that is short yet meaningful. \r\n• Be long enough to avoid name conflicts, but not excessive in length. \r\n• Include abbreviations that are generally accepted. \r\nNote: In general, the above guidelines should be followed. However, conventional usage of \r\nsimple identifiers (i, x, y, p, etc.) in small scopes can lead to cleaner code and will \r\ntherefore be permitted. \r\nAdditionally, the term ‘word’ in the following naming convention rules may be used to refer \r\nto a word, an acronym, an abbreviation, or a number. \r\nAV Rule 45\r\nAll words in an identifier will be separated by the ‘_’ character. \r\nRationale: Readability and Style. \r\nAV Rule 46 (MISRA Rule 11, Revised) \r\nUser-specified identifiers (internal and external) will not rely on significance of more than 64 \r\ncharacters. \r\nNote: The C++ standard suggests that a minimum of 1,024 characters will be significant. \r\n[10] \r\nAV Rule 47\r\nIdentifiers will not begin with the underscore character ‘_’. \r\nRationale: ‘_’ is often used as the first character in the name of library functions (e.g. _main, \r\n_exit, etc.) In order to avoid name collisions, identifiers should not begin with ‘_’. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6b01fee0-d015-402e-8681-4d199747e105.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3fbfadb3caef1e5396d3a7c30ef09059ca8ba7efd1b09b734139888673d722c9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 295
      },
      {
        "segments": [
          {
            "segment_id": "b4650107-f237-49bd-97a4-f8c71dbaf4d3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n25\r\nAV Rule 48\r\nIdentifiers will not differ by: \r\n• Only a mixture of case \r\n• The presence/absence of the underscore character \r\n• The interchange of the letter ‘O’, with the number ‘0’ or the letter ‘D’ \r\n• The interchange of the letter ‘I’, with the number ‘1’ or the letter ‘l’ \r\n• The interchange of the letter ‘S’ with the number ‘5’ \r\n• The interchange of the letter ‘Z’ with the number 2 \r\n• The interchange of the letter ‘n’ with the letter ‘h’. \r\nRationale: Readability. \r\nAV Rule 49\r\nAll acronyms in an identifier will be composed of uppercase letters. \r\nNote: An acronym will always be in upper case, even if the acronym is located in a portion \r\nof an identifier that is specified to be lower case by other rules. \r\nRationale: Readability. \r\n4.9.1.1 Naming Classes, Structures, Enumerated types and typedefs \r\nAV Rule 50\r\nThe first word of the name of a class, structure, namespace, enumeration, or type created \r\nwith typedef will begin with an uppercase letter. All others letters will be lowercase. \r\nRationale: Style. \r\nExample: \r\nclass Diagonal_matrix { … }; // Only first letter is capitalized; \r\nenum RGB_colors {red, green, blue}; // RGB is an acronym so all letters are un upper case \r\nException: The first letter of a typedef name may be in lowercase in order to conform to a \r\nstandard library interface or when used as a replacement for fundamental types (see AV Rule \r\n209). \r\ntypename C::value_type s=0; // value_type of container C begins with a lower case \r\n //letter in conformance with standard library typedefs ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/b4650107-f237-49bd-97a4-f8c71dbaf4d3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c44cf21bf33cda5c955848e45b5f644a1f939a14f015cf9c679591fbee65cf0",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "34fae2c7-90aa-437c-baf5-148528b6dc04",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n26\r\n4.9.1.2 Naming Functions, Variables and Parameters \r\nAV Rule 51\r\nAll letters contained in function and variable names will be composed entirely of lowercase \r\nletters. \r\nRationale: Style. \r\nExample: \r\nclass Example_class_name \r\n{ \r\n public: \r\n uint16 example_function_name (void); \r\n private: \r\n uint16 example_variable_name; \r\n }; \r\n4.9.1.3 Naming Constants and Enumerators \r\nAV Rule 52\r\nIdentifiers for constant and enumerator values shall be lowercase. \r\nExample: \r\nconst uint16 max_pressure = 100; \r\nenum Switch_position {up, down}; \r\nRationale: Although it is an accepted convention to use uppercase letters for constants and \r\nenumerators, it is possible for third party libraries to replace constant/enumerator names as \r\npart of the macro substitution process (macros are also typically represented with uppercase \r\nletters). \r\n4.9.2 Naming Files \r\nNaming files should follow the same guidelines as naming identifiers with a few additions. \r\nAV Rule 53\r\nHeader files will always have a file name extension of \".h\". \r\nAV Rule 53.1\r\nThe following character sequences shall not appear in header file names: ‘, \\, /*, //, or \". \r\nRationale: If any of the character sequences ‘, \\, /*, //, or \" appears in a header file name (i.e. \r\n<h-char-sequence>), the resulting behavior is undefined. [10], 2.8(2) Note that relative \r\npathnames may be used. However, only “/” may be used to separate directory and file names. \r\nExamples: \r\n#include <foo /* comment */ .h> // Bad: “/*” prohibited \r\n#include <foo’s .h> // Bad: “’” prohibited \r\n#include <dir1\\dir2\\foo.h> // Bad: “\\” prohibited \r\n#include <dir1/dir2/foo.h> // Good: relative path used ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/34fae2c7-90aa-437c-baf5-148528b6dc04.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2afecb563d6fc8e95b0980838a5a60246f5ae4881cd86b97295f9bff6ab6b041",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 511
      },
      {
        "segments": [
          {
            "segment_id": "269945e0-c9f4-4d93-88e6-88eb9096ca77",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n27\r\nAV Rule 54\r\nImplementation files will always have a file name extension of \".cpp\". \r\nAV Rule 55\r\nThe name of a header file should reflect the logical entity for which it provides declarations. \r\nExample: \r\nFor the Matrix entity, the header file would be named: \r\nMatrix.h \r\nAV Rule 56\r\nThe name of an implementation file should reflect the logical entity for which it provides \r\ndefinitions and have a “.cpp” extension (this name will normally be identical to the header \r\nfile that provides the corresponding declarations.) \r\nAt times, more than one .cpp file for a given logical entity will be required. In these cases, a \r\nsuffix should be appended to reflect a logical differentiation. \r\nExample 1: One .cpp file for the Matrix class: \r\nMatrix.cpp\r\nExample 2: Multiple files for a math library:\r\nMath_sqrt.cpp \r\nMath_sin.cpp \r\nMath_cos.cpp \r\n4.9.3 Classes \r\nAV Rule 57\r\nThe public, protected, and private sections of a class will be declared in that order (the public \r\nsection is declared before the protected section which is declared before the private section). \r\nRationale: By placing the public section first, everything that is of interest to a user is \r\ngathered in the beginning of the class definition. The protected section may be of interest to \r\ndesigners when considering inheriting from the class. The private section contains details that \r\nshould be of the least general interest. \r\n4.9.4 Functions \r\nAV Rule 58\r\nWhen declaring and defining functions with more than two parameters, the leading \r\nparenthesis and the first argument will be written on the same line as the function name. \r\nEach additional argument will be written on a separate line (with the closing parenthesis \r\ndirectly after the last argument). \r\nRationale: Readability and style. See AV Rule 58 in Appendix A for examples. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/269945e0-c9f4-4d93-88e6-88eb9096ca77.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d402b6e58a5f993065a4dd2a9ce092e9ba019cd602f7ee4e8131b53c675da1fc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 295
      },
      {
        "segments": [
          {
            "segment_id": "ccc8f2c2-8141-40b2-a66f-8c0da9b9058a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n28\r\n4.9.5 Blocks \r\nAV Rule 59 (MISRA Rule 59, Revised) \r\nThe statements forming the body of an if, else if, else, while, do…while or for statement shall\r\nalways be enclosed in braces, even if the braces form an empty block. \r\nRationale: Readability. It can be difficult to see “;” when it appears by itself. See AV Rule \r\n59 in Appendix A for examples. \r\nAV Rule 60\r\nBraces (\"{}\") which enclose a block will be placed in the same column, on separate lines \r\ndirectly before and after the block. \r\nExample: \r\nif (var_name == true) \r\n { \r\n } \r\n else \r\n { \r\n } \r\nAV Rule 61\r\nBraces (\"{}\") which enclose a block will have nothing else on the line except comments (if \r\nnecessary). \r\n4.9.6 Pointers and References \r\nAV Rule 62\r\nThe dereference operator ‘*’ and the address-of operator ‘&’ will be directly connected with \r\nthe type-specifier. \r\nRationale: The int32* p; form emphasizes type over syntax while the int32 *p; form \r\nemphasizes syntax over type. Although both forms are equally valid C++, the heavy \r\nemphasis on types in C++ suggests that int32* p; is the preferable form.\r\nExamples: \r\nint32* p; // Correct \r\nint32 *p; // Incorrect \r\nint32* p, q; // Probably error. However, this declaration cannot occur \r\n // under the one name per declaration style required by AV Rule 152. \r\n4.9.7 Miscellaneous \r\nAV Rule 63\r\nSpaces will not be used around ‘.’ or ‘->’, nor between unary operators and operands. \r\nRationale: Readability and style. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ccc8f2c2-8141-40b2-a66f-8c0da9b9058a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0d1f59da001e595c19c942d0eb76fb0a4574767391910b3f6d3ad3ecaea0c2c1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 246
      },
      {
        "segments": [
          {
            "segment_id": "a7258491-b9b5-4968-8add-398456ce9f71",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n29\r\n4.10 Classes \r\n4.10.1 Class Interfaces \r\nAV Rule 64\r\nA class interface should be complete and minimal. See Meyers [6], item 18. \r\nRationale: A complete interface allows clients to do anything they may reasonably want to \r\ndo. On the other hand, a minimal interface will contain as few functions as possible (i.e. no \r\ntwo functions will provide overlapping services). Hence, the interface will be no more \r\ncomplicated than it has to be while allowing clients to perform whatever activities are \r\nreasonable for them to expect. \r\nNote: Overlapping services may be required where efficiency requirements dictate. Also, the \r\nuse of helper functions (Stroustrup [2], 10.3.2) can simplify class interfaces. \r\n4.10.2 Considerations Regarding Access Rights \r\nRoughly two types of classes exist: those that essentially aggregate data and those that provide \r\nan abstraction while maintaining a well-defined state or invariant. The following rules provide \r\nguidance in this regard. \r\nAV Rule 65\r\nA structure should be used to model an entity that does not require an invariant. \r\nAV Rule 66\r\nA class should be used to model an entity that maintains an invariant. \r\nAV Rule 67\r\nPublic and protected data should only be used in structs—not classes. \r\nRationale: A class is able to maintain its invariant by controlling access to its data. However, \r\na class cannot control access to its members if those members non-private. Hence all data in \r\na class should be private. \r\nException: Protected members may be used in a class as long as that class does not \r\nparticipate in a client interface. See AV Rule 88. \r\n4.10.3 Member Functions \r\nAV Rule 68\r\nUnneeded implicitly generated member functions shall be explicitly disallowed. See Meyers \r\n[6], item 27. \r\nRationale: Eliminate any surprises that may occur as a result of compiler generated \r\nfunctions. For example, if the assignment operator is unneeded for a particular class, then it \r\nshould be declared private (and not defined). Any attempt to invoke the operator will result \r\nin a compile-time error. On the contrary, if the assignment operator is not declared, then \r\nwhen it is invoked, a compiler-generated form will be created and subsequently executed. \r\nThis could lead to unexpected results. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/a7258491-b9b5-4968-8add-398456ce9f71.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2c0bcfdc44c4e0aece7aaf5bcd1435646f8b256fb7cbed9df9a0325b0512da79",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 360
      },
      {
        "segments": [
          {
            "segment_id": "b2ff5f62-df7d-49af-a4b6-27677e3c8ddc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n30\r\nNote: If the copy constructor is explicitly disallowed, the assignment operator should be as \r\nwell.) \r\n4.10.4 const Member Functions \r\nAV Rule 69\r\nA member function that does not affect the state of an object (its instance variables) will be \r\ndeclared const. \r\nMember functions should be const by default. Only when there is a clear, explicit reason \r\nshould the const modifier on member functions be omitted. \r\nRationale: Declaring a member function const is a means of ensuring that objects will not be \r\nmodified when they should not. Furthermore, C++ allows member functions to be \r\noverloaded on their const-ness. \r\n4.10.5 Friends \r\nAV Rule 70\r\nA class will have friends only when a function or object requires access to the private \r\nelements of the class, but is unable to be a member of the class for logical or efficiency \r\nreasons. \r\nRationale: The overuse of friends leads to code that is both difficult to understand and \r\nmaintain. \r\nAV Rule 70 in Appendix A provides examples of acceptable uses of friends. Note that the \r\nalternative to friendship in some instances is to expose more internal detail than is necessary. \r\nIn those cases friendship is not only allowed, but is the preferable option. \r\n4.10.6 Object Lifetime, Constructors, and Destructors \r\n4.10.6.1 Object Lifetime \r\nConceptually, developers understand that objects should not be used before they have been \r\ncreated or after they have been destroyed. However, a number of scenarios may arise where this \r\ndistinction may not be obvious. Consequently, the following object-lifetime rule is provided to \r\nhighlight these instances. \r\nAV Rule 70.1\r\nAn object shall not be improperly used before its lifetime begins or after its lifetime ends. \r\nRationale: Improper use of an object, before it is created or after it is destroyed, results in \r\nundefined behavior. See section 3.8 of [10] for details on “proper” vs. “improper” use. See \r\nalso AV Rule 70.1 in Appendix A for examples. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/b2ff5f62-df7d-49af-a4b6-27677e3c8ddc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a866d7292a5e7f01df1d23acc70a60f6a15ff52479f35febb0d21aa2f2e39faf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 320
      },
      {
        "segments": [
          {
            "segment_id": "330e74ff-18f1-416a-9413-5ca89ab30ccb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n31\r\n4.10.6.2 Constructors \r\nAV Rule 71\r\nCalls to an externally visible operation of an object, other than its constructors, shall not be \r\nallowed until the object has been fully initialized. \r\nRationale: Avoid problems resulting from incomplete object initialization. Further details \r\nare given in AV Rule 71 in Appendix A. \r\nAV Rule 71.1\r\nA class’s virtual functions shall not be invoked from its destructor or any of its constructors. \r\nRationale: A class’s virtual functions are resolved statically (not dynamically) in its \r\nconstructors and destructor. See AV Rule 71.1 in Appendix_A for additional details. \r\nAV Rule 72\r\nThe invariant2 for a class should be: \r\n• a part of the postcondition of every class constructor, \r\n• a part of the precondition of the class destructor (if any), \r\n• a part of the precondition and postcondition of every other publicly accessible \r\noperation. \r\nRationale: Prohibit clients from influencing the invariant of an object through any other \r\nmeans than the public interface. \r\nAV Rule 73\r\nUnnecessary default constructors shall not be defined. See Meyers [7], item 4. (See also AV \r\nRule 143). \r\nRationale: Discourage programmers from creating objects until the requisite data is \r\navailable for complete object construction (i.e. prevent objects from being created in a \r\npartially initialized state). See AV Rule 73 in Appendix A for examples. \r\nAV Rule 74\r\nInitialization of nonstatic class members will be performed through the member initialization \r\nlist rather than through assignment in the body of a constructor. See Meyers [6], item 12. \r\nException: Assignment should be used when an initial value cannot be represented by a \r\nsimple expression (e.g. initialization of array values), or when a name must be introduced \r\nbefore it can be initialized (e.g. value received via an input stream). \r\nSee AV Rule 74 in Appendix A for details. \r\n \r\n2\r\n A class invariant is a statement-of-fact about a class that must be true for all stable instances of the class. A class is \r\nconsidered to be in a stable state immediately after construction, immediately before destruction, and immediately \r\nbefore and after any remote public method invocation. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/330e74ff-18f1-416a-9413-5ca89ab30ccb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2d252707f94bed2248360d1e50d59a6f93326f3a46dbcc7952f7914e3517e8c6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 347
      },
      {
        "segments": [
          {
            "segment_id": "461453d9-bfee-4abf-a5fc-867dccfb7255",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n32\r\nAV Rule 75\r\nMembers of the initialization list shall be listed in the order in which they are declared in the \r\nclass. See Stroustrup [2], 10.4.5 and Meyers [6], item 13. \r\nNote: Since base class members are initialized before derived class members, base class \r\ninitializers should appear at the beginning of the member initialization list. \r\nRationale: Members of a class are initialized in the order in which they are declared—not \r\nthe order in which they appear in the initialization list. \r\nAV Rule 76\r\nA copy constructor and an assignment operator shall be declared for classes that contain \r\npointers to data items or nontrivial destructors. See Meyers [6], item 11. \r\nNote: See also AV Rule 80 which indicates that default copy and assignment operators are \r\npreferable when those operators offer reasonable semantics. \r\nRationale: Ensure resources are appropriately managed during copy and assignment \r\noperations. See AV Rule 76 in Appendix A for additional details. \r\nAV Rule 77\r\nA copy constructor shall copy all data members and bases that affect the class invariant (a \r\ndata element representing a cache, for example, would not need to be copied). \r\nNote: If a reference counting mechanism is employed by a class, a literal copy need not be \r\nperformed in every case. See also AV Rule 83. \r\nRationale: Ensure data members and bases are properly handled when an object is copied. \r\nSee AV Rule 77 in Appendix A for additional details. \r\nAV Rule 77.1\r\nThe definition of a member function shall not contain default arguments that produce a \r\nsignature identical to that of the implicitly-declared copy constructor for the corresponding \r\nclass/structure. \r\nRationale: Compilers are not required to diagnose this ambiguity. See AV Rule 77.1 in \r\nAppendix A for additional details. \r\n4.10.6.3 Destructors \r\nAV Rule 78\r\nAll base classes with a virtual function shall define a virtual destructor. \r\nRationale: Prevent undefined behavior. If an application attempts to delete a derived class \r\nobject through a base class pointer, the result is undefined if the base class’s destructor is \r\nnon-virtual. \r\nNote: This rule does not imply the use of dynamic memory (allocation/deallocation from the \r\nfree store) will be used. See AV Rule 206. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/461453d9-bfee-4abf-a5fc-867dccfb7255.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9651eb3bf1cfa0c635f163abc9b352c39ba5c63833700a85352d4b7598e851b9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "eb6e8127-5ea3-4987-95a8-49b0401a2a5e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n33\r\nAV Rule 79\r\nAll resources acquired by a class shall be released by the class’s destructor. See Stroustrup \r\n[2], 14.4 and Meyers [7], item 9. \r\nRationale: Prevention of resource leaks, especially in error cases. See AV Rule 79 in \r\nAppendix A for additional details. \r\n4.10.7 Assignment Operators \r\nAV Rule 80\r\nThe default copy and assignment operators will be used for classes when those operators \r\noffer reasonable semantics. \r\nRationale: The default versions are more likely to be correct, easier to maintain and efficient \r\nthan that generated by hand. \r\nAV Rule 81\r\nThe assignment operator shall handle self-assignment correctly (see Stroustrup [2], \r\nAppendix E.3.3 and 10.4.4) \r\nRationale: a = a; must function correctly. See AV Rule 81 in Appendix A for examples. \r\nAV Rule 82\r\nAn assignment operator shall return a reference to *this. \r\nRationale: Both the standard library types and the built-in types behave in this manner. See \r\nAV Rule 81 for an example of an assignment operator overload.\r\nAV Rule 83\r\nAn assignment operator shall assign all data members and bases that affect the class invariant \r\n(a data element representing a cache, for example, would not need to be copied). \r\nNote: To correctly copy a stateful virtual base in a portable manner, it must hold that if x1\r\nand x2 are objects of virtual base X, then x1=x2; x1=x2; must be semantically \r\nequivalent to x1=x2; [10] 12.8(13) \r\nRationale: Ensure data members and bases are properly handled under assignment. See AV \r\nRule 83 in Appendix A for additional details. See also AV Rule 77. \r\n4.10.8 Operator Overloading \r\nAV Rule 84\r\nOperator overloading will be used sparingly and in a conventional manner. \r\nRationale: Since unconventional or inconsistent uses of operator overloading can easily lead \r\nto confusion, operator overloads should only be used to enhance clarity and should follow the \r\nnatural meanings and conventions of the language. For instance, a C++ operator \"+=\" shall \r\nhave the same meaning as \"+\" and \"=\". ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/eb6e8127-5ea3-4987-95a8-49b0401a2a5e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=63cecebf481e1778951863bb5083a6e41e8c08210e5a27d6f8da2b5cd8e5e667",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 328
      },
      {
        "segments": [
          {
            "segment_id": "07f4d5c0-8e45-45ec-ba48-b93777b442c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n34\r\nAV Rule 85\r\nWhen two operators are opposites (such as == and !=), both will be defined and one will be \r\ndefined in terms of the other. \r\nRationale: If operator==() is supplied, then one could reasonable expect that operator!=()\r\nwould be supplied as well. Furthermore, defining one in terms of the other simplifies \r\nmaintenance. See AV Rule 85 in Appendix A for an example. \r\n4.10.9 Inheritance \r\nClass hierarchies are appropriate when run-time selection of implementation is required. If \r\nrun-time resolution is not required, template parameterization should be considered \r\n(templates are better-behaved and faster than virtual functions). Finally, simple independent \r\nconcepts should be expressed as concrete types. The method selected to express the solution \r\nshould be commensurate with the complexity of the problem. \r\nThe following rules provide additional detail and guidance when considering the structure of \r\ninheritance hierarchies. \r\nAV Rule 86\r\nConcrete types should be used to represent simple independent concepts. See Stroustrup [2], \r\n25.2. \r\nRationale: Well designed concrete classes tend to be efficient in both space and time, have \r\nminimal dependencies on other classes, and tend to be both comprehensible and usable in \r\nisolation. \r\nAV Rule 87\r\nHierarchies should be based on abstract classes. See Stroustrup [2], 12.5. \r\nRationale: Hierarchies based on abstract classes tend to focus designs toward producing \r\nclean interfaces, keep implementation details out of interfaces, and minimize compilation \r\ndependencies while allowing alternative implementations to coexist. See AV Rule 87 in \r\nAppendix A for examples. \r\nAV Rule 88\r\nMultiple inheritance shall only be allowed in the following restricted form: n interfaces plus \r\nm private implementations, plus at most one protected implementation. \r\nRationale: Multiple inheritance can lead to complicated inheritance hierarchies that are \r\ndifficult to comprehend and maintain. \r\nSee AV Rule 88 in Appendix A for examples of both appropriate and inappropriate uses of \r\nmultiple inheritance. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/07f4d5c0-8e45-45ec-ba48-b93777b442c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b10b6149d1919747597d0b08af648398cbd3f484f50b25b66dc7ccb74e2a0e4e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 306
      },
      {
        "segments": [
          {
            "segment_id": "d349081d-5b11-4e58-b018-0cc3e7ef1521",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n35\r\nAV Rule 88.1\r\nA stateful virtual base shall be explicitly declared in each derived class that accesses it. \r\nRationale: Explicitly declaring a stateful virtual base at each level in a hierarchy (where that \r\nbase is used), documents that fact that no assumptions can be made with respect to the \r\nexclusive use of the data contained within the virtual base. See AV Rule 88.1 in Appendix A\r\nfor additional details. \r\nAV Rule 89\r\nA base class shall not be both virtual and non-virtual in the same hierarchy. \r\nRationale: Hierarchy becomes difficult to comprehend and use. \r\nAV Rule 90\r\nHeavily used interfaces should be minimal, general and abstract. See Stroustrup [2] 23.4. \r\nRationale: Enable interfaces to exhibit stability in the face of changes to their hierarchies. \r\nAV Rule 91\r\nPublic inheritance will be used to implement “is-a” relationships. See Meyers [6], item 35. \r\nRationale: Public inheritance and private inheritance mean very different things in C++ and \r\nshould therefore be used accordingly. Public inheritance implies an “is-a” relationship. That \r\nis, every object of a publicly derived class D is also an object of the base type B, but not vice \r\nversa. Moreover, type B represents a more general concept than type D, and type D\r\nrepresents a more specialized concept than type B. Thus, stating that D publicly inherits from \r\nB, is an assertion that D is a subtype of B. That is, objects of type D may be used anywhere \r\nthat objects of type B may be used (since an object of type D is really an object of type B as \r\nwell). \r\nIn contrast to public inheritance, private and protected inheritance means “is-implemented\u0002in-terms-of”. It is purely an implementation technique—the interface is ignored. See also AV \r\nRule 93. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d349081d-5b11-4e58-b018-0cc3e7ef1521.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9bc64de543a9c403cb630b7a73d1dfe1c3c79b3cc4ea90848fd1820df1352b47",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 295
      },
      {
        "segments": [
          {
            "segment_id": "01f35039-2b26-4f63-9548-1f04da911532",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n36\r\nAV Rule 92\r\nA subtype (publicly derived classes) will conform to the following guidelines with respect to \r\nall classes involved in the polymorphic assignment of different subclass instances to the same \r\nvariable or parameter during the execution of the system: \r\n• Preconditions of derived methods must be at least as weak as the preconditions of the \r\nmethods they override. \r\n• Postconditions of derived methods must be at least as strong as the postconditions of \r\nthe methods they override. \r\nIn other words, subclass methods must expect less and deliver more than the base class \r\nmethods they override. This rule implies that subtypes will conform to the Liskov \r\nSubstitution Principle. \r\nRationale: Predictable behavior of derived classes when used within base class contexts. See \r\nAV Rule 92 in Appendix A for additional details. \r\nAV Rule 93\r\n“has-a” or “is-implemented-in-terms-of” relationships will be modeled through membership \r\nor non-public inheritance. See Meyers [6], item 40. \r\nRationale: Public inheritance means “is-a” (see AV Rule 91) while nonpublic inheritance \r\nmeans “has-a” or “is-implemented-in-terms-of”. See AV Rule 93 in Appendix A for \r\nexamples. \r\nAV Rule 94\r\nAn inherited nonvirtual function shall not be redefined in a derived class. See Meyers [6], \r\nitem 37. \r\nRationale: Prevent an object from exhibiting “two-faced” behavior. See AV Rule 94 in \r\nAppendix A for an example. \r\nAV Rule 95\r\nAn inherited default parameter shall never be redefined. See Meyers [6], item 38. \r\nRationale: The redefinition of default parameters for virtual functions often produces \r\nsurprising results. See AV Rule 95 in Appendix A for an example. \r\nAV Rule 96\r\nArrays shall not be treated polymorphically. See Meyers [7], item 3. \r\nRationale: Array indexing in C/C++ is implemented as pointer arithmetic. Hence, a[i] is \r\nequivalent to a+i*SIZEOF(array element). Since derived classes are often larger than base \r\nclasses, polymorphism and pointer arithmetic are not compatible techniques. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/01f35039-2b26-4f63-9548-1f04da911532.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7260a949ee18ca75a92dcfd56d06ea9941838e6e3dfb309a5ba2590701a51fa2",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d813b6a1-526f-4616-a5ae-a0617510412a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n37\r\nAV Rule 97\r\nArrays shall not be used in interfaces. Instead, the Array class should be used. \r\nRationale: Arrays degenerate to pointers when passed as parameters. This “array decay” \r\nproblem has long been known to be a source of errors. \r\nNote: See Array.doc for guidance concerning the proper use of the Array class, including its \r\ninteraction with memory management and error handling facilities. \r\n4.10.10Virtual Member Functions \r\nAV Rule 97.1\r\nNeither operand of an equality operator (== or !=) shall be a pointer to a virtual member \r\nfunction. \r\nRationale: If either operand of an equality operator (== or !=) is a pointer to a virtual \r\nmember function, the result is unspecified [10], 5.10(2). \r\nSeveral other sections have also touched on virtual member functions and polymorphism. Hence, \r\nthe following cross references are provided so that these rules may be accessed from a single \r\nlocation: AV Rule 71, AV Rule 78, AV Rule 87-AV Rule 97, and AV Rule 221. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d813b6a1-526f-4616-a5ae-a0617510412a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f8ae8da330f21c501fcc1de260a2f6514ef10cc1800f33229d76c64eb950a81",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 475
      },
      {
        "segments": [
          {
            "segment_id": "3b01e83c-17d1-47ef-9a66-5efc7132f59f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n38\r\n4.11 Namespaces \r\nAV Rule 98\r\nEvery nonlocal name, except main(), should be placed in some namespace. See Stroustrup \r\n[2], 8.2. \r\nRationale: Avoid name clashes in large programs with many parts. \r\nAV Rule 99\r\nNamespaces will not be nested more than two levels deep. \r\nRationale: Simplicity and clarity. Deeply nested namespaces can be difficult to comprehend \r\nand use correctly. \r\nAV Rule 100\r\nElements from a namespace should be selected as follows: \r\n• using declaration or explicit qualification for few (approximately five) names, \r\n• using directive for many names. \r\nRationale: All elements in a namespace need not be pulled in if only a few elements are \r\nactually needed. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3b01e83c-17d1-47ef-9a66-5efc7132f59f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=09ad2cee04ec23b4c6d742f66ef25d4d64d5f019e5685e41f89f1ec7db0a0752",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1fb3d456-2c93-4745-963f-fe11334dbd47",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n39\r\n4.12 Templates \r\nTemplates provide a powerful technique for creating families of functions or classes \r\nparameterized by type. As a result, generic components may be created that match corresponding \r\nhand-written versions in both size and performance [2]. \r\nAlthough template techniques have proven to be both powerful and expressive, it may be unclear \r\nwhen to prefer the use of templates over the use of inheritance. The following guidelines \r\nprovided by Stroustrup[2], 13.8, offer advice in this regard: \r\n1. Prefer a template over derived classes when run-time efficiency is at a premium. \r\n2. Prefer derived classes over a template if adding new variants without recompilation is \r\nimportant. \r\n3. Prefer a template over derived classes when no common base can be defined. \r\n4. Prefer a template over derived classes when built-in types and structures with \r\ncompatibility constraints are important. \r\nAV Rule 101\r\nTemplates shall be reviewed as follows: \r\n1. with respect to the template in isolation considering assumptions or requirements \r\nplaced on its arguments. \r\n2. with respect to all functions instantiated by actual arguments. \r\nNote: The compiler should be configured to generate the list of actual template \r\ninstantiations. See AV Rule 101 in Appendix A for an example. \r\nRationale: Since many instantiations of a template can be generated, any review should \r\nconsider all actual instantiations as well as any assumptions or requirements placed on \r\narguments of instantiations. \r\nAV Rule 102\r\nTemplate tests shall be created to cover all actual template instantiations. \r\nNote: The compiler should be configured to generate the list of actual template \r\ninstantiations. See AV Rule 102 in Appendix A for an example. \r\nRationale: Since many instantiations of a template can be generated, test cases should be \r\ncreated to cover all actual instantiations. \r\nAV Rule 103\r\nConstraint checks should be applied to template arguments. \r\nRationale: Explicitly capture parameter constraints in code as well as produce \r\ncomprehensible error messages. See AV Rule 103 in Appendix A for examples. \r\nAV Rule 104\r\nA template specialization shall be declared before its use. See Stroustrup [2], 13.5. \r\nRationale: C++ language rule. The specialization must be in scope for every use of the type \r\nfor which it is specialized. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1fb3d456-2c93-4745-963f-fe11334dbd47.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ec7cc07a62ad2b14ce148fe5ac8a48df5e422057984e19fb0de36ea02d21fb8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 476
      },
      {
        "segments": [
          {
            "segment_id": "c2527fe0-1f5c-41d1-b446-e9055f66094a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n40\r\nExample: \r\ntemplate<class T> class List {…}; \r\nList<int32*> li; \r\ntemplate<class T> class List<T*> {…}; //Error: this specialization should be used for li \r\n // in the previous statement.\r\nAV Rule 105\r\nA template definition’s dependence on its instantiation contexts should be minimized. See \r\nStroustrup [2], 13.2.5 and C.13.8. \r\nRationale: Since templates are likely to be instantiated in multiple contexts with different \r\nparameter types, any nonlocal dependencies will increase the likelihood that errors or \r\nincompatibilities will eventually surface. \r\nAV Rule 106\r\nSpecializations for pointer types should be made where appropriate. See Stroustrup [2], 13.5. \r\nRationale: Pointer types often require special semantics or provide special optimization \r\nopportunities. \r\n4.13 Functions \r\n4.13.1 Function Declaration, Definition and Arguments \r\nAV Rule 107 (MISRA Rule 68) \r\nFunctions shall always be declared at file scope. \r\nRationale: Declaring functions at block scope may be confusing. \r\nAV Rule 108 (MISRA Rule 69) \r\nFunctions with variable numbers of arguments shall not be used. \r\nRationale: The variable argument feature is difficult to use in a type-safe manner (i.e. \r\ntypical language checking rules aren’t applied to the additional parameters). \r\nNote: In some cases, default arguments and overloading are alternatives to the variable \r\narguments feature. See AV Rule 108 in Appendix A for an example. \r\nAV Rule 109\r\nA function definition should not be placed in a class specification unless the function is \r\nintended to be inlined. \r\nRationale: Class specifications are less compact and more difficult to read when they \r\ninclude implementations of member functions. Consequently, it is often preferable to place \r\nmember function implementations in a separate file. However, including the implementation \r\nin the specification instructs the compiler to inline the method (if possible). Since inlining \r\nshort functions can save both time and space, functions intended to be inlined may appear in \r\nthe class specification. See AV Rule 109 in Appendix A for an example. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/c2527fe0-1f5c-41d1-b446-e9055f66094a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f38a2a9e9a59e00e8305863e9cfea0aa19c1a14ec8f206dfb8d79d155df7e6f1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 309
      },
      {
        "segments": [
          {
            "segment_id": "5a1719d6-b294-4bb6-84fc-3cb526651b34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n41\r\nAV Rule 110\r\nFunctions with more than 7 arguments will not be used. \r\nRationale: Functions having long argument lists can be difficult to read, use, and maintain. \r\nFunctions with too many parameters may indicate an under use of objects and abstractions. \r\nException: Some constructors may require more than 7 arguments. However, one should \r\nconsider if abstractions are being underused in this scenario. \r\nAV Rule 111\r\nA function shall not return a pointer or reference to a non-static local object. \r\nRationale: After return, the local object will no longer exist. \r\nAV Rule 112\r\nFunction return values should not obscure resource ownership. \r\nRationale: Potential source of resource leaks. See AV Rule 173 and AV Rule 112 in \r\nAppendix A for examples. \r\n4.13.2 Return Types and Values \r\nAV Rule 113 (MISRA Rule 82, Revised) \r\nFunctions will have a single exit point. \r\nRationale: Numerous exit points tend to produce functions that are both difficult to \r\nunderstand and analyze. \r\nException: A single exit is not required if such a structure would obscure or otherwise \r\nsignificantly complicate (such as the introduction of additional variables) a function’s control \r\nlogic. Note that the usual resource clean-up must be managed at all exit points. \r\nAV Rule 114 (MISRA Rule 83, Revised) \r\nAll exit points of value-returning functions shall be through return statements. \r\nRationale: Flowing off the end of a value-returning function results in undefined behavior. \r\nAV Rule 115 (MISRA Rule 86) \r\nIf a function returns error information, then that error information will be tested. \r\nRationale: Ignoring return values could lead to a situation in which an application continues \r\nprocessing under the false assumption that the context in which it is operating (or the item on \r\nwhich it is operating) is valid. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/5a1719d6-b294-4bb6-84fc-3cb526651b34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b374492749012e751bdb7aea96372988b86ff5175cc37103ddd4289b048c2dc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 291
      },
      {
        "segments": [
          {
            "segment_id": "ddf1c19f-ebbd-44aa-a512-305094aca81a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n42\r\n4.13.3 Function Parameters (Value, Pointer or Reference) \r\nAV Rule 116\r\nSmall, concrete-type arguments (two or three words in size) should be passed by value if \r\nchanges made to formal parameters should not be reflected in the calling function. \r\nRationale: Pass-by-value is the simplest, safest method for small objects of concrete type. \r\nNote that non-concrete objects must be passed by pointer or reference to realize polymorphic \r\nbehavior. See rules AV Rule 117 and AV Rule 118. \r\nAV Rule 117\r\nArguments should be passed by reference if NULL values are not possible: \r\nAV Rule 117.1 An object should be passed as const T& if the function should not change \r\nthe value of the object. \r\nAV Rule 117.2 An object should be passed as T& if the function may change the value of \r\nthe object. \r\nRationale: Since references cannot be NULL, checks for NULL values will be eliminated \r\nfrom the code. Furthermore, references offer a more convenient notation than pointers. \r\nAV Rule 118\r\nArguments should be passed via pointers if NULL values are possible: \r\nAV Rule 118.1 An object should be passed as const T* if its value should not be modified. \r\nAV Rule 118.2 An object should be passed as T* if its value may be modified. \r\nRationale: References cannot be NULL. \r\n4.13.4 Function Invocation \r\nAV Rule 119 (MISRA Rule 70) \r\nFunctions shall not call themselves, either directly or indirectly (i.e. recursion shall not be \r\nallowed). \r\nRationale: Since stack space is not unlimited, stack overflows are possible. \r\nException: Recursion will be permitted under the following circumstances: \r\n1. development of SEAL 3 or general purpose software, or \r\n2. it can be proven that adequate resources exist to support the maximum level of \r\nrecursion possible. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ddf1c19f-ebbd-44aa-a512-305094aca81a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a350365985ae4fc055a9bfc5c3bfc9d12c0f8242c6d0df1ee27828604e6d75af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 290
      },
      {
        "segments": [
          {
            "segment_id": "9df906da-ca30-4a9d-9966-a8ea6aae7246",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n43\r\n4.13.5 Function Overloading \r\nAV Rule 120\r\nOverloaded operations or methods should form families that use the same semantics, share \r\nthe same name, have the same purpose, and that are differentiated by formal parameters. \r\nRationale: Inconsistent use of overloading can lead to considerable confusion. See AV Rule \r\n120 in Appendix A for examples. \r\n4.13.6 Inline Functions \r\nInline functions often offer a speed advantage over traditional functions as they do not \r\nrequire the typical function call overhead. Functions are typically inlined when either the \r\nfunction definition is included in the class declaration or the keyword inline precedes the \r\nfunction definition. \r\nExample A: Inlined since definition is Example B: Inlined because of the inline\r\n included in declaration. keyword\r\nclass Sample_class int32 foo (void); \r\n{ \r\n public: inline int foo (void) \r\n int32 get_data (void) { \r\n { … \r\n return data; } \r\n } \r\n}; \r\nThe C++ standard [10] provides the following information in regards to the use of inline \r\nfunctions. These observations are not listed as AV Rules since they are C++ language rules. \r\n1. An inline function shall be defined in every translation unit in which it is used and shall \r\nhave exactly the same definition in every case. (Note this observation implies that inline \r\nfunction definitions should be included in header files.) \r\n2. If a function with external linkage is declared inline in one translation unit, it shall be \r\ndeclared inline in all translation units in which it appears; no diagnostic is required. \r\n3. An inline function with external linkage shall have the same address in all translation \r\nunits. \r\n4. A static local variable in an extern inline function always refers to the same object. \r\n5. A string literal in an extern inline function is the same object in different translation units. \r\nAV Rule 121\r\nOnly functions with 1 or 2 statements should be considered candidates for inline functions. \r\nRationale: The compiler is not compelled to actually make a function inline. Decision \r\ncriteria differ from one compiler to another. The keyword inline is simply a request for the \r\ncompiler to inline the function. The compiler is free to ignore this request and make a real \r\nfunction call. See AV Rule 121 in Appendix A for additional details. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9df906da-ca30-4a9d-9966-a8ea6aae7246.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f5366e71d0af2eaef00019a65170e26d69f7f9095276a4ad35c21ee56f14f2f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "153bf4b8-a2cc-494c-8623-e867888b2a2a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n44\r\nAV Rule 122\r\nTrivial accessor and mutator functions should be inlined. \r\nRationale: Inlining short, simple functions can save both time and space. See AV Rule 122 \r\nin Appendix A for an example. \r\nAV Rule 123\r\nThe number of accessor and mutator functions should be minimized. \r\nRationale: Numerous accessors and mutators may indicate that a class simply serves to \r\naggregate a collection of data rather than to embody an abstraction with a well-defined state \r\nor invariant. In this case, a struct with public data may be a better alternative (see section \r\n4.10.2, AV Rule 65, and AV Rule 66). \r\nAV Rule 124\r\nTrivial forwarding functions should be inlined. \r\nRationale: Inlining short, simple functions can save both time and space.\r\n4.13.7 Temporary Objects \r\nAV Rule 125\r\nUnnecessary temporary objects should be avoided. See Meyers [7], item 19, 20, 21. \r\nRationale: Since the creation and destruction of temporary objects that are either large or \r\ninvolve complicated constructions can result in significant performance penalties, they \r\nshould be avoided. See AV Rule 125 in Appendix A for additional details. \r\n4.14 Comments \r\nComments in header files are meant for the users of classes and functions, while comments in \r\nimplementation files are meant for those who maintain the classes. \r\nComments are often said to be either strategic or tactical. A strategic comment describes \r\nwhat a function or section of code is intended to do, and is placed before the code. A tactical \r\ncomment describes what a single line of code is intended to do. Unfortunately, too many \r\ntactical comments can make code unreadable. For this reason, comments should be primarily \r\nstrategic, unless trying to explain very complicated code (i.e. one should avoid stating in a \r\ncomment what is clearly stated in code). \r\nAV Rule 126\r\nOnly valid C++ style comments (//) shall be used. See AV Rule 126 in Appendix A for \r\nadditional details concerning valid C++ style comments. \r\nRationale: A single standard provides consistency throughout the code. \r\nException: Automatic code generators that cannot be configured to use the “//” form. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/153bf4b8-a2cc-494c-8623-e867888b2a2a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8cafcfab686be758e7b14a20a42fe836a4f3d7eae6c50aeef5b5a97a05f55429",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 343
      },
      {
        "segments": [
          {
            "segment_id": "9f8721cf-02c0-4076-97e9-9783448b2dff",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n45\r\nAV Rule 127\r\nCode that is not used (commented out) shall be deleted. \r\nRationale: No dead code is allowed. \r\nException: Code that is simply part of an explanation may appear in comments. \r\nAV Rule 128\r\nComments that document actions or sources (e.g. tables, figures, paragraphs, etc.) outside of \r\nthe file being documented will not be allowed. \r\nRationale: The comments in a file should require changes only when changes are necessary \r\nto the file itself. Note that this rule does not preclude the documentation of valid assumptions \r\nthat may made be entities contained within the file. \r\nAV Rule 129\r\nComments in header files should describe the externally visible behavior of the functions or \r\nclasses being documented. \r\nRationale: Exposing the internal workings of functions or classes to clients might enable \r\nthose clients to create dependences on the internal representations. \r\nAV Rule 130\r\nThe purpose of every line of executable code should be explained by a comment, although \r\none comment may describe more than one line of code. \r\nRationale: Readability. Every line of code should be represented by a comment. However, \r\nthis rule does not say that every line of code should have a comment; a comment might \r\nrepresent more than one source line of code. \r\nAV Rule 131\r\nOne should avoid stating in comments what is better stated in code (i.e. do not simply repeat \r\nwhat is in the code). \r\nRationale: While redundant comments are unnecessary, they also serve to increase the \r\nmaintenance effort. \r\nExample: The following example illustrates an unnecessary comment. \r\na = b+c; // Bad: add b to c and place the result in a. \r\nAV Rule 132\r\nEach variable declaration, typedef, enumeration value, and structure member will be \r\ncommented. \r\nException: Cases where commenting would be unnecessarily redundant. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9f8721cf-02c0-4076-97e9-9783448b2dff.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=868c1ca15ca263dd0d0e0301e3b516d7f68dda8a51bdb3eee5c755afd5976625",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 297
      },
      {
        "segments": [
          {
            "segment_id": "0e1dec10-71d1-4c78-b7db-a713def3837e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n46\r\nAV Rule 133\r\nEvery source file will be documented with an introductory comment that provides \r\ninformation on the file name, its contents, and any program-required information (e.g. legal \r\nstatements, copyright information, etc). \r\nAV Rule 134\r\nAssumptions (limitations) made by functions should be documented in the function’s \r\npreamble. \r\nRationale: Maintenance efforts become very difficult if the assumptions (limitations) upon \r\nwhich functions are built are unknown. \r\n4.15 Declarations and Definitions \r\nAV Rule 135 (MISRA Rule 21, Revised) \r\nIdentifiers in an inner scope shall not use the same name as an identifier in an outer scope, \r\nand therefore hide that identifier. \r\nRationale: Hiding identifiers can be very confusing. \r\nExample: \r\nint32 sum = 0; \r\n{ \r\n int32 sum = 0; // Bad: hides sum in outer scope. \r\n … \r\n sum = f (x); \r\n} \r\nAV Rule 136 (MISRA Rule 22, Revised) \r\nDeclarations should be at the smallest feasible scope. (See also AV Rule 143). \r\nRationale: This rule attempts to minimize the number of live variables that must be \r\nsimultaneously considered. Furthermore, variable declarations should be postponed until \r\nenough information is available for full initialization (i.e. a variable should never be placed in \r\na partly-initialized or initialized-but-not-valid state.) See AV Rule 136 in Appendix A for \r\nexamples. \r\nAV Rule 137 (MISRA Rule 23) \r\nAll declarations at file scope should be static where possible. \r\nRationale: Minimize dependencies between translation units where possible. See AV Rule \r\n137 in Appendix A for additional details. \r\nAV Rule 138 (MISRA Rule 24) \r\nIdentifiers shall not simultaneously have both internal and external linkage in the same \r\ntranslation unit. \r\nRationale: Avoid variable-name hiding which can be confusing. See AV Rule 138 in \r\nAppendix A for further details. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/0e1dec10-71d1-4c78-b7db-a713def3837e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=da3cd96abcb6dab0f38a0c62e9ea43f6968d67e471698704174bf165958314f8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 282
      },
      {
        "segments": [
          {
            "segment_id": "9daefeac-9930-443a-9839-f189145448df",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n47\r\nAV Rule 139 (MISRA Rule 27) \r\nExternal objects will not be declared in more than one file. (See also AV Rule 39.) \r\nRationale: Avoid inconsistent declarations. See AV Rule 139 in Appendix A for further \r\ndetails. \r\nNote: This type of error will be caught by linkers, but typically later than is desired (i.e. the \r\ninconsistency could exist in a different group’s build.) Normally this will mean \r\ndeclaring external objects in header files which will then be included in all other files \r\nthat need to use those objects (including the files which define them). \r\nAV Rule 140 (MISRA Rule 28, Revised) \r\nThe register storage class specifier shall not be used. \r\nRationale: Compiler technology is now capable of optimal register placement. \r\nAV Rule 141\r\nA class, structure, or enumeration will not be declared in the definition of its type. \r\nRationale: Readability. See AV Rule 141 in Appendix A for examples. \r\n4.16 Initialization \r\nAV Rule 142 (MISRA Rule 30, Revised) \r\nAll variables shall be initialized before use. (See also AV Rule 136, AV Rule 71, and AV \r\nRule 73, and AV Rule 143 concerning declaration scope, object construction, default \r\nconstructors, and the point of variable introduction respectively.) \r\nRationale: Prevent the use of variables before they have been properly initialized. See AV \r\nRule 142 in Appendix A for additional information. \r\nException: Exceptions are allowed where a name must be introduced before it can be \r\ninitialized (e.g. value received via an input stream). \r\nAV Rule 143\r\nVariables will not be introduced until they can be initialized with meaningful values. (See \r\nalso AV Rule 136, AV Rule 142, and AV Rule 73 concerning declaration scope, \r\ninitialization before use, and default constructors respectively.) \r\nRationale: Prevent clients from accessing variables without meaningful values. See AV Rule \r\n143 in Appendix A for examples. \r\nAV Rule 144 (MISRA Rule 31) \r\nBraces shall be used to indicate and match the structure in the non-zero initialization of \r\narrays and structures. \r\nRationale: Readability. \r\nExample: \r\nint32 a[2][2] = { {0,1} ,{2,3} }; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9daefeac-9930-443a-9839-f189145448df.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=422bba5d936137c162feae51f6751e762af6c734597383dc8ae67e4d97cf7f61",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 337
      },
      {
        "segments": [
          {
            "segment_id": "8edd90aa-e32c-4565-a87d-75ecf205c39f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n48\r\nAV Rule 145 (MISRA Rule 32 ) \r\nIn an enumerator list, the ‘=‘ construct shall not be used to explicitly initialize members \r\nother than the first, unless all items are explicitly initialized. \r\nRationale: Mixing the automatic and manual allocation of enumerator values is error-prone. \r\nNote that exceptions are allowed for clearly-defined standard conventions. See AV Rule 145 \r\nin Appendix A for additional details. \r\n4.17 Types \r\nAV Rule 146 (MISRA Rule 15) \r\nFloating point implementations shall comply with a defined floating point standard. \r\nThe standard that will be used is the ANSI/IEEE Std 754 [1]. \r\nRationale: Consistency. \r\nAV Rule 147 (MISRA Rule 16) \r\nThe underlying bit representations of floating point numbers shall not be used in any way by \r\nthe programmer. \r\nRationale: Manipulating bits is error prone. See AV Rule 147 in Appendix A for additional \r\ndetails. \r\nAV Rule 148\r\nEnumeration types shall be used instead of integer types (and constants) to select from a \r\nlimited series of choices. \r\nNote: This rule is not intended to exclude character constants (e.g. ‘A’, ‘B’, ‘C’, etc.) from \r\nuse as case labels. \r\nRationale: Enhances debugging, readability and maintenance. Note that a compiler flag (if \r\navailable) should be set to generate a warning if all enumerators are not present in a switch \r\nstatement. \r\n4.18 Constants \r\nSection 4.6.2 contains additional details concerning constants and the use of enum and \r\n#define. \r\nAV Rule 149 (MISRA Rule 19) \r\nOctal constants (other than zero) shall not be used. \r\nRationale: Any integer constant beginning with a zero (‘0’) is defined by the C++ standard \r\nto be an octal constant. Due to the confusion this causes, octal constants should be avoided. \r\nNote: Hexadecimal numbers and zero (which is also an octal constant) are allowed. \r\nAV Rule 150\r\nHexadecimal constants will be represented using all uppercase letters. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8edd90aa-e32c-4565-a87d-75ecf205c39f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=24a610caf5e649415bff9a6e943ae1cd54428752abef40982306f86134541140",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "393cbe96-a7df-4c72-bd5d-ff2beb05efc4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n49\r\nAV Rule 151\r\nNumeric values in code will not be used; symbolic values will be used instead. \r\nRationale: Improved readability and maintenance. \r\nException: A class/structure constructor may initialize an array member with numeric \r\nvalues. \r\nclass A \r\n{ \r\n A() \r\n { \r\n coefficient[0] = 1.23; // Good \r\n coefficient[1] = 2.34; // Good \r\n coefficient[2] = 3.45; // Good \r\n } \r\n private: \r\n float64 coefficient[3]; // Cannot be initialized via the member initialization list. \r\n};\r\nNote: In many cases ‘0’ and ‘1’ are not magic numbers but are part of the fundamental logic \r\nof the code (e.g. ‘0’ often represents a NULL pointer). In such cases, ‘0’ and ‘1’ may \r\nbe used. \r\nAV Rule 151.1\r\nA string literal shall not be modified. \r\nNote that strictly conforming compilers should catch violations, but many do not. \r\nRationale: The effect of attempting to modify a string literal is undefined [10], 2.13.4(2). \r\nSee also AV Rule 151.1 in Appendix A for additional details. \r\n4.19 Variables \r\nAV Rule 152\r\nMultiple variable declarations shall not be allowed on the same line. \r\nRationale: Increases readability and prevents confusion (see also AV Rule 62). \r\nExample:\r\nint32* p, q; // Probably error. \r\nint32 first button_on_top_of_the_left_box, i; // Bad: Easy to overlook i ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/393cbe96-a7df-4c72-bd5d-ff2beb05efc4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13d1628e3323be23431dca6b53ec50d4001a6b7bc2cda272f77cc11f293ab30e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 509
      },
      {
        "segments": [
          {
            "segment_id": "2e8ae61d-950e-41dc-a60e-80ae9eb7d565",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n50\r\n4.20 Unions and Bit Fields \r\nAV Rule 153 (MISRA Rule 110, Revised) \r\nUnions shall not be used. \r\nRationale: Unions are not statically type-safe and are historically known to be a source of \r\nerrors. \r\nNote: In some cases, derived classes and virtual functions may be used as an alternative to \r\nunions. \r\nAV Rule 154 (MISRA Rules 111 and 112, Revised) \r\nBit-fields shall have explicitly unsigned integral or enumeration types only. \r\nRationale: Whether a plain (neither explicitly signed nor unsigned) char, short, int or long \r\nbit-field is signed or unsigned is implementation-defined.[10] Thus, explicitly declaring a \r\nbit-filed unsigned prevents unexpected sign extension or overflow. \r\nNote: MISRA Rule 112 no longer applies since it discusses a two-bit minimum-length \r\nrequirement for bit-fields of signed types. \r\nAV Rule 155\r\nBit-fields will not be used to pack data into a word for the sole purpose of saving space. \r\nNote: Bit-packing should be reserved for use in interfacing to hardware or conformance to \r\ncommunication protocols. \r\nWarning: Certain aspects of bit-field manipulation are implementation-defined. \r\nRationale: Bit-packing adds additional complexity to the source code. Moreover, bit-packing \r\nmay not save any space at all since the reduction in data size achieved through packing is \r\noften offset by the increase in the number of instructions required to pack/unpack the data. \r\nAV Rule 156 (MISRA Rule 113) \r\nAll the members of a structure (or class) shall be named and shall only be accessed via their \r\nnames. \r\nRationale: Reading/writing to unnamed locations in memory is error prone. \r\nException: An unnamed bit-field of width zero may be used to specify alignment of the next \r\nbit-field at an allocation boundary. [10], 9.6(2) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/2e8ae61d-950e-41dc-a60e-80ae9eb7d565.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f1abd5c1b71a582fb7d59ad720242875e5431248688c78bd7353c38ca8c5089b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 276
      },
      {
        "segments": [
          {
            "segment_id": "731564b8-e5ad-43bc-8657-59cc9477edae",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n51\r\n4.21 Operators \r\nAV Rule 157 (MISRA Rule 33) \r\nThe right hand operand of a && or || operator shall not contain side effects. \r\nRationale: Readability. The conditional evaluation of the right-hand side could be \r\noverlooked. See AV Rule 157 in Appendix A for an example. \r\nAV Rule 158 (MISRA Rule 34) \r\nThe operands of a logical && or || shall be parenthesized if the operands contain binary \r\noperators. \r\nRationale: Readability. See AV Rule 158 in Appendix A for examples. \r\nAV Rule 159\r\nOperators ||, &&, and unary & shall not be overloaded. See Meyers [7], item 7. \r\nRationale: First, the behavior of the || and && operators depend on short-circuit evaluation \r\nof the operands. However, short-circuit evaluation is not possible for overloaded versions of \r\nthe || and && operators. Hence, overloading these operators may produce unexpected results. \r\nNext, if the address of an object of incomplete class type is taken, but the complete form of \r\nthe type declares operator&() as a member function, the resulting behavior is undefined. [10] \r\nAV Rule 160 (MISRA Rule 35, Modified) \r\nAn assignment expression shall be used only as the expression in an expression statement. \r\nRationale: Readability. Assignment (=) may be easily confused with the equality (==). See \r\nAV Rule 160 in Appendix A for examples. \r\nAV Rule 162\r\nSigned and unsigned values shall not be mixed in arithmetic or comparison operations. \r\nRationale: Mixing signed and unsigned values is error prone as it subjects operations to \r\nnumerous arithmetic conversion and integral promotion rules. \r\nAV Rule 163\r\nUnsigned arithmetic shall not be used. \r\nRationale: Over time, unsigned values will likely be mixed with signed values thus violating \r\nAV Rule 162. \r\nAV Rule 164 (MISRA Rule 38) \r\nThe right hand operand of a shift operator shall lie between zero and one less than the width \r\nin bits of the left-hand operand (inclusive). \r\nRationale: If the right operand is either negative or greater than or equal to the length in bits \r\nof the promoted left operand, the result is undefined. [10] ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/731564b8-e5ad-43bc-8657-59cc9477edae.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=32c2cc28a3939a871b7dac22c3d9a1bf9a9ad00f588cd5831e539e6f887fea33",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 342
      },
      {
        "segments": [
          {
            "segment_id": "663dbff2-2899-4d07-be12-7143873cee8f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n52\r\nAV Rule 164.1\r\nThe left-hand operand of a right-shift operator shall not have a negative value. \r\nRationale: For e1 >> e2, if e1 has a signed type and a negative value, the value of (e1 >> e2) is \r\nimplementation-defined. [10] \r\nAV Rule 165 (MISRA Rule 39) \r\nThe unary minus operator shall not be applied to an unsigned expression. \r\nAV Rule 166 (MISRA Rule 40) \r\nThe sizeof operator will not be used on expressions that contain side effects. \r\nRationale: Clarity. The side-effect will not be realized since sizeof only operates on the type \r\nof an expression: the expression itself will not be evaluated. \r\nAV Rule 167 (MISRA Rule 41) \r\nThe implementation of integer division in the chosen compiler shall be determined, \r\ndocumented and taken into account. \r\nRationale: If one or more of the operands of an integer division is negative, the sign of the \r\nremainder is implementation defined. [10] \r\nNote: For the Green Hills PowerPC C++ compiler, the sign of the remainder is the same as \r\nthat of the first operand. Also the quotient is rounded toward zero. \r\nAV Rule 168 (MISRA Rule 42, Revised) \r\nThe comma operator shall not be used. \r\nRationale: Readability. See AV Rule 168 in Appendix A for additional details. \r\n4.22 Pointers & References \r\nAV Rule 169\r\nPointers to pointers should be avoided when possible. \r\nRationale: Pointers to pointers are a source of bugs and result in obscure code. Containers or \r\nsome other form of abstraction should be used instead (see AV Rule 97). \r\nAV Rule 170 (MISRA Rule 102, Revised) \r\nMore than 2 levels of pointer indirection shall not be used. \r\nRationale: Multiple levels of pointer indirections typically produce code that is difficult to \r\nread, understand and maintain. \r\nNote: This rule leaves no room for using more than 2 levels of pointer indirection. The \r\nword “shall” replaces the word “should” in MISRA Rule 102. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/663dbff2-2899-4d07-be12-7143873cee8f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6b8eda6b79343f26edf48605e35b3f673a2533bb74b0e37362ef770e85d9bc8a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 317
      },
      {
        "segments": [
          {
            "segment_id": "7bcbf7e0-3326-4670-a63f-84c5c4fe6ca0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n53\r\nAV Rule 171 (MISRA Rule 103) \r\nRelational operators shall not be applied to pointer types except where both operands are of \r\nthe same type and point to: \r\n• the same object, \r\n• the same function, \r\n• members of the same object, or \r\n• elements of the same array (including one past the end of the same array). \r\nNote that if either operand is null, then both shall be null. Also, “members of the same \r\nobject” should not be construed to include base class subobjects (See also AV Rule 210). \r\nRationale: Violations of the above rule may result in unspecified behavior [10], 5.9(2). \r\nAV Rule 173 (MISRA Rule 106, Revised) \r\nThe address of an object with automatic storage shall not be assigned to an object which \r\npersists after the object has ceased to exist. \r\nRationale: An object in a function with automatic storage comes into existence when a \r\nfunction is called and disappears when the function is exited. Obviously if the object \r\ndisappears when the function exits, the address of the object is invalid as well. See Also AV \r\nRule 111 and AV Rule 112. \r\nAV Rule 174 (MISRA Rule 107) \r\nThe null pointer shall not be de-referenced. \r\nRationale: De-referencing a NULL pointer constitutes undefined behavior. [10] Note that \r\nthis often requires that a pointer be checked for non-NULL status before de-referencing \r\noccurs. \r\nAV Rule 175\r\nA pointer shall not be compared to NULL or be assigned NULL; use plain 0 instead. \r\nRationale: The NULL macro is an implementation-defined C++ null pointer constant that \r\nhas been defined in multiple ways including 0, 0L, and (void*)0. Due to C++’s stronger \r\ntype-checking, Stroustrup[2] advises the use plain 0 rather than any suggested NULL macro. \r\nAV Rule 176\r\nA typedef will be used to simplify program syntax when declaring function pointers. \r\nRationale: Improved readability. Pointers to functions can significantly degrade program \r\nreadability. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7bcbf7e0-3326-4670-a63f-84c5c4fe6ca0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1958e9d01361159928f8028f352e322b31ea9014253f46fc414ba4d004d046aa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 317
      },
      {
        "segments": [
          {
            "segment_id": "505bda3a-4e0b-45b0-9fe7-1a6297e19501",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n54\r\n4.23 Type Conversions \r\nAV Rule 177\r\nUser-defined conversion functions should be avoided. See Meyers [7], item 5. \r\nRationale: User-defined conversion functions may be called implicitly in cases where the \r\nprogrammer may not expect them to be called. See AV Rule 177 in Appendix A for \r\nadditional details. \r\nAV Rule 178\r\nDown casting (casting from base to derived class) shall only be allowed through one of the \r\nfollowing mechanism: \r\n• Virtual functions that act like dynamic casts (most likely useful in relatively simple \r\ncases) \r\n• Use of the visitor (or similar) pattern (most likely useful in complicated cases) \r\nRationale: Casting from a base class to a derived class is unsafe unless some mechanism is \r\nprovided to ensure that the cast is legitimate. \r\nNote: Type fields shall not be used as they are too error prone. \r\nNote: Dynamic casts are not allowed at this point due to lack of tool support, but could be \r\nconsidered at some point in the future after appropriate investigation has been \r\nperformed for SEAL1/2 software. Dynamic casts are fine for general purpose \r\nsoftware. \r\nAV Rule 179\r\nA pointer to a virtual base class shall not be converted to a pointer to a derived class. \r\nRationale: Since the virtualness of inheritance is not a property of a base class, the layout of \r\na derived class object, referenced through a virtual base pointer, is unknown at compile time. \r\nIn essence, this type of downcast cannot be performed safely without the use of a \r\ndynamic_cast or through virtual functions emulating a dynamic_cast. \r\nAV Rule 180 (MISRA Rule 43) \r\nImplicit conversions that may result in a loss of information shall not be used. \r\nRationale: The programmer may be unaware of the information loss. See AV Rule 180 in \r\nAppendix A for examples. \r\nNote: Templates can be used to resolve many type conversion issues. Also, any compiler \r\nflags that result in warnings for value-destroying conversions should be activated. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/505bda3a-4e0b-45b0-9fe7-1a6297e19501.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b2ba1075d121bcb8ab522aedaf9c60a7b5d6aa54657084f136c3f10e80cae51",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 325
      },
      {
        "segments": [
          {
            "segment_id": "28b466f0-da61-48c1-babd-5c9bf3df7d80",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n55\r\nAV Rule 181 (MISRA Rule 44) \r\nRedundant explicit casts will not be used. \r\nRationale: Unnecessary casting clutters the code and could mask later problems if variable \r\ntypes change over time. \r\nAV Rule 182 (MISRA Rule 45) \r\nType casting from any type to or from pointers shall not be used. \r\nRationale: This type of casting can lead to undefined or implementation-defined behavior \r\n(e.g. certain aspects of memory alignments are implementation-defined). Furthermore, \r\nconverting a pointer to an integral type can result in the loss of information if the pointer can \r\nrepresent values larger than the integral type to which it is converted. \r\nException 1: Casting from void* to T* is permissible. In this case, static_cast should be \r\nused, but only if it is known that the object really is a T. Furthermore, such code should only \r\noccur in low level memory management routines. \r\nException 2: Conversion of literals (i.e. hardware addresses) to pointers. \r\nDevice_register input = reinterpret_cast<Device_register>(0XFFA); \r\nAV Rule 183\r\nEvery possible measure should be taken to avoid type casting. \r\nRationale: Errors caused by casts are among the most pernicious, particularly because they \r\nare so hard to recognize. Strict type checking is your friend – take full advantage of it. \r\nAV Rule 184\r\nFloating point numbers shall not be converted to integers unless such a conversion is a \r\nspecified algorithmic requirement or is necessary for a hardware interface. \r\nRationale: Converting a floating-point number to an integer may result in an overflow or \r\nloss of precision. It is acceptable to explicitly cast integers to floating point numbers to \r\nperform mathematical operations (with awareness of the possible real-time impacts as well as \r\noverflow). If this is necessary, the deviation must clearly state how an overflow condition \r\ncannot occur. \r\nAV Rule 185\r\nC++ style casts (const_cast, reinterpret_cast, and static_cast) shall be used instead of the \r\ntraditional C-style casts. See Stroustrup [2], 15.4 and Meyers [7], item 2. \r\nRationale: C-style casts are more dangerous than the C++ named conversion operators since \r\nthe C-style casts are difficult to locate in large programs and the intent of the conversion is \r\nnot explicit (i.e. (T) e could be a portable conversion between related types, a non-portable \r\nconversion between unrelated types, or a combination of conversions).[0] See AV Rule 185 \r\nin Appendix A for additional details. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/28b466f0-da61-48c1-babd-5c9bf3df7d80.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4c017b25f62eb07372667353c99dcbed06fcfc7a25645c543ffac897a36a61eb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 385
      },
      {
        "segments": [
          {
            "segment_id": "bd7b0d55-54dc-475e-9195-c8cdab38b4fe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n56\r\n4.24 Flow Control Structures \r\nAV Rule 186 (MISRA Rule 52) \r\nThere shall be no unreachable code. \r\nNote: For reusable template components, unused members will not be included in the object \r\ncode. \r\nAV Rule 187 (MISRA Rule 53, Revised) \r\nAll non-null statements shall potentially have a side-effect. \r\nRationale: A non-null statement with no potential side-effect typically indicates a \r\nprogramming error. See AV Rule 187 in Appendix A for additional information. \r\nAV Rule 188 (MISRA Rule 55, Revised) \r\nLabels will not be used, except in switch statements. \r\nRationale: Labels are typically either used in switch statements or are as the targets for goto\r\nstatements. See exception given in AV Rule 189. \r\nAV Rule 189 (MISRA Rule 56) \r\nThe goto statement shall not be used. \r\nRationale: Frequent use of the goto statement tends to lead to code that is both difficult to \r\nread and maintain. \r\nException: A goto may be used to break out of multiple nested loops provided the \r\nalternative would obscure or otherwise significantly complicate the control logic. \r\nAV Rule 190 (MISRA Rule 57) \r\nThe continue statement shall not be used. \r\nAV Rule 191 (MISRA Rule 58) \r\nThe break statement shall not be used (except to terminate the cases of a switch statement). \r\nException: The break statement may be used to “break” out of a single loop provided the \r\nalternative would obscure or otherwise significantly complicate the control logic. \r\nAV Rule 192 (MISRA Rule 60, Revised) \r\nAll if, else if constructs will contain either a final else clause or a comment indicating why a \r\nfinal else clause is not necessary. \r\nRationale: Provide a defensive strategy to ensure that all cases are handled by an else if\r\nseries. See AV Rule 192 in Appendix A for examples. \r\nNote: This rule only applies when an if statement is followed by one or more else if’s. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/bd7b0d55-54dc-475e-9195-c8cdab38b4fe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f724cc730fabba7c59b5021722a0670328b28abac6611912b60c195949b93864",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 311
      },
      {
        "segments": [
          {
            "segment_id": "9686ca9d-6f3b-4cbb-84bf-c33e6d58e0b1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n57\r\nAV Rule 193 (MISRA Rule 61) \r\nEvery non-empty case clause in a switch statement shall be terminated with a break \r\nstatement. \r\nRationale: Eliminates potentially confusing behavior since execution will fall through to the \r\ncode of the next case clause if a break statement does not terminate the previous case clause. \r\nSee AV Rule 193 in Appendix A for an example. \r\nAV Rule 194 (MISRA Rule 62, Revised) \r\nAll switch statements that do not intend to test for every enumeration value shall contain a \r\nfinal default clause. \r\nRationale: Omitting the final default clause allows the compiler to provide a warning if all \r\nenumeration values are not tested in a switch statement. Moreover, the lack of a default\r\nclause indicates that a test for every case should be conducted. On the other hand, if all cases \r\nare not tested for, then a final default clause must be included to handle those untested cases. \r\nMISRA revised with shall replacing should. \r\nAV Rule 195 (MISRA Rule 63) \r\nA switch expression will not represent a Boolean value. \r\nRationale: An if statement provides a more natural representation. \r\nAV Rule 196 (MISRA Rule 64, Revised) \r\nEvery switch statement will have at least two cases and a potential default.\r\nRationale: An if statement provides a more natural representation. \r\nAV Rule 197 (MISRA Rule 65) \r\nFloating point variables shall not be used as loop counters. \r\nRationale: Subjects the loop counter to rounding and truncation errors. \r\nAV Rule 198\r\nThe initialization expression in a for loop will perform no actions other than to initialize the \r\nvalue of a single for loop parameter. Note that the initialization expression may invoke an \r\naccessor that returns an initial element in a sequence: \r\nfor (Iter_type p = c.begin() ; p != c.end() ; ++p) // Good \r\n{ \r\n… \r\n} \r\nRationale: Readability. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9686ca9d-6f3b-4cbb-84bf-c33e6d58e0b1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c56e23ae3ca456b3bccf4e75051de99c25278267145e464e1b3f08e072646e1c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 306
      },
      {
        "segments": [
          {
            "segment_id": "0caac2ce-47ff-44cf-bb3e-89a6f02e8257",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n58\r\nAV Rule 199\r\nThe increment expression in a for loop will perform no action other than to change a single \r\nloop parameter to the next value for the loop. \r\nRationale: Readability. \r\nAV Rule 200\r\nNull initialize or increment expressions in for loops will not be used; a while loop will be \r\nused instead. \r\nRationale: A while loop provides a more natural representation. \r\nAV Rule 201 (MISRA Rule 67, Revised) \r\nNumeric variables being used within a for loop for iteration counting shall not be modified \r\nin the body of the loop. \r\nRationale: Readability and maintainability. \r\nMISRA Rule 67 was revised by changing should to shall. \r\n4.25 Expressions \r\nAV Rule 202 (MISRA Rule 50) \r\nFloating point variables shall not be tested for exact equality or inequality. \r\nRationale: Since floating point numbers are subject to rounding and truncation errors, exact \r\nequality may not be achieved, even when expected. \r\nAV Rule 203 (MISRA Rule 51, Revised) \r\nEvaluation of expressions shall not lead to overflow/underflow (unless required \r\nalgorithmically and then should be heavily documented). \r\nRationale: Expressions leading to overflow/underflow typically indicate overflow error \r\nconditions. See also AV Rule 212. \r\nAV Rule 204\r\nA single operation with side-effects shall only be used in the following contexts: \r\n1. by itself \r\n2. the right-hand side of an assignment \r\n3. a condition \r\n4. the only argument expression with a side-effect in a function call \r\n5. condition of a loop \r\n6. switch condition \r\n7. single part of a chained operation. \r\nRationale: Readability. See AV Rule 204 in Appendix A for examples. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/0caac2ce-47ff-44cf-bb3e-89a6f02e8257.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f4fe66caacc4c7391432cc52946842423b8b1223b57a944a09bf7009aeccf186",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 260
      },
      {
        "segments": [
          {
            "segment_id": "987bbf30-f3e2-4df5-a0a5-0f51d8ec791b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n59\r\nAV Rule 204.1 (MISRA Rule 46) \r\nThe value of an expression shall be the same under any order of evaluation that the standard \r\npermits. \r\nRationale: Except where noted, the order in which operators and subexpression are \r\nevaluated, as well as the order in which side effects take place, is unspecified [10], 5(4). See \r\nAV Rule 204.1 in Appendix_A for examples. \r\nAV Rule 205\r\nThe volatile keyword shall not be used unless directly interfacing with hardware. \r\nRationale: The volatile keyword is a hint to the compiler that an object’s value may change \r\nin ways not specified by the language (e.g. object representing a hardware register). Hence, \r\naggressive optimizations should be avoided. [2] \r\n4.26 Memory Allocation \r\nAV Rule 206 (MISRA Rule 118, Revised) \r\nAllocation/deallocation from/to the free store (heap) shall not occur after initialization. \r\nNote that the “placement” operator new(), although not technically dynamic memory, may \r\nonly be used in low-level memory management routines. See AV Rule 70.1 for object \r\nlifetime issues associated with placement operator new(). \r\nRationale: repeated allocation (new/malloc) and deallocation (delete/free) from the free \r\nstore/heap can result in free store/heap fragmentation and hence non-deterministic delays in \r\nfree store/heap access. See Alloc.doc for alternatives. \r\nAV Rule 207\r\nUnencapsulated global data will be avoided. \r\nRationale: Global data is dangerous since no access protection is provided with respect to \r\nthe data. \r\nNote: If multiple clients require access to a single resource, that resource should be \r\nwrapped in a class that manages access to that resource. For example, semantic \r\ncontrols that prohibit unrestricted access may be provided (e.g. singletons and \r\ninput streams). See AV_Rule_207_Appendix_A for examples. \r\n4.27 Fault Handling \r\nAV Rule 208\r\nC++ exceptions shall not be used (i.e. throw, catch and try shall not be used.) \r\nRationale: Tool support is not adequate at this time. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/987bbf30-f3e2-4df5-a0a5-0f51d8ec791b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dfe637cc7ea6f9c76bca9812441d08c60c7842df3660d6ede01fee9ad4ef454e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 302
      },
      {
        "segments": [
          {
            "segment_id": "bde63273-797d-4927-b443-893314cf72a1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n60\r\n4.28 Portable Code \r\n4.28.1 Data Abstraction \r\nAV Rule 209 (MISRA Rule 13, Revised) \r\nThe basic types of int, short, long, float and double shall not be used, but specific-length \r\nequivalents should be typedef’d accordingly for each compiler, and these type names used in \r\nthe code. \r\nRationale: Since the storage length of types can vary from compiler to compiler and \r\nplatform-to-platform, this rule ensures that code can be easily reconfigured for storage size \r\ndifferences by simply changing definitions in one file. See AV Rule 209 in Appendix A for \r\nadditional details. \r\nException: Basic types are permitted in low-level routines to assist in the management of \r\nword alignment issues (e.g. memory allocators). \r\nMISRA rule was changed from should to shall. \r\n4.28.2 Data Representation \r\nAV Rule 210\r\nAlgorithms shall not make assumptions concerning how data is represented in memory (e.g. \r\nbig endian vs. little endian, base class subobject ordering in derived classes, nonstatic data \r\nmember ordering across access specifiers, etc.) \r\nRationale: Assumptions concerning architecture-specific aspects are non-portable. \r\nException: Low level routines that are expressly written for the purpose of data formatting \r\n(e.g. marshalling data, endian conversions, etc.) are permitted. \r\nAV Rule 210.1\r\nAlgorithms shall not make assumptions concerning the order of allocation of nonstatic data \r\nmembers separated by an access specifier. See also AV Rule 210 on data representation. \r\nRationale: The order of allocation of nonstatic data members, separated by an access\u0002specifier, is unspecified [10], 9.2(12). See AV Rule 210.1 in Appendix_A for additional \r\ndetails. \r\nAV Rule 211\r\nAlgorithms shall not assume that shorts, ints, longs, floats, doubles or long doubles begin at \r\nparticular addresses. \r\nRationale: The representation of data types in memory is highly machine-dependent. By \r\nallocating data members to certain addresses, a processor may execute code more efficiently. \r\nBecause of this, the data structure that represents a structure or class will sometimes include \r\nholes and be stored differently in different process architectures. Code which depends on a \r\nspecific representation is, of course, not portable. \r\nException: Low level routines that are expressly written for the purpose of data formatting \r\n(e.g. marshalling data, endian conversions, etc.) are permitted. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/bde63273-797d-4927-b443-893314cf72a1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=05623c86b569c789b4ed6866b9fc9e32252b4a6738150c470b0bb2859f86fe7b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 354
      },
      {
        "segments": [
          {
            "segment_id": "1ed0e75a-27be-40cb-9c77-b55927857129",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n61\r\n4.28.3 Underflow/Overflow \r\nAV Rule 212\r\nUnderflow or overflow functioning shall not be depended on in any special way. \r\nRationale: Dependence on undefined language aspects leads to non-portable \r\nimplementations. See also AV Rule 203. \r\n4.28.4 Order of Execution \r\nAV Rule 213 (MISRA Rule 47, Revised) \r\nNo dependence shall be placed on C++’s operator precedence rules, below arithmetic \r\noperators, in expressions. \r\nRationale: Readability. See AV Rule 213 in Appendix A for additional details. \r\nMISRA Rule 47 changed by replacing should with shall. \r\nAV Rule 214\r\nAssuming that non-local static objects, in separate translation units, are initialized in a special \r\norder shall not be done. \r\nRationale: Order dependencies lead to hard to find bugs. See AV Rule 214 in Appendix A\r\nfor additional details. \r\n4.28.5 Pointer Arithmetic \r\nAV Rule 215 (MISRA Rule 101) \r\nPointer arithmetic will not be used. \r\nRationale: The runtime computation of pointer values is error-prone (i.e. the computed value \r\nmay reference unintended or invalid memory locations). See AV Rule 97 and AV Rule 215 \r\nin Appendix A for additional information. \r\nExceptions: Objects such as containers, iterators, and allocators that manage pointer \r\narithmetic through well-defined interfaces are acceptable. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1ed0e75a-27be-40cb-9c77-b55927857129.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=01e7ea03e696c0420a132398fb5d5e3a7f3723eef7d549d9677cfebe10f966bc",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4639aab6-bf6f-4d6d-88b6-b3bfa128094b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n62\r\n4.29 Efficiency Considerations \r\nAV Rule 216\r\nProgrammers should not attempt to prematurely optimize code. See Meyers [7], item 16. \r\nRationale: Early focus on optimization can result in sacrificing the clarity and generality of \r\nmodules that will not be the true bottlenecks in the final system. See AV Rule 216 in \r\nAppendix A for additional details. \r\nPremature optimization is the root of all evil – Donald Knuth\r\nNote: This rule does not preclude early consideration of fundamental algorithmic and data \r\nstructure efficiencies. \r\nSee also AV Rule 125 and AV Rule 177 for performance recommendations. \r\n4.30 Miscellaneous \r\nAV Rule 217\r\nCompile-time and link-time errors should be preferred over run-time errors. See Meyers [6], \r\nitem 46. \r\nRationale: Errors detected at compile/link time will not occur at run time. \r\nWhenever possible, push the detection of an error back from run-time to link-time, and \r\npreferably compile-time. See also AV Rule 103 and AV Rule 194. \r\nAV Rule 218\r\nCompiler warning levels will be set in compliance with project policies. \r\nRationale: Compilers can typically be configured to generate a useful set of warning \r\nmessages that point out potential problems. Information gleaned from these messages could \r\nbe used to resolve certain errors before they occur at runtime. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/4639aab6-bf6f-4d6d-88b6-b3bfa128094b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ae56c85e7204595d12094fde5a3bbd178212f11eb1fec9f7b488d9aaa45066db",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 405
      },
      {
        "segments": [
          {
            "segment_id": "faec3e9a-f263-49f9-b2c0-080d538072e5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n63\r\n5 TESTING \r\nThis section provides guidance when testing inheritance hierarchies that employ virtual \r\nfunctions. \r\n5.1.1 Subtypes \r\nIf D is a subtype of B, then instances of type D will function transparently in any context in \r\nwhich instances of type B can exist. Thus it follows that all base class unit-level test cases must \r\nbe inherited by the test plan for derived classes. That is, derived classes must at least successfully \r\npass the test cases applicable to their base classes.3 \r\nAV Rule 219\r\nAll tests applied to a base class interface shall be applied to all derived class interfaces as \r\nwell. If the derived class poses stronger postconditions/invariants, then the new \r\npostconditions /invariants shall be substituted in the derived class tests. \r\nRationale: A publicly-derived class must function transparently in the context of its base \r\nclasses. \r\nNote: This rule will often imply that every test case appearing in the set of test cases \r\nassociated with a class will also appear in the set of test cases associated with each of \r\nits derived classes. \r\n5.1.2 Structure \r\nAV Rule 220\r\nStructural coverage algorithms shall be applied against flattened classes. \r\nRationale: Structural coverage reporting should be with respect to each class context—not a \r\nsummed across multiple class contexts. See AV Rule 220 in Appendix A for additional \r\ndetails. \r\nNote: When a class is viewed with respect to all of its components (both defined at the \r\nderived level as well as inherited from all of its base levels) it is said to be flattened. \r\nAV Rule 221\r\nStructural coverage of a class within an inheritance hierarchy containing virtual functions \r\nshall include testing every possible resolution for each set of identical polymorphic \r\nreferences. \r\nRationale: Provide decision coverage for dispatch tables. \r\n \r\n3\r\n Note that subclass tests will often be extensions of the superclass tests. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/faec3e9a-f263-49f9-b2c0-080d538072e5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13c8e6f07957f40803c940cb16ace454dcb7bcea13bb34cf3d0a1c34d964938c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9ea89ac1-9972-41a0-8f0c-a60233271d74",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9ea89ac1-9972-41a0-8f0c-a60233271d74.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=46ae156a8c2cf235342bac9204d2cbc28c4f97ece6f5cc921d7491980c53ae90",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3e28bbf2-0bc9-4f55-9ba9-46904f142400",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n65",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3e28bbf2-0bc9-4f55-9ba9-46904f142400.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0d733a3f09646c7a776e427e1d782939ff240626a04d428dd0b3b789e645f716",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 314
      },
      {
        "segments": [
          {
            "segment_id": "72dd2890-d362-4df5-8d82-1d8e54e0c2df",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n66\r\nAPPENDIX A \r\nAV Rule 3\r\nCyclomatic complexity measures the amount of decision logic in a single software module. It \r\nmay be used for two related purposes: a measure of design complexity and an aid in testing. \r\nFirst, cyclomatic complexity may be utilized throughout all phases of the software lifecycle, \r\nbeginning with design, to enhance software reliability, testability, and maintainability. Second, \r\ncyclomatic complexity aids in the test planning process by approximating the number of tests \r\nrequired for a given module. Cyclomatic complexity is a structural metric based entirely on \r\ncontrol flow through a piece of code; it is the number of non-repeating paths through the code. \r\nCyclomatic complexity (v(G)) is defined for each module to be: \r\nv(G) = e - n + 2 \r\nwhere n represents ‘nodes’, or computational statements, and e represents ‘edges’, or the \r\ntransfer of control between nodes. \r\nBelow is an example of source code followed by a corresponding node diagram. In the node \r\ndiagram, statements are illustrated as rectangles, decisions as triangles and transitions between \r\nstatements as lines. The number of nodes is fourteen while the number of lines connecting the \r\nnodes is seventeen for a complexity of five. \r\nAnother means of estimating complexity is also illustrated. The number of regions bounded by \r\nthe lines, including the “infinite” region outside of the function, is generally equivalent to the \r\ncomputed complexity. The illustration has 5 disjoint regions; note that it is equal to the computed \r\ncomplexity. \r\nThe illustration uses a multi-way decision or switch statement. Often, a switch statement may \r\nhave many cases causing the complexity to be high, yet the code is still easy to comprehend. \r\nTherefore, complexity limits should be set keeping in mind the ultimate goals: sensible and \r\nmaintainable code. \r\n \r\nExample: Source Code \r\nvoid compute_pay_check ( employee_ptr_type employee_ptr_IP, \r\n check_ptr_type chk_ptr_OP ) \r\n{ \r\n //Calculate the employee’s federal, fica and state tax withholdings \r\n 1. chk_ptr_OP->gross_pay = employee_ptr_IP->base_pay; \r\n 2. chk_ptr_OP->ged_tax = federal_tax ( employee_ptr_IP->base_pay ); \r\n 3. chk_ptr_OP->fica = fica ( employee_ptr_IP->base_pay ); \r\n 4. chk_ptr_OP->state_tax = state_tax ( employee_ptr_IP->base_pay ); \r\n //Determine medical expense based on the employee’s HMO selection \r\n 5. if ( employee_ptr_IP->participate_HMO == true ) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/72dd2890-d362-4df5-8d82-1d8e54e0c2df.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a84c9b881c177272ce5eb53fc9fb235914d90c3324c04cd4b23c7d637826e630",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1dddfa61-4d19-4422-a669-b0e08b4c1b7a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n67\r\n { \r\n 6. chk_ptr_OP->medical = med_expense_HMO; \r\n } \r\n else \r\n { \r\n 7. chk_ptr_OP->medical = med_expense_non_HMO; \r\n } \r\n // Calc a profit share deduction based on % of employee’s gross pay \r\n 8. if (employee_ptr_IP->participate_profit_share == true ) \r\n { \r\n 9. switch( employee_ptr_IP->profit_share_plan ) \r\n { \r\n case plan_a: \r\n 10. chk_ptr_OP->profit_share = two_percent * chk_ptr_OP->gross_pay; \r\n break; \r\n case plan_b: \r\n 11. chk_ptr_OP->profit_share = four_percent * chk_ptr_OP->gross_pay; \r\n break; \r\n case plan_c: \r\n 12. chk_ptr_OP->profit_share = six_percent * chk_ptr_OP->gross_pay; \r\n break; \r\n default: \r\n break; \r\n } \r\n } \r\n else \r\n { \r\n 13. chk_ptr_OP->profit_share = zero; \r\n } \r\n chk_ptr_OP->net_pay = ( chk_ptr_OP->gross_pay – \r\n chk_ptr_OP->fed_tax – \r\n chk_ptr_OP->fica – \r\n chk_ptr_OP->state_tax – \r\n chk_ptr_OP->medical – \r\n chk_ptr_OP->profit_share ); \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1dddfa61-4d19-4422-a669-b0e08b4c1b7a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=830e67c7b250a5a5154bce55b3ec446e246b9b999e5fa5bebcf541cbec5dc8ce",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 457
      },
      {
        "segments": [
          {
            "segment_id": "299d628e-3b0e-4745-95fa-217603e078ab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n68\r\nExample: Node Diagram \r\n1\r\n5\r\n2\r\n3\r\n4\r\n6 7\r\n8\r\n9\r\n13\r\n10 11 12\r\n14\r\n1\r\n2\r\n3\r\n4 5\r\nif\r\nif\r\nswitch\r\nNum ber of disjoint regions = 5\r\nNodes = 14\r\nEdges = 17\r\nCom plexity = 17 - 14 + 2 \r\n = 5 \r\ntrue false\r\ntrue false\r\nA\r\nB\r\nC",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/299d628e-3b0e-4745-95fa-217603e078ab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8fe4564aea5d8ffd8b3230358e0a9f097420e719989d997f9fee38ff52f488a4",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7b23d93c-74b0-4957-b019-24684d840fdd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n69\r\nAV Rule 11\r\nTrigraphs can lead to confusion when question marks are used. For example, the string:\r\n“Enter the date in the following form (??-??-????)” \r\nwould be interpreted as \r\n“Enter the date in the following form (~~??]” \r\nAV Rule 12\r\nThe use of digraphs listed in this rule can obscure the meaning of otherwise simple \r\nconstructs. For example, \r\nint16 a <: 2 :> <: 2 :> = <%<%0,1%>,<%2,3%>%>; \r\nis more simply written as \r\nint16 a[2][2] = { {0,1}, {2,3} }; \r\nAV Rule 15\r\nFor SEAL 1/2 applications, defensive programming checks are required. Defensive \r\nprogramming is the practice of evaluating potential failure modes (due to hardware failures \r\nand/or software errors) and providing safeguards against those failure modes. For SEAL 1/2 \r\nsoftware, System Safety is required to define all the possible software hazards (conditions in \r\nwhich software could contribute to the loss of system function). If the determination is made \r\nfrom the system level that hazard mitigation will be in software, then software requirements \r\nmust be derived (from the identified software hazards) to define appropriate hazard \r\nmitigations. During coding and subsequent code inspection, the code must be evaluated to \r\nensure that the defensive programming techniques implied by the hazard mitigation \r\nrequirements have been implemented and comply with the requirements. Examples where \r\ndefensive programming techniques are used include (but are not limited to) management of: \r\n• arithmetic errors—Overflow, underflow, divide-by-zero, etc. (See also AV Rule 203) \r\n• pointer arithmetic errors—A dynamically calculated pointer references an \r\nunreasonable memory location. (See also AV Rule 215) \r\n• array bounds errors—An array index does not lie within the bounds of the array. (See \r\nalso AV Rule 97) \r\n• range errors—Invalid arguments passed to functions (e.g. passing a negative value to \r\nthe sqrt() function). \r\nNote that explicit checks may not be required in all cases, but rather some other form of \r\nanalysis may be used that achieves the same end. Consider, for example, the following use of \r\ncontainer a. Notice that bounds errors are not possible by construction. Hence, array-access \r\nbounds errors are managed without explicit checks. \r\nconst uint32 n = a.size(); \r\nfor (uint32 i=0 ; i<n ; ++i) \r\n{ \r\n a[i] = i; \r\n }",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7b23d93c-74b0-4957-b019-24684d840fdd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ff96b01856bac32aee6371711339f4d43b57f5139ffd5a95fead08d2090e9f61",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 429
      },
      {
        "segments": [
          {
            "segment_id": "5d4cf1ab-2490-42d0-8df1-bbfd9a9528da",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n70\r\nAV Rule 29\r\nInline functions do not require text substitutions and are well-behaved when called with \r\narguments (e.g. type-checking is performed). \r\nExample: Compute the maximum of two integers. \r\n#define max (a,b) ((a > b) ? a : b) // Wrong: macro \r\ninline int32 maxf (int32 a, int32 b) // Correct: inline function \r\n{ \r\n return (a > b) ? a : b; \r\n} \r\ny = max (++p,q); // Wrong: ++p evaluated twice \r\ny=maxf (++p,q) // Correct: ++p evaluated once and type \r\n // checking performed. (q is const) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/5d4cf1ab-2490-42d0-8df1-bbfd9a9528da.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ee750938488cf1ea22c17f336ecc821fc340d9d7ad9f67e9080c4930a90d0484",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1f52907c-f032-48a2-a1b3-2f01dff7ba6f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n71\r\nAV Rule 30\r\nSince const variables follow scope rules, are subject to type checking, and do not require text \r\nsubstitutions (which can be confusing or misleading), they are preferable to macros as \r\nillustrated in the following example. \r\nExample: \r\n#define max_count 100 // Wrong: no type checking \r\nconst int16 max_count = 100; // Correct: type checking may be performed \r\nNote: Integral constants can be eliminated by optimizers, but non-integral constants will not. \r\nThus, in the example above, max_count will not be laid down in the resulting image. \r\nAV Rule 32\r\nThe exception to the rule involves template class and function definitions which may be \r\npartitioned into separate header and implementation files. In this case, the implementation \r\nfile may be included as a part of the header file. Note that the implementation file is logically \r\npart of the header and is not separately compilable as illustrated below. \r\nExample: \r\nFile A.h: \r\n-------------------------------- \r\n#ifndef A_H \r\n#define A_H \r\ntemplate< class T > \r\nclass A \r\n{ \r\npublic: \r\n void do_something(); \r\n}; \r\n#include <A.cpp> \r\n#endif \r\n------------------------------- \r\nFile A.cpp: \r\n------------------------------- \r\ntemplate< class T > \r\nA<T>::do_something() \r\n{ \r\n // do_something impelemtation \r\n} \r\n------------------------------- ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1f52907c-f032-48a2-a1b3-2f01dff7ba6f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=30088bb76242b3aed7a0fc91d9d896cc05020358ce73c9345a7ac560d7ecbdb9",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "07b7e3d3-3f5a-487c-90f3-df777f68264c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n72\r\nAV Rule 36\r\nUnnecessary recompilation of source files should be eliminated when possible. In the \r\nfollowing example, each source file includes all header files without a determination of \r\nwhich ones are actually required. \r\nExample: All header files are included in the three source files regardless of which files are \r\nactually required. This creates several problems: \r\n1. Inability to limit compilation scope. That is, any change to one header file means \r\nrecompiling (and consequently retesting) each source file. \r\n2. Unnecessarily long compilation times. The repeated compilation of unnecessary \r\nheader files will significantly increase the overall compilation time. \r\n// File 1 \r\n#include <header1.h> \r\n#include <header2.h> // Incorrect: unneeded \r\n#include <header3.h> // Incorrect: unneeded \r\n… // Source for file 1 \r\n// File 2 \r\n#include <header1.h> // Incorrect: unneeded \r\n#include <header2.h> \r\n#include <header3.h> // Incorrect: unneeded \r\n… // Source for file 2 \r\n// File 3 \r\n#include <header1.h> // Incorrect: unneeded \r\n#include <header2.h> // Incorrect: unneeded \r\n#include <header3.h> \r\n… // Source for file 3 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/07b7e3d3-3f5a-487c-90f3-df777f68264c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c2cce4af0005d6f1185b534b0060dc0ddce4f145e491df90054064ecb6b777cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 454
      },
      {
        "segments": [
          {
            "segment_id": "317dd13f-c9be-449b-8c3e-e57d9baa2034",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n73\r\nAV Rule 38\r\nThe header files of classes that are only referenced via pointers or references need not be \r\nincluded. Doing so often increases the coupling between classes, leading to increased \r\ncompilation dependencies as well as greater maintenance efforts. Forward declarations of \r\nthe classes in question (supplied by forward headers) can be used to limit implementation \r\ndependencies, maintenance efforts and compile times. \r\nExample A: This example unnecessarily includes header files creating additional \r\ndependencies in the Operator interface.\r\n// Operator.h \r\n#include <LM_string.h> // Incorrect: creates unnecessary dependency \r\n#include <Date.h> // Incorrect: creates unnecessary dependency \r\n#include <Record.h> // Incorrect: creates unnecessary dependency \r\nclass Operator \r\n{ \r\n public: \r\n Operator (const LM_string &name, \r\n const Date &birthday, \r\n const Record &flying_record); \r\n LM_string get_name () const; \r\n int32 get_age () const; \r\n Record get_record () const; \r\n … \r\n private: \r\n Operator_impl *impl; \r\n}; \r\nExample B: In contrast to Example A, Example B uses forward headers to forward declare \r\nimplementation classes used by Operator. Hence the Operator interface is not dependent on \r\nany of the implementation classes.\r\n// Operator.h The forward headers only contain declarations. \r\n#include <LM_string_fwd.h> \r\n#include <Date_fwd.h> \r\n#include <Record_fwd.h> \r\n#include <OperatorImpl.h> \r\nclass Operator \r\n{ \r\n public: \r\n Operator (const LM_string &name, \r\n const Date & birthday, \r\n const Record &flying_record); \r\n LM_string get_name() const; \r\n int32 get_age () const; \r\n record get_record () const; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/317dd13f-c9be-449b-8c3e-e57d9baa2034.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e318498e214221927303d7b46a00f9569d429b4ba28db560976af68b531800da",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "47758925-78bf-44d3-b7d5-f90b9f9ec59f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n74\r\n … \r\n private: \r\n Operator_impl *impl; \r\n}; \r\n// Operator.cc \r\n#include <Operator.h> \r\n#include <Operator_impl.h> // Contains implementation details of the Operator object. \r\n… \r\nint32 Operator::get_age() \r\n{ \r\n impl->get_age(); \r\n} \r\nAV Rule 39\r\nAlthough header files should not contain non-const variable or function definitions in \r\ngeneral, inline functions and template definitions will often be included. \r\nExample: Although definitions should, in general, be placed in .cpp files, a member function \r\ndefined inside a class declaration represents a suggestion to the compiler that the member \r\nfunction should be inlined (if possible). \r\nclass Square \r\n{ \r\n public: \r\n float32 area() // The member function definition in the class declaration \r\n { // suggests to the compiler that the member function should be \r\n return length *width; // inlined. \r\n } \r\n private: \r\n float32 length; \r\n float32 width; \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/47758925-78bf-44d3-b7d5-f90b9f9ec59f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=28a01219c7c756cc38981f8111df244472ebb301b6df1eaf748384b8b0195cdc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 347
      },
      {
        "segments": [
          {
            "segment_id": "02268726-3465-43e0-b71d-4196b9e094c3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n75\r\nAV Rule 40\r\nAV Rule 40 is intended to support the one definition rule (ODR). That is, only a single \r\ndefinition for each entity in a program may exist. Hence, placing the declaration of a type \r\n(included with its definition) in a single header file ensures that duplicate definitions are \r\nidentical. \r\nExample A: Scattering the definition of a type throughout an application (i.e. in .cpp files) \r\nincreases the likelihood of non-unique definitions (i.e. violations of the ODR).\r\n//s.cpp \r\nclass S // Bad: S declared in .cpp file. \r\n{ // S could be declared differently in a \r\n int32 x; // separate .cpp file \r\n char y; \r\n}; \r\nExample B: Placing the definition of S in two different header files provides an opportunity \r\nfor non-unique definitions (i.e. violation of the ODR).\r\n//s.h \r\nclass S \r\n{ \r\n int32 x; \r\n char y; \r\n}; \r\n// y.h \r\nclass S // Bad: S multiply defined in two different header files. \r\n{ \r\n int32 x; \r\n int32 y; \r\n };",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/02268726-3465-43e0-b71d-4196b9e094c3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b61488e3950143f42820516dad2ccabd2a387607839f1a6485c38198a839afe1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c2b14368-f462-4d37-aa6e-f9a6ff9633fe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n76\r\nAV Rule 42\r\nAV Rule 42 indicates that expression-statements must be on separate lines. An expression \r\nstatement has the following form:\r\nexpression-statement: \r\n expressionopt ;\r\nAll expressions in an expression-statement are evaluated and all side effects are completed \r\nbefore the next statement is executed. The most common expression-statements are \r\nassignments and function calls. [10]\r\nExamples: \r\nx = 7; y=3; // Incorrect: multiple expression statements on the same line. \r\na[i] = j[k]; i++; j++; // Incorrect: multiple expression statements on the same line. \r\na[i] = k[j]; // Correct. \r\ni++; \r\nj++; \r\nNote that a for statement is a special case where conditionopt and expressionopt may appear on \r\nthe same line as expression-statement[10]. \r\niteration-statement: \r\n while ( condition ) statement \r\n do statement while ( expression ) ; \r\n for ( for-init-statement condition-opt ; expression-opt ) statement\r\nfor-init-statement: \r\n expression-statement \r\n simple-declaration \r\nExamples: \r\nfor( i = 0 ; i < max ; ++i) fun(); // Incorrect: multiple expression statements on the same line. \r\n for(i = 0 ; i < max ; ++i) // Correct \r\n { \r\n foo(); \r\n }",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/c2b14368-f462-4d37-aa6e-f9a6ff9633fe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d4c1ee725ed9b1b4c615f2a1e64a3260e9c5c40e0f9cb261c080452b2663730c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 343
      },
      {
        "segments": [
          {
            "segment_id": "27a2fe13-4620-4704-8844-e09b62838557",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n77\r\nAV Rule 58\r\nExamples: The following examples illustrate the proper way to declare functions with \r\nmultiple arguments. \r\nint32 max (int32 a, int32 b) // Correct: two parameters may appear on the \r\n{ // same line. Order is easily understood. \r\n… \r\n} \r\n // Incorrect: too many parameters on the same line. \r\n // Difficult to document parameters in this form \r\nmsg1_in (uint16 msg_ID, float32 rate_IO, uint32 msg_size, uint16 rcv_max_instances) \r\n{ \r\n… \r\n} \r\n // Correct form. \r\nmsg1_in ( uint16 msg_ID, // Unique identifier that is the label for the message \r\n float32 rate_IO, // The desired rate for the message distributed \r\n uint32 msg_size, // Size in bytes of the message \r\n uint16 rcv_max_instances) // The maximum number of instances of this \r\n // message expected in a processing frame \r\n{ \r\n… \r\n} \r\nAV Rule 59\r\nAs the following examples illustrate, the bodies of if, else if, else, while, do..while and for\r\nstatements should always be enclosed within braces. As illustrated in Example A, code added \r\nat a later time will not be part of a block unless it is enclosed by braces. Furthermore, as \r\nillustrated by Example B, “;” can be difficult to see by itself. Hence a block (even if empty) \r\nis required after control flow primitives. \r\nExample A: \r\nif (flag == 1) \r\n{ \r\n success (); \r\n} \r\nelse // Incorrect: log_error() was added at a later time \r\n clean_up_resources(); // but is not part of the block (even though \r\n log_error(); // it is at the proper indentation level). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/27a2fe13-4620-4704-8844-e09b62838557.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9db192cffa0c1d5e79bf145c55be2b2897f27e271421c2a92828ddf3c12fa965",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 251
      },
      {
        "segments": [
          {
            "segment_id": "07ef2ea4-729a-449e-9b04-fa6cb368735e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n78\r\nExample B: A block, even if empty, is required after control flow primitives.\r\nwhile (f(x)); // Incorrect: “;” is difficult to see. \r\nwhile (f(x)) // Incorrect: “;” is difficult to see. \r\n ; \r\nwhile (f(x)) // Correct \r\n{ \r\n} \r\nAV Rule 70\r\nAV Rule 70 indicates that friends may be used only when a function or object requires \r\naccess to the private elements of a class, but is unable to be a member of the class for logical \r\nor efficiency reasons. The following three examples illustrate acceptable uses of friends. \r\nExample A: operator<<()\r\nConsider operator<<() and operator>>() where an implicit type conversion on the left-most \r\nargument is often required. Since an implicit type conversion on the left-most argument of a \r\nfunction can only be provided through non-member functions, operator<<() and \r\noperator>>() must be implemented as friend functions. \r\nThe preferred C++ solution is to declare such functions (that are conceptually part of the \r\npublic interface) as non-member friends of the class. This solution provides both private \r\nelement access as well as implicit type conversions. \r\nExample B: Binary operator overloads (+, -, *, /, etc.) \r\nConsider the example provided by Stroustrup [2]. How can a matrix-vector multiplication \r\noperation be provided without exposing the internal representation of the matrix or the \r\nvector? Clearly, the function requires access to the internal representation of both the matrix \r\nand the vector. Thus, the function cannot be a member of either one. However, if the function \r\nis not a friend, then accessors and mutators must be supplied which expose the internal \r\nrepresentation (i.e. violate encapsulation). Hence, adding the friend function operator*() to \r\nthe public interface of both Matrix and Vector provides a clean, encapsulated approach. \r\nclass Matrix; \r\nclass Vector \r\n{ \r\n float32 v[4]; \r\n // … \r\n friend Vector operator* (const matrix& m, const vector& v); \r\n}; \r\nclass Matrix { \r\n Vector v[4]; \r\n // … \r\n friend Vector operator*(const Matrix& m, const Vector& v); \r\n}; \r\nVector operator*(const Matrix& m, const Vector& v) \r\n{ ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/07ef2ea4-729a-449e-9b04-fa6cb368735e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1e5fc4a6bc48c37a822cfc8f75ca9f015a95f9b6ea711ee6eebda10ee6ee0a0f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "97c2ab02-be11-410f-aca6-ab5f9e5ea190",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n79\r\n Vector r; \r\n for (int32 i=0 ; i<4 ; i++) \r\n { \r\n r.v[i] = 0; \r\n for(int32 j=0; j<4 ; j++) \r\n { \r\n r.v[i] += m.v[i].v[j] * v.v[j]; \r\n } \r\n } \r\n return r; \r\n} \r\nExample C: External iterators. \r\nSince an iterator may be required to modify the contents of an object within a container \r\n(*iterator = value ), it must be able to access the private portions of that object. Thus, if an \r\niterator is external to a class, it must be a friend. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/97c2ab02-be11-410f-aca6-ab5f9e5ea190.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=707cd1edb33be49087aa6ce1b48d027c28bec4dab2f501b1054a0ac62adb49fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 417
      },
      {
        "segments": [
          {
            "segment_id": "c0780f28-5448-41f9-bd78-0268751e37dc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n80\r\nAV Rule 70.1\r\nConceptually, developers understand that objects should not be used before they have been \r\ncreated or after they have been destroyed. However, a number of scenarios may arise where \r\nthis distinction may not be obvious. Consequently, a series of examples is provided to \r\nhighlight possible areas of confusion. In many cases, the C++ standard [10] is quoted and an \r\nexplanatory code segment is provided. \r\nExample A: Exiting main().\r\nmain() should never exit independent of the application of which it is a part. Consider the \r\ncode sample below. When main() exits, the static object destructors are invoked. Hence, the \r\ntasks created by main() cannot depend the existence those static objects. \r\nint32 main() \r\n{ \r\n _main(); // Call static constructors (inserted by compiler) \r\n// Application code begins \r\n initialize_task_1(); // Initialize tasks \r\n initialize_task_2(); \r\n … \r\n initialize_task_n(); \r\n// Application code ends \r\n __call_dtors(); // Call static destructors (inserted by compiler) \r\n} \r\n// Tasks begin to run. However, static objects have been destroyed. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/c0780f28-5448-41f9-bd78-0268751e37dc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2b6c05f5d306ed6594d38d0a719c15de0add2f54840ad74e4d3a873f8785ffb0",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7af48b58-eb50-4456-8bb1-1e826b643746",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n81\r\nExample B: Accessing a const Object During Construction.\r\nNote that this scenario cannot occur without the use of global variables which are \r\nprohibited by AV Rule 207. \r\nDuring the construction of a const object, if the value of the object or any of its \r\nsubobjects is accessed through an lvalue that is not obtained, directly or indirectly, from \r\nthe constructor’s this pointer, the value of the object or subobject thus obtained is \r\nunspecified. [10] 12.1(15) \r\nstruct C; \r\nvoid no_opt(C*); \r\nstruct C \r\n{ \r\n int c; \r\n C() : c(0) \r\n { \r\n no_opt(this); \r\n } \r\n}; \r\nconst C cobj; \r\nvoid no_opt(C* cptr) \r\n{ \r\n int i = cobj.c * 100 // value of cobj.c is unspecified \r\n cptr->c = 1; \r\n cout << cobj.c * 100 // value of cobj.c is unspecified \r\n << ’\\n’; \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7af48b58-eb50-4456-8bb1-1e826b643746.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=239bf5863e57d0786ec984734badbb5e101645eaa905453e4b6f60ccd1d8133b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "aae342b2-773c-4680-a0e7-aa8bd3e19546",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n82\r\nExample C: Local Static Object with Non-Trivial Destructors.\r\nIf a function contains a local object of static storage duration that has been destroyed and \r\nthe function is called during the destruction of an object with static storage duration, the \r\nprogram has undefined behavior if the flow of control passes through the definition of the \r\npreviously destroyed local object. [10] 3.6.3(2) \r\nclass A \r\n{ \r\n public: \r\n ~A() { … } \r\n}; \r\nvoid foo() \r\n{ \r\n static A a; // Destructor of local static will be invoked on exit \r\n} \r\nclass B \r\n{ \r\n public: \r\n ~B() \r\n { \r\n foo(); // Destructor of static calls function with local static which may \r\n } // already be destroyed. \r\n}; \r\nstatic B B_var; // Destructor of static will be invoked on exit. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/aae342b2-773c-4680-a0e7-aa8bd3e19546.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d01f57db3122c922b6d3904bfeef7dc93b05364627a69c93857e21185d6bbc0a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 433
      },
      {
        "segments": [
          {
            "segment_id": "6065549f-7ffa-4679-a40a-c2df75166baa",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n83\r\nExample D: Invocation of Member Function after Lifetime of Object has Ended.\r\nBefore the lifetime of an object has started but after the storage which the object will \r\noccupy has been allocated or, after the lifetime of an object has ended and before the \r\nstorage which the object occupied is reused or released, any pointer that refers to the \r\nstorage location where the object will be or was located may be used but only in limited \r\nways. …if the object will be or was of a non-POD class type, the program has undefined \r\nbehavior if: \r\n• the pointer is used to access a non-static data member or call a non-static member \r\nfunction of the object, ... [10] 3.8(5)\r\nstruct B \r\n{ \r\n virtual void f(); \r\n void mutate(); \r\n virtual ~B(); \r\n }; \r\nstruct D1 : B \r\n{ \r\n void f() \r\n}; \r\nstruct D2 : B \r\n{ \r\n void f() \r\n}; \r\nvoid B::mutate() \r\n{ \r\n new (this) D2; // reuses storage – ends the lifetime of *this \r\n f(); // undefined behavior \r\n ... = this; // OK, this points to valid memory \r\n} \r\n // Note: placement new is only allowed in low-level memory \r\n // management routines (see AV Rule 206). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6065549f-7ffa-4679-a40a-c2df75166baa.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=96ee385f89a3ca8ceb2818276b581214631c32397e60378dab9214cb418ef2f8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "36cb6f1b-db51-4b73-91b9-8a6c5b2002ca",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n84\r\nExample E: Storage Reuse does not Require Implicit Destructor Invocation.\r\nFor an object of a class type with a non-trivial destructor, the program is not required to \r\ncall the destructor explicitly before the storage which the object occupies is reused or \r\nreleased; however, if there is no explicit call to the destructor or if a delete-expression \r\n(5.3.5) is not used to release the storage, the destructor shall not be implicitly called and \r\nany program that depends on the side effects produced by the destructor has undefined \r\nbehavior. [8] 3.8(4) \r\nstruct A \r\n{ \r\n ~A() \r\n { \r\n …non-trivial destructor \r\n } \r\n}; \r\nstruct B { … }; \r\nvoid c_03_06_driver() \r\n{ \r\n A a_obj; \r\n new (&a_obj) B(); // a_obj’s lifetime ended without calling \r\n … // nontrivial destructor. \r\n} \r\n // Note: placement new is only allowed in low-level memory \r\n // management routines (see AV Rule 206). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/36cb6f1b-db51-4b73-91b9-8a6c5b2002ca.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=218e55882c9000a45047dea2f1d2a9f14a524cf0e7d9b734fe663a503dd19a4c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1cfbe1fe-0349-43da-891b-6f401e29b2e0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 84,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n85\r\nExample F: Object of Original Type Must Occupy Storage for Implicit Destructor \r\nCall.\r\nIf a program ends the lifetime of an object of type T with static (3.7.1) or automatic \r\n(3.7.2) storage duration and if T has a non-trivial destructor, the program must ensure that \r\nan object of the original type occupies that same storage location when the implicit \r\ndestructor call takes place; otherwise the behavior of the program is undefined. This is \r\ntrue even if the block is exited with an exception. [10] 3.8(8) \r\nclass T { }; \r\n struct B { \r\n ~B() { … }; \r\n }; \r\n \r\n void c_03_11_driver() \r\n { \r\n B b; \r\n new (&b) T; // B’s nontrivial dtor implicitly called on memory occupied by an \r\n // object of different type. \r\n} //undefined behavior at block exit \r\n // Note: placement new is only allowed in low-level memory \r\n // management routines (see AV Rule 206). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1cfbe1fe-0349-43da-891b-6f401e29b2e0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=781bfc184b23ea8bfe62eeaeac95c7612f361ce934609868e5b28bfb58c1b814",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 502
      },
      {
        "segments": [
          {
            "segment_id": "83b9b930-3c40-4269-83f7-d6f38d147d72",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n86\r\nExample G: Creating a New Object at the Storage Location of a const Object.\r\nCreating a new object at the storage location that a const object with static or automatic \r\nstorage duration occupies or, at the storage location that such a const object used to \r\noccupy before its lifetime ended results in undefined behavior. [10] 3.8(9) \r\nstruct B \r\n{ \r\n B() { … }; \r\n ~B() { … }; \r\n}; \r\nconst B b; \r\nvoid c_03_12_driver() \r\n{ \r\n b.~B(); // A new object is created at the storage location that a const \r\n // object used to occupy before its lifetime ended. This results \r\n new (&b) const B; // in undefined behavior \r\n} \r\n // Note: placement new is only allowed in low-level memory \r\n // management routines (see AV Rule 206). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/83b9b930-3c40-4269-83f7-d6f38d147d72.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=03a2443a68d92d2d8aa7fc1087c378f60ceef4d07290e49ce220ca3e3fe5a6cd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 134
      },
      {
        "segments": [
          {
            "segment_id": "cb6ecc0f-8359-4959-a501-f084186fd2bf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 86,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n87\r\nExample H: Member Function in ctor-Initializer Invoked Before Bases are \r\nInitialized.\r\nIf these operations (member function invocation, operand of typeid or dynamic_cast) are \r\nperformed in a ctor-initializer (or in a function called directly or indirectly from a ctor\u0002initializer) before all the mem-initializers for base classes have completed, the result of \r\nthe operation is undefined. [10] 12.6.2(8) \r\nclass A { public: A(int) { … }}; \r\nclass B : public A \r\n{ \r\n int j; \r\n public: \r\n int f() { … }; \r\n B() : A(f()), // Undefined: calls member function but base A is \r\n // is not yet initialized \r\n j(f()) { … } // Well-defined: bases are all initialized \r\n };\r\nAV Rule 71\r\nThe intent of AV Rule 71 is to prevent an object from being used before it is in a fully \r\ninitialized state. This may occur in three cases: \r\n1. a class constructor invokes an overridden method before the derived class (supplying \r\nthe method) has been fully constructed, \r\n2. a class constructor invokes a public or protected method that requires the object to be \r\nfully initialized as a pre-condition of method invocation, or \r\n3. the constructor does not fully initialize the object allowing clients access to \r\nuninitialized data. \r\nIn the first case, C++ will not allow overridden methods to resolve to their corresponding \r\nsubclass versions since the subclass itself will not have been fully constructed and thus, by \r\ndefinition, will not exist. In other words, while the base class component of a derived class is \r\nbeing constructed, no methods of the derived class can be invoked through the virtual method \r\nmechanism. Consequently, constructors should make no attempt to employ dynamic binding \r\nin any form. \r\nSecondly, public (and in some cases protected) methods assume object initialization and \r\nclass invariants have been established prior to invocation. Thus, invocation of such methods \r\nduring object construction risks the use of uninitialized or invalid data since class invariants \r\ncan not be guaranteed before an object is fully constructed. \r\nFinally, the constructor should fully initialize an object (see Stroustrup [2], Appendix E and \r\nAV Rule 72). If for some reason the constructor cannot fully initialize an object, some \r\nprovision must be made (and documented in the constructor) to ensure that clients cannot \r\naccess the uninitialized portions of the object. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/cb6ecc0f-8359-4959-a501-f084186fd2bf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3e2f58333612f014479d79eb5f8c3d07012941077758d196f7be19c0d7441d74",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 380
      },
      {
        "segments": [
          {
            "segment_id": "3a1454ad-d25e-411d-8d11-67f8011fa6f7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 87,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n88\r\nAV Rule 71.1\r\nThe intent of AV Rule 71.1 is to clarify that a class’s virtual functions are resolved statically \r\nin any of its constructors or its destructor. As a result, the placement of virtual functions in \r\nconstructors/destructors often leads to unexpected behavior. \r\nConsider the examples below. In Example A, the virtual function does not exhibit \r\npolymorphic behavior. In contrast, the same function is called in Example B. This time, \r\nhowever, the scope resolution operator is used to clarify that the virtual function is statically \r\nbound. \r\nExample A: \r\nclass Base \r\n{ \r\n public: \r\n Base() \r\n { \r\n v_fun(); // Bad: virtual function called from constructor. Polymorphic \r\n } // behavior will not be realized. \r\n virtual void v_fun() \r\n { \r\n } \r\n}; \r\nExample B: \r\nclass Base \r\n{ \r\n public: \r\n Base() \r\n { \r\n Base::v_fun(); // Good: scope resolution operator used to specify static \r\n } // binding \r\n virtual void v_fun() \r\n { \r\n } \r\n};",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/3a1454ad-d25e-411d-8d11-67f8011fa6f7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4116719e824b9da67ea97e4b7cacdfc733b174c9c6afd5f85675b2d85937b846",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7239564d-6079-487d-b346-5ef684d65d32",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 88,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n89\r\nAV Rule 73\r\nA default constructor is a constructor that can be called without any arguments. Calling a \r\nconstructor without any arguments implies that objects can be created and initialized without \r\nsupplying external information from the point of call. Although this may be appropriate for \r\nsome classes of objects, there are others for which there is no reasonable means of \r\ninitialization without passing in external information. For this class of objects, the presence \r\nof default constructors requires that additional logic be added to member functions to ensure \r\ncomplete object initialization before operations are allowed to proceed. Hence, avoiding \r\ngratuitous default constructors leads to less complex, more efficient operations on fully \r\ninitialized objects. \r\nConsider the following examples where a Part must always have a SerialNumber. Example A\r\nillustrates the code for a single method, getPartName(), that returns the name of the part \r\nidentified by a particular serial number. Note that additional logic must be added to the \r\nmember function getPartName() to determine if the part has been fully initialized. In \r\ncontrast, Example B does not have the unnecessary default constructor. The corresponding \r\nimplementation is cleaner, simpler, and more efficient. \r\nExample A: Gratuitous default constructor. \r\nclass Part \r\n{ \r\n public: \r\n Part () \r\n { serial_number =unknown; \r\n } // Default constructor: \r\n Part (int32 n) : serial_number(n) {} \r\n int32 get_part_name() \r\n { \r\n if (serial_number == unknown) // Logic must be added to check for \r\n { // uninitialized state \r\n return “”; \r\n } \r\n else \r\n { \r\n return lookup_name (serial_number); \r\n } \r\n private: \r\n int32 serialNumber; \r\n static const int32 unknown; \r\n}; \r\nExample B: No gratuitous default constructor. \r\nclass Part \r\n{ \r\n public: \r\n Part (int32 n) : serial_number(n) {} \r\n int32 get_part_name () { return lookup_name (serial_number);} \r\n private: ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7239564d-6079-487d-b346-5ef684d65d32.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=896d917747b35855603fdb14b41de2a8feb384a01fd9debcdd77fe136e598007",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 433
      },
      {
        "segments": [
          {
            "segment_id": "0eda5fa3-f18e-4136-a154-1a7a3f5b0d3b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 89,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n90\r\n int32 serial_number; \r\n} \r\n; \r\nNote: The absence of a default constructor implies certain restrictions for arrays and \r\ntemplate-based containers of such objects. See Meyers [7] for more specific \r\ndetails. \r\nAV Rule 74\r\nRationale: This rule stems from the following observations: \r\n• Member initialization is the only option for const members. \r\n• Member initialization is the only option for reference members. \r\n• Member initialization is never less efficient and often more efficient than assignment. \r\n• Member initialization tends to simplify maintenance of classes. \r\nExample A: For class Rectangle with attributes length and width, the member initialization \r\nlist should be used to initialize both attributes. \r\nRectangle (float32 length_, float32 width_) : length(length_), width(width_) \r\n{ \r\n} \r\nExample B: Suppose that length and width cannot be represented as simple expressions (e.g. \r\nthey must be read from an input stream). In this case, the member initialization list cannot be \r\nused. \r\nRectangle () \r\n{ \r\n cin >> length >> width; \r\n} \r\nAV Rule 76\r\nIf an object contains a pointer to a data element, what should happen when that object is \r\ncopied? Should the pointer itself be copied and thus two different objects reference the same \r\ndata item, or should the data pointed to be copied? The default behavior is to copy the \r\npointer. This behavior, however, is often not the desired behavior. The solution is to define \r\nboth the copy constructor and assignment operator for such cases. \r\nIf clients should never be able to make copies of an object, then the copy constructor and the \r\nassignment operator should be declared private (with no definition). This will prevent clients \r\nfrom calling these functions as well as compilers from generating them. \r\nFinally, a nontrivial destructor typically implies some form of resource cleanup. Hence, that \r\ncleanup will most likely need to be performed during an assignment operation. \r\nNote: There are some cases where the default copy and assignment operators do offer \r\nreasonable semantics. For example, a function object holding a pointer to a member \r\nfunction (e.g. std::mem_fun_t) may not require non-default behavior. For these cases, \r\nsee AV Rule 80. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/0eda5fa3-f18e-4136-a154-1a7a3f5b0d3b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a7e176e4403e078378bf703952358e30a02074248036580c4ff9d0e8037027a1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "57453c66-22c3-4d28-91f3-f8dec92b8c9a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 90,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n91\r\nAV Rule 77\r\nA class may contain many data members as well as exist within an inheritance hierarchy. \r\nHence the copy constructor must copy all members (that affect the class invariant), including \r\nthose in base classes, as in the following example: \r\nclass Base \r\n{ \r\n public: \r\n Base (int32 x) : base_member (x) { } \r\n Base (const Base& rhs) : base_member (rhs.base_member) {} \r\n private: \r\n int32 base_member; \r\n}; \r\nclass Derived : public Base \r\n{ \r\n public: \r\n Derived (int32 x, int32 y, int32 z) : Base (x), \r\n derived_member_1 (y), \r\n derived_member_2 (z) { } \r\n Derived(const Derived& rhs) : Base(rhs), \r\n derived_member_1 (rhs.derived_member_1), \r\n derived_member_2 (rhs.derived_member_2) { } \r\n private: \r\n int32 derived_member_1; \r\n int32 derived_member_2; \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/57453c66-22c3-4d28-91f3-f8dec92b8c9a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7524efec1f5456cce9843802c42a66114802c96c960c89c0e76d5f8a174ff98f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 463
      },
      {
        "segments": [
          {
            "segment_id": "f06340d6-206b-40f2-ba59-318c5b959053",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n92\r\nAV Rule 77.1\r\nA particular ambiguity can arise with respect to compiler-supplied, implicit copy constructors \r\nas noted in [10] 12.8(4): \r\nIf the class definition does not explicitly declare a copy constructor, one is declared implicitly. \r\nThus, for the class definition \r\nstruct X { \r\n X(const X&, int); \r\n}; \r\na copy constructor is implicitly-declared. If the user-declared constructor is later defined as \r\nX::X(const X& x, int i =0) { /* ... */ } \r\nthen any use of X’s copy constructor is ill-formed because of the ambiguity; no diagnostic \r\nis required.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/f06340d6-206b-40f2-ba59-318c5b959053.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5685979506205d0901a9f85f8bc1d1a1435e6822b03649582af74368747a42ed",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7c069c2a-419f-43df-8370-30670e17219d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n93\r\nAV Rule 79\r\nReleasing resources in a destructor provides a convenient means of resource management, \r\nespecially in regards to exceptional cases. Moreover, if it is possible that a resource could be \r\nleaked, then that resource should be wrapped in a class whose destructor automatically cleans \r\nup the resource. \r\nExample A: Stroustrup [2] provides an example based on a file handle. Note that the \r\nconstructor opens the file while the destructor closes the file. Any \r\npossibility that a client may “forget” to cleanup the resource is eliminated. \r\n class File_ptr // Raw file pointer wrapped in class to ensure \r\n{ // resources are not leaked. \r\n public: \r\n File_ptr (const char *n, const char * a) { p = fopen(n,a); } \r\n File_ptr (FILE* pp) { p = pp; } \r\n ~File_ptr () \r\n { \r\n if (p) \r\n { \r\n fclose(p) \r\n }; \r\n } // Clean up file handle. \r\n … \r\n private: \r\n FILE *p; \r\n}; \r\nuse_file (const char *file_name) \r\n{ // Client does not have to remember to clean up file handle \r\n File_ptr f(fn,”r”); // (impossible to leak file handles). \r\n // use f \r\n} // f goes out of scope so the destructor is called, \r\n // cleaning up the file handle.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7c069c2a-419f-43df-8370-30670e17219d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=64288180852c238c4192b93dec9f93d78a3e9a32805ee9bd37d62c5741f76ab9",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b4580272-a608-4666-801d-83174290cbf8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n94\r\nAV Rule 81\r\nSelf-assignment must be handled appropriately by the assignment operator. Example A \r\nillustrates a potential problem, whereas Example B illustrates an acceptable approach. \r\nExample A: Although it is not necessary to check for self-assignment in all cases, the \r\nfollowing example illustrates a context where it would be appropriate. \r\nBase &operator= (const Base &rhs) \r\n{ \r\n release_handle (my_handle); // Error: the resource referenced by myHandle is \r\n my_handle = rhs.myHandle; // erroneously released in the self-assignment case. \r\n return *this; \r\n} \r\nExample B: One means of handling self-assignment is to check for self-assignment before \r\nfurther processing continues as illustrated below.\r\nBase &operator= (const Base& rhs) \r\n{ \r\n if (this != &rhs) // Check for self assignment before continuing. \r\n { \r\n release_handle(my_handle); // Release resource. \r\n my_handle = rhs.my_handle; // Assign members (only one member in class). \r\n } \r\n else \r\n { \r\n } \r\n return *this; \r\n } ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/b4580272-a608-4666-801d-83174290cbf8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d1ac96115b00f5bd225c4c4f369f530d2cf00747cc0e5fee4b8922ab7d976464",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 443
      },
      {
        "segments": [
          {
            "segment_id": "77b2c76f-e007-4b6a-9c9a-a8fd2af2482b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n95\r\nAV Rule 83\r\nA class may contain many data members as well as exist within an inheritance hierarchy. \r\nHence the assignment operator must assign all members, including those in base classes, \r\nwhich affect the class invariant as in the following example: \r\nNote: Definition of operator=() is included in the class declaration to simplify the \r\nexplanation of this rule. It breaks the “no function definition in class declaration” \r\nrule. \r\nclass Base \r\n{ \r\n public: \r\n Base (int32 x) : base_member (x) {} \r\n Base &operator=(const Base& rhs) \r\n { \r\n if (this != &rhs) // Check for self assignment before continuing. \r\n { \r\n base_member = rhs.base_member; // Assign members (only one member in class). \r\n } \r\n else \r\n { \r\n } \r\n return *this; \r\n } \r\n private: \r\n int32 base_member; \r\n}; \r\nclass Derived : public Base \r\n{ \r\n public: \r\n Derived (int32 x, int32 y, int32 z) : Base (x), \r\n derived_member_1 (y), \r\n derived_member_2 (z) {} \r\n Derived& operator=(const Derived& rhs) \r\n { \r\n if (this != &rhs) // Check for self-assignment \r\n { \r\n Base::operator=(rhs); // Copy base class elements. \r\n derived_member_1 = rhs.derived_member_1; // Assign all members of derived class \r\n derived_member_2 = rhs.derived_member_2; \r\n } \r\n else \r\n { \r\n } \r\n return *this; \r\n } ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/77b2c76f-e007-4b6a-9c9a-a8fd2af2482b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7b122a92419b2d3f0af0688eecf76369edddade40736c3daa1d52babd923ca6f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f2396e62-7d83-43fd-bc48-72261bf587ac",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n96\r\n private: \r\n int32 derived_member_1; \r\n int32 derived_member_2; \r\n}; \r\nAV Rule 85\r\nThe following example illustrates how operator!=() may be defined in terms of \r\noperator==(). This construction simplifies maintenance. \r\nbool operator==(Sometype a) \r\n{ \r\n if ( (a.attribute_1 == attribute_1) && \r\n (a.attribute_2 == attribute_2) && \r\n (a.attribute_3 == attribute_3) && \r\n ... \r\n (a.attribute_n == attribute_n) ) \r\n { \r\n return true; \r\n } \r\n else \r\n { \r\n return false; \r\n } \r\nbool operator!=(Some_type a) \r\n{ \r\n return !(*this==a); //Note “!=” is defined in terms of \"==\" \r\n } ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/f2396e62-7d83-43fd-bc48-72261bf587ac.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3356e522be39473be2796386959ebbac103102b5504673c92b73d6693e75a88f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "23a22e1e-3cac-46d7-af1e-3b9fdb9044a1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n97\r\nAV Rule 87\r\nHierarchies based on abstract classes are preferred. Therefore the hierarchies at the top of the \r\ndiagram are preferred over the hierarchy at the bottom of the diagram. \r\nUsers \r\nInterface\r\nD1 D2 \r\nImpl \r\nInterface \r\nImpl \r\nD1 D2 \r\nBase \r\nInterface \r\n& Data \r\nD1 D2 \r\nUsers \r\nUsers\r\nAbstract class \r\nhierarchies\r\nNon abstract \r\nclass hierarchy\r\nHierarchies based on abstract \r\nclasses are preferred.\r\nPublic inheritance\r\nPrivate/protected \r\ninheritance ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/23a22e1e-3cac-46d7-af1e-3b9fdb9044a1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=311cb5fcb45f438933c9ff086af9bd2fb2e494bf7cc095a986c99023550c7983",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 345
      },
      {
        "segments": [
          {
            "segment_id": "ce319d26-3655-4b10-86c8-19c8e6ee5625",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n98\r\nAV Rule 88\r\nIn the context of this rule, an interface is specified by a class which has the following \r\nproperties: \r\n• it is intended to be an interface, \r\n• its public methods are pure virtual functions, and \r\n• it does not hold any data, unless those data items are small and function as part of the \r\ninterface (e.g. a unique object identifier). \r\nNote 1: Protected members may be used in a class as long as that class does not \r\nparticipate in a client interface. \r\nNote 2: Classes with additional state information may be used as bases provided \r\ncomposition is performed in a disciplined manner with templates (e.g. policy\u0002based design). See the “Programming with Policies” paragraph below. \r\nThe following diagrams illustrate both good and bad examples of multiple inheritance. \r\nImplementers \r\ninterface \r\nclass \r\nimplementation implementation implementation\r\nderived \r\nclass \r\nPublic inheritance\r\nPrivate/protected \r\ninheritance \r\nGood: Two interfaces, two private implementations, \r\n and one protected implementation. \r\ninterface \r\nclass \r\nPrivate inheritance\r\nUsers \r\n \r\ninterface \r\nclass \r\ninterface \r\nclass \r\ninterface \r\nclass \r\ninterface \r\nclass \r\nimplementation \r\nderived \r\nclass \r\n…\r\n1 2 3 n 1\r\nPublic inheritance\r\nPrivate/protected \r\ninheritance \r\nGood: n interfaces and one protected implementation. \r\nUsers Implementers ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/ce319d26-3655-4b10-86c8-19c8e6ee5625.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d0c99ef41c8001a2ef53d26308c5cf4ddbdae451293df69e37ab473f058eee35",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8ac657c1-a9e8-4055-9789-782157452900",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n99\r\nPublic inheritance\r\nProtected/private \r\ninheritance \r\nPrivate inheritance\r\nGood: D1 has one interface and one implementation. \r\n D2 has two interfaces and one implementation. \r\nUsers \r\nImplementers \r\ninterface \r\nclass \r\nD2 \r\ninterface \r\nclass \r\nImpl \r\nD1 \r\nD1 \r\nImpl \r\nD2 \r\nImpl \r\ninterface \r\nclass \r\nPublic inheritance\r\nProtected/private \r\ninheritance \r\nPrivate inheritance\r\nGood: Both D1 and D2 have one interface and one \r\n implementation. \r\nImplementers Users ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8ac657c1-a9e8-4055-9789-782157452900.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6f2fb742456133a2921dc5082808c6411e8ee1debb1a639b527d90165860b1e8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6793929e-7ff7-4a75-bee6-19808d94410f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 99,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n100\r\nVirtual base classes: The following diagram illustrates the difference between virtual and \r\nnon-virtual base classes. The subsequent diagram illustrates legitimate uses of virtual base \r\nclasses. \r\nBase \r\nDer1 Der2 \r\nJoin \r\nclass Base {…}; \r\nclass Der1 : public Base {…}; \r\nclass Der2 : public Base {…}; \r\nclass Join : public Der1, public Der2 {…}; \r\nBase \r\nDer1 Der2 \r\nJoin \r\nBase \r\nclass Base {…}; \r\nclass Der1 : public virtual Base {…}; \r\nclass Der2 : public virtual Base {…}; \r\nclass Join : public Der1, public Der2 {…}; \r\nNon-virtual Virtual base \r\nbases ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6793929e-7ff7-4a75-bee6-19808d94410f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=26cdf1e3adf5b456b1ad9dead8bf408a67cb2a6f8d38091a4f8a530745b82720",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a62bb2e8-5b5b-42cf-aa1f-f68f2114b920",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 100,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n101\r\nInterface \r\nDer1 Der2 \r\nJoin \r\nShared \r\nImpl \r\n(data) \r\nDer1 Der2 \r\nJoin \r\nUsers\r\nInterface 1 Interface 2\r\nUsers \r\nPublic inheritance\r\nPrivate/protected \r\ninheritance \r\nGood: Both hierarchies are acceptable. Note the \r\n Implementation class in the right hierarchy \r\n should not be directly used by clients. \r\nImplementers ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/a62bb2e8-5b5b-42cf-aa1f-f68f2114b920.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0035c077e72fe9e90bf7600cb910e2125190104fe36214766cbbaf03cd7c0c7e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 404
      },
      {
        "segments": [
          {
            "segment_id": "07926f3a-6d76-42a5-ab70-f947e049680b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n102\r\nProtected data in class interface: As previously mentioned, protected data may be used in a \r\nclass as long as that class does not participate in a client interface. The following diagram \r\nillustrates this point. \r\nInterface \r\n& data \r\nD1 D2 D3 \r\nUsers Protected data\r\nBad: Derived classes (D1, D2, or D3) may hijack\r\n the base class invariant since they have access \r\n to the base class protected data. \r\nPublic inheritance\r\nPrivate/protected \r\ninheritance \r\nShared \r\nImpl \r\nD1 D2 D3 \r\nProtected data\r\nUsers \r\nGood: The base class is an implementation class. Non-public inheritance prevents \r\n derived classes from being implicitly converted to the base class type. Hence users \r\n may only manipulate the derived classes through the derived class interfaces. \r\nPublic inheritance\r\nPrivate/protected \r\ninheritance ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/07926f3a-6d76-42a5-ab70-f947e049680b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d6264fb42cf3cd9d774dd65c1a89ac1baeb8eb6c51227b199f54e39ba087ffec",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8c7ce915-5aea-4091-b715-7e2a032b7c38",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 102,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n103\r\nPolicy-based Design \r\nAs previously mentioned, classes with additional state information may be used as bases \r\nprovided composition is performed in a disciplined manner with templates (e.g. policy-based \r\ndesign). A form of programming that is used when classes must be customizable but \r\nefficiency is paramount is called policy programming. When a class’ functionality can be \r\nseparated into a set of independent concerns and each concern can be programmed in more \r\nthan one way, policy programming is very useful. In particular, it simplifies maintenance by \r\navoiding replication of code. A classic example is a matrix math package. The concerns are \r\nas follows: \r\n• Access – how are the elements laid out in memory? Some possibilities are row \r\nmajor, column major, and upper triangular. \r\n• Allocation – from where does the memory come? Some possibilities are the system \r\nheap, a fixed area, or allocated by a user-specified allocation scheme. \r\n• Error Handling – what is done when an error occurs? Some possibilities are to throw \r\nan exception, log an error message, set an error code, or restart the process. \r\nThese concerns are independent of one another and can be coded separately. For example: \r\ntemplate< class T > \r\nclass Row_major \r\n{ \r\n public: \r\n typedef T value_type; \r\n Row_major( int32 nrows, int32 ncols, T* array ) : \r\n nrows_(nrows), ncols_(ncols), array_(array) \r\n {} \r\n ~Row_major() {} \r\n int32 size1() const { return nrows_; } \r\n int32 size2() const { return ncols_; } \r\n const T& operator() ( int32 i, int32 j ) const { return array_[i*ncols_+j]; } \r\n T& operator() ( int32 i, int32 j ) { return array_[i*ncols_+j]; } \r\n private: \r\n int32 nrows_; \r\n int32 ncols_; \r\n T* array_; \r\n};\r\nThe class Column_major would be very similar except that the parenthesis operator would \r\nreturn array_[j*nrows_+i].\r\nRather than create code for each possible combination of concerns, we create a template class \r\nthat brings together implementations for each concern. Thus, assuming that: \r\n• Access defines the parenthesis operator, \r\n• Alloc defines the template method \r\nT* allocate<T>( int32 n ) , and\r\n• Err defines the following methods ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8c7ce915-5aea-4091-b715-7e2a032b7c38.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fb9d3048829ab8b3ad4a1101d4ea671a05b959f5bf7e5c975a83ae1d44cdcd87",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 464
      },
      {
        "segments": [
          {
            "segment_id": "cccd0df7-96a8-4b07-aaac-f79e3a8e12cb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 103,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n104\r\nvoid handle_error( int32 code, int32 nr, int32 nc ) \r\nvoid handle_error( int32 code, int32 i, int32 j, int32 nr, int32 nc ) \r\nwe can compose the Matrix class as follows: \r\ntemplate< class Access, class Alloc, class Err > \r\nclass Matrix : public Access, Alloc, Err // Alloc and Err are private bases \r\n{ \r\n Matrix( int32 nrows, int32 ncols ) : \r\n Access(nrows,ncols,allocate<T>(nrows*ncols)) \r\n { \r\n if( array_==0 ) \r\n { \r\n handle_error( Err::allocation_failed, nrows, ncols ); \r\n } \r\n } \r\n Access::value_type& at( int32 i, int32 j ) \r\n { \r\n if( i<0 || i>nrows_ || j<0 || j>ncols_ ) \r\n { \r\n handle_error( Err::index_out_of_bounds, i, j, nrows_, ncols_ ); \r\n i = j = 0; \r\n } \r\n return this->operator()(i,j); \r\n } \r\n // and so on... \r\n}; \r\nThus, the Matrix class brings all the policies together into a functional class. Users may \r\ncreate \r\n• Matrix< Row_major, Heap, Exceptions > or\r\n• Matrix< Lower_triangular, Pool_allocation, Restart > \r\nas dictated by their needs. \r\nNote that the Matrix class could have been written where Access, Alloc, and Err exist as data \r\nmembers of Matrix rather than deriving from it. This technique has several drawbacks including \r\nthe necessity of creating (and maintaining) a large number of forwarding functions as well as \r\ninferior performance characteristics.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/cccd0df7-96a8-4b07-aaac-f79e3a8e12cb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a545898ea4f741ace9a6f6ef07b0bb849f35561e52f042fbb36641072b43bf76",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 204
      },
      {
        "segments": [
          {
            "segment_id": "26ad2cb9-26ba-4038-9013-3af14bfef1c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n105\r\nAV Rule 88.1\r\nStateful virtual bases should be rarely used and only after other design options have been \r\ncarefully weighed. Stateful virtual bases do introduce a concern with respect to non-exclusive \r\naccess to shared data. However, this concern is not unique to stateful virtual bases. On the \r\ncontrary, it is present in any form of aliasing. For example, two pointers that point to a single \r\ndata object suffer from the same condition, but this situation is arguably worse since there are \r\nno declarations in the system to highlight this form of aliasing (as there are for virtual bases). \r\nStateful virtual bases are theoretically important since they provide the only explicit means of \r\nsharing data within a class hierarchy without transitioning to a brittle, single-rooted hierarchy \r\nemploying stateful bases. The other alternative is simpler and uglier yet: give each class that \r\nneeds access to shared data a pointer to (1) a part of the object or to (2) a separate object - \r\nthus \"simulating\" a virtual base. In essence, a stateful virtual base should be used only to \r\navoid the implicit sharing of data via pointers or references. \r\nConsider the following hierarchy: \r\n A \r\n / \\ \r\n B C \r\n | | \r\n D E \r\n \\ / \r\n F \r\nAV Rule 88.1 would make the fact that A is a virtual base explicit not only in the declarations \r\nof B and C, but also in the declarations of D, E, and F (assuming D, E, and F all access A): \r\nstruct A {}; \r\nstruct B : virtual A {}; \r\nstruct C : virtual A {}; \r\nstruct D : B, virtual A {}; \r\nstruct E : C, virtual A {}; \r\nstruct F : D, E, virtual A {}; \r\nConsequently, the sharing of data is explicitly documented. The alternative: \r\nstruct A {}; \r\nstruct B : virtual A {}; \r\nstruct C : virtual A {}; \r\nstruct D : B {}; // Violation of 88.1 \r\nstruct E : C {}; // Violation of 88.1 \r\nstruct F : D, E {}; // Violation of 88.1 \r\ncan be obscure. That is, it is not obvious that D and E do not have exclusive access to A. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/26ad2cb9-26ba-4038-9013-3af14bfef1c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=adc4895fbe32abde6c78cdc35edee4602b4da268f56f8a12d1d366e17e88d7b2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 363
      },
      {
        "segments": [
          {
            "segment_id": "8df898d7-3ee6-4d5a-93bb-fd70f5937850",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n106\r\nAV Rule 92\r\nAV Rule 92 specifies that subtypes should conform to the Liskov Substitution Principle \r\n(LSP) which states: \r\n…for each object o1 of type S there is an object o2 of type T such that for all \r\nprograms P defined in terms of T, the behavior of P is unchanged when o1 is \r\nsubstituted for o2 then S is a subtype of T [5]. \r\nMore simply put, the LSP suggests that a pointer or reference to a derived type may be \r\nsubstituted anywhere one of its base types is used without the context being aware of the \r\nsubstitution. Following this important principle will ensure that functions/modules can be \r\nconstructed without requiring the context of a base class to be aware of all current and future \r\nderivatives of that base class. In other words, class hierarchies may be constructed so that \r\nnew extensions/specializations will not break or yield surprise results when used in existing \r\napplications. \r\nFor example, should Penguin be derived from the base class, Bird, that contains the fly()\r\noperation? The precondition (all birds can fly) for the base class, Bird, is stronger than the \r\nprecondition (I can’t fly) of the derived class, Penguin. Hence, Penguin is not a subtype of \r\nBird, and therefore should not be publicly derived from Bird. \r\nAV Rule 93\r\nExample A illustrates the class Person that is constructed with members Name, Address, and \r\nPhoneNumber. Hence, the functionality of Person is implemented in terms of the member \r\nelements (Name, Address, and PhoneNumber). \r\nExample A: \r\nclass Person \r\n{ \r\n private: \r\n string name; // Person is composed of members Name, Address, and \r\n // PhoneNumber \r\n string address; \r\n string phone_number; \r\n… \r\n}; \r\nIn general, membership should be used except where access to protected members or virtual \r\nmethods is required. In these situations, membership will not work. Instead, non-public \r\ninheritance should be used. Consider the GenericStack example provided by Meyers [6], item \r\n43. One may reuse the GenericStack implementation for stacks of any type as illustrated in \r\nExample B. Note, however, that the GenericStack implementation is “too dangerous” to be \r\nused by it self. Instead, type-safe interfaces are supplied through a template class. The \r\nGenericStack’s methods are declared protected to prevent the use of this class in isolation \r\nfrom a type-safe interface. As a result, derived classes must make use of GenericStack’s \r\nprotected members via inheritance rather than class membership. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8df898d7-3ee6-4d5a-93bb-fd70f5937850.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=086c7edce04d1d387642bc2588732b396343ce9132ac5ec84d7c5a758a5fa87b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "aa80e17b-912a-4bb8-82d2-9cb1c947e613",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n107\r\nExample B: \r\nclass Generic_stack \r\n{ \r\n protected: // Methods are protected so that Generic_stack \r\n // cannot be used by itself. \r\n Generic_stack(); \r\n ~Generic_stack(); \r\n void push (void *object); \r\n void * pop (void); \r\n bool empty () const; \r\n private: \r\n… \r\n}; \r\nA type-safe interface for GenericStack may be implemented as: \r\ntemplate<class T> \r\nclass Stack: private Generic_stack // Reuse base class implementation \r\n{ \r\n public: \r\n void push (T *object_ptr) { GenericStack::push (object_ptr); } \r\n T * pop (void) { return static_cast<T*>(Generic_stack::pop()); } \r\n bool empty () const { return Generic_stack::empty(); } \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/aa80e17b-912a-4bb8-82d2-9cb1c947e613.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5fdc31c177ae293dd99a497fc8e1eb5b886c4f143248376212c661065869c4ed",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 490
      },
      {
        "segments": [
          {
            "segment_id": "6e66aa28-83b9-49b4-8d6d-d57d2324a78f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n108\r\nAV Rule 94\r\nNonvirtual functions are statically bound. In essence, a nonvirtual function will hide its \r\ncorresponding base class version. Hence a single derived class object may behave either as a \r\nbase class object or as a derived class object depending on the way in which it was \r\naccessed—either through a base class pointer/reference or a derived class pointer/reference. \r\nTo avoid this duality in behavior, nonvirtual functions should never be redefined. \r\nExample: \r\nclass Base \r\n{ \r\n public: \r\n mf (void); \r\n}; \r\nclass Derived : public Base \r\n{ \r\n public: \r\n mf (void); \r\n}; \r\nexample_function(void) \r\n{ \r\n Derived derived; \r\n Base* base_ptr = &derived; // Points to derived \r\n Derived* derived_ptr = &derived; // Points to derived \r\n base_ptr->mf(); // Calls Base::mf() *** Different behavior for same object!! \r\n derived_ptr->mf(); // Calls Derived::mf() \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/6e66aa28-83b9-49b4-8d6d-d57d2324a78f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdc9b8d6614cd2977cf89dd7edbe8c4cd6394e968b086db3f7ae52a7376563ae",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c44f1087-766f-4ed2-bd6c-ae33d7b9f4c8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n109\r\nAV Rule 95\r\nWhile C++ dynamically binds virtual methods, the default parameters of those methods are \r\nstatically bound. Hence, the draw() method of the derived type (Circle), if referenced through \r\na base type pointer (Shape *), will be invoked with the default parameters of the base type \r\n(Shape).\r\nExample A: \r\nenum Shape_color { red, green, blue }; \r\nclass Shape \r\n{ \r\n public: \r\n virtual void draw (Shape_color color = green) const; \r\n … \r\n} \r\nclass Circle : public Shape \r\n{ \r\n public: \r\n virtual void draw (Shape_color color = red) const; \r\n … \r\n} \r\nvoid fun() \r\n{ \r\n Shape* sp; \r\n sp = new Circle; \r\n sp->draw (); // Invokes Circle::draw(green) even though the default \r\n} // parameter for Circle is red. \r\n ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/c44f1087-766f-4ed2-bd6c-ae33d7b9f4c8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a1d15318a15188f8bcbfc42188a95cd8f8fc148e3654c420e2e138040db29610",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "27ac2a85-6c49-48f4-bfff-5a2b233b663b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 109,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n110\r\nAV Rule 101 and AV Rule 102\r\nSince many template instantiations may be generated, the compiler should be configured to \r\nprovide a list of actual instantiations for review and testing purposes. The following table \r\nillustrates the output of a Stack class that was instantiated for both float32 and int32 types. \r\nNote that the method instantiations are listed so that a complete test plan may be constructed. \r\nTemplate Parameter Type Library/Module \r\nStack<T1>::Stack<float32>(int) [with T1=float32] shape_hierarchy.a(shape_main.o)\r\nStack<T1>::Stack<int32>(int) [with T1=int32] shape_hierarchy.a(shape_main.o) \r\nT1 Stack<T1>::pop() [with T1=float32] shape_hierarchy.a(shape_main.o) \r\nT1 Stack<T1>::pop() [with T1=int32] shape_hierarchy.a(shape_main.o) \r\nvoid Stack<T1>::push(T1) [with T1=float32] shape_hierarchy.a(shape_main.o) \r\nvoid Stack<T1>::push(T1) [with T1=int32] shape_hierarchy.a(shape_main.o)\r\n ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/27ac2a85-6c49-48f4-bfff-5a2b233b663b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c4e1185fc0ad0a3fefa250fa441630a9eff17a3b8282a996f29653a355dfa043",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "2385a729-7968-4679-805a-35e86d142851",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 110,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n111\r\nAV Rule 103\r\nStroustrup [4] provides a solution (for creating template parameter constraints) that requires \r\nminimal effort, requires no additional code to be generated, and causes compilers to produce \r\nacceptable error messages (including the word constraint). \r\nMoreover, Stroustrup provides the following sample constraints that check the ability of \r\ntemplate parameters to engage in derivations, assignments, comparisons and multiplications. \r\n(Note that the following elements are good candidates for a constraints library.) \r\ntemplate<class T, class B> struct Derived_from { \r\n static void constraints(T* p) { B* pb = p; } \r\n Derived_from() { void(*p)(T*) = constraints; } \r\n}; \r\ntemplate<class T1, class T2> struct Can_copy { \r\n static void constraints(T1 a, T2 b) { T2 c = a; b = a; } \r\n Can_copy() { void(*p)(T1,T2) = constraints; } \r\n}; \r\ntemplate<class T1, class T2 = T1> struct Can_compare { \r\n static void constraints(T1 a, T2 b) { a==b; a!=b; a<b; } \r\n Can_compare() { void(*p)(T1,T2) = constraints; } \r\n}; \r\ntemplate<class T1, class T2, class T3 = T1> struct Can_multiply { \r\n static void constraints(T1 a, T2 b, T3 c) { c = a*b; } \r\n Can_multiply() { void(*p)(T1,T2,T3) = constraints; } \r\n}; \r\nThus, given the Can_copy constraint above, a draw_all() function may be written that \r\nasserts, at compile time, that only containers comprised of pointers to Shape or pointers to a \r\nclasses publicly derived from Shape (or convertible to Shape) may be passed in. \r\ntemplate<class Container> \r\nvoid draw_all(Container& c) \r\n{ \r\n typedef typename Container::value_type T; \r\n Can_copy<T,Shape*>(); // accept containers of only Shape*’s \r\n for_each(c.begin(),c.end(),mem_fun(&Shape::draw)); \r\n} \r\nAdditional constraints may be easily created. See [4] for further information concerning \r\nconstraint creation and use. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/2385a729-7968-4679-805a-35e86d142851.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2dcd4498412ce5e52b67d468b047e16e769bec8d0074cbbc2160c4e4abc1e61c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "dc22efde-a7ff-43f5-97ea-6b0c3d30aeea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 111,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n112\r\nAV Rule 108\r\nThe following example illustrates a case where function overloading or parameter defaults \r\nmay be used instead of an unspecified number of arguments. \r\nExample A: Consider a function to compute the length of two, three, or four dimensional \r\nvectors. A variable argument list could be used, but introduces unnecessary complexities. \r\nAlternatively, function overloading or parameter defaulting provide much better solutions. \r\n// Unspecified number of arguments \r\nfloat32 vector_length (float32 x, float32 y, …); // Error prone \r\n// Function overloading \r\nfloat32 vector_length (float32 x, float32 y); \r\nfloat32 vector_length (float32 x, float32 y, float32 z); \r\nfloat32 vector_length (float32 x, float32 y, float32, z, float32 w); \r\n// Default parameters \r\nfloat32 vector_length (float32 x, float32 y, float32 z=0, float32 w=0); \r\nAV Rule 109\r\nIn the following example, Square declares two functions area() and morph(). Since the \r\ndesigner wants to inline the relatively simple method area(), it is defined within the class \r\nspecification. In contrast, there is no intent to inline the complex method morph(). Hence \r\nonly the method declaration is included. \r\nclass Square : public Shape \r\n{ \r\n public: \r\n float32 area() \r\n { \r\n return length*width; \r\n } // area() will be inlined since it is defined \r\n // in the class specification. \r\n morph (Shape &s); // morph() is not intended to be inlined so its \r\n}; // implementation is contained in a separate file. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/dc22efde-a7ff-43f5-97ea-6b0c3d30aeea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ea6c3bc976ffc52cc8700835f01b3231b48d3e9be1b2a515e5451719033082d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 493
      },
      {
        "segments": [
          {
            "segment_id": "d88e481d-8b03-4a8a-8e18-162b63772348",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n113\r\nAV Rule 112\r\nThe following examples illustrate several ways in which function return values can obscure \r\nresource ownership and hence risk resource leakage. Note in the following examples, new\r\nneed not allocate memory from the heap, but could be overloaded on the class in question. \r\nExample A: Returning a dereferenced pointer initialized by new is error prone since the \r\ncaller must remember to delete the object. This becomes more difficult if that object happens \r\nto be a temporary object. \r\nX& f (float32 a) \r\n{ \r\n return *new x(a); // Error prone. Caller must remember to perform \r\n} // the delete. \r\nX& ref = f(1); // The caller of f() must be responsible for deleting \r\n… // the memory. \r\ndelete &ref // delete must be called for every invocation of f(). \r\n… \r\nX& x = f(1)*f(2)*f(3)*f(4); // Memory leak: delete not called for temporaries. \r\nExample B: Returning a pointer to a local object is problematic since the object ceases to \r\nexist after return. AV Rule 111 explicitly prohibited this practice. \r\nX* f (float32 a) // Error: the caller most likely believes he is \r\n{ // responsible for deleting the object. However, the object \r\n X b(a); // ceases to exist when the function returns. \r\n return &b \r\n} \r\nExample C: A function can return a pointer to an object, but the recipient must remember to \r\nperform the delete. \r\nX *f(float32 a) \r\n{ \r\n return new X(a); // Beware of leak: recipient must remember to perform the delete. \r\n} \r\nExample D: Returning an object by value is a simple method that does not obscure \r\nownership issues. \r\nX f(float 32 a) // Simple and clear. \r\n{ \r\n X b(a); \r\n return b; \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d88e481d-8b03-4a8a-8e18-162b63772348.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=17bad1d7b6b32879239a28be47eb9c97e3fe0eac2a8b7e6c4c45e832fee9bea2",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d2dbd5f4-7360-4ca8-8b1a-293dce109e85",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n114\r\nAV Rule 120\r\nOverloading functions can be a powerful tool for creating families of related operations that \r\ndiffer only with respect to argument type. If not used consistently, however, overloading can \r\nlead to considerable confusion. \r\nExample A: Proper usage of function overloading is illustrated below. All overloads of \r\ncontains() share the same name as well as perform the same conceptual task. \r\n class String \r\n { \r\n public: // Used like this: \r\n // ... // String x = \"abc123\"; \r\n int32 contains ( const char c ); // int32 i = x.contains( 'b' ); \r\n int32 contains ( const char* cs ); // int32 j = x.contains( \"bc1\" ); \r\n int32 contains ( const String& s ); // int32 k = x.contains( x ); \r\n // ... \r\n }; \r\nExample B: Improper use of operator overloading is illustrated below. For two-dimensional \r\nvectors, operator*() means dot product while for three dimensional vectors, operator*()\r\nmeans cross product. \r\nVector2d { \r\n public: \r\n float32 operator*(const Vector2d & v); // compute dot product \r\n … \r\n}; \r\nVector3d { \r\n public: \r\n Vector3d operator*(const Vector3d & v) // compute cross product \r\n … \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d2dbd5f4-7360-4ca8-8b1a-293dce109e85.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=30e132172620a9d8e5e1c0c4a48a3305f5d6ba5a7d8215065a7f8f914d2a15da",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 467
      },
      {
        "segments": [
          {
            "segment_id": "2680502f-95b4-4737-a534-2df064171887",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 114,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n115\r\nAV Rule 121\r\nThe Green Hills compiler employs two inlining approaches, each using a different inlining \r\nstrategy, and each coming at a different stage. The first is a front-end inliner. It will only \r\nconsider inline functions (functions declared with the keyword inline or member functions \r\nwhose bodies are defined inside class definitions). \r\nThe front-end inliner will inline only those functions which can be converted to expressions. \r\nTherefore, functions which simply return an expression, straight code functions (which can \r\nbe converted to comma expressions), or functions with if statements that can be converted to \r\n“?:” expressions will be considered candidates for inlining. The front-end inliner is not \r\ncapable of inlining more complex statements (e.g. functions containing loops). \r\nThe second inliner is the independent code inliner which is capable of inlining most any \r\nfunction (except recursive functions). Inlining complex functions may lead to significant \r\ncode bloat as well as to complicate debugging efforts. As a result, only the front-end inliner \r\nshould be used in C/C++ programs. \r\nAV Rule 122\r\nThe following example illustrates a class that inlines a trivial accessor and a trivial mutator. \r\nclass Example_class \r\n{ \r\n public: \r\n int32 get_limit (void) // Sample accessor to be inlined \r\n { \r\n return limit; \r\n } \r\n void set_limit (int32 limit_parm) // Sample mutator to be inlined \r\n { \r\n limit = limit_parm; \r\n } \r\n private: \r\n int32 limit; \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/2680502f-95b4-4737-a534-2df064171887.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ac2a19181b56293b091d70de31713c01c2a22acba463ea7c3701d5730557afec",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "947db123-580e-40f0-92fc-a7b0bc4c2b0d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 115,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n116\r\nAV Rule 124\r\nSimple forwarding functions should be inlined as illustrated below. \r\nExample A: \r\ninline draw() // Example of a forwarding function that should be inlined \r\n{ \r\n draw_foreground (); \r\n} \r\nAV Rule 125\r\nThe construction of large or complex temporary objects can exact a significant performance \r\npenalty. Consequently, the following observations are provided as guidance in limiting the \r\nnumber unnecessary temporaries. \r\n• Problem 1: Temporary objects are created (and destroyed) to make function calls \r\nsucceed via implicit type conversions. The conversions will occur either when an \r\nargument is passed by value or is passed as a reference to const objects. \r\n• Solution 1: Overload the function in question so that the implicit conversion will not \r\nbe necessary. \r\n• Problem 2: Temporary objects are created (and destroyed) when a function returns \r\nan object. \r\n• Solution 2a: Return a reference when possible. If it is not possible to return a \r\nreference (as in the case of overloading operator*()), try to take advantage of “return \r\nvalue optimization” (eliminating a local temporary by utilizing the object at the \r\nfunctions return site). For example: \r\nc = a * b; \r\n… \r\ninline const Rational operator*(const Rational& lhs, \r\n const Rational& rhs) \r\n{ \r\n return Rational (lhs.get_numerator() * rhs.get_numerator(), \r\n lhs.get_denominator() * rhs.get_denominator()); \r\n} \r\nEliminates both the temporary created inside the operation*() and the temporary \r\nreturned by operator*(). The new object is simply constructed inside the space \r\nallocated for “c”. \r\n• Solution 2b: Change the design. For example, use operator*=() instead of \r\noperator*(), since operator*= () does not require the generation of a temporary as \r\ndoes operator*().",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/947db123-580e-40f0-92fc-a7b0bc4c2b0d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b7e059df8c7593f29d838d246fb813f824ae96ef3aa3c7f460e99d3ef959fa4a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 493
      },
      {
        "segments": [
          {
            "segment_id": "7a1b3f75-72f9-469b-9b48-efcd408aa576",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n117\r\nAV Rule 126\r\nA C++ style comment begins with “//” and terminates with a new-line. However, the \r\nplacement of vertical-tab or form-feed characters within a comment may produce unexpected \r\nresults. That is, if a form-feed or a vertical-tab character occurs in a C++ style comment, only \r\nwhite-space characters may appear between it and the new-line that terminates the comment. \r\nAn implementation is not required to diagnose a violation of this rule. [10] \r\nAV Rule 136\r\nThe following code illustrates some problems encountered when a variable is not declared at \r\nthe smallest feasible scope. \r\nvoid fun_1() \r\n{ \r\n int32 i; // Bad: i is prematurely declared (the intent is to use i in the \r\n // for loop only) \r\n … // Bad: i has a meaningless value in the region of the code \r\n for (i=0 ; i<max ; ++i) \r\n { \r\n … \r\n } \r\n …. // Bad: i should not be used here, but could be used anyway \r\n \r\n for(int32 j=0 ; j<max ; ++j) // Good: j is not declared or initialized until needed \r\n { // Good: j is only known within the for loop’s scope \r\n … \r\n } \r\n} \r\nAV Rule 137\r\nMISRA Reason: Declarations at file scope are external by default. Therefore if two files \r\nboth declare an identifier with the same name at file scope, the linker will either give an \r\nerror, or they will be the same variable, which may not be what the programmer intended. \r\nThis is also true if one of the variables is in a library somewhere. Use of the static storage\u0002class specifier will ensure that identifiers are only visible to the file in which they are \r\ndeclared. \r\nIf a variable is only to be used by functions within the same file then use static. Similarly if a \r\nfunction is only called from elsewhere within the same file, use static. \r\nTypically, functions whose declarations appear in a header (.h) file are intended to be called \r\nfrom other files and should therefore never be specified with the static keyword. Conversely, \r\nfunctions whose declarations appear in an implementation body (.cpp) file should never be \r\ncalled from other files, and hence should always be declared with the static keyword. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7a1b3f75-72f9-469b-9b48-efcd408aa576.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=adbf5304c59525efa4f81831f6a7488c2b0a39651890c4e1e36cfeb29b07f402",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 366
      },
      {
        "segments": [
          {
            "segment_id": "acf35dfa-11a9-4bbd-b0ad-c672b1497a85",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n118\r\nAV Rule 138\r\nThe C++ Standard [10] defines linkage in the following way: \r\n• When a name has external linkage, the entity it denotes can be referred to by names \r\nfrom scopes of other translation units or from other scopes of the same translation \r\nunit. \r\n• When a name has internal linkage, the entity it denotes can be referred to by names \r\nfrom other scopes in the same translation unit. \r\nHence, having names with both internal and external linkage can be confusing since the \r\nobjects to which they actually refer may not be obvious. Consider the following example \r\nwhere the i declared on line 1 has internal linkage while the i on line 2 has external linkage. \r\nWhich entity is referenced by the i on line 3? \r\n{ \r\n static int32 i=1; // line 1 \r\n { // Bad: the i with external linkage hides the i \r\n // with internal linkage. \r\n extern int32 i; // line 2 \r\n … \r\n a[i] = 10; // line 3: Confusing: which i? \r\n } \r\n} \r\nAV Rule 139\r\nAdherence to this rule will normally mean declaring external objects in header files which \r\nwill then be included in all those files that use those objects (including the files which define \r\nthe objects). \r\nExample A: Two files declare the same variable. This style could lead to errors since a\r\ncould be declared in many different files. A change in one of those files \r\nwould affect all others and would be difficult to pinpoint. \r\n// In File_1.cpp \r\nint32 a = 3; \r\n// In File_2.cpp \r\nextern int32 a; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/acf35dfa-11a9-4bbd-b0ad-c672b1497a85.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bff9709b8d0699b0d0cee8345e8e1d5752e70813354a7cea99ee67526e4ba3c0",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b840a5f6-27f8-49d2-af10-1bf63e2a6bf7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n119\r\nExample B: Here, a is declared in a header file. All other files that need access to a\r\nsimply include the header file. In this way, consistency is assured. \r\n// In File_1.h \r\nextern int32 a; \r\n// In File_1.cpp \r\n#include <File_1.h> \r\nint32 a = 3; \r\n// In File_2.cpp \r\n #include <File_1.h> \r\nAV Rule 141\r\nExample A: Declaring an enumeration in the definition of its type can lead to readability \r\nproblems and unnamed data types as illustrated below. \r\nenum // Don’t do this: Creates an unnamed data type. \r\n{ \r\n up, \r\n down \r\n} direction; \r\nenum i { in, out } i; // Don’t do this: Difficult to read. \r\nExample B: Separation of the declaration and definition are preferred as illustrated below. \r\nNote that this requires the data type to be named which provides a mechanism to create other \r\nvariables of the same type and the ability to type cast. \r\nenum XYZ_direction \r\n{ \r\n up, \r\n down \r\n}; \r\nXYZ_direction direction; \r\nExample C: Note that a legitimate use of an unnamed enumeration is to define symbolic \r\nconstants within a class declaration. \r\nclass X \r\n{ \r\n enum \r\n { \r\n max_length = 100, \r\n max_time = 73 \r\n }; // Defines symbolic constants for the class \r\n … \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/b840a5f6-27f8-49d2-af10-1bf63e2a6bf7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5539b57a10a7ccc2cf7b45b77fcb4f8ce38c9cb1bece31c5b36c251e12853cb0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 468
      },
      {
        "segments": [
          {
            "segment_id": "7f93580f-ef21-42fe-8bce-16b754e029e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n120\r\nExample D: Note that the following declarations are not prohibited under this rule. \r\nint32 i=0; \r\npair<float32,int32> p; \r\nAV Rule 142\r\nMISRA Rule 30 requires all automatic variables to have an assigned value. Compilers will, \r\nby default, initialize external and static variables to the value zero. However, it is considered \r\ngood practice to initialize all variables, not just automatic/stack variables, to an initial value \r\nfor purposes of 1) clarity and 2) bringing focused attention to the initialization of each \r\nvariable. Therefore, this rule requires ALL variables to be initialized. Exception may be \r\ngranted for volatile variables. \r\nAV Rule 143\r\nIntroducing variables before they can be assigned meaningful values causes a number of \r\nproblems as illustrated in the following examples. \r\nExample A: The following code illustrates some problems encountered when variables are \r\nintroduced before they can be properly initialized. \r\nvoid fun_1() // Poor implementation \r\n{ \r\n int32 i; // Bad: i is prematurely declared (the intent is to use i in the for \r\n // loop only) \r\n int32 max=0; // Bad: max initialized with a dummy value. \r\n … // Bad: i and max have meaningless values in this \r\n // region of the code. \r\n max = f(x); \r\n for (i=0 ; i<max ; ++i) \r\n { \r\n … \r\n } \r\n …. // Bad: i should not be used here, but could be used anyway \r\n} \r\nvoid fun_1() // Good implementation \r\n{ \r\n …. \r\n int32 max = f(x); // Good: max not introduced until meaningful value is \r\n // available \r\n for (int32 i=0 ; i<max ; ++i) // Good: i is not declared or initialized until needed \r\n { // Good: i is only known within the for loop’s scope \r\n … \r\n } \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/7f93580f-ef21-42fe-8bce-16b754e029e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aa49825726e0a84b7181ada218ac893d7cb68668326c75fb93341262e9cdfd4d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "abfb59bd-a2e4-4b5f-9f41-c501d6545dd0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n121\r\nExample B: An instance of class X is constructed prior to the point at which it can be fully \r\ninitialized. To complete the initialization, a separate init() method must be called when \r\nsufficient information becomes available. However, since the object may only be in a quasi\u0002valid state prior to the invocation of init(), all method invocations between object \r\nconstruction and init() are suspect. See also AV Rule 73 concerning unnecessary default \r\nconstructors. \r\nclass X { \r\n public: \r\n X::X() {} // Bad: default constructor builds partially initialized object. \r\n init (int32 max_, int32 min_) \r\n { \r\n max = _max ; \r\n min = _min; \r\n } \r\n int32 range() \r\n { \r\n return max-min ; \r\n } \r\n … \r\n private: \r\n int32 max; \r\n int32 min; \r\n}; \r\nvoid foo() \r\n{ \r\n X x; // Bad: x constructed but without data \r\n … \r\n x.range(); // Bad: undefined result. \r\n …. \r\n x.init(lbound, ubound); // Bad: x initialized later than necessary \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/abfb59bd-a2e4-4b5f-9f41-c501d6545dd0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fb5af40dcacf63654fd0d9a4f162bf5580c0035e6d71667e7827a80dffefc58d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 431
      },
      {
        "segments": [
          {
            "segment_id": "46ccd7b4-ed85-4a92-bbd5-39290fd99af6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n122\r\nAV Rule 145\r\nIf an enumerator list is given with no explicit initialization of members, then C++ allocates a \r\nsequence of integers starting at 0 for the first element and increasing by 1 for each \r\nsubsequent element. For most purposes this will be adequate. \r\nAn explicit initialization of the first element, as permitted by the above rule, forces the \r\nallocation of integers to start at the given value. When adopting this approach it is essential to \r\nensure that the initialization value used is small enough that no subsequent value in the list \r\nwill exceed the int storage used by enumeration constants. \r\nExplicit initialization of all items in the list, which is also permissible, prevents the mixing of \r\nautomatic and manual allocation, which is error prone. However it is then the responsibility \r\nof the programmer to ensure that all values are in the required range, and that values are not \r\nunintentionally duplicated. \r\nExample A: \r\n//Legal enumerated list using compiler-assigned enum values \r\n//off=0, green=1, yellow=2, red=3 \r\nenum Signal_light_states_type \r\n{ \r\n off, \r\n green, \r\n yellow, \r\n red \r\n}; \r\nExample 2: \r\n// Legal enumeration, assigning a value to the first item in the list. \r\nenum Channel_assigned_type \r\n{ \r\n channel_unassigned = -1, \r\n channel_a, \r\n channel_b, \r\n channel_c \r\n}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/46ccd7b4-ed85-4a92-bbd5-39290fd99af6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1c0d752eb8cd356a611c01f0d45d0172eb40f536bc67e0e0b754a93c5512925b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "90c59950-4854-4452-ad18-f7d74f725ce2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 122,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n123\r\nExample 3: \r\n// Control mask enumerated list. All items explicitly \r\n// initialized. \r\nenum FSM_a_to_d_control_enum_type \r\n{ \r\n start_conversion = 0x01, \r\n stop_conversion = 0x02, \r\n start_list = 0x04, \r\n end_list = 0x08, \r\n reserved_3_bit = 0x70, \r\n reset_device = 0x80 \r\n}; \r\nExample 4: \r\n// Legal: standard convention used for enumerations that are intended to index arrays. \r\nenum Color { \r\n red, \r\n orange, \r\n yellow, \r\n green, \r\n blue, \r\n indigo, \r\n violet, \r\n Color_begin = red, \r\n Color_end = violet, \r\n Color_NOE // Number of elements in array \r\n}; \r\nAV Rule 147\r\nManipulating the underlying bit representation of a floating point number is error-prone, as \r\nrepresentations may vary from compiler to compiler, and platform to platform. There are, \r\nhowever, specific built-in operators and functions that may be used to extract the mantissa \r\nand exponent of floating point values. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/90c59950-4854-4452-ad18-f7d74f725ce2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=87985fb84821cc8717bad329365c4d39d647f3e2f4d229db0661dffdd97752d5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 337
      },
      {
        "segments": [
          {
            "segment_id": "b5432ee6-728e-4e62-ab2d-fedb6c52b4a1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 123,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n124\r\nAV Rule 151.1\r\nSince string literals are constant, they should only be assigned to constant pointers as \r\nindicated below: \r\n char* c1 = “Hello”; // Bad: assigned to non-const \r\n char c2[] = “Hello”; // Bad: assigned to non-const \r\n char c3[6] = “Hello”; // Bad: assigned to non-const \r\n c1[3] = ‘a’; // Undefined (but compiles) \r\n const char* c1 = “Hello”; // Good \r\n const char c2[] = “Hello”; // Good \r\n const char c3[6] = “Hello”; // Good \r\n c1[3] = ‘a’; // Compile error \r\nAV Rule 157\r\nCare should be taken when short-circuit operators are utilized. For example, if the logical \r\nexpression in the following code evaluates to false, the variable x will not be incremented. \r\nThis could be problematic since subsequent statements may assume that x has been \r\nincremented.\r\nif ( logical_expression && ++x) // Bad: right-hand side not evaluated if the logical \r\n // expression is false. \r\n… \r\nf(x); // Error: Assumes x is always incremented. \r\n… \r\nAV Rule 158\r\nThe intent of this rule is to require parenthesis where clarity will be enhanced while stopping \r\nshort of over-parenthesizing expressions. In the following examples, parenthesizing operands \r\n(that contain binary operators) of the logical operators && or || enhances readability. \r\nExamples: \r\nvalid (p) && add(p) // parenthesis not required \r\nx.flag && y.flag // parenthesis not required \r\na[i] || b[j] // parenthesis not required \r\n(x < max ) && (x > min) // parenthesis required \r\n(a || b) && (c || d) // parenthesis required ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/b5432ee6-728e-4e62-ab2d-fedb6c52b4a1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=332cd322c81cfbdd0d6554affb866844cb5d82af045ecb29b37a1b8404c3c02f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 249
      },
      {
        "segments": [
          {
            "segment_id": "0b8ffcb1-aa5d-416f-8c40-ca3da8c68e66",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 124,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n125\r\nAV Rule 160\r\nThe intent of this rule is to prohibit assignments in contexts that are obscure or otherwise \r\neasily misunderstood. The following example illustrates some of the problems this rule \r\naddresses. \r\nNote that a for-init-statement (that is not a declaration) is an expression statement. \r\nfor ( for-init-statement condition-opt ; expression-opt ) statement\r\nfor-init-statement: \r\n expression-statement \r\n simple-declaration \r\nExamples: \r\nx = y; // Good: the intent to assign y to x and then check if x is \r\nif (x != 0) // not zero is explicitly stated. \r\n{ \r\n foo (); \r\n} \r\nif ( ( x = y) != 0 ) // Bad: not as readable as it could be. \r\n{ // Assignment should be performed prior to the “if”statement \r\n foo (); \r\n} \r\nif (x = y) // Bad: intent is very obscure: a code reviewer could easily \r\n{ // think that “==” was intended instead of “=”. \r\n foo (); \r\n} \r\nfor (i=0 ; i<max ; ++i) // Good: assignment in expression statement of “for” statement \r\n{ \r\n … \r\n} \r\nAV Rule 168\r\nMISRA Rule 42 only allows use of the comma operator in the control expression of a for\r\nloop. The comma operator can be used to create confusing expressions. It can be used to \r\nexchange the values of variable array elements where the exchange appears to be a single \r\noperation. This simplicity of operation makes the code less intuitive and less readable. The \r\ncomma operator may also be easily confused with a semicolon used in the for loop syntax. \r\nTherefore, all uses of the comma operator will not be allowed. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/0b8ffcb1-aa5d-416f-8c40-ca3da8c68e66.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f2b496933b0e5929e11784c5c9727c8b9a976fd9d7f98a7fd37ff8892aabe385",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 267
      },
      {
        "segments": [
          {
            "segment_id": "91a343eb-907b-49af-9df2-8a6880948713",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 125,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n126\r\nAV Rule 177\r\nUser-defined conversion functions come in two forms: single-argument constructors and type \r\nconversion operators. Implicit type conversions may be eliminated as follows: \r\n• Single-argument constructors: use the “explicit” keyword on single-argument \r\nconstructors so that the compiler will not supply implicit conversions through the \r\nconstructor. \r\n• Type conversion operators: don’t define conversion operators. If type conversion \r\nfunctionality is required, then define a member function to fulfill the same role. \r\nUnlike the type conversion operator, however, a member function must be called \r\nexplicitly, thus eliminating any “surprises” that could arise if the type conversion \r\noperator were used. \r\nExamples 1 and 2 demonstrate these principles. \r\nExample 1a: The Vector_int class below has a single argument constructor used to build \r\nvectors. However, this constructor may be called in ways a user may not expect. The solution \r\nis to use the explicit keyword in the constructor declaration which precludes the constructor \r\nfrom being called implicitly. \r\nbool operator == (const Vector_int &lhs, const Vector_int &rhs) \r\n{ \r\n // compare two Vector_ints \r\n} \r\nclass Vector_int { \r\n public: \r\n Vector_int (int32 n); \r\n … \r\n}; \r\nVector_int v1(10), \r\n v2(10); // create two vectors of size 10; \r\n… \r\nfor (int32 i=0 ; i<10 ; ++i) \r\n{ \r\n if (v1 == v2[i]) // The programmer meant to compare the elements of two Vectors. \r\n { // However, the subscript of the first was inadvertently left off. \r\n … // Thus, the compiler is asked to compare a Vector_int with an \r\n } // integer. The single argument constructor is called to convert the \r\n} // integer to a new Vector_int so that the comparison can take place. \r\n // This is almost certainly not what is expected. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/91a343eb-907b-49af-9df2-8a6880948713.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19a9056e171fcf09983110f32c60ae7a3221de3e67b8ddc591e6007b1bccf44e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 279
      },
      {
        "segments": [
          {
            "segment_id": "5097d391-30db-4171-a227-9caf85026514",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 126,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n127\r\nExample 1b: The constructor is declared explicit so that the error is caught at compile time. \r\nclass Vector_int \r\n{ \r\n public: \r\n explicit Vector_int (int32 n) ; \r\n … \r\n}; \r\nVector_int v1(10), v2(10); // create two vectors of size 10; \r\n… \r\nfor (int32 i=0 ; i<10 ; ++i) \r\n{ \r\n if (v1 == v2[i]) // The programmer meant to compare the elements of two Vectors. \r\n { // However, the subscript of the first was inadvertently left off. \r\n … // Thus, the compiler is asked to compare a Vector_int with an \r\n } // integer. The explicit keyword prevents the constructor from \r\n} // being called implicitly, so the compiler generates an error. \r\nExample 2a: Class Complex defines a complex number, but the output operator has not \r\nbeen defined for the class. Thus, when the user attempts to print out a \r\ncomplex number, an error is not generated. Instead, the number is silently\r\nconverted to a real number by the conversion operator. This yields a \r\npotentially surprising result to the client. \r\nclass Complex \r\n{ \r\n public: \r\n Complex (double r, double i = 1) : real(r), imaginary(i) {} // Constructor \r\n operator double() const; // Conversion operator \r\n … // converts Complex to double \r\n private: \r\n double real; \r\n double imaginary; \r\n}; \r\nComplex r(1,2); \r\ncout << r << endl; // User might expect compile error, but instead \r\n // r is automatically converted to decimal form \r\n // potentially losing information. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/5097d391-30db-4171-a227-9caf85026514.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=797b3851dcd5f3f206ba43df9d77ec92971e19daacb2e2e878117187d4380d7f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "00b2c8ed-d22f-469e-9487-b4a801990ee7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 127,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n128\r\nExample 2b: Instead of the conversion operator, class Complex now has a member function \r\nthat performs the same role. Hence, the same functionality is maintained but without any \r\npotential surprises. \r\nclass Complex \r\n{ \r\n public: \r\n Complex (double r, double i = 1) : real(r), imaginary(i) {} // Constructor \r\n double as_double() const; // Conversion operator \r\n … // converts Complex to double \r\n private: \r\n double real; \r\n double imaginary; \r\n}; \r\nComplex r(1,2); \r\ncout << r << endl; // Compile error generated. \r\ncout << r.asDouble() << endl; // Called explicitly rather than \r\n // implicitly. \r\nAV Rule 180\r\nThe following examples illustrate implicit conversions that result in the loss of information: \r\nint32 i =1024; \r\nchar c = i; // Bad: (integer-to-char) implicit loss of information. \r\nfloat32 f = 7.3; \r\nint32 j= f; // Bad: (float-to-int) implicit loss of information. \r\nint32 k = 1234567890; \r\nfloat32 g = k; // Bad: (int-to-float) implicit loss of information \r\n // (g will be 1234567936) \r\nNote that an explicit cast to a narrower type (where the loss of information could occur) may \r\nbe used only where specifically required algorithmically. The explicit cast draws attention to \r\nthe fact that information loss is possible and that appropriate mitigations must be in place. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/00b2c8ed-d22f-469e-9487-b4a801990ee7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fd71424723e7b5bb297019ddb0879706567971c50143471d519857ca9d2ef476",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 442
      },
      {
        "segments": [
          {
            "segment_id": "1f5d6110-9af2-4fe1-a332-6ac7572da427",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 128,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n129\r\n \r\nAV Rule 185\r\nTraditional C-style casts raise several concerns. First, they enable most any type to be \r\nconverted to most any other type without any indication of the reason for the conversion \r\nNext, the C-style cast syntax: \r\n(type) expression // convert expression to be of type type. \r\nis difficult to identify for both reviewers and tools. Consequently, both the location of \r\nconversion expressions as well as the subsequent analysis of the conversion rationale proves \r\ndifficult for C-style casts. \r\nThus, C++ introduces several new-style casts (const_cast, dynamic_cast4, reinterpret_cast, \r\nand static_cast) that address these problems. The new-style casts have the following form: \r\nconst_cast<type> (expression) // convert expression to be of type type. \r\n reinterpret_cast<type> (expression) \r\n static_cast<type> (expression) \r\nNot only are these casts easy to identify, but they also communicate more precisely the \r\ndeveloper’s intent for applying a cast. \r\nSee also rule AV Rule 178 concerning conversions between derived classes and base classes. \r\nAV Rule 187\r\nISO/IEC 14882 defines a side effect as a change in the state of the execution environment. \r\nMore precisely, \r\nAccessing an object designated by a volatile lvalue, modifying an object, calling a library \r\nI/O function, or calling a function that does any of those operations are all side effects, \r\nwhich are changes in the state of the execution environment. \r\nExample: Potential side effect \r\nif (flag) // Has side effect only if flag is true. \r\n { \r\n foo(); \r\n } \r\nExample: The following expression has no side effects \r\n• 3 + 4; // Bad: statement has zero side effects \r\nExample: The following expressions have side effects \r\n• x = 3 + 4; // Statement has one side effect: x is set to 7. \r\n• y = x++; // Statement two side effects: y is set to x and x is incremented.\r\n4\r\n Note that dynamic casts are not allowed at this point due to lack of tool support, but could be considered at some \r\npoint in the future after appropriate investigation has been performed for SEAL1/2 software. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/1f5d6110-9af2-4fe1-a332-6ac7572da427.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a4990f4ba40c5dcba718bd9aabbfaf282856e9ef47d7b6e555bc90b63f3e06a6",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8de72e74-868a-437a-9d74-1f90472706cb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 129,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n130\r\nAV Rule 192\r\nProviding a final else clause (or comment indicating why a final else clause is unnecessary) \r\nensures all cases are handled in an else if series as illustrated by the following examples. \r\nExample A: Final else clause not needed since there is no else if. \r\nif (a < b) \r\n{ \r\n foo(); \r\n} \r\nExample B: Final else clause needed in case none of the prior conditions are satisfied. \r\nif (a < b) \r\n{ \r\n … \r\n} \r\nelse if (b < c) \r\n{ \r\n … \r\n} \r\nelse if (c < d) \r\n{ \r\n} \r\nelse // Final else clause needed \r\n{ \r\n handle_error(); \r\n} \r\nExample C: Final else clause not needed, since all possible conditions are handled. \r\nTherefore a comment is included to clarify this condition. \r\nif (status == error1) \r\n{ \r\n handle_error1(); \r\n} \r\nelse if (status == error2) \r\n{ \r\n handle_error2() \r\n} \r\nelse if (status == error3) \r\n{ \r\n handle_error3() \r\n} // No final else needed: all possible errors are accounted for. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/8de72e74-868a-437a-9d74-1f90472706cb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9bcc71add01c3e93f81c04262e75730d68ff91cf84901470f2cb1ee6ca6b1405",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 499
      },
      {
        "segments": [
          {
            "segment_id": "f7f6d108-9482-4e46-830a-966883ffeb19",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 130,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n131\r\nAV Rule 193\r\nTerminating a non-empty case clause in a switch statement with a break statement eliminates \r\npotentially confusing behavior by prohibiting control from falling through to subsequent \r\nstatements. In the example below, primary and secondary colors are handled similarly so \r\nbreak statements are unneeded within each group. However, every non-empty case clause \r\nmust be terminated with a break statement for this segment of code to work as intended. \r\nNote: Omitting the final default clause allows the compiler to provide a warning if all \r\nenumeration values are not tested in the switch statement. \r\nswitch (value) \r\n{ \r\n case red : // empty since primary_color() should be called \r\n case green : // empty since primary_color() should be called \r\n case blue : primary_color (value); \r\n break; // Must break to end primary color handling \r\n case cyan : \r\n case magenta : \r\n case yellow : secondary_color (value); \r\n break; // Must break to end secondary color handling \r\n case black : black (value); \r\n break; \r\n case white : white (value); \r\n break; \r\n} ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/f7f6d108-9482-4e46-830a-966883ffeb19.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d74a5a7b754309b5d623104fc9a34ce5e063044bbd0896bc4629b8997fdee201",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "01e28606-e595-438c-8a1a-73e612bcdeeb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 131,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n132\r\nAV Rule 204\r\nAV Rule 204 attempts to prohibit side-effects in expressions that would be unclear, \r\nmisleading, obscure, or would otherwise result in unspecified or undefined behavior. \r\nConsequently, an operation with side-effects will only be used in the following contexts: \r\nNote: It is permissible for a side-effect to occur in conjunction with a constant expression. \r\nHowever, care should be taken so that additional side-effects are not “hidden” within \r\nthe expression. \r\nNote: Functions f(), g(), and h() have side-effects. \r\n1. by itself \r\n++i; // Good \r\nfor (int32 i=0 ; i<max ; ++i) // Good: includes the expression portion of a \r\n // for statement \r\ni++ - ++j; // Bad: operation with side-effect doesn’t occur by itself. \r\n2. the right-hand side of an assignment \r\ny = f(x); // Good \r\ny = ++x; // Good: logically the same as y=f(x) \r\ny = (-b + sqrt(b*b -4*a*c))/(2*a); // Good: sqrt() does not have side-effect \r\ny = f(x) + 1; // Good: side-effect may occur with a constant \r\ny = g(x) + h(z); // Bad: operation with side-effect doesn’t occur by itself \r\n // on rhs of assignment \r\nk = i++ - ++j; // Bad: same as above \r\ny = f(x) + z; // Bad: same as above \r\n3. a condition \r\nif (x.f(y)) // Good \r\nif (int x = f(y)) // Good: this form is often employed with dynamic casts \r\n // if (D* pd = dynamic_cast<D*> (pb)) {…} \r\nif (++p == NULL) /// Good: side-effect may occur with a constant \r\nif (i++ - --j) // Bad: operation with side-effect doesn’t occur by itself \r\n // in a condition \r\n4. the only argument expression with a side-effect in a function call \r\nf(g(z)); // Good \r\nf(g(z),h(w)); // Bad: two argument expressions with side-effects \r\nf(++i,++j); // Bad: same as above \r\nf(g(z), 3); // Good: side-effect may occur with a constant ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/01e28606-e595-438c-8a1a-73e612bcdeeb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a06c83448d22a10b8f4dde862ffae7b8b2478cbf4d97e8a8d1f1a92415887f99",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 480
      },
      {
        "segments": [
          {
            "segment_id": "48243bbe-65aa-444a-b798-4467cfb1c4c8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 132,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n133\r\n5. condition of a loop \r\nwhile (f(x)) // Good \r\nwhile(--x) // Good \r\nwhile((c=*p++) != -1) // Bad: operation with side-effect doesn’t occur by itself \r\n // in a loop condition \r\n6. switch condition \r\nswitch (f(x)) // Good \r\nswitch (c = *p++) // Bad: operation with side-effect doesn’t occur by itself \r\n // in a switch condition \r\n7. single part of a chained operation \r\nx.f().g().h(); // Good \r\na + b * c; // Good: (operator+() and operator*() are overloaded) \r\ncout << x << y; // Good ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/48243bbe-65aa-444a-b798-4467cfb1c4c8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b8b6b3e0031d5ade1fae1d5e421766de72b580a34f6832641a293e483a0a88e7",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a2dc7696-08a6-4646-82ba-f4e4ed6436bc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 133,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n134\r\nAV Rule 204.1\r\nSince the order in which operators and subexpression are evaluated is unspecified, \r\nexpressions must be written in a manner that produces the same value under any order the \r\nstandard permits. \r\n i = v[i++]; // Bad: unspecified behavior \r\n i = ++i + 1; // Bad: unspecified behavior \r\n p->mem_func(*p++); // Bad: unspecified behavior \r\nAV Rule 207\r\nUnencapsulated global data can be dangerous and thus should be avoided. Note that objects \r\nwith only get and set methods, or get and set methods for each attribute are not considered to \r\nbe encapsulated. \r\nint32 x=0; // Bad: Unencapsulated global object. \r\nclass Y { \r\n in32 x; \r\n public: \r\n Y(int32 y_); \r\n int32 get_x(); \r\n void set_x(); \r\n}; \r\nY y (0); // Bad: Unencapsulated global object. \r\nAV Rule 209\r\nA UniversalTypes file will be created to define all standard types for developers to use. The \r\ntypes include: \r\nbool, // built-in type \r\nchar, // built-in type \r\nint8, int16, int32, int64, // user-defined types \r\nuint8, uint16, uint32, uint64, // user-defined types \r\nfloat32, float64 // user-defined types \r\nNote: Whether char represents signed or unsigned values is implementation-defined. \r\nHowever, since modern implementations almost exclusively treat char as unsigned \r\nchar, the built-in char type will be used under the assumption that it is unsigned. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/a2dc7696-08a6-4646-82ba-f4e4ed6436bc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6223d79f979702a7b2b79877d8815bfb1818eea0c9ccc46ba553888f28b15e94",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "aa2cf66b-6997-4d6d-91bb-483db8c3eded",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 134,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n135\r\nAV Rule 210.1\r\nThis rule is intended to prohibit an application from making assumptions concerning the \r\norder in which non-static data members, separated by an access specifier, are ordered. \r\nConsider Example A below. Class A can not be reliably “overlayed” on incoming message \r\ndata, since attribute ordering (across access specifiers) is unspecified. \r\nIn contrast, structure B may be reliably “overlayed” on the same incoming message data. \r\nExample A: \r\nclass A \r\n{ \r\n… \r\n protected: // a could be stored before b, or vice versa \r\n int32 a; \r\n private: \r\n int32 b; \r\n}; \r\n… \r\n // Bad: application assumes that objects of \r\n // type A will always have attribute a\r\n // stored before attribute b. \r\nA* a_ptr = static_cast<A*>(message_buffer_ptr); \r\nExample B: \r\nstruct B \r\n{ \r\n int32 a; \r\n int32 b; \r\n}; \r\n … \r\n // Good: attributes in B not separated \r\n // by an access specifier \r\n B* b_ptr = static_cast<B*>(message_buffer_ptr);",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/aa2cf66b-6997-4d6d-91bb-483db8c3eded.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8c96e5ffb0764f51c2bda6556e54deb0641df1a825f1ddb8d39125f6ed20cee6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 453
      },
      {
        "segments": [
          {
            "segment_id": "5e813833-a611-4ac1-80c3-50c54ebac3a5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 135,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n136\r\nAV Rule 213\r\nParentheses should be used to clarify operator precedence rules to enhance readability and \r\nreduce mistakes. However, overuse of parentheses can clutter an expression thereby reducing \r\nreadability. Requiring parenthesis below arithmetic operators strikes a reasonable balance \r\nbetween readability and clutter. \r\nTable 2 documents C++ operator precedence rules where items higher in the table have \r\nprecedence over those lower in the table. \r\nExamples: Consider the following examples. Note that parentheses are required to specify \r\noperator ordering for those operators below the arithmetic operators. \r\nx = a * b + c; // Good: can assume “*” binds before “+” \r\nx = v->a + v->b + w.c; // Good: can assume “->” and “.” Bind before “+” \r\nx = (f()) + ((g()) * (h())); // Bad: overuse of parentheses. Can assume \r\n // function call binds before “+” and “*” \r\nx = a & b | c; // Bad: must use parenthesis to clarify order \r\nx = a >> 1 + b; // Bad: must use parenthesis to clarify order ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/5e813833-a611-4ac1-80c3-50c54ebac3a5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=51e6e0d066225cf94b57deac6acb808941edf338d92d0bcdb8cd7950c0d6770b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "35b71db5-ec11-4b68-9139-dd071a645519",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 136,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n137\r\nTable 2 Operator Precedence [2] \r\nOperator Description Associativity \r\nscope resolution \r\nscope resolution \r\nglobal \r\nglobal \r\nclass_name :: member \r\nnamespace_name :: member \r\n:: name \r\n:: qualified-name \r\nleft-to-right \r\nleft-to-right \r\nright-to-left \r\nright-to-left \r\nmember selection \r\nmember selection \r\nsubscripting \r\nfunction call \r\nvalue construction \r\npost increment \r\npost decrement \r\ntype identification \r\nrun-time type identification \r\nrun-time checked conversion \r\ncompile-time checked conversion \r\nunchecked conversion \r\nconst conversion \r\nobject . member \r\npointer -> member \r\npointer [ expr ] \r\nexpr ( expr_list ) \r\ntype ( expr_list ) \r\nlvalue ++ \r\nlvalue – \r\ntypeid ( type ) \r\ntypeid ( expr ) \r\ndynamic_cast < type > (expr ) \r\nstatic_cast < type > (expr ) \r\nreinterpret_cast < type > ( expr ) \r\nconst_cast < type > ( expr ) \r\nleft-to-right \r\nsize of object \r\nsize of type \r\npre increment \r\npre decrement \r\ncomplement \r\nnot \r\nunary minus \r\nunary plus \r\naddress of \r\ndereference \r\ncreate (allocate) \r\ncreate (allocate and initialize) \r\ncreate (place) \r\ncreate (place and initialize) \r\ndestroy (deallocate) \r\ndestroy array \r\ncast (type conversion) \r\nsizeof expr \r\nsizeof ( type ) \r\n++ lvalue \r\n-- lvalue \r\n~ expr \r\n! expr \r\n- expr \r\n+ expr \r\n& lvalue \r\n* expr \r\nnew type \r\nnew type ( expr-list ) \r\nnew (expr-list ) type \r\nnew (expr-list ) type ( expr-list ) \r\ndelete pointer \r\ndelete [] pointer \r\n( type ) expr \r\nright-to-left \r\nmember selection \r\nmember selection \r\nobject .* pointer-to-member \r\npointer ->* pointer-to-member \r\nleft-to-right \r\nmultiply \r\ndivide \r\nmodulo (remainder) \r\nexpr * expr \r\nexpr / expr \r\nexpr % expr \r\nleft-to-right \r\nadd (plus) \r\nsubtract (minus) \r\nexpr + expr \r\nexpr – expr \r\nleft-to-right \r\nshift left expr << expr left-to-right ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/35b71db5-ec11-4b68-9139-dd071a645519.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c63dd4cd239a7227e51567ee30c3ee57eae4227d0217743c6259962be138b9c2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 429
      },
      {
        "segments": [
          {
            "segment_id": "698dd7db-7308-4bfa-a0c0-a6885780a2d8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 137,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n138\r\nshift right expr >> expr \r\nless than \r\nless than or equal \r\ngreater than \r\ngreater than or equal \r\nexpr < expr \r\nexpr <= expr \r\nexpr > expr \r\nexpr >= expr \r\nleft-to-right \r\nequal \r\nnot equal \r\nexpr == expr \r\nexpr != expr \r\nleft-to-right \r\nbitwise AND expr & expr left-to-right \r\nbitwise exclusive OR expr ^ expr left-to-right \r\nbitwise inclusive OR expr | expr left-to-right \r\nlogical AND expr && expr left-to-right \r\nlogical OR expr || expr left-to-right \r\nconditional expression expr ? expr : expr right-to-left \r\nsimple assignment \r\nmultiply and assign \r\ndivide and assign \r\nmodula and assign \r\nadd and assign \r\nsubtract and assign \r\nshift left and assign \r\nshift right and assign \r\nAND and assign \r\ninclusive OR and assign \r\nexclusive OR and assign \r\nlvalue = expr \r\nlvalue *= expr \r\nlvalue /= expr \r\nlvalue %= expr \r\nlvalue += expr \r\nlvalue -= expr \r\nlvalue <<= expr \r\nlvalue >>= expr \r\nlvalue &= expr \r\nlvalue |= expr \r\nlvalue ^= expr \r\nright-to-left \r\nthrow exception throw expr right-to-left \r\ncomma (sequencing) expr , expr left-to-right ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/698dd7db-7308-4bfa-a0c0-a6885780a2d8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c4f9272dac9a275c59a48913c0e6f2ef14b12eb532d6295691315e3ba63ffeb1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 170
      },
      {
        "segments": [
          {
            "segment_id": "9b7dd24c-1d12-46ea-898a-45195536c2a9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 138,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n139\r\nAV Rule 214\r\nThe order of initialization for non-local static objects may present problems. For example, a \r\nnon-local static object may not be used in a constructor if that object will not be initialized \r\nbefore the constructor runs. At present, the order of initialization for non-local static objects, \r\nwhich are defined in different compilation units, is not defined. This can lead to errors that \r\nare difficult to locate. \r\nThe problem may be resolved by moving each non-local static object to its own function \r\nwhere it becomes a local static object. If the function returns a reference to the local static \r\nobject it contains, then clients may access the object via the function without any of the \r\ninitialization order problems. Note that the function can be inlined to eliminate the function \r\ncall overhead. \r\nExample: \r\n// file 1 \r\nstatic int32 x = 5; \r\n// file 2 \r\nstatic int32 y = x + 1; // Bad assumption. The compiler might not have initialized \r\n // static variable x. \r\nThe solution is to substitute static local objects for static non-local objects since the creation \r\ntime is precisely defined for static local objects: the first time through the enclosing function. \r\ninline Resource& the_resource() \r\n{ \r\n static Resource r; \r\n return r; \r\n} \r\nNow clients may at any time reference the Resource object, r, as the_resource() without \r\nconsideration for the order of initialization among r and any other similarly defined local \r\nstatic objects. \r\nAlternately, one might consider allocating objects in a memory pool or on a stack at startup. \r\nAV Rule 215\r\nPointers should be eliminated from user interfaces wherever possible. Instead, objects with \r\nwell defined interfaces should be used to hide pointers from clients as well as to ensure any \r\npointer manipulation would be performed in a well-defined manner. For example, passing an \r\nArray object (instead of a raw array) through an interface eliminates the array decay problem \r\nand hence any pointer arithmetic required on the receiving end. \r\nAV Rule 216\r\nThe overall performance of a program is usually determined by a relatively small portion of \r\ncode. This is often referred to as the “80-20 Rule” which states that 80% of the time is spent \r\nin only 20% of the code. Thus, design and coding decisions should be made from a safety \r\nand clarity perspective with efficiency as a secondary goal. Only after adequate profiling \r\nanalysis has been performed (where the true bottlenecks have been identified) should \r\nattempts at optimization be made. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9b7dd24c-1d12-46ea-898a-45195536c2a9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bb448ddf0ee58e5545a05c3c95b7f88b2c13ea2f844f13021981116e183aee8c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 413
      },
      {
        "segments": [
          {
            "segment_id": "d90913af-5e41-44a4-b215-14d99162ed60",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 139,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n140\r\nAV Rule 220\r\nConsider the class diagram in Example A where method_1() is inherited by classes B and C. \r\nSuppose portions of method_1() (indicated by the shaded regions) are executed in each of A, \r\nB, and C such that 100% of method_1() is covered, but not in any one context. A report \r\ngenerated at the method level would produce a misleading view of coverage. \r\nAlternately, consider the flattened class diagram in Example B. Each method is considered in \r\nthe context of the flattened class in which it exists. Hence coverage of method_1() is reported \r\nindependently for each context (A, B, and C). \r\nExample A: Structural coverage of concrete (non-inherited) attributes produces a single \r\nreport purporting 100% coverage of method_1(). However, method_1() was not completely \r\ncovered in any one context. \r\nA \r\nmethod_1 \r\nB \r\nmethod_2 \r\nC \r\nmethod_3 \r\nStructural \r\nCoverage \r\nReport \r\n(100%)\r\nCoverage in A\r\nCoverage in B\r\nCoverage in C",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/d90913af-5e41-44a4-b215-14d99162ed60.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b5f9f4cc10bb29d359d82bccf6914c04d2dec5be813e6789d8160d23b78abec1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "cf9759fd-fdab-4d76-a7b2-a9be85fa3542",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 140,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n141\r\nExample B: Structural coverage of the flattened hierarchy considers method_1() to be a \r\nmember of each derived class. Hence an individual coverage report is generated for \r\nmethod_1() in the context of classes A, B, and C. \r\nA \r\nmethod_1 \r\nB \r\nmethod_1 \r\nmethod 2\r\nC \r\nmethod_1 \r\nmethod 3\r\nStructural \r\nCoverage \r\nReport \r\nCoverage in A\r\nCoverage in B\r\nCoverage in C",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/cf9759fd-fdab-4d76-a7b2-a9be85fa3542.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=25ceb64009dd6b23bf55269e9a3a101cf4daf811bf3e388165c1c05fd3efd73d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9b4a1b32-8518-48ec-aa20-6246c7fe51ed",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 141,
            "page_width": 612,
            "page_height": 792,
            "content": "Doc. No. 2RDU00001 Rev C \r\nDate: December 2005 \r\n142\r\nAPPENDIX B (COMPLIANCE) \r\n“LDRA_Compliance” lists the rules in this document that can be automatically checked by \r\nLDRA. Rules not checked by LDRA will be verified by manual inspection and results captured \r\non checklists. \r\nNote that if other tools are employed to automatically check rules not checked by LDRA, this \r\nappendix should be updated to reflect the source of verification ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/fa0f35c2-b425-4b1d-9c71-d7146951f919/images/9b4a1b32-8518-48ec-aa20-6246c7fe51ed.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041300Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=43ff2e2287e456cc1f98d6b35d1a5d6dee6d6f47a768a22fcf84df3e884b3c9f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 292
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\n \"title\": \"JOINT STRIKE FIGHTER\\nAIR VEHICLE\\nC++ CODING STANDARDS\\nFOR THE SYSTEM DEVELOPMENT AND DEMONSTRATION PROGRAM\"\n}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "K. Carroll"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "December 2005\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": null}\n```\n"
        }
      ]
    }
  }
}