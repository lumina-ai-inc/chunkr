{
  "file_name": "Kmd Kit - 0x07 Lookaside Lists.pdf",
  "task_id": "6a4e352a-1593-4d93-b43a-5b945744997d",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "86a28128-38ef-4562-9bb0-f4698aeeca1e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 1,
            "page_width": 595,
            "page_height": 842,
            "content": "Lookaside Lists\r\n7.1 Lookaside Lists\r\n7.2 LookasideList driver source code\r\n7.3 Working with Lookaside List\r\n7.4 AddEntry routine\r\n7.5 RemoveEntry routine\r\nSource code: KmdKit\\examples\\basic\\MemoryWorks\\LookasideList\r\n7.1 Lookaside Lists\r\nHeap manager manages system and user heaps splitting heap space into blocks of equal size. When a heap allocation query arrives heap \r\nmanager is trying to choose a free block with appropriate size. This can take some time, of course. If you need a memory blocks with \r\nfixed size but you don't know its amount and usage frequency beforehand you should use, for performance reasons, so called lookaside \r\nlists, which exists in the kernel mode only. The main difference of lookaside lists from the system pools is that you can allocate memory \r\nblocks with fixed and predefined size only. Allocation from the lookaside lists is faster because no need to search free region with suitable \r\nsize.\r\nWhen you first come to the lookaside lists the first problem you have to solve apart from the creation lookaside list itself will be \r\nmanagement of the memory blocks you wish to allocate from it. Specifically where and how to store the block addresses you will refer \r\nand free to. This could be a serious problem since you don't know the quantity of these blocks. There are three structures for resolving \r\nsuch a problems:\r\n● Singly linked list; \r\n● S-list, sequenced singly-linked list (a singly linked list modification); \r\n● Doubly linked list. \r\nWe'll examine doubly linked list only as the most universal solution.\r\nThe following code may look complicated if you deal with lookaside and doubly linked lists concept for the first time, but anyway it is \r\nrather simple.\r\nBoth are called lists, but they are completely different things though. The lookaside list is a group of preallocated memory blocks of equal \r\nsize. Some of the blocks may be in use and some of them are not. System will walk through the list searching for the nearest free block \r\nwhen allocation request arrives. If free block found, the allocation can be satisfied very quickly. Otherwise the system must allocate from \r\npaged or nonpaged pool. The system automatically tune the number of freed blocks that lookaside lists store according to how often the \r\nallocations from the list occur - the more frequent the allocations, the more blocks are stored on a list. Lookaside lists are automatically \r\nreduced in size if they aren't being allocated from.\r\nDouble linked list is just a form of data organization. It is convenient to link homogeneous structures in a list and traverse through it. \r\nDouble linked lists are used by the system intensively for internal structure handling.\r\n7.2 LookasideList driver source code\r\nI was thinking really hard but I was failed to depict sensible and simple example for this article. That's why this driver will act probably \r\nsenselessly. However this should not prevent you from understanding the concepts or associative and double linked lists.\r\nThere will be no driver control program, use KmdManager (included in KmdKit package) or something similar. Use DebugView ( http://\r\nwww.sysinternals.com ) or SoftICE console to watch driver's debug messages.\r\n;@echo off\r\n;goto make\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; \r\n; LookasideList - Merely allocates and releases some fixed-size blocks of memory. \r\n; \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n.486\r\n.model flat, stdcall\r\noption casemap:none",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/86a28128-38ef-4562-9bb0-f4698aeeca1e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a5d1d8e5bcc64b73cacb34bf420c1688f7584ed46951580b46c2e566af4f1a2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 537
      },
      {
        "segments": [
          {
            "segment_id": "86a28128-38ef-4562-9bb0-f4698aeeca1e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 1,
            "page_width": 595,
            "page_height": 842,
            "content": "Lookaside Lists\r\n7.1 Lookaside Lists\r\n7.2 LookasideList driver source code\r\n7.3 Working with Lookaside List\r\n7.4 AddEntry routine\r\n7.5 RemoveEntry routine\r\nSource code: KmdKit\\examples\\basic\\MemoryWorks\\LookasideList\r\n7.1 Lookaside Lists\r\nHeap manager manages system and user heaps splitting heap space into blocks of equal size. When a heap allocation query arrives heap \r\nmanager is trying to choose a free block with appropriate size. This can take some time, of course. If you need a memory blocks with \r\nfixed size but you don't know its amount and usage frequency beforehand you should use, for performance reasons, so called lookaside \r\nlists, which exists in the kernel mode only. The main difference of lookaside lists from the system pools is that you can allocate memory \r\nblocks with fixed and predefined size only. Allocation from the lookaside lists is faster because no need to search free region with suitable \r\nsize.\r\nWhen you first come to the lookaside lists the first problem you have to solve apart from the creation lookaside list itself will be \r\nmanagement of the memory blocks you wish to allocate from it. Specifically where and how to store the block addresses you will refer \r\nand free to. This could be a serious problem since you don't know the quantity of these blocks. There are three structures for resolving \r\nsuch a problems:\r\n● Singly linked list; \r\n● S-list, sequenced singly-linked list (a singly linked list modification); \r\n● Doubly linked list. \r\nWe'll examine doubly linked list only as the most universal solution.\r\nThe following code may look complicated if you deal with lookaside and doubly linked lists concept for the first time, but anyway it is \r\nrather simple.\r\nBoth are called lists, but they are completely different things though. The lookaside list is a group of preallocated memory blocks of equal \r\nsize. Some of the blocks may be in use and some of them are not. System will walk through the list searching for the nearest free block \r\nwhen allocation request arrives. If free block found, the allocation can be satisfied very quickly. Otherwise the system must allocate from \r\npaged or nonpaged pool. The system automatically tune the number of freed blocks that lookaside lists store according to how often the \r\nallocations from the list occur - the more frequent the allocations, the more blocks are stored on a list. Lookaside lists are automatically \r\nreduced in size if they aren't being allocated from.\r\nDouble linked list is just a form of data organization. It is convenient to link homogeneous structures in a list and traverse through it. \r\nDouble linked lists are used by the system intensively for internal structure handling.\r\n7.2 LookasideList driver source code\r\nI was thinking really hard but I was failed to depict sensible and simple example for this article. That's why this driver will act probably \r\nsenselessly. However this should not prevent you from understanding the concepts or associative and double linked lists.\r\nThere will be no driver control program, use KmdManager (included in KmdKit package) or something similar. Use DebugView ( http://\r\nwww.sysinternals.com ) or SoftICE console to watch driver's debug messages.\r\n;@echo off\r\n;goto make\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; \r\n; LookasideList - Merely allocates and releases some fixed-size blocks of memory. \r\n; \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n.486\r\n.model flat, stdcall\r\noption casemap:none",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/86a28128-38ef-4562-9bb0-f4698aeeca1e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a5d1d8e5bcc64b73cacb34bf420c1688f7584ed46951580b46c2e566af4f1a2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 537
      },
      {
        "segments": [
          {
            "segment_id": "a1d41162-b983-4024-bc77-2db047fe4a80",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 2,
            "page_width": 595,
            "page_height": 842,
            "content": ";:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; I N C L U D E F I L E S \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\ninclude \\masm32\\include\\w2k\\ntstatus.inc\r\ninclude \\masm32\\include\\w2k\\ntddk.inc\r\ninclude \\masm32\\include\\w2k\\ntoskrnl.inc\r\nincludelib \\masm32\\lib\\w2k\\ntoskrnl.lib\r\ninclude \\masm32\\Macros\\Strings.mac\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; S T R U C T U R E S \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\nSOME_STRUCTURE STRUCT\r\n SomeField1 DWORD ?\r\n SomeField2 DWORD ?\r\n ; . . . ; Any other fields come here\r\n ListEntry LIST_ENTRY <> ; For tracking memory blocks.\r\n ; It can be the first member but\r\n; to place it into is more common solution.\r\n ; . . . ; Any other fields come here\r\n SomeFieldX DWORD ?\r\nSOME_STRUCTURE ENDS\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; U N I N I T I A L I Z E D D A T \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n.data?\r\ng_pPagedLookasideList PPAGED_LOOKASIDE_LIST ?\r\ng_ListHead LIST_ENTRY <>\r\ng_dwIndex DWORD ?\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; C O D E \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n.code\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; AddEntry \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\nAddEntry proc uses esi\r\n invoke ExAllocateFromPagedLookasideList, g_pPagedLookasideList\r\n .if eax != NULL\r\n mov esi, eax\r\n invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: + Memory block allocated from lookaside list at address %08X\\n\"), esi\r\n invoke memset, esi, 0, sizeof SOME_STRUCTURE\r\n assume esi:ptr SOME_STRUCTURE\r\n lea eax, g_ListHead\r\n lea ecx, [esi].ListEntry\r\n InsertHeadList eax, ecx\r\n inc g_dwIndex\r\n mov eax, g_dwIndex\r\n mov [esi].SomeField1, eax\r\n invoke DbgPrint, $CTA0(\"LookasideList: + Entry #%d added\\n\"), [esi].SomeField1\r\n assume esi:nothing\r\n .else\r\n invoke DbgPrint, $CTA0(\"LookasideList: Very bad. Couldn't allocate from lookaside list\\n\")\r\n .endif\r\n ret\r\nAddEntry endp\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; RemoveEntry \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\nRemoveEntry proc uses esi\r\n IsListEmpty addr g_ListHead",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/a1d41162-b983-4024-bc77-2db047fe4a80.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=40b8ada4e6db42f756225586d5a44ffb67cbb9fe62e559b9da9a7dcc3dc134f5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9e07bab0-b0c5-4714-9520-345ed6f60467",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 3,
            "page_width": 595,
            "page_height": 842,
            "content": " .if eax != TRUE\r\n lea eax, g_ListHead\r\n RemoveHeadList eax\r\n sub eax, SOME_STRUCTURE.ListEntry\r\n mov esi, eax\r\n invoke DbgPrint, $CTA0(\"LookasideList: - Entry #%d removed\\n\"), \\\r\n (SOME_STRUCTURE PTR [esi]).SomeField1\r\n invoke ExFreeToPagedLookasideList, g_pPagedLookasideList, esi\r\n invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: - Memory block at address %08X returned to lookaside list\\n\"), esi\r\n .else\r\n invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: An attempt was made to remove entry from empty lookaside list\\n\")\r\n .endif\r\n ret\r\nRemoveEntry endp\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; DriverEntry \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\nDriverEntry proc uses ebx pDriverObject:PDRIVER_OBJECT, pusRegistryPath:PUNICODE_STRING\r\n invoke DbgPrint, $CTA0(\"\\nLookasideList: Entering DriverEntry\\n\")\r\n invoke ExAllocatePool, NonPagedPool, sizeof PAGED_LOOKASIDE_LIST\r\n .if eax != NULL\r\n mov g_pPagedLookasideList, eax\r\n \r\n invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: Nonpaged memory for lookaside list allocated at address %08X\\n\"), \\\r\n g_pPagedLookasideList\r\n invoke ExInitializePagedLookasideList, g_pPagedLookasideList, NULL, NULL, \\\r\n 0, sizeof SOME_STRUCTURE, 'msaW', 0\r\n invoke DbgPrint, $CTA0(\"LookasideList: Lookaside list initialized\\n\")\r\n lea eax, g_ListHead\r\n InitializeListHead eax\r\n invoke DbgPrint, $CTA0(\"LookasideList: Doubly linked list head initialized\\n\")\r\n invoke DbgPrint, $CTA0(\"\\nLookasideList: Start to allocate/free from/to lookaside list\\n\")\r\n and g_dwIndex, 0\r\n xor ebx, ebx\r\n .while ebx < 5\r\n invoke AddEntry\r\n invoke AddEntry\r\n invoke RemoveEntry\r\n inc ebx\r\n .endw\r\n invoke DbgPrint, $CTA0(\"\\nLookasideList: Free the rest to lookaside list\\n\")\r\n .while TRUE\r\n invoke RemoveEntry\r\n lea eax, g_ListHead\r\n IsListEmpty eax\r\n .if eax == TRUE\r\n invoke DbgPrint, $CTA0(\"LookasideList: Doubly linked list is empty\\n\\n\")\r\n .break\r\n .endif\r\n .endw\r\n invoke ExDeletePagedLookasideList, g_pPagedLookasideList\r\n invoke DbgPrint, $CTA0(\"LookasideList: Lookaside list deleted\\n\")\r\n invoke ExFreePool, g_pPagedLookasideList\r\n invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: Nonpaged memory for lookaside list at address %08X released\\n\"), \\\r\n g_pPagedLookasideList\r\n .else",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/9e07bab0-b0c5-4714-9520-345ed6f60467.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8c4a13d151ff896f7784efecca0fb6facaf55f97fd6d49cdba796e89e9dd6d44",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 454
      },
      {
        "segments": [
          {
            "segment_id": "2d076336-39f2-472f-a780-364d814f141f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 4,
            "page_width": 595,
            "page_height": 842,
            "content": " invoke DbgPrint, \\\r\n $CTA0(\"LookasideList: Couldn't allocate nonpaged memory for lookaside list control structure\")\r\n .endif\r\n invoke DbgPrint, $CTA0(\"LookasideList: Leaving DriverEntry\\n\")\r\n mov eax, STATUS_DEVICE_CONFIGURATION_ERROR\r\n ret\r\nDriverEntry endp\r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n; \r\n;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\nend DriverEntry\r\n:make\r\nset drv=LookasideList\r\n\\masm32\\bin\\ml /nologo /c /coff %drv%.bat\r\n\\masm32\\bin\\link /nologo /driver /base:0x10000 /align:32 /out:%drv%.sys /subsystem:native %drv%.obj\r\ndel %drv%.obj\r\necho.\r\npause\r\n7.3 Working with Lookaside List\r\n invoke ExAllocatePool, NonPagedPool, sizeof PAGED_LOOKASIDE_LIST\r\n .if eax != NULL\r\n mov g_pPagedLookasideList, eax\r\nWe allocate nonpaged memory for PAGED_LOOKASIDE_LIST structure, which is used to manage lookaside list and save the pointer into\r\nthe g_pPagedLookasideList variable. Note that lookaside list itself we use here is pageable, i.e. the memory we get from it can be paged \r\nout. The documentation is pretty clear about it.\r\n invoke ExInitializePagedLookasideList, g_pPagedLookasideList, NULL, NULL, \\\r\n 0, sizeof SOME_STRUCTURE, 'msaW', 0\r\nExInitializePagedLookasideList fills the PAGED_LOOKASIDE_LIST structure we allocated on the previous step. Now lookaside list is ready \r\nto use.\r\nNote that during initialization we did not specify how many blocks we are require. But how the system knows exactly how much memory \r\nit should allocate? Indeed, if memory allocation hasn't been done beforehand the lookaside list will not work faster than common system \r\npool allocation. The point is that initially the system allocates just a few (the quantity is defined by the system itself) blocks. So if we \r\nstart to allocate from the lookaside list we'll get the pointers to those preallocated memory blocks. Once per second the system adjusts \r\nall system lookaside lists calling ExAdjustLookasideDepth. The system will allocate new blocks if it founds free block spare diminished \r\nduring the adjustment. The number of the extra blocks depends on lookaside list's load, i.e. its allocation frequency. The system tries to \r\nadjust lookaside lists more effective way. If we had exhausted all preallocated blocks within adjustment time, the system just uses \r\nsystem pool allocation until the next adjustment. The important thing to understand is that if the allocation speed is too high we have no \r\nperformance gain comparing the allocation form the system pool. You can estimate the efficiency of the lookaside list using MS Kernel \r\nDebugger's command \"!lookaside\".\r\nkd> !lookaside ed374840\r\nLookaside \"\" @ ed374840 \"Regm\"\r\n Type = 0001 PagedPool\r\n Current Depth = 2 Max Depth = 4\r\n Size = 1024 Max Alloc = 4096\r\n AllocateMisses = 4 FreeMisses = 0\r\n TotalAllocates = 1319722 TotalFrees = 1319720\r\n Hit Rate = 99% Hit Rate = 100%\r\nLet's see the lookaside list use efficiency of the RegMon ( http://www.sysinternals.com ) utility. As you can see the efficiency approaches \r\nto 100% considering huge amount (above one million) of alloc/free operations. The reason is that RegMon does not keep allocated block \r\nfor a long time.\r\n lea eax, g_ListHead\r\n InitializeListHead eax\r\nCalling InitializeListHead macro we initialize doubly linked list head. Now both LIST_ENTRY's fields contain the pointers to this structure ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/2d076336-39f2-472f-a780-364d814f141f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2db4569e1279adc8590ebe38d5abb798a67871adadf7568cd1eb50d9e0d1c630",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 463
      },
      {
        "segments": [
          {
            "segment_id": "57c1721b-5cc7-4b79-b22c-ba32f7fa159e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 5,
            "page_width": 595,
            "page_height": 842,
            "content": "itself. This means doubly linked list is empty (figure 7.1, imgage 1)\r\nFigure. 7-1. This picture allows you visually realize how doubly linked list functions.\r\n and g_dwIndex, 0\r\nThis global variable is only used to place something into SOME_STRUCTURE allocated from lookaside list and to output its value through \r\ndebug messages.\r\n xor ebx, ebx\r\n .while ebx < 5\r\n invoke AddEntry\r\n invoke AddEntry\r\n invoke RemoveEntry\r\n inc ebx\r\n .endw\r\nLoop five times. Each pass adds two entries and removes one entry. Each entry represents SOME_STRUCTURE. All allocated structures ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/57c1721b-5cc7-4b79-b22c-ba32f7fa159e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f135f56caaa2903920153f9f653957981d0e36f503afa687cf6ca625c1612f8d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "062fe808-8f79-4d9c-ae0b-b471dae88704",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 6,
            "page_width": 595,
            "page_height": 842,
            "content": "linked to each other using doubly linked list.\r\nThis loop simulates the random allocation from the lookaside list. We assume here we work somehow with allocated entries. For \r\nexample, we could write a driver intercepting calls of some system service, say ZwOpenKey, and saving information into the allocated \r\nmemory.\r\n .while TRUE\r\n invoke RemoveEntry\r\n lea eax, g_ListHead\r\n IsListEmpty eax\r\n .if eax == TRUE\r\n .break\r\n .endif\r\n .endw\r\nAt this point we have some amount of allocated from lookaside list entries linked together in doubly linked lists. We assume these entries \r\nare not needed for us anymore.\r\nWe call RemoveEntry routine in the endless loop. RemoveEntry removes an entry from the head of a doubly linked list and releases it \r\nback to the lookaside list. The loop runs until doubly linked list is empty. Calling IsListEmpty macro checks this condition. IsListEmpty \r\nchecks to see whether both fields of the doubly linked list head (LIST_ENTRY structure) point to the head itself. At this point we came to \r\nthe state we have right after InitializeListHead macro call (figure 7-1, imgage 1).\r\n invoke ExDeletePagedLookasideList, g_pPagedLookasideList\r\nWhen doubly linked list is empty all entries allocated from lookaside list are returned back as well, since we used doubly linked list to \r\nmanage allocations from the lookaside list. Now we can delete lookaside list by calling ExDeletePagedLookasideList. It frees any \r\nremaining entries in the lookaside list and then removes the list from the system-wide set of active lookaside lists.\r\n invoke ExFreePool, g_pPagedLookasideList\r\nExFreePool releases nonpaged memory allocated for PAGED_LOOKASIDE_LIST structure. In case you forget (I didn't) to call \r\nExDeletePagedLookasideList beforehand you will see BSOD since in about a second the system will try to adjust missing lookaside list.\r\n mov eax, STATUS_DEVICE_CONFIGURATION_ERROR\r\n ret\r\nSince we have released all allocated resources we can unload the driver.\r\n7.4 AddEntry routine\r\nWe call AddEntry when we need a new memory block. It allocates new entry from the lookaside list and adds it into doubly linked list.\r\n invoke ExAllocateFromPagedLookasideList, g_pPagedLookasideList\r\n .if eax != NULL\r\n mov esi, eax\r\nCalling ExAllocateFromPagedLookasideList we get the new memory block pointer and save it in esi. Note we don't tell the system about \r\nblock size because the size was defined while calling ExInitializePagedLookasideList and is equal to the size of SOME_STRUCTURE.\r\n invoke memset, esi, 0, sizeof SOME_STRUCTURE\r\nZeroing allocated block. It doesn't need though.\r\n assume esi:ptr SOME_STRUCTURE\r\nNow we have new instance of the SOME_STRUCTURE. We should link it to our doubly linked list, which is empty during the first AddEntry\r\nrun.\r\n lea eax, g_ListHead\r\n lea ecx, [esi].ListEntry",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/062fe808-8f79-4d9c-ae0b-b471dae88704.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=295e713c8b4c4fc78a76164088af5aaaed98084c40b333d056dc1763568aace2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 505
      },
      {
        "segments": [
          {
            "segment_id": "19089274-bf69-4b65-88b1-12ecefcc5045",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595,
              "height": 842
            },
            "page_number": 7,
            "page_width": 595,
            "page_height": 842,
            "content": " InsertHeadList eax, ecx\r\nFigure 7-1, image 2 depicts a state after the first InsertHeadList macro call. Pay your attention to the second argument of the \r\nInsertHeadList macro, which is not an address of the SOME_STRUCTURE but an address of its ListEntry field. I.e. InsertHeadList macro \r\naccepts the pointers to the two LIST_ENTRY structures, the first one is the head of doubly linked list and the second one is a structure \r\nmember we need to link to this doubly linked list. InsertHeadList links the new structure at the head of the doubly linked list (to the right \r\nin Figure 7-1). You can use InsertTailList macro to link at the tail.\r\nBoth macros produce the same result if you add the first entry to the doubly linked list and after that it will looks like it reflected on the \r\nFigure 7-1, image 2.\r\nIf doubly linked list is not empty InsertHeadList macro will split the doubly linked list between its head and the entry to the right and \r\nplace the new entry in between (see Figure 7-1, image 3). InsertTailList macro does the same but at the tail.\r\nHope everything is pretty clear now.\r\n inc g_dwIndex\r\n mov eax, g_dwIndex\r\n mov [esi].SomeField1, eax\r\nWe save newly created entry number in the SomeField1. You can watch the order in which those structures are added/removed in \r\nDbgView.\r\n7.5 RemoveEntry routine\r\nRemoveEntry routine is the reciprocal of the AddEntry. It unlinks the entry from the head of the doubly linked list and returns it back to \r\nthe lookaside list.\r\n IsListEmpty addr g_ListHead\r\n .if eax != TRUE\r\nMake sure the doubly linked list is empty.\r\n lea eax, g_ListHead\r\n RemoveHeadList eax\r\nRemoveHeadList unlinks the entry from the doubly linked list's head (as you already guess RemoveTailList macro does the same but\r\nfrom the tail. You can also remove any entry using RemoveEntryList macro). At this point extracted from the doubly linked list entry \r\nexist on its own and doubly linked list is enclosed to link remaining entries together.\r\n sub eax, SOME_STRUCTURE.ListEntry\r\n mov esi, eax\r\nPay your attention to this point. RemoveTailList/RemoveHeadList/RemoveEntryList return a pointer to the entry (nested LIST_ENTRY\r\nstructure) that was at the tail/head/middle of the list but not the pointer to unlinked SOME_STRUCTURE structure itself. The macros \r\ndon't know exact place of the LIST_ENTRY in the structure. And there is no way for them to know about. This is entirely up to you to \r\ncalculate offset to the ListEntry field in the SOME_STRUCTUREto get the pointer to the structure itself (that's what DDK's \r\nCONTAINING_RECORD macro does).\r\n invoke ExFreeToPagedLookasideList, g_pPagedLookasideList, esi\r\nExFreeToPagedLookasideList returns the entry to the lookaside list or to paged pool.\r\nCopyright © 2002-2004 Four-F, four-f@mail.ru\r\nTranslated by masquer",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6a4e352a-1593-4d93-b43a-5b945744997d/images/19089274-bf69-4b65-88b1-12ecefcc5045.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041618Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d0299b85d4a9c7bf3453a4a3cebdd24de45c6af534a157729348992340188ab7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 444
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\n  \"title\": \"Lookaside Lists\"\n}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "Author: masquer\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "Field Value:  Not mentioned in the provided text."
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": null}\n```\n"
        }
      ]
    }
  }
}