{
  "file_name": "KQguard - Protecting Kernel Callback Queues - 2012 (WRK_Tech_Report_03_12).pdf",
  "task_id": "20f1eac8-4aad-4adc-903d-777bbb9d6ef1",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "fac40c45-62bf-455f-8a7b-e81fbf300a74",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "0 \r\nFlorida International University Technical Report TR‐2012‐SEC‐03‐01\r\nKQguard: Protecting Kernel Callback Queues\r\nJinpeng Wei1, Feng Zhu1, Calton Pu2\r\n1\r\nSchool of Computing and Information Sciences \r\nFlorida International University \r\nMiami, FL 33199 \r\n{weijp, fzhu001}@cs.fiu.edu\r\n2\r\nCollege of Computing \r\nGeorgia Institute of Technology \r\nAtlanta, GA 30332 \r\ncalton@cc.gatech.edu",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/fac40c45-62bf-455f-8a7b-e81fbf300a74.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2386b138d1da10eff72b2669b909cdbae796849a8e2fbd5b15818267e47c2398",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 45
      },
      {
        "segments": [
          {
            "segment_id": "62ce8c72-58e7-4e93-992f-f3a6e5acfc1b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "1 \r\nKQguard: Protecting Kernel Callback Queues\r\nJinpeng Wei, Feng Zhu, Calton Pu\r\nABSTRACT\r\nKernel callback queues (KQs) are the mechanism of choice for \r\nhandling events in modern kernels. KQs have been misused by \r\nreal-world malware to get a kernel thread to run malicious code. \r\nCurrent defense mechanisms for kernel code and data integrity \r\nhave difficulties with KQ attacks, since they work without neces\u0002sarily changing legitimate kernel code or data. In this paper, we \r\ndescribe the design, implementation, and evaluation of KQguard, \r\nan efficient and effective protection mechanism of KQs. KQguard \r\nuses static and dynamic analysis of kernel and device drivers to \r\nlearn the legitimate event handlers. At runtime, KQguard rejects \r\nall the unknown KQ requests that cannot be validated. We im\u0002plemented KQguard on Windows Research Kernel (WRK) and \r\nextensive experimental evaluation shows KQguard is efficient (up \r\nto 5% overhead) and effective (capable of achieving zero false \r\npositives and false negatives against 11 real malware and 9 syn\u0002thetic attacks). KQguard protects all the 20 KQs in WRK, can be \r\nextended to accommodate new device drivers, and through dy\u0002namic analysis can support closed source device drivers. \r\n1. INTRODUCTION \r\nOne of the most time-critical functions of an operating system \r\n(OS) kernel is interrupt/event handling, e.g., timer interrupts. In \r\nsupport of asynchronous event handling, multi-threads kernels \r\nstore the information necessary for handling an event as an ele\u0002ment in a kernel queue (called KQ for short), specialized for that \r\nevent type. To avoid interpretation overhead, each element of a \r\nKQ contains a callback function pointer to an event handler spe\u0002cialized for that specific event, plus its associated execution con\u0002text and input parameters. When an event happens, a kernel \r\nthread invokes the specified callback function as a subroutine to \r\nhandle the event. \r\nKQs are the mechanism of choice for handling events in modern \r\nkernels. As concrete examples, we found 20 KQs in the Windows \r\nResearch Kernel (WRK) and 22 in Linux. In addition to being \r\npopular with kernel programmers, KQs also have become a very \r\nuseful tool for kernel-level rootkits (Section 5.2 and [5][21]), \r\nmalicious programs that remain hidden in the kernel to execute \r\nkernel tasks ordered by an attacker. For example, the Push\u0002do/Cutwail spam bot has misused the Registry Operation Notifi\u0002cation Queue of the Windows kernel to monitor, block, or modify \r\nlegitimate registry operations [8]. This paper includes 11 exam\u0002ples of real world rootkits misusing KQs demonstrating these \r\nserious current exploits, and 9 additional synthetic potential mi\u0002suses for illustration of future dangers. \r\nTo counter these threats, one potential solution is to consider the \r\nKQs as bugs as typical exploits of kernel bugs today, and try to \r\nfix them. Since the rootkits are only exploiting legitimate APIs of \r\nKQs, the only way to fix this bug is to remove KQs themselves. \r\nThis drastic solution would require significant and extensive ker\u0002nel redesign and it is currently impractical. Instead, we consider \r\nKQs as important kernel features that we would like to keep. Our \r\ndefense, called KQguard, performs validation checks that will \r\nensure the execution of legitimate event handlers only, by filter\u0002ing out all the callbacks of unknown origin. \r\nKQguard is carefully designed and implemented to satisfy four \r\nstringent requirements of kernel facilities. The first two are func\u0002tional software requirements, while the last two are practical \r\nadoption requirements. The first requirement is efficiency: KQ\u0002guard should minimize the overhead of callback function valida\u0002tion. The second is effectiveness: KQguard should distinguish \r\nattack KQ requests from legitimate event handlers with zero er\u0002rors. The third is coverage: KQguard should work for all the KQs \r\nin the kernel. The fourth is extensibility: KQguard should support \r\nfuture legitimate event handlers such as device drivers. The fifth \r\nis inclusiveness: KQguard should work without source code in \r\norder to support third-party, closed source device drivers. A sur\u0002vey of potential solutions for addressing the KQ exploits is in\u0002cluded in Section 6, where we explain our findings that current \r\nsolutions have difficulties with one or more of the four require\u0002ments. \r\nThe main contribution of this paper is the design, implementation, \r\nand evaluation of KQguard. By combining several techniques \r\n(e.g., static analysis of kernel source code and dynamic analysis \r\nof device driver binaries), KQguard is able to satisfy the design \r\nrequirements of efficiency, effectiveness, coverage, extensibility, \r\nand inclusiveness. We have implemented the KQguard in WRK \r\n[33] and started work on the Linux kernel. Extensive evaluation \r\nof KQguard on WRK shows its effectiveness against KQ exploits \r\n(both real and synthetic), detecting all the attacks (zero false \r\nnegatives). With appropriate training, we eliminated all false \r\nalarms from KQguard (zero false positives) for representative \r\nworkloads. For resource intensive benchmarks, KQguard carries a \r\nsmall performance overhead of up to 5%. The ongoing implemen\u0002tation effort on Linux confirms our experience on WRK. KQ\u0002guard protects all 20 KQs in WRK; it can be extended to accom\u0002modate new device drivers, and it supports closed source device \r\ndrivers through dynamic analysis. \r\nThe rest of the paper is organized as follows. Section 2 summariz\u0002es the problem caused by rootkits misusing KQs. Section 3 de\u0002scribes the high level design of KQguard defense by abstracting \r\nthe KQ facility. Section 4 outlines some implementation details of \r\nKQguard for WRK and Linux, validating the design. Section 5 \r\npresents the results of an experimental evaluation, demonstrating \r\nthe effectiveness and efficiency of KQguard. Section 6 outlines \r\nrelated work and Section 7 concludes the paper. \r\n2. PROBLEM ANALYSIS: KQ Hijack \r\n2.1 Importance of KQ Hijack Attacks \r\nFunctionally, KQs are kernel queues that support the callback of a \r\nprogrammer-defined event handler, specialized for efficient han\u0002dling of that particular event. For example, the soft timer queue of \r\nthe Linux kernel supports scheduling of timed event-handling \r\nfunctions. The original kernel thread requesting the timed event \r\nspecifies an event time and a callback function to be executed at \r\nthe specified time. When the system timer reaches the specified \r\ntime, the kernel timer interrupt handler invokes the callback func\u0002tion stored in the soft timer request queue (Figure 1). More gener\u0002ally and regardless of the specific event semantics among the \r\nKQs, their control flow conforms to the same abstract type: For ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/62ce8c72-58e7-4e93-992f-f3a6e5acfc1b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd9b18f02f5b8cc56c785a636f9811855783c9a2af03e0e7e78f695ed8c6bb15",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 999
      },
      {
        "segments": [
          {
            "segment_id": "62ce8c72-58e7-4e93-992f-f3a6e5acfc1b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "1 \r\nKQguard: Protecting Kernel Callback Queues\r\nJinpeng Wei, Feng Zhu, Calton Pu\r\nABSTRACT\r\nKernel callback queues (KQs) are the mechanism of choice for \r\nhandling events in modern kernels. KQs have been misused by \r\nreal-world malware to get a kernel thread to run malicious code. \r\nCurrent defense mechanisms for kernel code and data integrity \r\nhave difficulties with KQ attacks, since they work without neces\u0002sarily changing legitimate kernel code or data. In this paper, we \r\ndescribe the design, implementation, and evaluation of KQguard, \r\nan efficient and effective protection mechanism of KQs. KQguard \r\nuses static and dynamic analysis of kernel and device drivers to \r\nlearn the legitimate event handlers. At runtime, KQguard rejects \r\nall the unknown KQ requests that cannot be validated. We im\u0002plemented KQguard on Windows Research Kernel (WRK) and \r\nextensive experimental evaluation shows KQguard is efficient (up \r\nto 5% overhead) and effective (capable of achieving zero false \r\npositives and false negatives against 11 real malware and 9 syn\u0002thetic attacks). KQguard protects all the 20 KQs in WRK, can be \r\nextended to accommodate new device drivers, and through dy\u0002namic analysis can support closed source device drivers. \r\n1. INTRODUCTION \r\nOne of the most time-critical functions of an operating system \r\n(OS) kernel is interrupt/event handling, e.g., timer interrupts. In \r\nsupport of asynchronous event handling, multi-threads kernels \r\nstore the information necessary for handling an event as an ele\u0002ment in a kernel queue (called KQ for short), specialized for that \r\nevent type. To avoid interpretation overhead, each element of a \r\nKQ contains a callback function pointer to an event handler spe\u0002cialized for that specific event, plus its associated execution con\u0002text and input parameters. When an event happens, a kernel \r\nthread invokes the specified callback function as a subroutine to \r\nhandle the event. \r\nKQs are the mechanism of choice for handling events in modern \r\nkernels. As concrete examples, we found 20 KQs in the Windows \r\nResearch Kernel (WRK) and 22 in Linux. In addition to being \r\npopular with kernel programmers, KQs also have become a very \r\nuseful tool for kernel-level rootkits (Section 5.2 and [5][21]), \r\nmalicious programs that remain hidden in the kernel to execute \r\nkernel tasks ordered by an attacker. For example, the Push\u0002do/Cutwail spam bot has misused the Registry Operation Notifi\u0002cation Queue of the Windows kernel to monitor, block, or modify \r\nlegitimate registry operations [8]. This paper includes 11 exam\u0002ples of real world rootkits misusing KQs demonstrating these \r\nserious current exploits, and 9 additional synthetic potential mi\u0002suses for illustration of future dangers. \r\nTo counter these threats, one potential solution is to consider the \r\nKQs as bugs as typical exploits of kernel bugs today, and try to \r\nfix them. Since the rootkits are only exploiting legitimate APIs of \r\nKQs, the only way to fix this bug is to remove KQs themselves. \r\nThis drastic solution would require significant and extensive ker\u0002nel redesign and it is currently impractical. Instead, we consider \r\nKQs as important kernel features that we would like to keep. Our \r\ndefense, called KQguard, performs validation checks that will \r\nensure the execution of legitimate event handlers only, by filter\u0002ing out all the callbacks of unknown origin. \r\nKQguard is carefully designed and implemented to satisfy four \r\nstringent requirements of kernel facilities. The first two are func\u0002tional software requirements, while the last two are practical \r\nadoption requirements. The first requirement is efficiency: KQ\u0002guard should minimize the overhead of callback function valida\u0002tion. The second is effectiveness: KQguard should distinguish \r\nattack KQ requests from legitimate event handlers with zero er\u0002rors. The third is coverage: KQguard should work for all the KQs \r\nin the kernel. The fourth is extensibility: KQguard should support \r\nfuture legitimate event handlers such as device drivers. The fifth \r\nis inclusiveness: KQguard should work without source code in \r\norder to support third-party, closed source device drivers. A sur\u0002vey of potential solutions for addressing the KQ exploits is in\u0002cluded in Section 6, where we explain our findings that current \r\nsolutions have difficulties with one or more of the four require\u0002ments. \r\nThe main contribution of this paper is the design, implementation, \r\nand evaluation of KQguard. By combining several techniques \r\n(e.g., static analysis of kernel source code and dynamic analysis \r\nof device driver binaries), KQguard is able to satisfy the design \r\nrequirements of efficiency, effectiveness, coverage, extensibility, \r\nand inclusiveness. We have implemented the KQguard in WRK \r\n[33] and started work on the Linux kernel. Extensive evaluation \r\nof KQguard on WRK shows its effectiveness against KQ exploits \r\n(both real and synthetic), detecting all the attacks (zero false \r\nnegatives). With appropriate training, we eliminated all false \r\nalarms from KQguard (zero false positives) for representative \r\nworkloads. For resource intensive benchmarks, KQguard carries a \r\nsmall performance overhead of up to 5%. The ongoing implemen\u0002tation effort on Linux confirms our experience on WRK. KQ\u0002guard protects all 20 KQs in WRK; it can be extended to accom\u0002modate new device drivers, and it supports closed source device \r\ndrivers through dynamic analysis. \r\nThe rest of the paper is organized as follows. Section 2 summariz\u0002es the problem caused by rootkits misusing KQs. Section 3 de\u0002scribes the high level design of KQguard defense by abstracting \r\nthe KQ facility. Section 4 outlines some implementation details of \r\nKQguard for WRK and Linux, validating the design. Section 5 \r\npresents the results of an experimental evaluation, demonstrating \r\nthe effectiveness and efficiency of KQguard. Section 6 outlines \r\nrelated work and Section 7 concludes the paper. \r\n2. PROBLEM ANALYSIS: KQ Hijack \r\n2.1 Importance of KQ Hijack Attacks \r\nFunctionally, KQs are kernel queues that support the callback of a \r\nprogrammer-defined event handler, specialized for efficient han\u0002dling of that particular event. For example, the soft timer queue of \r\nthe Linux kernel supports scheduling of timed event-handling \r\nfunctions. The original kernel thread requesting the timed event \r\nspecifies an event time and a callback function to be executed at \r\nthe specified time. When the system timer reaches the specified \r\ntime, the kernel timer interrupt handler invokes the callback func\u0002tion stored in the soft timer request queue (Figure 1). More gener\u0002ally and regardless of the specific event semantics among the \r\nKQs, their control flow conforms to the same abstract type: For ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/62ce8c72-58e7-4e93-992f-f3a6e5acfc1b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd9b18f02f5b8cc56c785a636f9811855783c9a2af03e0e7e78f695ed8c6bb15",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 999
      },
      {
        "segments": [
          {
            "segment_id": "4e9aaf6e-4cd7-48c8-bc32-541cace41570",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "2 \r\neach request in the queue, a kernel thread invokes the callback \r\nfunction specified in the KQ request to handle the event. \r\nFigure 1: Life cycle of a soft timer request in Linux \r\nKernel-level rootkits exploit the KQ callback control flow to ex\u0002ecute malicious code by inserting their own request into a KQ \r\n(e.g., by supplying malicious callback function or data in step 1 of \r\nFigure 1). This kind of manipulation, called a KQ hijack attack, \r\nonly uses legitimate kernel API and it does not change legitimate \r\nkernel code or statically allocated data structures such as global \r\nvariables. Therefore, syntactically a KQ hijack request is indistin\u0002guishable from normal event handlers. Consider the Registry \r\nOperation Notification Queue as illustration. Using it in defense, \r\nanti-virus software event handlers can detect potential intruder \r\nmalicious activity on the registry. Using it in KQ hijack attack, \r\nPushdo/Cutwail [8] can monitor, block, or modify legitimate regi\u0002stry operations. \r\nSeveral KQ Hijack Attacks by real world malware have been \r\ndocumented. First, rootkits have misused KQs to hide better \r\nagainst discovery. For example, the Rustock.C spam bot relies on \r\ntwo Windows kernel timers [17] to check whether it is being de\u0002bugged/traced [2][15] (e.g., whether KdDebuggerEnabled is true). \r\nSecond, rootkits have misused normal KQ functionality for covert \r\nrootkit operations. For example, Pushdo/Cutwail botnet sets up \r\nthree callback routines by invoking \r\nIoRegisterFsRegistrationChange, CmRegister \r\nCallback, and PsSetCreateProcessNotifyRoutine, \r\nrespectively [8]; these callback routines enable it to monitor file \r\nsystem registrations, monitor, block, or modify a registry opera\u0002tion, and inject a malicious module into a services.exe process. \r\nRustock.C also invokes PsSetCreateProcessNotify \r\nRoutine [7][23] to inject code into seemingly benign processes \r\n(e.g., sevices.exe) so that spamming can be done in the context of \r\nan innocent process. Third, rootkits have misused KQ functionali\u0002ty to attack security products directly. For example, the \r\nStorm/Peacomm spam bot invokes PsSetLoadImageNotify \r\nRoutine to register a malicious callback function that disables \r\nsecurity products when they are loaded [4]. Table 3 shows the KQ \r\nhijack attacks against WRK that we have studied. It is a repre\u0002sentative sample, covering some of the most notorious malware \r\ntoday: the TDSS botnet consists of 4.5 million infected machines \r\nand is considered the most sophisticated threat [11], and Duqu \r\n[12] is believed to be closely related to the widespread Stuxnet \r\nworm [29]. Undoubtedly, KQ Hijack Attacks represent a clear \r\nand present danger to current OS kernels. \r\n2.2 KQ Hijack Attack Model \r\nThe KQ hijack malware listed in Table 3 misuse KQs in a \r\nstraightforward way. They prepare a malicious function in kernel \r\nspace and use its address as the callback function pointer in a KQ \r\nrequest. We call these callback-into-malware attacks. Since their \r\nmalicious functions must be injected somewhere in kernel space, \r\ncallback-into-malware attacks can be detected by runtime kernel \r\ncode integrity checkers such as SecVisor [25] or NICKLE [24]. \r\nCallback-into-malware is considered the basic level of attack, \r\nwhich may be countered by current defense techniques. \r\nUnfortunately, sophisticated attack technology already developed \r\nis able to bypass the detection of standalone malware, e.g., “re\u0002turn-into-libc” attacks [27][30] that use snippets of legitimate \r\nkernel code to achieve their malicious intent. The second level of \r\nKQ hijack attacks, called callback-into-libc (in analogy to return\u0002into-libc), create a malicious callback request containing a legiti\u0002mate event handler, but invoked with malicious input parameters. \r\nWhen activated, the event handler may carry out unintended ac\u0002tions on behalf of the attacker. \r\nCallback-into-libc KQ hijack attacks represent a new and interest\u0002ing challenge, since they allow an attacker to execute malicious \r\nlogic without injecting his own code. To demonstrate the feasi\u0002bility of callback-into-libc attacks, we developed a prototype KQ \r\nhijack program that only uses legitimate kernel code to bypass \r\nSELinux. In recent Linux kernels [26], SELinux has been imple\u0002mented as a Linux Security Module (LSM). SELinux registers its \r\nsecurity auditing functions through the register_security\r\nfacility, which fills a global variable called security_ops\r\nwith SELinux functions. Since there is a legitimate function \r\nreset_security_ops that overwrites security_ops to \r\nthe initial value that points to another global data structure called \r\ndefault_security_ops that does no security auditing, our \r\nprototype KQ hijack program inserts a soft timer request with \r\nreset_security_ops as the callback function. When this \r\nsoft timer expires, reset_security_ops is invoked and SE\u0002Linux is turned off. \r\nThe design of KQguard in the next section shows how we can \r\ndetect both the basic level (callback-into-malware) and the second \r\nlevel (callback-into-libc) KQ hijack attacks. \r\n2.3 Design Requirements in KQ Defense \r\nAn effective KQ defense should satisfy five requirements, i.e., \r\nefficiency, effectiveness, coverage, extensibility, and inclusive\u0002ness. In this section, we outline the reasons some previous tech\u0002niques may solve specific problems, but have difficulties with \r\nsatisfying all five requirements. At the same time, we outline the \r\nreasons KQguard satisfies these requirements. A more detailed \r\ndiscussion of related work is in Section 6. \r\nEfficiency. Although some KQs have higher efficiency require\u0002ments than others (e.g., timer interrupts vs. registry operations), it \r\nis important for KQ defenses to minimize their overhead. KQ\u0002guard is designed to protect all KQs (the coverage requirement) \r\nwith low overhead, including the time-sensitive ones. \r\nEffectiveness. KQ defenses should detect all the KQ Hijack At\u0002tacks (zero false negatives) and make no mistakes regarding the \r\nlegitimate event handlers (zero false positives). KQguard is de\u0002signed to achieve this level of precision and recall by focusing on \r\nthe recognition of all legitimate event handlers. \r\nCoverage. It is important for a KQ defense to protect all KQs, not \r\njust the ones under past attacks. Although we do not rule out spe\u0002cialized solutions to protect individual KQs a priori, KQguard is \r\ndesigned to protect all KQs that activate their requests by execut\u0002ing a callback function. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/4e9aaf6e-4cd7-48c8-bc32-541cace41570.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1a3dba3af84c2ec85eca1d2efddbe300c9442e0d778191469ecdaf7a6d0a2d75",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 922
      },
      {
        "segments": [
          {
            "segment_id": "4e9aaf6e-4cd7-48c8-bc32-541cace41570",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "2 \r\neach request in the queue, a kernel thread invokes the callback \r\nfunction specified in the KQ request to handle the event. \r\nFigure 1: Life cycle of a soft timer request in Linux \r\nKernel-level rootkits exploit the KQ callback control flow to ex\u0002ecute malicious code by inserting their own request into a KQ \r\n(e.g., by supplying malicious callback function or data in step 1 of \r\nFigure 1). This kind of manipulation, called a KQ hijack attack, \r\nonly uses legitimate kernel API and it does not change legitimate \r\nkernel code or statically allocated data structures such as global \r\nvariables. Therefore, syntactically a KQ hijack request is indistin\u0002guishable from normal event handlers. Consider the Registry \r\nOperation Notification Queue as illustration. Using it in defense, \r\nanti-virus software event handlers can detect potential intruder \r\nmalicious activity on the registry. Using it in KQ hijack attack, \r\nPushdo/Cutwail [8] can monitor, block, or modify legitimate regi\u0002stry operations. \r\nSeveral KQ Hijack Attacks by real world malware have been \r\ndocumented. First, rootkits have misused KQs to hide better \r\nagainst discovery. For example, the Rustock.C spam bot relies on \r\ntwo Windows kernel timers [17] to check whether it is being de\u0002bugged/traced [2][15] (e.g., whether KdDebuggerEnabled is true). \r\nSecond, rootkits have misused normal KQ functionality for covert \r\nrootkit operations. For example, Pushdo/Cutwail botnet sets up \r\nthree callback routines by invoking \r\nIoRegisterFsRegistrationChange, CmRegister \r\nCallback, and PsSetCreateProcessNotifyRoutine, \r\nrespectively [8]; these callback routines enable it to monitor file \r\nsystem registrations, monitor, block, or modify a registry opera\u0002tion, and inject a malicious module into a services.exe process. \r\nRustock.C also invokes PsSetCreateProcessNotify \r\nRoutine [7][23] to inject code into seemingly benign processes \r\n(e.g., sevices.exe) so that spamming can be done in the context of \r\nan innocent process. Third, rootkits have misused KQ functionali\u0002ty to attack security products directly. For example, the \r\nStorm/Peacomm spam bot invokes PsSetLoadImageNotify \r\nRoutine to register a malicious callback function that disables \r\nsecurity products when they are loaded [4]. Table 3 shows the KQ \r\nhijack attacks against WRK that we have studied. It is a repre\u0002sentative sample, covering some of the most notorious malware \r\ntoday: the TDSS botnet consists of 4.5 million infected machines \r\nand is considered the most sophisticated threat [11], and Duqu \r\n[12] is believed to be closely related to the widespread Stuxnet \r\nworm [29]. Undoubtedly, KQ Hijack Attacks represent a clear \r\nand present danger to current OS kernels. \r\n2.2 KQ Hijack Attack Model \r\nThe KQ hijack malware listed in Table 3 misuse KQs in a \r\nstraightforward way. They prepare a malicious function in kernel \r\nspace and use its address as the callback function pointer in a KQ \r\nrequest. We call these callback-into-malware attacks. Since their \r\nmalicious functions must be injected somewhere in kernel space, \r\ncallback-into-malware attacks can be detected by runtime kernel \r\ncode integrity checkers such as SecVisor [25] or NICKLE [24]. \r\nCallback-into-malware is considered the basic level of attack, \r\nwhich may be countered by current defense techniques. \r\nUnfortunately, sophisticated attack technology already developed \r\nis able to bypass the detection of standalone malware, e.g., “re\u0002turn-into-libc” attacks [27][30] that use snippets of legitimate \r\nkernel code to achieve their malicious intent. The second level of \r\nKQ hijack attacks, called callback-into-libc (in analogy to return\u0002into-libc), create a malicious callback request containing a legiti\u0002mate event handler, but invoked with malicious input parameters. \r\nWhen activated, the event handler may carry out unintended ac\u0002tions on behalf of the attacker. \r\nCallback-into-libc KQ hijack attacks represent a new and interest\u0002ing challenge, since they allow an attacker to execute malicious \r\nlogic without injecting his own code. To demonstrate the feasi\u0002bility of callback-into-libc attacks, we developed a prototype KQ \r\nhijack program that only uses legitimate kernel code to bypass \r\nSELinux. In recent Linux kernels [26], SELinux has been imple\u0002mented as a Linux Security Module (LSM). SELinux registers its \r\nsecurity auditing functions through the register_security\r\nfacility, which fills a global variable called security_ops\r\nwith SELinux functions. Since there is a legitimate function \r\nreset_security_ops that overwrites security_ops to \r\nthe initial value that points to another global data structure called \r\ndefault_security_ops that does no security auditing, our \r\nprototype KQ hijack program inserts a soft timer request with \r\nreset_security_ops as the callback function. When this \r\nsoft timer expires, reset_security_ops is invoked and SE\u0002Linux is turned off. \r\nThe design of KQguard in the next section shows how we can \r\ndetect both the basic level (callback-into-malware) and the second \r\nlevel (callback-into-libc) KQ hijack attacks. \r\n2.3 Design Requirements in KQ Defense \r\nAn effective KQ defense should satisfy five requirements, i.e., \r\nefficiency, effectiveness, coverage, extensibility, and inclusive\u0002ness. In this section, we outline the reasons some previous tech\u0002niques may solve specific problems, but have difficulties with \r\nsatisfying all five requirements. At the same time, we outline the \r\nreasons KQguard satisfies these requirements. A more detailed \r\ndiscussion of related work is in Section 6. \r\nEfficiency. Although some KQs have higher efficiency require\u0002ments than others (e.g., timer interrupts vs. registry operations), it \r\nis important for KQ defenses to minimize their overhead. KQ\u0002guard is designed to protect all KQs (the coverage requirement) \r\nwith low overhead, including the time-sensitive ones. \r\nEffectiveness. KQ defenses should detect all the KQ Hijack At\u0002tacks (zero false negatives) and make no mistakes regarding the \r\nlegitimate event handlers (zero false positives). KQguard is de\u0002signed to achieve this level of precision and recall by focusing on \r\nthe recognition of all legitimate event handlers. \r\nCoverage. It is important for a KQ defense to protect all KQs, not \r\njust the ones under past attacks. Although we do not rule out spe\u0002cialized solutions to protect individual KQs a priori, KQguard is \r\ndesigned to protect all KQs that activate their requests by execut\u0002ing a callback function. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/4e9aaf6e-4cd7-48c8-bc32-541cace41570.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1a3dba3af84c2ec85eca1d2efddbe300c9442e0d778191469ecdaf7a6d0a2d75",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 922
      },
      {
        "segments": [
          {
            "segment_id": "37b2b050-1ae8-4d22-88dc-b02143952f6b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "3 \r\nExtensibility. Due to the rapid proliferation of new devices, it is \r\nimportant for kernel defenses to extend their coverage to protect \r\nthe new drivers. The KQguard design isolates the knowledge on \r\nlegitimate event handlers into a table (the EH-Signature Collec\u0002tion), which is easily extensible. \r\nInclusiveness. A practical concern of commercial kernels is the \r\nprotection of third-party, closed source device drivers. KQguard \r\nuses static analysis when source code is available, and dynamic \r\nanalysis to protect the closed source legitimate drivers. \r\n3. DESIGN OF KQGUARD \r\nIn this section, we describe the design of KQguard as a general \r\nprotection mechanism for the KQ abstract type. The concrete \r\nimplementations (WRK and Linux) are described in Section 4. In \r\nthe rest of the paper, we will refine our terminology slightly. We \r\nwill use the term “event handler” to denote legitimate KQ call\u0002back functions when the context is clear. \r\n3.1 Assumptions and Architecture \r\n3.1.1 Security Assumptions \r\nWe make the following assumptions about the underlying system: \r\n(1) The core kernel and all legitimate device drivers main\u0002tain integrity in both their code and data against tamper\u0002ing by malware. This is a realistic assumption due to ex\u0002isting solutions that can protect/check the data integrity \r\nof legitimate programs [3][6][14][16]. \r\n(2) KQguard code and data (EH-Signature Collection) are \r\nsimilarly protected from tampering by any rootkits in\u0002stalled in the kernel. \r\n(3) KQguard design assumes that detailed information \r\nabout loaded modules (e.g., name and address range) is \r\nmaintained by the kernel and accessible by KQguard. \r\nKernel source code availability is a more complex issue. KQguard \r\nrelies on static analysis of source code to find the KQs and the \r\nevent handlers associated with them. However, to satisfy the in\u0002clusiveness requirement KQguard should provide an alternative \r\nsolution for protecting device drivers for which source code is \r\nunavailable. Thus we have an additional assumption: \r\n(4) A representative and comprehensive workload is avail\u0002able for a training process to find all the legitimate KQ \r\nevent handlers (Section 3.3.4). During the training \r\nprocess, we further assume the system is free of \r\nrootkits. \r\nA limitation of current KQguard implementation (Section 4) is \r\nthat the training process is run only once. Thus the runtime dy\u0002namic loading of legitimate device drivers is supported only par\u0002tially. Namely, new drivers that use known KQ event handlers \r\ncan be dynamically loaded with full protection. Acceptance of \r\nnew drivers that introduce new KQ callback functions (not seen \r\nduring training) is postponed to future work. \r\n3.1.2 KQguard Architecture Overview \r\nThe main function of KQ defense is to decide at runtime whether \r\na callback function in a KQ request is a legitimate event handler \r\nor a malicious KQ hijack attack. KQguard achieves this goal by \r\ncollecting all of the known event handlers into a table (called EH\u0002Signature Collection) and checking the callback function in ques\u0002tion against the EH-Signature Collection. \r\nAlthough the checking decision is superficially similar to that of \r\nanti-virus malware scanners, our approach is fundamentally dif\u0002ferent from, and complementary to, malware scanners. On the one \r\nhand, the construction of signature-based malware scanners is \r\ntypically reactive: samples of malware are needed in order to \r\ndesign their signatures. On the other hand, KQguard is proactive \r\nby identifying the set of legitimate event handlers as a starting \r\npoint. Instead of assuming the unknown to be benign (malware \r\nscanners), KQguard assumes the unknown to be a threat. Conse\u0002quently, KQguard focuses on the legitimate code and it is largely \r\nindependent of any concrete knowledge about the implementation \r\nspecifics of KQ hijack attacks. \r\nKQguard uses a compact and “relocatable” representation of call\u0002back functions (the Callback-Signature, explained in Section 3.2) \r\nfor efficient and effective checking. In the following, we will \r\nrefer to the Callback-Signatures of known legitimate event han\u0002dlers as EH-Signatures. Under the assumption of full kernel \r\nsource code availability and without concern for inclusion of \r\nclosed source device drivers, we could use static analysis of the \r\nentire source code (kernel + drivers) to find all the EH-Signatures. \r\nHowever, this assumption is not always satisfied in practice. \r\nTo relax the full kernel source code availability assumption, we \r\nadopt dynamic analysis. Figure 2 shows the two-phase KQguard \r\napproach, based on dynamic analysis to satisfy the inclusiveness \r\nrequirement (which avoids the source code assumption). In the \r\nfirst (training) phase, we collect all the legitimate EH-Signatures \r\nused by the system into the EH-Signature Collection (Section \r\n3.3). Under the assumption of training in a controlled environ\u0002ment free of rootkits, no malware callback-signature will be gen\u0002erated, so we can guarantee zero false negatives in the second \r\n(guarding) phase. In addition, under the assumption of having a \r\nrepresentative and comprehensive workload, dynamic analysis \r\nwould also produce a complete EH-Signature Collection. Our \r\nexperimental evaluation shows that it is feasible to reduce the \r\nfalse positives to zero and thus confirms the reasonableness of \r\nworkload assumption. \r\nThe actual validation of callback functions requires simple but \r\nextensive kernel instrumentation. Conceptually, every KQ dis\u0002patcher needs to check every callback function invocation before \r\nexecution. Section 3.4 describes the non-trivial search for all the \r\nlocations of these simple changes. Concretely, we use static anal\u0002ysis of kernel code to find all the KQ dispatchers, which is anoth\u0002er necessary condition for zero false negatives. \r\nFigure 2: Overall Architecture of KQguard ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/37b2b050-1ae8-4d22-88dc-b02143952f6b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cb8c8c104cd51613f1000388d7a76cc88a7809f20812722a10c4be29b045e02f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 852
      },
      {
        "segments": [
          {
            "segment_id": "37b2b050-1ae8-4d22-88dc-b02143952f6b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "3 \r\nExtensibility. Due to the rapid proliferation of new devices, it is \r\nimportant for kernel defenses to extend their coverage to protect \r\nthe new drivers. The KQguard design isolates the knowledge on \r\nlegitimate event handlers into a table (the EH-Signature Collec\u0002tion), which is easily extensible. \r\nInclusiveness. A practical concern of commercial kernels is the \r\nprotection of third-party, closed source device drivers. KQguard \r\nuses static analysis when source code is available, and dynamic \r\nanalysis to protect the closed source legitimate drivers. \r\n3. DESIGN OF KQGUARD \r\nIn this section, we describe the design of KQguard as a general \r\nprotection mechanism for the KQ abstract type. The concrete \r\nimplementations (WRK and Linux) are described in Section 4. In \r\nthe rest of the paper, we will refine our terminology slightly. We \r\nwill use the term “event handler” to denote legitimate KQ call\u0002back functions when the context is clear. \r\n3.1 Assumptions and Architecture \r\n3.1.1 Security Assumptions \r\nWe make the following assumptions about the underlying system: \r\n(1) The core kernel and all legitimate device drivers main\u0002tain integrity in both their code and data against tamper\u0002ing by malware. This is a realistic assumption due to ex\u0002isting solutions that can protect/check the data integrity \r\nof legitimate programs [3][6][14][16]. \r\n(2) KQguard code and data (EH-Signature Collection) are \r\nsimilarly protected from tampering by any rootkits in\u0002stalled in the kernel. \r\n(3) KQguard design assumes that detailed information \r\nabout loaded modules (e.g., name and address range) is \r\nmaintained by the kernel and accessible by KQguard. \r\nKernel source code availability is a more complex issue. KQguard \r\nrelies on static analysis of source code to find the KQs and the \r\nevent handlers associated with them. However, to satisfy the in\u0002clusiveness requirement KQguard should provide an alternative \r\nsolution for protecting device drivers for which source code is \r\nunavailable. Thus we have an additional assumption: \r\n(4) A representative and comprehensive workload is avail\u0002able for a training process to find all the legitimate KQ \r\nevent handlers (Section 3.3.4). During the training \r\nprocess, we further assume the system is free of \r\nrootkits. \r\nA limitation of current KQguard implementation (Section 4) is \r\nthat the training process is run only once. Thus the runtime dy\u0002namic loading of legitimate device drivers is supported only par\u0002tially. Namely, new drivers that use known KQ event handlers \r\ncan be dynamically loaded with full protection. Acceptance of \r\nnew drivers that introduce new KQ callback functions (not seen \r\nduring training) is postponed to future work. \r\n3.1.2 KQguard Architecture Overview \r\nThe main function of KQ defense is to decide at runtime whether \r\na callback function in a KQ request is a legitimate event handler \r\nor a malicious KQ hijack attack. KQguard achieves this goal by \r\ncollecting all of the known event handlers into a table (called EH\u0002Signature Collection) and checking the callback function in ques\u0002tion against the EH-Signature Collection. \r\nAlthough the checking decision is superficially similar to that of \r\nanti-virus malware scanners, our approach is fundamentally dif\u0002ferent from, and complementary to, malware scanners. On the one \r\nhand, the construction of signature-based malware scanners is \r\ntypically reactive: samples of malware are needed in order to \r\ndesign their signatures. On the other hand, KQguard is proactive \r\nby identifying the set of legitimate event handlers as a starting \r\npoint. Instead of assuming the unknown to be benign (malware \r\nscanners), KQguard assumes the unknown to be a threat. Conse\u0002quently, KQguard focuses on the legitimate code and it is largely \r\nindependent of any concrete knowledge about the implementation \r\nspecifics of KQ hijack attacks. \r\nKQguard uses a compact and “relocatable” representation of call\u0002back functions (the Callback-Signature, explained in Section 3.2) \r\nfor efficient and effective checking. In the following, we will \r\nrefer to the Callback-Signatures of known legitimate event han\u0002dlers as EH-Signatures. Under the assumption of full kernel \r\nsource code availability and without concern for inclusion of \r\nclosed source device drivers, we could use static analysis of the \r\nentire source code (kernel + drivers) to find all the EH-Signatures. \r\nHowever, this assumption is not always satisfied in practice. \r\nTo relax the full kernel source code availability assumption, we \r\nadopt dynamic analysis. Figure 2 shows the two-phase KQguard \r\napproach, based on dynamic analysis to satisfy the inclusiveness \r\nrequirement (which avoids the source code assumption). In the \r\nfirst (training) phase, we collect all the legitimate EH-Signatures \r\nused by the system into the EH-Signature Collection (Section \r\n3.3). Under the assumption of training in a controlled environ\u0002ment free of rootkits, no malware callback-signature will be gen\u0002erated, so we can guarantee zero false negatives in the second \r\n(guarding) phase. In addition, under the assumption of having a \r\nrepresentative and comprehensive workload, dynamic analysis \r\nwould also produce a complete EH-Signature Collection. Our \r\nexperimental evaluation shows that it is feasible to reduce the \r\nfalse positives to zero and thus confirms the reasonableness of \r\nworkload assumption. \r\nThe actual validation of callback functions requires simple but \r\nextensive kernel instrumentation. Conceptually, every KQ dis\u0002patcher needs to check every callback function invocation before \r\nexecution. Section 3.4 describes the non-trivial search for all the \r\nlocations of these simple changes. Concretely, we use static anal\u0002ysis of kernel code to find all the KQ dispatchers, which is anoth\u0002er necessary condition for zero false negatives. \r\nFigure 2: Overall Architecture of KQguard ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/37b2b050-1ae8-4d22-88dc-b02143952f6b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cb8c8c104cd51613f1000388d7a76cc88a7809f20812722a10c4be29b045e02f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 852
      },
      {
        "segments": [
          {
            "segment_id": "6fa5ab2d-f928-43df-9180-818f99002b15",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "4 \r\n3.2 Callback-Signature Abstract Data Type \r\nThe central data structure of KQguard is the Callback-Signature, \r\nan efficient and effective representation of callback functions for \r\nchecking. At an abstract level, the Callback-Signature of a KQ is \r\na symbolic pair (callback_function, callback_parameters). For \r\nclarity, we use the term EH-Signature to denote known Callback\u0002Signatures of legitimate event handlers. \r\nFor different concrete types of KQ (e.g., timer_list in Figure 3), \r\nthe syntax and semantics of their Callback-Signatures may vary, \r\nbut their function is the same: to contain sufficient information to \r\nidentify a legitimate KQ request with a known callback function. \r\nThe two parts of Callback-Signature reflect the two attack modes \r\ndescribed in Section 2.2. The callback_function part of Callback\u0002Signature is used to protect the kernel against callback-into\u0002malware. Both callback-function and callback_parameters parts \r\nare used to protect the kernel against callback-into-libc attacks. \r\nTo achieve efficient and effective checking, the Callback\u0002Signature from a KQ request is generated at runtime and matched \r\nagainst the set of EH-Signatures generated in the training phase. \r\nWe describe first the callback-function part of the Callback\u0002Signature. The starting value is a physical address of an executa\u0002ble. Since a module’s physical addresses from different reboots \r\nare unlikely to match, we perform a translation process that can \r\nbe called “de-linking”: it translates a linked callback function \r\npointer back into the location-independent “object code” format \r\nprior to becoming linked into kernel memory. The callback\u0002function pointer is translated back into module name and then a \r\nunique module ID, plus the displacement relative to the starting \r\npoint of its containing module (usually a device driver). Under the \r\nassumption that the kernel maintains a uniform mapping of mod\u0002ule location to module ID (e.g., driver’s name), the pair (module \r\nID, displacement) becomes an invariant representation of the \r\ncallback-function pointer, suitable for KQguard checking. \r\nThe translation of the second part (callback_parameters) is more \r\ninvolved, since it may contain up to three sub-types: actual val\u0002ues, global variables, and heap objects. Actual values are non\u0002pointer types such as integers, which require no translation. Glob\u0002al variables are pointers to kernel shared variables (Figure 4.a), \r\nand they are translated to a pair (module ID, displacement) the \r\nsame way as the callback-function. Heap objects (Figure 4.b) \r\ncould have been translated similarly, if the mapping between a \r\nheap object and its allocator is maintained by the kernel. \r\nSince most kernels do not maintain the mapping between the re\u0002quester and its allocated heap objects, we add this mapping to \r\ntheir heap allocator function (e.g., ExAllocatePoolWithTag\r\nin WRK). Specifically, the extended heap allocator function \r\nsearches the call stack backwards until it reaches a return address \r\nthat falls within the code segment of a device driver; then such a \r\nreturn address (after subtracting from it the starting address of the \r\ndevice driver) becomes the displacement part of the heap object \r\nrepresentation. The extended heap allocator searches backwards \r\non the call stack instead of stopping at the immediate return ad\u0002dress because the immediate return address may be in some wrap\u0002per function for the heap allocation function (e.g., in WRK, \r\nExAllocatePoolWithTag is called by \r\nObpAllocateObject), and this kind of chained function call \r\ncan continue (see an example in Figure 5); a kernel device driver \r\ncan call a function at the top of the call chain to allocate a heap \r\nobject (for example, atapi.sys calls IoCreateDevice to \r\ncreate a heap object). \r\nIn summary, the design goal of Callback-Signature is to support \r\nan efficient and effective runtime determination of the legitimacy \r\nof callback functions. The callback-function part detects callback\u0002intro-malware attacks while the callback-parameters part detects \r\ncallback-into-libc attacks. \r\nFigure 4: Illustration of Different Origins of call\u0002back_parameters: (a) Global Variable; (b) Heap Variable \r\n3.3 Building the EH-Signature Collection \r\n3.3.1 Design Requirements \r\nThe next step in the construction of KQguard defense is to collect \r\nthe legitimate EH-Signatures. The set of all EH-Signatures forms \r\nthe EH-Signature Collection. The challenge of building the EH\u0002Signature Collection is to find the exact set of legitimate EH\u0002Signatures. In the process of distinguishing malware Callback\u0002Signatures from legitimate EH-Signatures, missing an EH\u0002Signature causes false positives, denying the execution of a legi\u0002timate KQ request. Worse yet, including a malware Callback\u0002Signature into the EH-Signature Collection causes false negatives, \r\nallowing malware to execute. \r\nFigure 5: Indirect Heap Object Allocation in a Call Stack \r\nIn an ideal kernel development environment, one could imagine \r\nannotating the entire kernel and all device driver code to make \r\nKQs explicit, e.g., by defining a KQ abstract type. Processing the \r\nKQ annotations in the complete source code will give us the exact \r\nEH-Signature Collection. There are several reasons this ideal \r\nscenario is unlikely to happen. First, there are many third-party \r\nclosed source device drivers that are unlikely to share their source \r\ncode. Second, it is likely that human errors will be introduced in \r\nthe large number of lines of kernel code, currently on the order of \r\nmillions. Third, it is likely that most OS kernel builds will only \r\ncontain a small subset of all device drivers, making it unwieldy to \r\ninclude all possible EH-Signatures in all systems. \r\nOur design decision is to build software tools to automate the \r\nprocess of obtaining a specialized EH-Signature Collection that \r\nfits the configuration and usage of each system. In a training \r\nstruct timer_list { \r\n struct list_head list; \r\n unsigned long expires; \r\n unsigned long data; \r\n void (*function)(unsigned long); \r\n}; \r\nFigure 3: The Definition of timer_list in Linux Kernel 2.4 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/6fa5ab2d-f928-43df-9180-818f99002b15.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a8292227d3e93c4399457351c2c11eba9f63cf6ec7bf99d89c5b347539a964e7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 881
      },
      {
        "segments": [
          {
            "segment_id": "6fa5ab2d-f928-43df-9180-818f99002b15",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "4 \r\n3.2 Callback-Signature Abstract Data Type \r\nThe central data structure of KQguard is the Callback-Signature, \r\nan efficient and effective representation of callback functions for \r\nchecking. At an abstract level, the Callback-Signature of a KQ is \r\na symbolic pair (callback_function, callback_parameters). For \r\nclarity, we use the term EH-Signature to denote known Callback\u0002Signatures of legitimate event handlers. \r\nFor different concrete types of KQ (e.g., timer_list in Figure 3), \r\nthe syntax and semantics of their Callback-Signatures may vary, \r\nbut their function is the same: to contain sufficient information to \r\nidentify a legitimate KQ request with a known callback function. \r\nThe two parts of Callback-Signature reflect the two attack modes \r\ndescribed in Section 2.2. The callback_function part of Callback\u0002Signature is used to protect the kernel against callback-into\u0002malware. Both callback-function and callback_parameters parts \r\nare used to protect the kernel against callback-into-libc attacks. \r\nTo achieve efficient and effective checking, the Callback\u0002Signature from a KQ request is generated at runtime and matched \r\nagainst the set of EH-Signatures generated in the training phase. \r\nWe describe first the callback-function part of the Callback\u0002Signature. The starting value is a physical address of an executa\u0002ble. Since a module’s physical addresses from different reboots \r\nare unlikely to match, we perform a translation process that can \r\nbe called “de-linking”: it translates a linked callback function \r\npointer back into the location-independent “object code” format \r\nprior to becoming linked into kernel memory. The callback\u0002function pointer is translated back into module name and then a \r\nunique module ID, plus the displacement relative to the starting \r\npoint of its containing module (usually a device driver). Under the \r\nassumption that the kernel maintains a uniform mapping of mod\u0002ule location to module ID (e.g., driver’s name), the pair (module \r\nID, displacement) becomes an invariant representation of the \r\ncallback-function pointer, suitable for KQguard checking. \r\nThe translation of the second part (callback_parameters) is more \r\ninvolved, since it may contain up to three sub-types: actual val\u0002ues, global variables, and heap objects. Actual values are non\u0002pointer types such as integers, which require no translation. Glob\u0002al variables are pointers to kernel shared variables (Figure 4.a), \r\nand they are translated to a pair (module ID, displacement) the \r\nsame way as the callback-function. Heap objects (Figure 4.b) \r\ncould have been translated similarly, if the mapping between a \r\nheap object and its allocator is maintained by the kernel. \r\nSince most kernels do not maintain the mapping between the re\u0002quester and its allocated heap objects, we add this mapping to \r\ntheir heap allocator function (e.g., ExAllocatePoolWithTag\r\nin WRK). Specifically, the extended heap allocator function \r\nsearches the call stack backwards until it reaches a return address \r\nthat falls within the code segment of a device driver; then such a \r\nreturn address (after subtracting from it the starting address of the \r\ndevice driver) becomes the displacement part of the heap object \r\nrepresentation. The extended heap allocator searches backwards \r\non the call stack instead of stopping at the immediate return ad\u0002dress because the immediate return address may be in some wrap\u0002per function for the heap allocation function (e.g., in WRK, \r\nExAllocatePoolWithTag is called by \r\nObpAllocateObject), and this kind of chained function call \r\ncan continue (see an example in Figure 5); a kernel device driver \r\ncan call a function at the top of the call chain to allocate a heap \r\nobject (for example, atapi.sys calls IoCreateDevice to \r\ncreate a heap object). \r\nIn summary, the design goal of Callback-Signature is to support \r\nan efficient and effective runtime determination of the legitimacy \r\nof callback functions. The callback-function part detects callback\u0002intro-malware attacks while the callback-parameters part detects \r\ncallback-into-libc attacks. \r\nFigure 4: Illustration of Different Origins of call\u0002back_parameters: (a) Global Variable; (b) Heap Variable \r\n3.3 Building the EH-Signature Collection \r\n3.3.1 Design Requirements \r\nThe next step in the construction of KQguard defense is to collect \r\nthe legitimate EH-Signatures. The set of all EH-Signatures forms \r\nthe EH-Signature Collection. The challenge of building the EH\u0002Signature Collection is to find the exact set of legitimate EH\u0002Signatures. In the process of distinguishing malware Callback\u0002Signatures from legitimate EH-Signatures, missing an EH\u0002Signature causes false positives, denying the execution of a legi\u0002timate KQ request. Worse yet, including a malware Callback\u0002Signature into the EH-Signature Collection causes false negatives, \r\nallowing malware to execute. \r\nFigure 5: Indirect Heap Object Allocation in a Call Stack \r\nIn an ideal kernel development environment, one could imagine \r\nannotating the entire kernel and all device driver code to make \r\nKQs explicit, e.g., by defining a KQ abstract type. Processing the \r\nKQ annotations in the complete source code will give us the exact \r\nEH-Signature Collection. There are several reasons this ideal \r\nscenario is unlikely to happen. First, there are many third-party \r\nclosed source device drivers that are unlikely to share their source \r\ncode. Second, it is likely that human errors will be introduced in \r\nthe large number of lines of kernel code, currently on the order of \r\nmillions. Third, it is likely that most OS kernel builds will only \r\ncontain a small subset of all device drivers, making it unwieldy to \r\ninclude all possible EH-Signatures in all systems. \r\nOur design decision is to build software tools to automate the \r\nprocess of obtaining a specialized EH-Signature Collection that \r\nfits the configuration and usage of each system. In a training \r\nstruct timer_list { \r\n struct list_head list; \r\n unsigned long expires; \r\n unsigned long data; \r\n void (*function)(unsigned long); \r\n}; \r\nFigure 3: The Definition of timer_list in Linux Kernel 2.4 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/6fa5ab2d-f928-43df-9180-818f99002b15.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a8292227d3e93c4399457351c2c11eba9f63cf6ec7bf99d89c5b347539a964e7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 881
      },
      {
        "segments": [
          {
            "segment_id": "79ba661f-f56b-4320-986d-28e9d6195144",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "5 \r\nphase, we run representative and comprehensive workloads. Un\u0002der the assumption that the training is done in a secure environ\u0002ment, we consider all the KQ requests made as legitimate and \r\ninclude them into the EH-Signature Collection. \r\n3.3.2 Constructing Callback-Signatures \r\nThe software tools used in the building of general Callback\u0002Signatures and EH-Signatures in particular are small extensions of \r\nkernel facilities that manipulate KQs: KQ request creation, KQ \r\nrequest initialization, and KQ request dispatch. These are APIs \r\nprovided by the core kernel for the device drivers. We extend \r\nthese kernel calls with a KQ request logging utility, which records \r\nevery KQ request mentioned in the legitimate kernel and device \r\ndrivers. This happens because during the training phase our goal \r\nis to approach the complete coverage as much as possible. \r\nConcrete examples of other useful kernel functions include device \r\ndriver loader functions, which are extended to log address range \r\ninformation about loaded device drivers. They help us “de-link” \r\n(Section 3.2) the physical address in the Callback-Signature and \r\nmap it back to its originating device driver. Similarly, the heap \r\nallocation functions are extended to provide allocation ranges of \r\ndevice driver requests of heap objects. \r\nIn general, the information contained in Callback-Signatures is \r\nreadily available in the kernel, although the precise location of \r\nsuch information may differ from kernel to kernel. It is a matter of \r\nidentifying the appropriate location to instrument the kernel to \r\nextract the necessary information. The extensions are applied to \r\nthe kernel at source code level. The instrumented kernel is then \r\nrebuilt for the Callback-Signature collection process. \r\n3.3.3 Automated Detection of KQs \r\nSince every KQ can be exploited by malware, we need to build \r\nthe EH-Signatures for all of KQs. This is straightforward for \r\nknown KQs that have published APIs and source code as outlined \r\nin Section 3.3.2. Under the hypothesis that a system software \r\nprovider can apply our method and tools to protect all KQs in a \r\nkernel, we can claim the completeness of our proposed solution. \r\nOn the other hand, for the purposes of our research, it is still im\u0002portant to find out the KQs in a large kernel such as WRK and \r\nLinux for several reasons. First, we need to evaluate the impor\u0002tance and potential impact of the KQ exploitation, which is re\u0002lated to the quantity and variety of KQs present in a kernel (the \r\nattack surface). Second, we want to demonstrate the effectiveness \r\nof KQguard for a realistic set of KQs. Third, by calling attention \r\nof the research community to the named KQs, we may be able to \r\nfind additional KQ exploits that have not been identified so far. \r\nTherefore, we designed and implemented a KQ discovery tool \r\nthat automates the process of finding KQs in a kernel by analyz\u0002ing its source code. Since kernel programmers are not intentional\u0002ly hiding KQs, they usually follow similar programming patterns \r\nthat our tool uses effectively: \r\n- A KQ is typically implemented as a linked list or an array. In \r\naddition to insert/delete, KQ has a dispatcher that operates on \r\nthe corresponding type. \r\n- A KQ dispatcher usually contains a loop to act upon on all or a \r\nsubset of queue elements. For example, pm_send_all in Fig\u0002ure 7 contains the dispatcher loop for the Power Management \r\nNotification queue of Linux kernel 2.4.32. \r\n- A KQ dispatcher usually changes the kernel control flow, e.g., \r\ninvoking a callback function contained in a queue element. \r\nBased on the above analysis, the KQ discovery tool recognizes a \r\nKQ in several steps. It starts by detecting a loop that iterates \r\nthrough a candidate data structure. Then it checks whether a \r\nqueue element is derived and acted upon inside the loop. Next, \r\nour tool marks the derived queue element as a taint source and \r\nperforms a flow-sensitive taint propagation through the rest of the \r\nloop body; this part is flow-sensitive because it propagates taint \r\ninto downstream functions through parameters (e.g., dev passed \r\nfrom pm_send_all to pm_send in Figure 7). During the prop\u0002agation, our tool checks whether any tainted function pointer is \r\ninvoked (e.g., dev->callback in pm_send in Figure 7), and \r\nif that is the case, it reports a candidate KQ. Pseudo code of our \r\nKQ discovery algorithm is shown in Figure 6. Due to space con\u0002straints we omit further details, but the results (e.g., KQs found in \r\nWRK) are interesting and shown in Sections 4.1.2 and 4.2.2. \r\n3.3.4 Dynamic Profiling to Collect EH-Signatures \r\nUnder the assumption of full kernel source code access, we can \r\ngenerate the code for building the EH-Signature for all known \r\nKQs. By finding all the KQ invocations, theoretically we will be \r\nable to build corresponding EH-Signatures. Unfortunately, this \r\nmethod requires the source code of third-party device drivers, \r\nwhich often are unavailable. \r\nInstead of relying on the full source code access assumption, we \r\nchose to relax this assumption by adopting a practical method \r\nbased on dynamic profiling. We run a set of representative set of \r\nbenchmark applications using a comprehensive workload. We call \r\nthis process of collecting the EH-Signatures “training phase”, \r\nsince it is somewhat reminiscent of training a filter in machine \r\nlearning. During the training phase, the kernel extensions de\u0002scribed in Section 3.3.2 is triggered by every KQ request and \r\nlogged. \r\nTo avoid false negatives in KQguard, the training phase is per\u0002formed in a controlled environment (a clean and instrumented set \r\nof kernel and device drivers) to ensure no malware Callback\u0002Signatures are included. To avoid false positives, the training \r\nphase needs to be comprehensive enough to trigger all of the \r\nFor each function, \r\n For each while or for loop in that function, \r\nFor each assignment statement L = R_exp inside the loop, \r\n if R_exp satisfies either of the following conditions: \r\n- it is an array element Ar[i] and Ar is a global array \r\nwith a non-primitive element type (e.g., a structure or a \r\nfunction pointer), \r\n- it is a type casting (T) rr_exp, T is a structure type \r\nthat has a link field (e.g., a pointer to its own type, or \r\nLIST_ENTRY) and rr_exp contains a pointer arithmet\u0002ic operation, \r\nthen, (1) set L as a tainted variable and perform a transitive \r\ntaint analysis through the rest of the loop body; (2) if dur\u0002ing the taint analysis, some tainted function pointer is in\u0002voked, report the top-level data structure (e.g., Ar[] or \r\nrr_exp) as a potential KQ. \r\nFigure 6: KQ Detection Algorithm ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/79ba661f-f56b-4320-986d-28e9d6195144.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3a0fc845ab7b6000a87dc1a2f6a56d041d0006a86b85c38bf69b8b591fd46d9a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1047
      },
      {
        "segments": [
          {
            "segment_id": "79ba661f-f56b-4320-986d-28e9d6195144",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "5 \r\nphase, we run representative and comprehensive workloads. Un\u0002der the assumption that the training is done in a secure environ\u0002ment, we consider all the KQ requests made as legitimate and \r\ninclude them into the EH-Signature Collection. \r\n3.3.2 Constructing Callback-Signatures \r\nThe software tools used in the building of general Callback\u0002Signatures and EH-Signatures in particular are small extensions of \r\nkernel facilities that manipulate KQs: KQ request creation, KQ \r\nrequest initialization, and KQ request dispatch. These are APIs \r\nprovided by the core kernel for the device drivers. We extend \r\nthese kernel calls with a KQ request logging utility, which records \r\nevery KQ request mentioned in the legitimate kernel and device \r\ndrivers. This happens because during the training phase our goal \r\nis to approach the complete coverage as much as possible. \r\nConcrete examples of other useful kernel functions include device \r\ndriver loader functions, which are extended to log address range \r\ninformation about loaded device drivers. They help us “de-link” \r\n(Section 3.2) the physical address in the Callback-Signature and \r\nmap it back to its originating device driver. Similarly, the heap \r\nallocation functions are extended to provide allocation ranges of \r\ndevice driver requests of heap objects. \r\nIn general, the information contained in Callback-Signatures is \r\nreadily available in the kernel, although the precise location of \r\nsuch information may differ from kernel to kernel. It is a matter of \r\nidentifying the appropriate location to instrument the kernel to \r\nextract the necessary information. The extensions are applied to \r\nthe kernel at source code level. The instrumented kernel is then \r\nrebuilt for the Callback-Signature collection process. \r\n3.3.3 Automated Detection of KQs \r\nSince every KQ can be exploited by malware, we need to build \r\nthe EH-Signatures for all of KQs. This is straightforward for \r\nknown KQs that have published APIs and source code as outlined \r\nin Section 3.3.2. Under the hypothesis that a system software \r\nprovider can apply our method and tools to protect all KQs in a \r\nkernel, we can claim the completeness of our proposed solution. \r\nOn the other hand, for the purposes of our research, it is still im\u0002portant to find out the KQs in a large kernel such as WRK and \r\nLinux for several reasons. First, we need to evaluate the impor\u0002tance and potential impact of the KQ exploitation, which is re\u0002lated to the quantity and variety of KQs present in a kernel (the \r\nattack surface). Second, we want to demonstrate the effectiveness \r\nof KQguard for a realistic set of KQs. Third, by calling attention \r\nof the research community to the named KQs, we may be able to \r\nfind additional KQ exploits that have not been identified so far. \r\nTherefore, we designed and implemented a KQ discovery tool \r\nthat automates the process of finding KQs in a kernel by analyz\u0002ing its source code. Since kernel programmers are not intentional\u0002ly hiding KQs, they usually follow similar programming patterns \r\nthat our tool uses effectively: \r\n- A KQ is typically implemented as a linked list or an array. In \r\naddition to insert/delete, KQ has a dispatcher that operates on \r\nthe corresponding type. \r\n- A KQ dispatcher usually contains a loop to act upon on all or a \r\nsubset of queue elements. For example, pm_send_all in Fig\u0002ure 7 contains the dispatcher loop for the Power Management \r\nNotification queue of Linux kernel 2.4.32. \r\n- A KQ dispatcher usually changes the kernel control flow, e.g., \r\ninvoking a callback function contained in a queue element. \r\nBased on the above analysis, the KQ discovery tool recognizes a \r\nKQ in several steps. It starts by detecting a loop that iterates \r\nthrough a candidate data structure. Then it checks whether a \r\nqueue element is derived and acted upon inside the loop. Next, \r\nour tool marks the derived queue element as a taint source and \r\nperforms a flow-sensitive taint propagation through the rest of the \r\nloop body; this part is flow-sensitive because it propagates taint \r\ninto downstream functions through parameters (e.g., dev passed \r\nfrom pm_send_all to pm_send in Figure 7). During the prop\u0002agation, our tool checks whether any tainted function pointer is \r\ninvoked (e.g., dev->callback in pm_send in Figure 7), and \r\nif that is the case, it reports a candidate KQ. Pseudo code of our \r\nKQ discovery algorithm is shown in Figure 6. Due to space con\u0002straints we omit further details, but the results (e.g., KQs found in \r\nWRK) are interesting and shown in Sections 4.1.2 and 4.2.2. \r\n3.3.4 Dynamic Profiling to Collect EH-Signatures \r\nUnder the assumption of full kernel source code access, we can \r\ngenerate the code for building the EH-Signature for all known \r\nKQs. By finding all the KQ invocations, theoretically we will be \r\nable to build corresponding EH-Signatures. Unfortunately, this \r\nmethod requires the source code of third-party device drivers, \r\nwhich often are unavailable. \r\nInstead of relying on the full source code access assumption, we \r\nchose to relax this assumption by adopting a practical method \r\nbased on dynamic profiling. We run a set of representative set of \r\nbenchmark applications using a comprehensive workload. We call \r\nthis process of collecting the EH-Signatures “training phase”, \r\nsince it is somewhat reminiscent of training a filter in machine \r\nlearning. During the training phase, the kernel extensions de\u0002scribed in Section 3.3.2 is triggered by every KQ request and \r\nlogged. \r\nTo avoid false negatives in KQguard, the training phase is per\u0002formed in a controlled environment (a clean and instrumented set \r\nof kernel and device drivers) to ensure no malware Callback\u0002Signatures are included. To avoid false positives, the training \r\nphase needs to be comprehensive enough to trigger all of the \r\nFor each function, \r\n For each while or for loop in that function, \r\nFor each assignment statement L = R_exp inside the loop, \r\n if R_exp satisfies either of the following conditions: \r\n- it is an array element Ar[i] and Ar is a global array \r\nwith a non-primitive element type (e.g., a structure or a \r\nfunction pointer), \r\n- it is a type casting (T) rr_exp, T is a structure type \r\nthat has a link field (e.g., a pointer to its own type, or \r\nLIST_ENTRY) and rr_exp contains a pointer arithmet\u0002ic operation, \r\nthen, (1) set L as a tainted variable and perform a transitive \r\ntaint analysis through the rest of the loop body; (2) if dur\u0002ing the taint analysis, some tainted function pointer is in\u0002voked, report the top-level data structure (e.g., Ar[] or \r\nrr_exp) as a potential KQ. \r\nFigure 6: KQ Detection Algorithm ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/79ba661f-f56b-4320-986d-28e9d6195144.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3a0fc845ab7b6000a87dc1a2f6a56d041d0006a86b85c38bf69b8b591fd46d9a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1047
      },
      {
        "segments": [
          {
            "segment_id": "1088bf52-6a5e-40f6-b12f-c02716fcd478",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "6 \r\n/* linux-2.4.32/kernel/pm.c */ \r\nint pm_send_all (pm_request_t rqst, void *data) \r\n{ \r\n struct list_head *entry; \r\n entry = pm_devs.next; \r\n while (entry != &pm_devs) { \r\n struct pm_dev *dev = list_entry(entry, \r\nstruct pm_dev, entry); \r\n if (dev->callback) { \r\n int status = pm_send(dev, rqst, data); \r\n …… \r\n } \r\n entry = entry->next; \r\n } \r\n …… \r\n return 0; \r\n} \r\nstruct pm_dev \r\n{ pm_dev_t type; \r\n unsigned long id; \r\n pm_callback callback; \r\n …… \r\n struct list_head entry; \r\n}; \r\n/* linux-2.4.32/kernel/pm.c */ \r\nstatic LIST_HEAD(pm_devs); \r\nstruct pm_dev *pm_register(pm_dev_t \r\ntype, unsigned long id, pm_callback call\u0002back) \r\n{ \r\n struct pm_dev *dev = kmalloc (sizeof \r\n(struct pm_dev), GFP_KERNEL); \r\n if (dev) { \r\n memset(dev, 0, sizeof(*dev)); \r\n dev->type = type; \r\n dev->id = id; \r\n dev->callback = callback; \r\n list_add(&dev->entry, \r\n&pm_devs); \r\n } \r\n return dev; \r\n} \r\n/* linux-2.4.32/kernel/pm.c */ \r\nint pm_send(struct pm_dev *dev, \r\npm_request_t rqst, void *data) \r\n{ …… \r\n if (prev_state != next_state){ \r\n…… \r\n status = (*dev->callback) (dev, \r\nrqst, data); \r\n …… \r\n } …… \r\n} \r\nFigure 7: Details of the Power Management Notification Queue on Linux Kernel 2.4.32 \r\nlegitimate KQ requests. In practice, we expect an OS software \r\nvendor (e.g., Microsoft), a capable system software reseller (e.g., \r\nRed Hat), or a reputable software validator (e.g., a software secu\u0002rity company) to perform the training phase, which is similar to \r\n(and uses the same tools of) the comprehensive testing before a \r\nrelease. As in all software testing, missing some execution paths \r\nmay introduce false positives when a previously unseen Callback\u0002Signature is triggered during runtime. We note that our coverage \r\nrequirements are significantly less than software correctness test\u0002ing, since we only need to trigger each execution path that in\u0002vokes a KQ request once, not the entire input space. \r\nIn our experiments, we approximate the software validation \r\nprocess in two ways. First, we choose a representative set of \r\nbenchmark programs (e.g., PerformanceTest, Super PI, and \r\nIozone). Second, in addition to the test input, we also run the in\u0002strumented kernel during normal usage, including rebooting the \r\nOS. Our evaluation (Section 5) shows a very low false positive \r\nrate, indicating the feasibility of the dynamic profiling method. In \r\ngeneral, the issue of test coverage for large scale software without \r\nsource code is a significant challenge and beyond the scope of this \r\npaper. \r\n3.4 Validation Using EH-Signature Collection \r\nWe modify the dispatcher of every identified KQ so that the dis\u0002patcher checks the legitimacy of a pending KQ request before \r\ninvoking the call back function. To perform the check, the dis\u0002patcher first build the Callback-Signature from a pending request, \r\nand then matches the Callback-Signature against the EH\u0002Signature Collection (the complete list of legitimate event han\u0002dlers, see Section 3.3). If a match is found, the dispatcher invokes \r\nthe confirmed event handler. Otherwise, the dispatcher takes ne\u0002cessary actions against the potential threat (e.g., generating a \r\nwarning message). \r\nThe construction of the KQ request’s Callback-Signature follows \r\nthe same algorithm as the construction of EH-Signatures (Section \r\n3.3.2), including the de-linking of callback-function and the anal\u0002ysis of callback-parameters by sub-type (integer values, global \r\nvariables, and heap objects). \r\n4. IMPLEMENTATIONS OF KQGUARD \r\n4.1 WRK Implementation of KQguard \r\nThe KQguard design (Section 3) was implemented on the WRK. \r\nOur implementation consists of about 2,300 lines of C code and \r\n2,003 lines of Objective Caml code. \r\n4.1.1 Construction of Callback-Signatures in WRK \r\nIn order to collect the Callback-Signatures for the 20 KQs in the \r\nWRK, we instrumented the kernel in two sets of functions. First, \r\nwe studied and modified the functions that manipulate the KQs \r\ndirectly. Second, we studied and modified auxiliary functions that \r\ncontribute with useful information in the construction of Call\u0002back-Signatures. \r\nThe main functions that manipulate KQs include the functions \r\nthat initialize KQ requests, insert KQ requests, and dispatch KQ \r\nrequests. These functions have direct access to KQ request data \r\nstructures and can provide both the callback-function and call\u0002back-parameters parts of a Callback-Signature. For both EH\u0002Signature collection in the training phase and for Callback\u0002Signature validation in the testing phase, we instrument every KQ \r\nmanipulation function. This is because sometimes a KQ request \r\ncan be removed before the dispatching (e.g., a timer request can \r\nbe cancelled). In total, our instrumentation of the KQ functions \r\nconsists of 500 lines of C code in WRK. The specific KQ dispatch \r\nfunctions instrumented are list in Table 2, and the specific KQ \r\nrequest insertion functions instrumented can be found in Table 9 \r\nin the Appendix. \r\nAs explained in Section 3.3.2, the construction of a Callback\u0002Signature involves the de-linking of callback-function address and \r\nglobal variables, and the identification of heap objects. The de\u0002linking follows the algorithm outlined in Section3.2. The analysis \r\nof heap objects is somewhat specific to WRK. It starts from the \r\ninstrumentation of heap allocation and deallocation functions, \r\nwhich in WRK include ExAllocatePoolWithTag and Ex\u0002FreePool. Our instrumentation maintains a table of tuples <ad\u0002dress, length, driver ID, call site>, where address and length are \r\nthe starting address and length of an allocated heap memory block \r\nat runtime, and the driver ID and call site identify the requester or \r\n“owner” of the heap memory block. When a heap memory block ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/1088bf52-6a5e-40f6-b12f-c02716fcd478.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b54938c0dfd2d177809e6c65560558c200bccf55630e550cdad5ed2ac9122c9c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 812
      },
      {
        "segments": [
          {
            "segment_id": "1088bf52-6a5e-40f6-b12f-c02716fcd478",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "6 \r\n/* linux-2.4.32/kernel/pm.c */ \r\nint pm_send_all (pm_request_t rqst, void *data) \r\n{ \r\n struct list_head *entry; \r\n entry = pm_devs.next; \r\n while (entry != &pm_devs) { \r\n struct pm_dev *dev = list_entry(entry, \r\nstruct pm_dev, entry); \r\n if (dev->callback) { \r\n int status = pm_send(dev, rqst, data); \r\n …… \r\n } \r\n entry = entry->next; \r\n } \r\n …… \r\n return 0; \r\n} \r\nstruct pm_dev \r\n{ pm_dev_t type; \r\n unsigned long id; \r\n pm_callback callback; \r\n …… \r\n struct list_head entry; \r\n}; \r\n/* linux-2.4.32/kernel/pm.c */ \r\nstatic LIST_HEAD(pm_devs); \r\nstruct pm_dev *pm_register(pm_dev_t \r\ntype, unsigned long id, pm_callback call\u0002back) \r\n{ \r\n struct pm_dev *dev = kmalloc (sizeof \r\n(struct pm_dev), GFP_KERNEL); \r\n if (dev) { \r\n memset(dev, 0, sizeof(*dev)); \r\n dev->type = type; \r\n dev->id = id; \r\n dev->callback = callback; \r\n list_add(&dev->entry, \r\n&pm_devs); \r\n } \r\n return dev; \r\n} \r\n/* linux-2.4.32/kernel/pm.c */ \r\nint pm_send(struct pm_dev *dev, \r\npm_request_t rqst, void *data) \r\n{ …… \r\n if (prev_state != next_state){ \r\n…… \r\n status = (*dev->callback) (dev, \r\nrqst, data); \r\n …… \r\n } …… \r\n} \r\nFigure 7: Details of the Power Management Notification Queue on Linux Kernel 2.4.32 \r\nlegitimate KQ requests. In practice, we expect an OS software \r\nvendor (e.g., Microsoft), a capable system software reseller (e.g., \r\nRed Hat), or a reputable software validator (e.g., a software secu\u0002rity company) to perform the training phase, which is similar to \r\n(and uses the same tools of) the comprehensive testing before a \r\nrelease. As in all software testing, missing some execution paths \r\nmay introduce false positives when a previously unseen Callback\u0002Signature is triggered during runtime. We note that our coverage \r\nrequirements are significantly less than software correctness test\u0002ing, since we only need to trigger each execution path that in\u0002vokes a KQ request once, not the entire input space. \r\nIn our experiments, we approximate the software validation \r\nprocess in two ways. First, we choose a representative set of \r\nbenchmark programs (e.g., PerformanceTest, Super PI, and \r\nIozone). Second, in addition to the test input, we also run the in\u0002strumented kernel during normal usage, including rebooting the \r\nOS. Our evaluation (Section 5) shows a very low false positive \r\nrate, indicating the feasibility of the dynamic profiling method. In \r\ngeneral, the issue of test coverage for large scale software without \r\nsource code is a significant challenge and beyond the scope of this \r\npaper. \r\n3.4 Validation Using EH-Signature Collection \r\nWe modify the dispatcher of every identified KQ so that the dis\u0002patcher checks the legitimacy of a pending KQ request before \r\ninvoking the call back function. To perform the check, the dis\u0002patcher first build the Callback-Signature from a pending request, \r\nand then matches the Callback-Signature against the EH\u0002Signature Collection (the complete list of legitimate event han\u0002dlers, see Section 3.3). If a match is found, the dispatcher invokes \r\nthe confirmed event handler. Otherwise, the dispatcher takes ne\u0002cessary actions against the potential threat (e.g., generating a \r\nwarning message). \r\nThe construction of the KQ request’s Callback-Signature follows \r\nthe same algorithm as the construction of EH-Signatures (Section \r\n3.3.2), including the de-linking of callback-function and the anal\u0002ysis of callback-parameters by sub-type (integer values, global \r\nvariables, and heap objects). \r\n4. IMPLEMENTATIONS OF KQGUARD \r\n4.1 WRK Implementation of KQguard \r\nThe KQguard design (Section 3) was implemented on the WRK. \r\nOur implementation consists of about 2,300 lines of C code and \r\n2,003 lines of Objective Caml code. \r\n4.1.1 Construction of Callback-Signatures in WRK \r\nIn order to collect the Callback-Signatures for the 20 KQs in the \r\nWRK, we instrumented the kernel in two sets of functions. First, \r\nwe studied and modified the functions that manipulate the KQs \r\ndirectly. Second, we studied and modified auxiliary functions that \r\ncontribute with useful information in the construction of Call\u0002back-Signatures. \r\nThe main functions that manipulate KQs include the functions \r\nthat initialize KQ requests, insert KQ requests, and dispatch KQ \r\nrequests. These functions have direct access to KQ request data \r\nstructures and can provide both the callback-function and call\u0002back-parameters parts of a Callback-Signature. For both EH\u0002Signature collection in the training phase and for Callback\u0002Signature validation in the testing phase, we instrument every KQ \r\nmanipulation function. This is because sometimes a KQ request \r\ncan be removed before the dispatching (e.g., a timer request can \r\nbe cancelled). In total, our instrumentation of the KQ functions \r\nconsists of 500 lines of C code in WRK. The specific KQ dispatch \r\nfunctions instrumented are list in Table 2, and the specific KQ \r\nrequest insertion functions instrumented can be found in Table 9 \r\nin the Appendix. \r\nAs explained in Section 3.3.2, the construction of a Callback\u0002Signature involves the de-linking of callback-function address and \r\nglobal variables, and the identification of heap objects. The de\u0002linking follows the algorithm outlined in Section3.2. The analysis \r\nof heap objects is somewhat specific to WRK. It starts from the \r\ninstrumentation of heap allocation and deallocation functions, \r\nwhich in WRK include ExAllocatePoolWithTag and Ex\u0002FreePool. Our instrumentation maintains a table of tuples <ad\u0002dress, length, driver ID, call site>, where address and length are \r\nthe starting address and length of an allocated heap memory block \r\nat runtime, and the driver ID and call site identify the requester or \r\n“owner” of the heap memory block. When a heap memory block ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/1088bf52-6a5e-40f6-b12f-c02716fcd478.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b54938c0dfd2d177809e6c65560558c200bccf55630e550cdad5ed2ac9122c9c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 812
      },
      {
        "segments": [
          {
            "segment_id": "8f99b072-e38e-458f-a5aa-6231227b5c06",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "7 \r\nis allocated, a new entry is inserted into this table. Symmetrically, \r\nthe instrumented deallocation function removes the entry with key \r\n<address>. The driver ID is derived from a search of the call stack \r\nbackwards until it reaches a return address that falls within the \r\ncode segment of a device driver. The return address is de-linked \r\n(subtracting from it the starting address of the device driver), \r\nbecoming the call site part of the tuple for the heap object. The \r\ncall stack walk resolves chained function calls (Figure 5). Our \r\ninstrumentation of the heap allocator / deallocator consists of 600 \r\nlines of C code in total. \r\n4.1.2 Automated Detection of KQs for the WRK \r\nAs explained in Section 3.1, we alleviate the assumption of full \r\nkernel source code availability through a combination of static \r\nanalysis to find the KQs and dynamic analysis to build the EH\u0002Signature Collection. We implemented the KQ discovery tool for \r\nWRK using the C Intermediate Language (CIL) [19]. Our imple\u0002mentation consists of 2,003 lines of Objective Caml code. \r\nWe applied the KQ discovery tool to the WRK source code \r\n(665,950 lines of C) and 20 KQs were detected with 16 distinct \r\nKQ data structure types (some KQs share a common type, e.g., \r\nProcess Creation/Deletion Notification queue and Thread Crea\u0002tion/Deletion Notification queue). Due to space constraints, we \r\nlist a few representative KQs in Table 1, and the full list in Table \r\n9 of the Appendix. Most of these KQs are implemented as linked \r\nlists (such as the I/O timer queue), but a few of them are imple\u0002mented as arrays (e.g., the Process Creation/Deletion Notification \r\nqueue). A majority of these KQs (15 out of 20) have a global \r\nvariable as their queue head. For each KQ, we report the number \r\nof callback-parameters that are included in the Callback-Signature \r\n(in the “# param. tainted” column). As illustration of KQ manipu\u0002lation functions, we include the KQ insertion function for each \r\nKQ. \r\n4.1.3 EH-Signature Collection \r\nAfter the KQs have been found, we instrument these KQ-related \r\nfunctions (insertion, initialization, and dispatch) as described in \r\nSections 3.2 and 3.3). Then we run the training workloads (Sec\u0002tion 5.1) in a training process (Section 4.1.3). The Callback\u0002Signatures collected during training are assumed to be legitimate \r\nand incorporated into the EH-Signature Collection. \r\nWe developed a set of utility functions to manage the Callback\u0002Table 1: Representative Automatically Detected KQs \r\nKQ Name Queue header \r\nvariable \r\n# param. \r\ntainted \r\nName of Request \r\nInsertion Function(s)\r\nWindows Research Kernel \r\nI/O timer \r\nqueue \r\nIopTimer\u0002QueueHead 2 IoInitializeTimer \r\nRegistryCall\u0002back \r\nqueue \r\nCmpCallBack\u0002Vector 1 CmRegisterCallback\r\nLoad image \r\nnotification \r\nqueue \r\nPspLoadImage\u0002NotifyRoutine 0 PsSetLoadImageNo\u0002tifyRoutine \r\nLinux Kernel 2.4.32 \r\nTasklet queue tasklet_vec[], \r\ntasklet_hi_vec[] \r\n1 tasklet_schedule, \r\ntasklet_hi_schedule \r\nPacket type \r\nqueue \r\nptype_all, \r\nptype_base[] \r\n1 dev_add_pack \r\nSignatures, including the EH-Signature Collection. These func\u0002tions support the generation, comparison, insertion, and search of \r\nCallback-Signatures. For example, during the training phase, the \r\nsame EH-signature can be detected repeatedly from time to time, \r\nso one helper function checks for duplicate EH-signatures. These \r\nhelper functions are implemented in 900 lines of C code, and they \r\nare invoked both in the training phase (for EH-Signature collec\u0002tion) and in the testing phase (to query EH-Signatures during \r\nCallback-Signature validation). \r\n4.1.4 Validation of Callback-Signature in WRK \r\nWe instrument the dispatcher of every identified KQ in the WRK \r\nso that the dispatcher checks the legitimacy of a pending KQ re\u0002quest before invoking the call back function. To perform the \r\ncheck, the dispatcher first retrieves the Callback-Signature from a \r\npending request, and then matches the Callback-Signature against \r\nthe EH-Signature Collection. If a match is found, the dispatcher \r\ninvokes the call back function; otherwise, the dispatcher takes \r\nnecessary actions (e.g., generating a warning message). \r\nMore specifically, we instrument the dispatch functions listed in \r\nTable 2, and our instrumentation consists of about 300 lines of C \r\ncode. \r\nThe current implementation of Callback-Signature validation in \r\nthe dispatcher follows directly from the conceptual design. It \r\nguarantees that only a validated KQ request will be executed. \r\nHowever, we are aware of the lengthened critical path for event \r\nhandling in the kernel. We are considering several implementa\u0002tion alternatives that will take the validation code out of the criti\u0002cal path in the KQ dispatcher. For example, validation can be \r\ndone at the KQ request insertion time. We will add a validation \r\nstamp (an encrypted checksum) to protect each validated KQ \r\nrequest. At the KQ request dispatch time, the validation stamp can \r\nbe quickly checked with small constant overhead. All unknown \r\nand invalid KQ requests (e.g., the ones inserted without using the \r\nofficial API and thus without the stamp) will be rejected. \r\n4.2 Linux Implementation of KQguard \r\n4.2.1 Construction of Callback-Signatures in Linux \r\nWe have started the work on the Linux implementation of KQ\u0002guard, which follows the same conceptual design described in \r\nSection 3. We instrumented the Linux kernel functions that mani\u0002pulate the Linux KQs. Of course, the names and syntax of specific \r\nfunctions that we instrument are different: they are listed in Table \r\n10 of the Appendix, in the last two columns. \r\nAs a concrete example, the de-linking of Callback-function ad\u0002dresses and global variables as well as the identification of heap \r\nobjects follow the same design (Section 3.3.2) as in our WRK \r\nimplementation, but the heap object identification uses kmalloc\r\nand kfree, which are specific to Linux. \r\n4.2.2 Automated Detection of KQs in Linux \r\nWe apply the KQ detector to Linux kernel 2.4.32 (with 482,369 \r\nlines of C code) and it found 22 KQs. Two representative KQs are \r\nlisted in Table 1, and the full list is in Table 10 of the Appendix. \r\nPerhaps not surprisingly, we found differences as well as similari\u0002ties between WRK and Linux. As an example of differences, \r\nWRK KQs are implemented both as linked lists and arrays, but all \r\nLinux KQs are implemented as linked lists. More concretely, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/8f99b072-e38e-458f-a5aa-6231227b5c06.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bb7c299ce92f98c677fde91bbb9d87406d633b4aeb7f271254f1fb3bc3ef878c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 951
      },
      {
        "segments": [
          {
            "segment_id": "8f99b072-e38e-458f-a5aa-6231227b5c06",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "7 \r\nis allocated, a new entry is inserted into this table. Symmetrically, \r\nthe instrumented deallocation function removes the entry with key \r\n<address>. The driver ID is derived from a search of the call stack \r\nbackwards until it reaches a return address that falls within the \r\ncode segment of a device driver. The return address is de-linked \r\n(subtracting from it the starting address of the device driver), \r\nbecoming the call site part of the tuple for the heap object. The \r\ncall stack walk resolves chained function calls (Figure 5). Our \r\ninstrumentation of the heap allocator / deallocator consists of 600 \r\nlines of C code in total. \r\n4.1.2 Automated Detection of KQs for the WRK \r\nAs explained in Section 3.1, we alleviate the assumption of full \r\nkernel source code availability through a combination of static \r\nanalysis to find the KQs and dynamic analysis to build the EH\u0002Signature Collection. We implemented the KQ discovery tool for \r\nWRK using the C Intermediate Language (CIL) [19]. Our imple\u0002mentation consists of 2,003 lines of Objective Caml code. \r\nWe applied the KQ discovery tool to the WRK source code \r\n(665,950 lines of C) and 20 KQs were detected with 16 distinct \r\nKQ data structure types (some KQs share a common type, e.g., \r\nProcess Creation/Deletion Notification queue and Thread Crea\u0002tion/Deletion Notification queue). Due to space constraints, we \r\nlist a few representative KQs in Table 1, and the full list in Table \r\n9 of the Appendix. Most of these KQs are implemented as linked \r\nlists (such as the I/O timer queue), but a few of them are imple\u0002mented as arrays (e.g., the Process Creation/Deletion Notification \r\nqueue). A majority of these KQs (15 out of 20) have a global \r\nvariable as their queue head. For each KQ, we report the number \r\nof callback-parameters that are included in the Callback-Signature \r\n(in the “# param. tainted” column). As illustration of KQ manipu\u0002lation functions, we include the KQ insertion function for each \r\nKQ. \r\n4.1.3 EH-Signature Collection \r\nAfter the KQs have been found, we instrument these KQ-related \r\nfunctions (insertion, initialization, and dispatch) as described in \r\nSections 3.2 and 3.3). Then we run the training workloads (Sec\u0002tion 5.1) in a training process (Section 4.1.3). The Callback\u0002Signatures collected during training are assumed to be legitimate \r\nand incorporated into the EH-Signature Collection. \r\nWe developed a set of utility functions to manage the Callback\u0002Table 1: Representative Automatically Detected KQs \r\nKQ Name Queue header \r\nvariable \r\n# param. \r\ntainted \r\nName of Request \r\nInsertion Function(s)\r\nWindows Research Kernel \r\nI/O timer \r\nqueue \r\nIopTimer\u0002QueueHead 2 IoInitializeTimer \r\nRegistryCall\u0002back \r\nqueue \r\nCmpCallBack\u0002Vector 1 CmRegisterCallback\r\nLoad image \r\nnotification \r\nqueue \r\nPspLoadImage\u0002NotifyRoutine 0 PsSetLoadImageNo\u0002tifyRoutine \r\nLinux Kernel 2.4.32 \r\nTasklet queue tasklet_vec[], \r\ntasklet_hi_vec[] \r\n1 tasklet_schedule, \r\ntasklet_hi_schedule \r\nPacket type \r\nqueue \r\nptype_all, \r\nptype_base[] \r\n1 dev_add_pack \r\nSignatures, including the EH-Signature Collection. These func\u0002tions support the generation, comparison, insertion, and search of \r\nCallback-Signatures. For example, during the training phase, the \r\nsame EH-signature can be detected repeatedly from time to time, \r\nso one helper function checks for duplicate EH-signatures. These \r\nhelper functions are implemented in 900 lines of C code, and they \r\nare invoked both in the training phase (for EH-Signature collec\u0002tion) and in the testing phase (to query EH-Signatures during \r\nCallback-Signature validation). \r\n4.1.4 Validation of Callback-Signature in WRK \r\nWe instrument the dispatcher of every identified KQ in the WRK \r\nso that the dispatcher checks the legitimacy of a pending KQ re\u0002quest before invoking the call back function. To perform the \r\ncheck, the dispatcher first retrieves the Callback-Signature from a \r\npending request, and then matches the Callback-Signature against \r\nthe EH-Signature Collection. If a match is found, the dispatcher \r\ninvokes the call back function; otherwise, the dispatcher takes \r\nnecessary actions (e.g., generating a warning message). \r\nMore specifically, we instrument the dispatch functions listed in \r\nTable 2, and our instrumentation consists of about 300 lines of C \r\ncode. \r\nThe current implementation of Callback-Signature validation in \r\nthe dispatcher follows directly from the conceptual design. It \r\nguarantees that only a validated KQ request will be executed. \r\nHowever, we are aware of the lengthened critical path for event \r\nhandling in the kernel. We are considering several implementa\u0002tion alternatives that will take the validation code out of the criti\u0002cal path in the KQ dispatcher. For example, validation can be \r\ndone at the KQ request insertion time. We will add a validation \r\nstamp (an encrypted checksum) to protect each validated KQ \r\nrequest. At the KQ request dispatch time, the validation stamp can \r\nbe quickly checked with small constant overhead. All unknown \r\nand invalid KQ requests (e.g., the ones inserted without using the \r\nofficial API and thus without the stamp) will be rejected. \r\n4.2 Linux Implementation of KQguard \r\n4.2.1 Construction of Callback-Signatures in Linux \r\nWe have started the work on the Linux implementation of KQ\u0002guard, which follows the same conceptual design described in \r\nSection 3. We instrumented the Linux kernel functions that mani\u0002pulate the Linux KQs. Of course, the names and syntax of specific \r\nfunctions that we instrument are different: they are listed in Table \r\n10 of the Appendix, in the last two columns. \r\nAs a concrete example, the de-linking of Callback-function ad\u0002dresses and global variables as well as the identification of heap \r\nobjects follow the same design (Section 3.3.2) as in our WRK \r\nimplementation, but the heap object identification uses kmalloc\r\nand kfree, which are specific to Linux. \r\n4.2.2 Automated Detection of KQs in Linux \r\nWe apply the KQ detector to Linux kernel 2.4.32 (with 482,369 \r\nlines of C code) and it found 22 KQs. Two representative KQs are \r\nlisted in Table 1, and the full list is in Table 10 of the Appendix. \r\nPerhaps not surprisingly, we found differences as well as similari\u0002ties between WRK and Linux. As an example of differences, \r\nWRK KQs are implemented both as linked lists and arrays, but all \r\nLinux KQs are implemented as linked lists. More concretely, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/8f99b072-e38e-458f-a5aa-6231227b5c06.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bb7c299ce92f98c677fde91bbb9d87406d633b4aeb7f271254f1fb3bc3ef878c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 951
      },
      {
        "segments": [
          {
            "segment_id": "5da9bbd6-ddae-460e-9958-508266db2897",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "8 \r\nWRK and Linux have different name conventions: the WRK \r\nlinked list implementation of KQs utilizes the structure type \r\nLIST_ENTRY, while the Linux linked list uses the structure type \r\nlist_head. With minor modifications to reconcile these differenc\u0002es, our KQ detector is able to analyze both the WRK and the Li\u0002nux kernel. \r\n4.2.3 Validation of Callback-Signature in Linux \r\nWe instrument the functions listed in the “name of dispatch func\u0002tions” column of Table 10 to validate the pending KQ requests in \r\nLinux. The retrieval of Callback-Signature follows the same \r\nprocess as the WRK implementation, and the EH-Signature man\u0002agement functions were ported from our WRK implementation. \r\n5. Evaluation of KQguard in WRK \r\nDue to the ongoing efforts to implement KQguard in Linux (Sec\u0002tion 4.2), we only report the evaluation results of the more mature \r\nWRK implementation of KQguard in this section. \r\nTable 2: WRK functions modified to guard the KQs \r\nKernel Queue Dispatcher Functions Modified \r\nPer-stream context \r\nqueue \r\nFsRtlTeardownPerStreamContexts \r\nI/O timer queue IopTimerDispatch \r\nFile system registra\u0002tion change notifi\u0002cation queue \r\nIoRegisterFileSystem, IoUnregisterFileSys\u0002tem, IoRegisterFsRegistrationChange \r\nProcess crea\u0002tion/deletion notifi\u0002cation queue \r\nPspCreateThread, PspExitProcess \r\nDriver Reinitialize \r\nroutine queue \r\nIopCallDriverReinitializationRoutines \r\nBoot driver reini\u0002tialize routine queue IopCallBootDriverReinitializationRoutines \r\nThread crea\u0002tion/deletion notifi\u0002cation queue \r\nPspCreateThread, PspExitThread \r\nRegistryCallback \r\nQueue \r\nCmpCallCallBacks \r\nLoad-image notifi\u0002cation queue PsCallImageNotifyRoutines \r\nBug check reason \r\ncallback queue \r\nKiInvokeBugCheckEntryCallbacks \r\nCallback object \r\nqueue \r\nExNotifyCallback \r\nWaiting IRP queue FsRtlRemoveAndCompleteWaitIrp, \r\nFsRtlUninitializeOplock \r\nIRP waiting lock \r\nqueue \r\nFsRtlPrivateCancelFileLockIrp \r\nFirmware table \r\nproviders queue \r\nExpGetSystemFirmwareTableInformation \r\nBugCheckCallback \r\nroutine queue \r\nKiScanBugCheckCallbackList \r\nDeferred write \r\nqueue \r\nCcPostDeferredWrites \r\nChange directory \r\nnotification queue \r\nFsRtlNotifyFilterReportChange \r\nSystem worker \r\nthread queue \r\nExpWorkerThread \r\nThe DPC queue KiExcuteDpc, KiRetireDpcList \r\nThe APC queue KiDeliverApc \r\n5.1 Experimental Method and Setup \r\nWe evaluate both the effectiveness and efficiency of KQguard \r\nthrough measurements on production kernels. By effectiveness we \r\nmean precision (whether it misidentifies the attacks found, meas\u0002ured in false positives) and recall (whether it misses a real attack, \r\nmeasured in false negatives) of KQguard when identifying KQ \r\nhijack attacks. By efficiency we mean the overhead introduced by \r\nKQguard. \r\nWe divide the effectiveness evaluation into two groups: defense \r\nagainst real malware attacks (Section 5.2) and defense against \r\nsynthetic attacks (Section 5.3). Real malware represents an easier \r\nclass of attacks (only callback-into-malware). Synthetic attacks \r\ninclude both callback-into-malware and callback-into-libc attacks. \r\nWe show that KQguard can detect all the real malware and all the \r\nsynthetic attacks (no false negatives). In Section 5.4, we study the \r\npotential false positives from KQguard, which may arise due to an \r\nincomplete EH-Signature Collection or imperfect Callback\u0002Signature design. We found no false positives in our experiments. \r\nThe efficiency evaluation of KQguard introduces some new chal\u0002lenges due to the asynchronous nature of KQ executions. First, \r\nthe application benchmarks do not invoke directly any KQ re\u0002quests. Second, the kernel services that create KQ request are not \r\nnecessarily invoked directly by applications. Consequently, be\u0002sides microbenchmarks that measure direct invocations of KQ \r\noperations, it is non-trivial to measure directly the impact on per\u0002formance caused by the various KQs. \r\nThe microbenchmark 1 in Section 5.5 measures the actual time \r\ntaken to run the Callback-Signature validation algorithm of KQ\u0002guard. The microbenchmark 2 measures the difference between a \r\nkernel with and without KQguard when handling specific events. \r\nBoth show a very small overhead, particularly when compared to \r\ntypical callback functions that it guards.\r\nThe macrobenchmarks in Section 5.5 measure the total elapsed \r\ntime of an application macrobenchmark run. The design rationale \r\nof the experiments is that various kernel services are triggered \r\nduring a resource-intensive application execution. Consequently, \r\nthe total elapsed time is a direct measure of application resource \r\nrequirements plus kernel requirements. By comparing the elapsed \r\ntime of the original kernel (without KQguard) and the instru\u0002mented kernel with KQguard, we have a measure of the additional \r\noverhead introduced by the KQguard. This is a composite meas\u0002ure of the accumulated overhead for all the KQs. \r\nAll the experiments are run on a 2.4 GHz Intel Xeon 8-Core serv\u0002er with 16 GB of RAM. The host operating system is Microsoft \r\nWindows XP Service Park 3 running Microsoft Virtual PC 2007 \r\n(version 6.0.156.0). The guest operating systems is Windows \r\nServer 2003 Service Pack 1 running the WRK, and it is allocated \r\n256 MB of RAM and 20 GB of hard disk.\r\nWorkloads. For performance evaluation, we have chosen several \r\nresource-intensive application benchmarks. They have been cho\u0002sen because each one saturates some resource and therefore kernel \r\noverhead should have a noticeable effect on the elapsed time. The \r\nfirst benchmark is Super PI, a CPU-intensive workload calculat\u0002ing 32 million digits of π. The second benchmark copies a direc\u0002tory with a total size of 1.5 GB, which stress the file system. The \r\nthird benchmark is also CPU-intensive, performing the compres\u0002sion and decompression of the 1.5 GB directory with 7-Zip. The \r\nfourth benchmark downloads a 160 MB file with WinSCP, which ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/5da9bbd6-ddae-460e-9958-508266db2897.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c5b0f03ea4bedbe19500abf64e95fb880ea414c68118e9ea37c9daaf2f7ab723",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 774
      },
      {
        "segments": [
          {
            "segment_id": "5da9bbd6-ddae-460e-9958-508266db2897",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "8 \r\nWRK and Linux have different name conventions: the WRK \r\nlinked list implementation of KQs utilizes the structure type \r\nLIST_ENTRY, while the Linux linked list uses the structure type \r\nlist_head. With minor modifications to reconcile these differenc\u0002es, our KQ detector is able to analyze both the WRK and the Li\u0002nux kernel. \r\n4.2.3 Validation of Callback-Signature in Linux \r\nWe instrument the functions listed in the “name of dispatch func\u0002tions” column of Table 10 to validate the pending KQ requests in \r\nLinux. The retrieval of Callback-Signature follows the same \r\nprocess as the WRK implementation, and the EH-Signature man\u0002agement functions were ported from our WRK implementation. \r\n5. Evaluation of KQguard in WRK \r\nDue to the ongoing efforts to implement KQguard in Linux (Sec\u0002tion 4.2), we only report the evaluation results of the more mature \r\nWRK implementation of KQguard in this section. \r\nTable 2: WRK functions modified to guard the KQs \r\nKernel Queue Dispatcher Functions Modified \r\nPer-stream context \r\nqueue \r\nFsRtlTeardownPerStreamContexts \r\nI/O timer queue IopTimerDispatch \r\nFile system registra\u0002tion change notifi\u0002cation queue \r\nIoRegisterFileSystem, IoUnregisterFileSys\u0002tem, IoRegisterFsRegistrationChange \r\nProcess crea\u0002tion/deletion notifi\u0002cation queue \r\nPspCreateThread, PspExitProcess \r\nDriver Reinitialize \r\nroutine queue \r\nIopCallDriverReinitializationRoutines \r\nBoot driver reini\u0002tialize routine queue IopCallBootDriverReinitializationRoutines \r\nThread crea\u0002tion/deletion notifi\u0002cation queue \r\nPspCreateThread, PspExitThread \r\nRegistryCallback \r\nQueue \r\nCmpCallCallBacks \r\nLoad-image notifi\u0002cation queue PsCallImageNotifyRoutines \r\nBug check reason \r\ncallback queue \r\nKiInvokeBugCheckEntryCallbacks \r\nCallback object \r\nqueue \r\nExNotifyCallback \r\nWaiting IRP queue FsRtlRemoveAndCompleteWaitIrp, \r\nFsRtlUninitializeOplock \r\nIRP waiting lock \r\nqueue \r\nFsRtlPrivateCancelFileLockIrp \r\nFirmware table \r\nproviders queue \r\nExpGetSystemFirmwareTableInformation \r\nBugCheckCallback \r\nroutine queue \r\nKiScanBugCheckCallbackList \r\nDeferred write \r\nqueue \r\nCcPostDeferredWrites \r\nChange directory \r\nnotification queue \r\nFsRtlNotifyFilterReportChange \r\nSystem worker \r\nthread queue \r\nExpWorkerThread \r\nThe DPC queue KiExcuteDpc, KiRetireDpcList \r\nThe APC queue KiDeliverApc \r\n5.1 Experimental Method and Setup \r\nWe evaluate both the effectiveness and efficiency of KQguard \r\nthrough measurements on production kernels. By effectiveness we \r\nmean precision (whether it misidentifies the attacks found, meas\u0002ured in false positives) and recall (whether it misses a real attack, \r\nmeasured in false negatives) of KQguard when identifying KQ \r\nhijack attacks. By efficiency we mean the overhead introduced by \r\nKQguard. \r\nWe divide the effectiveness evaluation into two groups: defense \r\nagainst real malware attacks (Section 5.2) and defense against \r\nsynthetic attacks (Section 5.3). Real malware represents an easier \r\nclass of attacks (only callback-into-malware). Synthetic attacks \r\ninclude both callback-into-malware and callback-into-libc attacks. \r\nWe show that KQguard can detect all the real malware and all the \r\nsynthetic attacks (no false negatives). In Section 5.4, we study the \r\npotential false positives from KQguard, which may arise due to an \r\nincomplete EH-Signature Collection or imperfect Callback\u0002Signature design. We found no false positives in our experiments. \r\nThe efficiency evaluation of KQguard introduces some new chal\u0002lenges due to the asynchronous nature of KQ executions. First, \r\nthe application benchmarks do not invoke directly any KQ re\u0002quests. Second, the kernel services that create KQ request are not \r\nnecessarily invoked directly by applications. Consequently, be\u0002sides microbenchmarks that measure direct invocations of KQ \r\noperations, it is non-trivial to measure directly the impact on per\u0002formance caused by the various KQs. \r\nThe microbenchmark 1 in Section 5.5 measures the actual time \r\ntaken to run the Callback-Signature validation algorithm of KQ\u0002guard. The microbenchmark 2 measures the difference between a \r\nkernel with and without KQguard when handling specific events. \r\nBoth show a very small overhead, particularly when compared to \r\ntypical callback functions that it guards.\r\nThe macrobenchmarks in Section 5.5 measure the total elapsed \r\ntime of an application macrobenchmark run. The design rationale \r\nof the experiments is that various kernel services are triggered \r\nduring a resource-intensive application execution. Consequently, \r\nthe total elapsed time is a direct measure of application resource \r\nrequirements plus kernel requirements. By comparing the elapsed \r\ntime of the original kernel (without KQguard) and the instru\u0002mented kernel with KQguard, we have a measure of the additional \r\noverhead introduced by the KQguard. This is a composite meas\u0002ure of the accumulated overhead for all the KQs. \r\nAll the experiments are run on a 2.4 GHz Intel Xeon 8-Core serv\u0002er with 16 GB of RAM. The host operating system is Microsoft \r\nWindows XP Service Park 3 running Microsoft Virtual PC 2007 \r\n(version 6.0.156.0). The guest operating systems is Windows \r\nServer 2003 Service Pack 1 running the WRK, and it is allocated \r\n256 MB of RAM and 20 GB of hard disk.\r\nWorkloads. For performance evaluation, we have chosen several \r\nresource-intensive application benchmarks. They have been cho\u0002sen because each one saturates some resource and therefore kernel \r\noverhead should have a noticeable effect on the elapsed time. The \r\nfirst benchmark is Super PI, a CPU-intensive workload calculat\u0002ing 32 million digits of π. The second benchmark copies a direc\u0002tory with a total size of 1.5 GB, which stress the file system. The \r\nthird benchmark is also CPU-intensive, performing the compres\u0002sion and decompression of the 1.5 GB directory with 7-Zip. The \r\nfourth benchmark downloads a 160 MB file with WinSCP, which ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/5da9bbd6-ddae-460e-9958-508266db2897.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c5b0f03ea4bedbe19500abf64e95fb880ea414c68118e9ea37c9daaf2f7ab723",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 774
      },
      {
        "segments": [
          {
            "segment_id": "28b8e94e-36b9-4e8e-ac6b-55eb906e8756",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "9 \r\nstresses the network connection. We also ran standard bench\u0002marks such as PostMark and PassMark. \r\nFor effectiveness evaluation, we run a set of normal workload \r\nprograms in the modified WRK to measure the false positive rate \r\nof our KQ guarding. These programs include Acrobat Reader, \r\nWindows Driver Kit, Firefox, Windows Media Player, Easy Me\u0002dia Player, and several games (Minesweeper, Microsoft Hearts \r\nNetwork, and 3D pinball). We chose these programs to represent \r\nthe normal workload on a Windows platform, for example docu\u0002ment processing, programming (Windows Driver Kit has tools to \r\ncompile device drivers), web browsing, and entertainment (mul\u0002timedia applications and gaming). This set of normal use pro\u0002grams showed zero false positives (Section 5.4). \r\nFor the false negatives part of effectiveness evaluation, we chose \r\n11 real-world malware samples (section 5.2) and nine synthetic \r\ntest device drivers (section 5.3) as test workloads. The real-world \r\nmalware samples come in the form of Windows executable files, \r\nand they can be activated by running the respective executables \r\n(e.g., malware.exe in Figure 8), which includes the automatic \r\ninstallation of malicious device drivers that hijack KQs. Once \r\nactive, the malicious drivers initiate the KQ hijack attacks that \r\nKQguard detects. The synthetic device drivers that we develop \r\nare manually installed into the WRK using the “Add Hardware \r\nWizard” from the Control Panel. \r\n5.2 Real World KQ Hijack Attacks \r\nWe start our evaluation of KQguard effectiveness by testing our \r\nWRK implementation (Section 4.1) against real work KQ Hijack \r\nattacks in Windows OS. Such malware samples are available from \r\nopen sources such as Offensive Computing \r\n(http://offensivecomputing.net). So far, we studied 10 spam bots \r\ndownloaded from this website. \r\nTo test the malware samples in a safe environment, we created a \r\nmalware analysis laboratory consisting of several dedicated vir\u0002tual machines that have no access to the public network. We start \r\nthe virtual machine monitor (e.g., VMware Workstation) in a \r\nclean state and boot a clean copy of WRK instrumented with KQ\u0002guard. We run each malware sample in the virtual machine and \r\ncollect the monitoring log generated by KQguard during the mal\u0002ware's execution. \r\nWe have studied the KQ hijacking behavior of several well\u0002known malware (e.g., spam bots), and report the results in Table \r\n3. We started with malware with reported KQ Hijack Attacks, \r\nwhich are marked with a “√” with citation. We were able to con\u0002firm some of these attacks, shaded in green. The rows with green \r\n“√” without citations are confirmed new KQ Hijack Attacks that \r\nhave not been reported by other sources. \r\nWe discuss the KQ Hijack Attack in Rustock as an illustrative \r\nexample. It is known [2][15][23] that Rustock.C uses the Timer \r\nqueue, the Create Process Notification queue, and the APC \r\n(Asynchronous Procedure Call) queue. However, all the Rus\u0002tock.C samples that we obtained failed to run in our lab, perhaps \r\ndue to the virtual environment. Instead, we were able to run a \r\nclosely related variant, Rustock.J, and we confirmed that Rus\u0002tock.J uses the KQ Hijack Attack on Load-Image Notification \r\nqueue, the Create Process Notification queue, and the APC queue. \r\nFigure 8 shows a screenshot in which KQguard for the APC \r\nqueue generated a warning message about a suspect APC callback \r\nfunction at address 0xF83FE316, which falls within the address \r\nrange of a device driver called msliksurserv.sys that is loaded by \r\nRustock.J. This confirmed detection of Rustock.J hijacking the \r\nAPC queue marks the corresponding entry in Table 3 as green. \r\nTo confirm the origin of callback-into-malware, we use WRK’s \r\nPsLoadedModuleList. However, advanced malware such as \r\nRustock.J can remove their entries from this global list in order to \r\nhide. To find the true information (e.g., address range) about a \r\nhidden malicious device driver, we instrument the device driver \r\nloading function of the WRK to log information of every loaded \r\ndriver, including its name and address range. We find this ap\u0002proach effective in detecting hidden drivers installed by Rus\u0002tock.J, Pushdo/Cutwail, Storm/Peacomm, Srizbi, TDSS, and Ze\u0002roAccess. \r\n Another technique that we use to attribute KQ requests to a mal\u0002ware sample is call stack information. For example, when a new \r\nDPC request structure is initialized via the API \r\nKeInitializeDpc, we check the device driver calling this \r\nAPI. In order to confirm the origin of the caller, we modify func\u0002tions such as KeInitializeDpc to traverse the call stack, \r\nTable 3: Known KQ Hijack Attacks in Current Malware \r\nKQ => \r\n---------------\r\nMalware \r\nTimer\r\n/DPC\r\nWorker \r\nThread \r\nLoad \r\nImage \r\nNotify \r\nCreate \r\nProcess \r\nNotify \r\nAPC\r\nFsRegis\r\ntration\r\nChange\r\nRegistr\r\nyOpCal\r\nlback \r\nRustock.C √ [2] \r\n[15] \r\n √ [23] √\r\n[23] \r\n \r\nRustock.J √ √ √\r\nPushdo / \r\nCutwail \r\n√ √ [8] √ √ [8] √ [8] \r\nStorm / \r\nPeacomm \r\n√ √ [4] √\r\n[20] \r\n \r\nSrizbi √ √ \r\nBlackEnergy √ [11] \r\nBrazilian \r\nbanker \r\n √ [11] \r\nTDSS √ √ √\r\nDuqu √ √ [13] √ \r\nZeroAccess √ √ [9] √ [9] √\r\nKoutodoor √ √ \r\nPandex √ \r\nMebroot √ \r\nFigure 8: Detection of KQ Hijack Attacks in Rustock.J ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/28b8e94e-36b9-4e8e-ac6b-55eb906e8756.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=97dd1a856d3422199c85ea73e83089d3f58ab7576ca81f7c24c7c4632dfcd97b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 803
      },
      {
        "segments": [
          {
            "segment_id": "28b8e94e-36b9-4e8e-ac6b-55eb906e8756",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "9 \r\nstresses the network connection. We also ran standard bench\u0002marks such as PostMark and PassMark. \r\nFor effectiveness evaluation, we run a set of normal workload \r\nprograms in the modified WRK to measure the false positive rate \r\nof our KQ guarding. These programs include Acrobat Reader, \r\nWindows Driver Kit, Firefox, Windows Media Player, Easy Me\u0002dia Player, and several games (Minesweeper, Microsoft Hearts \r\nNetwork, and 3D pinball). We chose these programs to represent \r\nthe normal workload on a Windows platform, for example docu\u0002ment processing, programming (Windows Driver Kit has tools to \r\ncompile device drivers), web browsing, and entertainment (mul\u0002timedia applications and gaming). This set of normal use pro\u0002grams showed zero false positives (Section 5.4). \r\nFor the false negatives part of effectiveness evaluation, we chose \r\n11 real-world malware samples (section 5.2) and nine synthetic \r\ntest device drivers (section 5.3) as test workloads. The real-world \r\nmalware samples come in the form of Windows executable files, \r\nand they can be activated by running the respective executables \r\n(e.g., malware.exe in Figure 8), which includes the automatic \r\ninstallation of malicious device drivers that hijack KQs. Once \r\nactive, the malicious drivers initiate the KQ hijack attacks that \r\nKQguard detects. The synthetic device drivers that we develop \r\nare manually installed into the WRK using the “Add Hardware \r\nWizard” from the Control Panel. \r\n5.2 Real World KQ Hijack Attacks \r\nWe start our evaluation of KQguard effectiveness by testing our \r\nWRK implementation (Section 4.1) against real work KQ Hijack \r\nattacks in Windows OS. Such malware samples are available from \r\nopen sources such as Offensive Computing \r\n(http://offensivecomputing.net). So far, we studied 10 spam bots \r\ndownloaded from this website. \r\nTo test the malware samples in a safe environment, we created a \r\nmalware analysis laboratory consisting of several dedicated vir\u0002tual machines that have no access to the public network. We start \r\nthe virtual machine monitor (e.g., VMware Workstation) in a \r\nclean state and boot a clean copy of WRK instrumented with KQ\u0002guard. We run each malware sample in the virtual machine and \r\ncollect the monitoring log generated by KQguard during the mal\u0002ware's execution. \r\nWe have studied the KQ hijacking behavior of several well\u0002known malware (e.g., spam bots), and report the results in Table \r\n3. We started with malware with reported KQ Hijack Attacks, \r\nwhich are marked with a “√” with citation. We were able to con\u0002firm some of these attacks, shaded in green. The rows with green \r\n“√” without citations are confirmed new KQ Hijack Attacks that \r\nhave not been reported by other sources. \r\nWe discuss the KQ Hijack Attack in Rustock as an illustrative \r\nexample. It is known [2][15][23] that Rustock.C uses the Timer \r\nqueue, the Create Process Notification queue, and the APC \r\n(Asynchronous Procedure Call) queue. However, all the Rus\u0002tock.C samples that we obtained failed to run in our lab, perhaps \r\ndue to the virtual environment. Instead, we were able to run a \r\nclosely related variant, Rustock.J, and we confirmed that Rus\u0002tock.J uses the KQ Hijack Attack on Load-Image Notification \r\nqueue, the Create Process Notification queue, and the APC queue. \r\nFigure 8 shows a screenshot in which KQguard for the APC \r\nqueue generated a warning message about a suspect APC callback \r\nfunction at address 0xF83FE316, which falls within the address \r\nrange of a device driver called msliksurserv.sys that is loaded by \r\nRustock.J. This confirmed detection of Rustock.J hijacking the \r\nAPC queue marks the corresponding entry in Table 3 as green. \r\nTo confirm the origin of callback-into-malware, we use WRK’s \r\nPsLoadedModuleList. However, advanced malware such as \r\nRustock.J can remove their entries from this global list in order to \r\nhide. To find the true information (e.g., address range) about a \r\nhidden malicious device driver, we instrument the device driver \r\nloading function of the WRK to log information of every loaded \r\ndriver, including its name and address range. We find this ap\u0002proach effective in detecting hidden drivers installed by Rus\u0002tock.J, Pushdo/Cutwail, Storm/Peacomm, Srizbi, TDSS, and Ze\u0002roAccess. \r\n Another technique that we use to attribute KQ requests to a mal\u0002ware sample is call stack information. For example, when a new \r\nDPC request structure is initialized via the API \r\nKeInitializeDpc, we check the device driver calling this \r\nAPI. In order to confirm the origin of the caller, we modify func\u0002tions such as KeInitializeDpc to traverse the call stack, \r\nTable 3: Known KQ Hijack Attacks in Current Malware \r\nKQ => \r\n---------------\r\nMalware \r\nTimer\r\n/DPC\r\nWorker \r\nThread \r\nLoad \r\nImage \r\nNotify \r\nCreate \r\nProcess \r\nNotify \r\nAPC\r\nFsRegis\r\ntration\r\nChange\r\nRegistr\r\nyOpCal\r\nlback \r\nRustock.C √ [2] \r\n[15] \r\n √ [23] √\r\n[23] \r\n \r\nRustock.J √ √ √\r\nPushdo / \r\nCutwail \r\n√ √ [8] √ √ [8] √ [8] \r\nStorm / \r\nPeacomm \r\n√ √ [4] √\r\n[20] \r\n \r\nSrizbi √ √ \r\nBlackEnergy √ [11] \r\nBrazilian \r\nbanker \r\n √ [11] \r\nTDSS √ √ √\r\nDuqu √ √ [13] √ \r\nZeroAccess √ √ [9] √ [9] √\r\nKoutodoor √ √ \r\nPandex √ \r\nMebroot √ \r\nFigure 8: Detection of KQ Hijack Attacks in Rustock.J ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/28b8e94e-36b9-4e8e-ac6b-55eb906e8756.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=97dd1a856d3422199c85ea73e83089d3f58ab7576ca81f7c24c7c4632dfcd97b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 803
      },
      {
        "segments": [
          {
            "segment_id": "0294a359-a7ae-46e1-a151-aff118d096cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "10 \r\nwhich contains the return addresses in the caller, the caller’s call\u0002er, and so on. By mapping the caller function(s) to the loaded \r\ndevice drivers, we can find any malicious driver(s) anywhere in \r\nthe call chain, thus confirming the KQ Hijack Attack on DPC. \r\nCall stack walk has helped us confirm the KQ Hijack Attacks in \r\nRustock.J, Storm/Peacomm, and ZeroAccess. \r\nFor all the malware that we were able to activate, we confirmed \r\nthe reported KQ Hijack Attacks, except for the Duqu attack on \r\nLoad-Image Notification queue. The study of Rustock shows that \r\nmalware designers have significant ability and flexibility in hi\u0002jacking different KQs. Concretely, Rustock.J has stopped using \r\nthe Timer queue, which Rustock.C uses, but Rustock.J started to \r\nuse the Load-Image Notification queue, which Rustock.C does \r\nnot. This may have happened to Duqu’s attack on the same queue, \r\nor Duqu does not activate the attack on Load-Image Notification \r\nqueue during our experiment. This kind of evolution underscores \r\nthe importance of guarding all KQs preventively, not just reacting \r\nto the ones that have been reported. \r\n5.3 Protection of All KQs \r\nIn addition to real world malware, we created synthetic KQ Hi\u0002jack Attacks for two reasons. First, the malware testing was in\u0002complete, as shown by several KQs (9 in Table 8 have maximum \r\nqueue length of zero) that have not been called during our testing. \r\nExamples of such KQs include the Thread Creation/Deletion No\u0002tification queue and the Waiting IRP queue. Second, the malware \r\nanalyzed in Section 5.2 belong to the callback-into-malware cate\u0002gory. Although there have been no reports of callback-into-libc \r\nattacks in the wild, it is important to evaluate the effectiveness of \r\nKQguard for both kinds of attacks. \r\nFor completeness, we developed a test Windows device driver for \r\neach of the nine KQs that have not been called (zero length in \r\nTable 8). These test drivers have a common code pattern: initializ\u0002ing and inserting a KQ request data structure into their respective \r\nKQs, and using the same callback function (which calculates a \r\nfactorial of a small fixed number). The main difference among the \r\ntest drivers is the specific APIs called to initialize and insert KQ \r\nrequests. These test drivers are not part of the normal set of legi\u0002timate drivers. Therefore, the KQguard should raise alarms when \r\nsuch test drivers become active. \r\nWe have confirmed that our KQ defense can detect all the test \r\ndevice drivers, which suggests that our defense is effective \r\nagainst potential and future KQ Hijack attacks. We observe that \r\nthe KQguard defense does not contain specific knowledge of the \r\nmalware internals or the internals of the test drivers. Consequent\u0002ly, we have confidence that KQguard defense will work for a \r\nwide range of KQ Hijack Attacks regardless of their implementa\u0002tion details. \r\n5.4 False Alarms \r\nThe complete defense (zero false negatives) achieved by KQ\u0002guard against malware (Section 5.2) and synthetic test drivers \r\n(Section 5.3) may suggest that KQguard could be easily triggered. \r\nIn experiments running a variety of benchmarks and normal use \r\napplication workloads, we have found zero false positives. This is \r\nachievable when two conditions hold: (1) the Callback-Signature \r\nvalidation against EH-Signature Collection has no errors, and (2) \r\nthe training workload is comprehensive to produce the full EH\u0002Signature Collection. \r\nTo evaluate the false positive rate of our KQ guarding, we first \r\nrun the WRK in the training mode to collect EH-Signatures. We \r\nlet the machine run for half an hour, during which time we run \r\nNotepad, My Computer, WinSCP, and Internet Explorer; then we \r\nreboot the machine and repeat the process. During the first run we \r\ncollect 855 EH-Signatures, after the first reboot we collect 10 \r\nmore EH-Signatures, and after the second, third, and fourth re\u0002boots we collect three, one, and one new signature, respectively. \r\nAfter the fifth reboot we do not see any new signatures. There\u0002fore, we stop the training after five reboots with 870 EH\u0002Signatures in the EH-Signatures Collection. \r\nNext we rebuild the WRK so that it will be running in the test \r\nmode based on the EH-Signatures Collection. Then we reboot the \r\nvirtual machine using the instrumented WRK. During the period \r\nof more than one day, we run the workload programs discussed in \r\nSection 5.1, as well as other normal applications to keep the in\u0002strumented WRK active as much as possible. Throughout the \r\ntesting phase, we observe zero false alarms. \r\nThe zero false positives result shows that both conditions hold. \r\nFirst, we have an effective Callback-Signature validation algo\u0002rithm capable of matching all legitimate KQ requests against the \r\nEH-Signatures Collection. Second, the training phase outlined in \r\nSection 3.3 has built a full EH-Signatures Collection with respect \r\nto the workload described in Section 5.1. \r\nWhile the experimental result appears encouraging, we avoid \r\nmaking a claim that dynamic analysis will always achieve zero \r\nfalse positives. Instead, we note that the 870 EH-Signatures are \r\nnot collected in one run. Concretely, 15 of them are collected \r\nafter rebooting the machine at least once. We analyzed the details \r\nof these 15 “late-coming” EH-Signatures to better understand our \r\ndynamic analysis based signature collection. These 15 EH\u0002Signatures are different from previous signatures in terms of ei\u0002ther the callback-function (4 cases) or the callback-parameters (11 \r\ncases). More specifically, the new callback functions can be from \r\nthe core kernel or a device driver, and the new callback parame\u0002ters can be a global variable or a heap variable. This variety sug\u0002gests some potential limitations of a dynamic analysis based ap\u0002proach. Fortunately, our experience suggests that the set of legi\u0002timate KQ signatures can be collected within a few reboots. \r\nWe note that an alternative to dynamic analysis is the full kernel \r\nsource code availability assumption. For example, a software \r\nvendor in possession of the entire kernel source code and device \r\ndrivers (with or without source code), should be able to build the \r\nfull EH-Signatures Collection through a combination of static and \r\ndynamic analysis as described in this paper. \r\n5.5 Performance Overhead \r\nAs mentioned in Section 5.1, the performance evaluation of KQ\u0002guard is non-trivial due to the asynchronous nature of KQ opera\u0002tions. We divide the performance measurements into two steps. \r\nFirst, we measure the overhead of KQguard through microben\u0002chmarks that invoke those operations directly. Second, we meas\u0002ure the difference in elapsed time of application macroben\u0002chmarks by comparing the measured response time on the original \r\nkernel and the KQguard-instrumented kernel. \r\nFor the first step, we measured the overhead of KQguard valida\u0002tion check and heap object tracking. KQguard validation check \r\nmatches Callback-Signatures against the EH-Signature Collection, \r\nand its overhead consists of matching the callback-function part \r\nand the callback-parameters part. Heap object tracking affects \r\nevery heap allocation and deallocation operation (e.g., ExAlloca-",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/0294a359-a7ae-46e1-a151-aff118d096cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0aaeea2c9966b64e47d13f47a66bd81c377d6a53ea3d7ff7f979919091cc21d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1089
      },
      {
        "segments": [
          {
            "segment_id": "0294a359-a7ae-46e1-a151-aff118d096cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "10 \r\nwhich contains the return addresses in the caller, the caller’s call\u0002er, and so on. By mapping the caller function(s) to the loaded \r\ndevice drivers, we can find any malicious driver(s) anywhere in \r\nthe call chain, thus confirming the KQ Hijack Attack on DPC. \r\nCall stack walk has helped us confirm the KQ Hijack Attacks in \r\nRustock.J, Storm/Peacomm, and ZeroAccess. \r\nFor all the malware that we were able to activate, we confirmed \r\nthe reported KQ Hijack Attacks, except for the Duqu attack on \r\nLoad-Image Notification queue. The study of Rustock shows that \r\nmalware designers have significant ability and flexibility in hi\u0002jacking different KQs. Concretely, Rustock.J has stopped using \r\nthe Timer queue, which Rustock.C uses, but Rustock.J started to \r\nuse the Load-Image Notification queue, which Rustock.C does \r\nnot. This may have happened to Duqu’s attack on the same queue, \r\nor Duqu does not activate the attack on Load-Image Notification \r\nqueue during our experiment. This kind of evolution underscores \r\nthe importance of guarding all KQs preventively, not just reacting \r\nto the ones that have been reported. \r\n5.3 Protection of All KQs \r\nIn addition to real world malware, we created synthetic KQ Hi\u0002jack Attacks for two reasons. First, the malware testing was in\u0002complete, as shown by several KQs (9 in Table 8 have maximum \r\nqueue length of zero) that have not been called during our testing. \r\nExamples of such KQs include the Thread Creation/Deletion No\u0002tification queue and the Waiting IRP queue. Second, the malware \r\nanalyzed in Section 5.2 belong to the callback-into-malware cate\u0002gory. Although there have been no reports of callback-into-libc \r\nattacks in the wild, it is important to evaluate the effectiveness of \r\nKQguard for both kinds of attacks. \r\nFor completeness, we developed a test Windows device driver for \r\neach of the nine KQs that have not been called (zero length in \r\nTable 8). These test drivers have a common code pattern: initializ\u0002ing and inserting a KQ request data structure into their respective \r\nKQs, and using the same callback function (which calculates a \r\nfactorial of a small fixed number). The main difference among the \r\ntest drivers is the specific APIs called to initialize and insert KQ \r\nrequests. These test drivers are not part of the normal set of legi\u0002timate drivers. Therefore, the KQguard should raise alarms when \r\nsuch test drivers become active. \r\nWe have confirmed that our KQ defense can detect all the test \r\ndevice drivers, which suggests that our defense is effective \r\nagainst potential and future KQ Hijack attacks. We observe that \r\nthe KQguard defense does not contain specific knowledge of the \r\nmalware internals or the internals of the test drivers. Consequent\u0002ly, we have confidence that KQguard defense will work for a \r\nwide range of KQ Hijack Attacks regardless of their implementa\u0002tion details. \r\n5.4 False Alarms \r\nThe complete defense (zero false negatives) achieved by KQ\u0002guard against malware (Section 5.2) and synthetic test drivers \r\n(Section 5.3) may suggest that KQguard could be easily triggered. \r\nIn experiments running a variety of benchmarks and normal use \r\napplication workloads, we have found zero false positives. This is \r\nachievable when two conditions hold: (1) the Callback-Signature \r\nvalidation against EH-Signature Collection has no errors, and (2) \r\nthe training workload is comprehensive to produce the full EH\u0002Signature Collection. \r\nTo evaluate the false positive rate of our KQ guarding, we first \r\nrun the WRK in the training mode to collect EH-Signatures. We \r\nlet the machine run for half an hour, during which time we run \r\nNotepad, My Computer, WinSCP, and Internet Explorer; then we \r\nreboot the machine and repeat the process. During the first run we \r\ncollect 855 EH-Signatures, after the first reboot we collect 10 \r\nmore EH-Signatures, and after the second, third, and fourth re\u0002boots we collect three, one, and one new signature, respectively. \r\nAfter the fifth reboot we do not see any new signatures. There\u0002fore, we stop the training after five reboots with 870 EH\u0002Signatures in the EH-Signatures Collection. \r\nNext we rebuild the WRK so that it will be running in the test \r\nmode based on the EH-Signatures Collection. Then we reboot the \r\nvirtual machine using the instrumented WRK. During the period \r\nof more than one day, we run the workload programs discussed in \r\nSection 5.1, as well as other normal applications to keep the in\u0002strumented WRK active as much as possible. Throughout the \r\ntesting phase, we observe zero false alarms. \r\nThe zero false positives result shows that both conditions hold. \r\nFirst, we have an effective Callback-Signature validation algo\u0002rithm capable of matching all legitimate KQ requests against the \r\nEH-Signatures Collection. Second, the training phase outlined in \r\nSection 3.3 has built a full EH-Signatures Collection with respect \r\nto the workload described in Section 5.1. \r\nWhile the experimental result appears encouraging, we avoid \r\nmaking a claim that dynamic analysis will always achieve zero \r\nfalse positives. Instead, we note that the 870 EH-Signatures are \r\nnot collected in one run. Concretely, 15 of them are collected \r\nafter rebooting the machine at least once. We analyzed the details \r\nof these 15 “late-coming” EH-Signatures to better understand our \r\ndynamic analysis based signature collection. These 15 EH\u0002Signatures are different from previous signatures in terms of ei\u0002ther the callback-function (4 cases) or the callback-parameters (11 \r\ncases). More specifically, the new callback functions can be from \r\nthe core kernel or a device driver, and the new callback parame\u0002ters can be a global variable or a heap variable. This variety sug\u0002gests some potential limitations of a dynamic analysis based ap\u0002proach. Fortunately, our experience suggests that the set of legi\u0002timate KQ signatures can be collected within a few reboots. \r\nWe note that an alternative to dynamic analysis is the full kernel \r\nsource code availability assumption. For example, a software \r\nvendor in possession of the entire kernel source code and device \r\ndrivers (with or without source code), should be able to build the \r\nfull EH-Signatures Collection through a combination of static and \r\ndynamic analysis as described in this paper. \r\n5.5 Performance Overhead \r\nAs mentioned in Section 5.1, the performance evaluation of KQ\u0002guard is non-trivial due to the asynchronous nature of KQ opera\u0002tions. We divide the performance measurements into two steps. \r\nFirst, we measure the overhead of KQguard through microben\u0002chmarks that invoke those operations directly. Second, we meas\u0002ure the difference in elapsed time of application macroben\u0002chmarks by comparing the measured response time on the original \r\nkernel and the KQguard-instrumented kernel. \r\nFor the first step, we measured the overhead of KQguard valida\u0002tion check and heap object tracking. KQguard validation check \r\nmatches Callback-Signatures against the EH-Signature Collection, \r\nand its overhead consists of matching the callback-function part \r\nand the callback-parameters part. Heap object tracking affects \r\nevery heap allocation and deallocation operation (e.g., ExAlloca-",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/0294a359-a7ae-46e1-a151-aff118d096cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0aaeea2c9966b64e47d13f47a66bd81c377d6a53ea3d7ff7f979919091cc21d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1089
      },
      {
        "segments": [
          {
            "segment_id": "f4cf9382-57f3-4973-a1be-d396f00a94c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "11 \r\ntePoolWithTag and ExFreePool in WRK). These heap operations \r\nare invoked at a global level, with overhead proportional to the \r\noverall system and application use of the heap. \r\nMicrobenchmark 1: we measured the total time spent in perform\u0002ing 1,000 KQguard validation checks for the DPC queue and the \r\nI/O timer queue. We chose these two KQs because they are more \r\nactively invoked than other KQs (Table 8). The main result is that \r\nglobal heap object tracking during the experiment dominated the \r\nKQguard overhead. Table 4 shows that DPC queue validation \r\nconsumed 93.7 milliseconds of CPU, while heap object tracking \r\nconsumed 8,527 milliseconds. These 1,000 DPC callback func\u0002tions are dispatched over a time span of 250,878 milliseconds (4 \r\nminutes 11 seconds). The total CPU consumed by our KQguard \r\nvalidation for DPC queue and the supporting heap object tracking \r\nis 8,620.7 milliseconds (about 3.4%). The measurements of the \r\nI/O timer queue confirm the DPC queue results. \r\nMicrobenchmark 2: we measure the overhead based on each indi\u0002vidual KQ callback function. This is because the validation \r\nchecks for each individual callback function may vary in com\u0002plexity (e.g., they may check different numbers of parameters and \r\nthe de-linking of each parameter may also be different across \r\ncallback functions), and each callback function may require dif\u0002ferent amount of execution time, so the relative slowdown caused \r\nby our validation may vary from one callback function to another. \r\nTable 5 shows overhead measurements for three representative \r\nKQ callback functions in the DPC queue and one callback func\u0002tion in the I/O timer queue. For each callback function, we meas\u0002ure its execution time, including the validation check and the \r\nactual execution in the original WRK (shown in the “Original” \r\ncolumn); then we measure the same callback function with KQ\u0002guard and show the result in the “With KQguard” column. From \r\nthe difference between these two execution times we calculate the \r\nsignature validation check time (shown in the “Signature \r\nTable 4: KQguard Overhead (1,000 Callback Function calls) \r\nKQ Heap Object \r\nTracking \r\nTime (milli\u0002seconds) \r\nKQ Valida\u0002tion Time \r\n(millise\u0002conds) \r\nTotal Time \r\n(millise\u0002conds) \r\nCPU Over\u0002head per \r\nminute \r\nDPC \r\nqueue \r\n8,527 93.7 250,878 3.4%\r\nI/O timer \r\nqueue \r\n11,807 180 345,825 3.5%\r\nTable 5: KQguard Overhead of 4 Callback Functions (C1: \r\nacpi.sys+0x2c50; C2: atapi.sys +0x8a0a; C3:acpi.sys+0x6cce; C4: \r\nclasspnp.sys+0x1069)\r\nKQ: Call\u0002back \r\nfunction \r\nOrigi\u0002nal \r\n(us) \r\nWith \r\nKQguard \r\n(us) \r\nSignature \r\nValidation \r\n(us) \r\nOver\u0002head Number of \r\nmeasure\u0002ments \r\nDPC: C1 461 \r\n±102 \r\n471 \r\n±102 \r\n10.2 \r\n±0.6 \r\n2.2% 26\r\nDPC: C2 94 \r\n±2.8 \r\n184 \r\n±4.2 \r\n90 \r\n±2.5 \r\n96% 505\r\nDPC: C3 286 \r\n±31 \r\n296 \r\n±31 \r\n10 \r\n±0.27 \r\n3.5% 18\r\nI/O Timer: \r\nC4\r\n1,470 \r\n±174 \r\n1,577 \r\n±174 \r\n107 \r\n±13 \r\n7.3% 100\r\nValidation” column). Then the overhead is calculated by dividing \r\nsignature validation time by the original execution time. The ex\u0002ecution time results for each callback function are averaged across \r\nmultiple invocations of that callback function and we report the \r\nnumber of measurements in the last column of Table 5. \r\nTable 5 shows the execution times of different callback functions \r\nvarying significantly, from 94 to 1,470 microseconds. In compari\u0002son, the signature validation time is relatively small (from 10 \r\nmicroseconds to 107 microseconds). As a result, the relative \r\noverhead added by KQguard varies from 2.2% for callback func\u0002tion acpi.sys+0x2c50 to 96% for callback function \r\natapi.sys+0x8a0a. The main source of variation comes \r\nfrom heap object tracking. These overhead measurements were \r\nobtained with a relatively busy heap: an average of 164 heap op\u0002erations per second, with 37,000 to 38,000 objects in the heap, \r\nand a peak of 39,681 objects. \r\nFor the second step, Table 6 shows the results of 5 application \r\nlevel benchmarks that stress one or more system resources, in\u0002cluding CPU, memory, disk, and network. Each workload is run \r\nat least 5 times and the average is reported. We can see that in \r\nterms of execution time of the selected applications, KQguard \r\nincurs modest elapsed time increases, from 2.8% for decompres\u0002sion to 5.6% for directory copying. These elapsed time increases \r\nare consistent with the microbenchmark measurements (Table 4 \r\nand Table 5), with higher or lower heap activities as the most \r\nprobable cause of the variations. \r\nTable 7 shows the results of running the PostMark file system \r\nbenchmark. The KQguard-instrumented WRK increases the \r\nread/write throughput of the file system to drop by about 3.9%. \r\nSimilar results were found when we ran the PassMark Performan\u0002ceTest benchmark, with an execution time increase of 4.9%, and \r\nmemory consumption increase of 2.9%. \r\nTo better understand the reasons for the overhead, we measure the \r\nmaximum KQ length (i.e., the maximum number of pending re\u0002quests for each KQ) and the dispatch frequency of the 20 KQs \r\n(the APC queue is divided into two sub-queues) during the expe\u0002riments, as shown in Table 8. The measurements show that 9 KQs \r\nhave not been called (0 maximum queue length). Of the 11 KQs \r\nthat have been called, 5 KQs have infrequent dispatches (0 per \r\nminute) and 6 KQs are active (non-zero requests per minute). In \r\nterms of invocation frequency, the APC queue is the most active: \r\n372 callbacks occur per minute on average. All KQs taken togeth\u0002er, callbacks happen 787 times per minute, or 13 times per \r\nsecond. \r\nTable 6: Performance Overhead of KQ Guarding in WRK \r\nWorkload Original \r\n(seconds) \r\nKQ Guarding \r\n(seconds) \r\nSlowdown \r\nSuper PI 2,108 \r\n±41 \r\n2,213\r\n±37\r\n5.0%\r\nCopy a 1.5 GB \r\ndirectory \r\n231 \r\n±9.0 \r\n244\r\n±15.9\r\n5.6%\r\nCompress a 1.5 \r\nGB directory \r\n1,113 \r\n±24 \r\n1,145\r\n±16\r\n2.9%\r\nDecompress a 1.5 \r\nGB directory \r\n181 \r\n±4.1 \r\n186\r\n±5.1\r\n2.8%\r\nDownload a 160 \r\nMB file \r\n145 \r\n±11 \r\n151\r\n±11\r\n4.1%",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/f4cf9382-57f3-4973-a1be-d396f00a94c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7eadd8992e2317866212e594f46e847d8cc72768090e6bb85a4c8e684bcabf1c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 904
      },
      {
        "segments": [
          {
            "segment_id": "f4cf9382-57f3-4973-a1be-d396f00a94c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "11 \r\ntePoolWithTag and ExFreePool in WRK). These heap operations \r\nare invoked at a global level, with overhead proportional to the \r\noverall system and application use of the heap. \r\nMicrobenchmark 1: we measured the total time spent in perform\u0002ing 1,000 KQguard validation checks for the DPC queue and the \r\nI/O timer queue. We chose these two KQs because they are more \r\nactively invoked than other KQs (Table 8). The main result is that \r\nglobal heap object tracking during the experiment dominated the \r\nKQguard overhead. Table 4 shows that DPC queue validation \r\nconsumed 93.7 milliseconds of CPU, while heap object tracking \r\nconsumed 8,527 milliseconds. These 1,000 DPC callback func\u0002tions are dispatched over a time span of 250,878 milliseconds (4 \r\nminutes 11 seconds). The total CPU consumed by our KQguard \r\nvalidation for DPC queue and the supporting heap object tracking \r\nis 8,620.7 milliseconds (about 3.4%). The measurements of the \r\nI/O timer queue confirm the DPC queue results. \r\nMicrobenchmark 2: we measure the overhead based on each indi\u0002vidual KQ callback function. This is because the validation \r\nchecks for each individual callback function may vary in com\u0002plexity (e.g., they may check different numbers of parameters and \r\nthe de-linking of each parameter may also be different across \r\ncallback functions), and each callback function may require dif\u0002ferent amount of execution time, so the relative slowdown caused \r\nby our validation may vary from one callback function to another. \r\nTable 5 shows overhead measurements for three representative \r\nKQ callback functions in the DPC queue and one callback func\u0002tion in the I/O timer queue. For each callback function, we meas\u0002ure its execution time, including the validation check and the \r\nactual execution in the original WRK (shown in the “Original” \r\ncolumn); then we measure the same callback function with KQ\u0002guard and show the result in the “With KQguard” column. From \r\nthe difference between these two execution times we calculate the \r\nsignature validation check time (shown in the “Signature \r\nTable 4: KQguard Overhead (1,000 Callback Function calls) \r\nKQ Heap Object \r\nTracking \r\nTime (milli\u0002seconds) \r\nKQ Valida\u0002tion Time \r\n(millise\u0002conds) \r\nTotal Time \r\n(millise\u0002conds) \r\nCPU Over\u0002head per \r\nminute \r\nDPC \r\nqueue \r\n8,527 93.7 250,878 3.4%\r\nI/O timer \r\nqueue \r\n11,807 180 345,825 3.5%\r\nTable 5: KQguard Overhead of 4 Callback Functions (C1: \r\nacpi.sys+0x2c50; C2: atapi.sys +0x8a0a; C3:acpi.sys+0x6cce; C4: \r\nclasspnp.sys+0x1069)\r\nKQ: Call\u0002back \r\nfunction \r\nOrigi\u0002nal \r\n(us) \r\nWith \r\nKQguard \r\n(us) \r\nSignature \r\nValidation \r\n(us) \r\nOver\u0002head Number of \r\nmeasure\u0002ments \r\nDPC: C1 461 \r\n±102 \r\n471 \r\n±102 \r\n10.2 \r\n±0.6 \r\n2.2% 26\r\nDPC: C2 94 \r\n±2.8 \r\n184 \r\n±4.2 \r\n90 \r\n±2.5 \r\n96% 505\r\nDPC: C3 286 \r\n±31 \r\n296 \r\n±31 \r\n10 \r\n±0.27 \r\n3.5% 18\r\nI/O Timer: \r\nC4\r\n1,470 \r\n±174 \r\n1,577 \r\n±174 \r\n107 \r\n±13 \r\n7.3% 100\r\nValidation” column). Then the overhead is calculated by dividing \r\nsignature validation time by the original execution time. The ex\u0002ecution time results for each callback function are averaged across \r\nmultiple invocations of that callback function and we report the \r\nnumber of measurements in the last column of Table 5. \r\nTable 5 shows the execution times of different callback functions \r\nvarying significantly, from 94 to 1,470 microseconds. In compari\u0002son, the signature validation time is relatively small (from 10 \r\nmicroseconds to 107 microseconds). As a result, the relative \r\noverhead added by KQguard varies from 2.2% for callback func\u0002tion acpi.sys+0x2c50 to 96% for callback function \r\natapi.sys+0x8a0a. The main source of variation comes \r\nfrom heap object tracking. These overhead measurements were \r\nobtained with a relatively busy heap: an average of 164 heap op\u0002erations per second, with 37,000 to 38,000 objects in the heap, \r\nand a peak of 39,681 objects. \r\nFor the second step, Table 6 shows the results of 5 application \r\nlevel benchmarks that stress one or more system resources, in\u0002cluding CPU, memory, disk, and network. Each workload is run \r\nat least 5 times and the average is reported. We can see that in \r\nterms of execution time of the selected applications, KQguard \r\nincurs modest elapsed time increases, from 2.8% for decompres\u0002sion to 5.6% for directory copying. These elapsed time increases \r\nare consistent with the microbenchmark measurements (Table 4 \r\nand Table 5), with higher or lower heap activities as the most \r\nprobable cause of the variations. \r\nTable 7 shows the results of running the PostMark file system \r\nbenchmark. The KQguard-instrumented WRK increases the \r\nread/write throughput of the file system to drop by about 3.9%. \r\nSimilar results were found when we ran the PassMark Performan\u0002ceTest benchmark, with an execution time increase of 4.9%, and \r\nmemory consumption increase of 2.9%. \r\nTo better understand the reasons for the overhead, we measure the \r\nmaximum KQ length (i.e., the maximum number of pending re\u0002quests for each KQ) and the dispatch frequency of the 20 KQs \r\n(the APC queue is divided into two sub-queues) during the expe\u0002riments, as shown in Table 8. The measurements show that 9 KQs \r\nhave not been called (0 maximum queue length). Of the 11 KQs \r\nthat have been called, 5 KQs have infrequent dispatches (0 per \r\nminute) and 6 KQs are active (non-zero requests per minute). In \r\nterms of invocation frequency, the APC queue is the most active: \r\n372 callbacks occur per minute on average. All KQs taken togeth\u0002er, callbacks happen 787 times per minute, or 13 times per \r\nsecond. \r\nTable 6: Performance Overhead of KQ Guarding in WRK \r\nWorkload Original \r\n(seconds) \r\nKQ Guarding \r\n(seconds) \r\nSlowdown \r\nSuper PI 2,108 \r\n±41 \r\n2,213\r\n±37\r\n5.0%\r\nCopy a 1.5 GB \r\ndirectory \r\n231 \r\n±9.0 \r\n244\r\n±15.9\r\n5.6%\r\nCompress a 1.5 \r\nGB directory \r\n1,113 \r\n±24 \r\n1,145\r\n±16\r\n2.9%\r\nDecompress a 1.5 \r\nGB directory \r\n181 \r\n±4.1 \r\n186\r\n±5.1\r\n2.8%\r\nDownload a 160 \r\nMB file \r\n145 \r\n±11 \r\n151\r\n±11\r\n4.1%",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/f4cf9382-57f3-4973-a1be-d396f00a94c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7eadd8992e2317866212e594f46e847d8cc72768090e6bb85a4c8e684bcabf1c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 904
      },
      {
        "segments": [
          {
            "segment_id": "eec66a3b-43e7-4985-8991-445db76f4b65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "12 \r\nTable 7: Performance Overhead Measured by PostMark \r\nWorkload Original \r\n(MB/s) \r\nKQ Guarding \r\n(MB/s) \r\nOverhead \r\nRead 855 MB data 3.41±0.11 3.29±0.07 3.5%\r\nWrite 1,600 MB data 6.38±0.20 6.13±0.23 3.9%\r\nTable 8: Frequency and intensity of KQ invocation in WRK \r\nK-Queue Name Max. \r\nLength \r\nFrequency of dis\u0002patch (per minute) \r\nPer-stream context queue 0 0 \r\nI/O timer queue 8 181 \r\nFile system registration \r\nchange notification queue \r\n9 2 \r\nProcess Creation/Deletion \r\nnotification queue \r\n7 3 \r\nDriver Reinitialize routine \r\nqueue \r\n8 0 \r\nBoot driver Reinitialize rou\u0002tine queue 5 0 \r\nThread Creation/Deletion \r\nnotification queue \r\n0 0 \r\nRegistryCallback queue 0 0 \r\nLoad image notification \r\nqueue \r\n0 0 \r\nBug check reason callback \r\nqueue \r\n1 0 \r\nCallback object queue 4 0 \r\nWaiting IRP queue 0 0 \r\nIRP waiting lock queue 0 0 \r\nFirmware table providers \r\nqueue \r\n0 0 \r\nBugCheckCallback routine \r\nqueue \r\n7 0 \r\nDeferred write queue 0 0 \r\nChange directory notification \r\nqueue \r\n0 0 \r\nAPC \r\nqueue \r\nKernelRoutine 476 312 \r\nNormalRoutine 203 60 \r\nDPC queue 127 226 \r\nSystem worker thread queue 15 3 \r\nTotal 870 787 \r\n6. Related Work \r\nIn this section, we survey related work that can potentially solve \r\nthe KQ hijacking problem and satisfy the five design requirement: \r\nefficiency, effectiveness, coverage, extensibility, and inclusive\u0002ness (Section 2.3). \r\nSecVisor [25] or NICKLE [24] are designed to preserve kernel \r\ncode integrity or block the execution of foreign code in the kernel. \r\nThey can defeat callback-into-malware KQ attacks because such \r\nattacks require that malicious functions be injected somewhere in \r\nthe kernel space. However, they cannot detect callback-into-libc \r\nattacks because such attacks do not inject malicious code or modi\u0002fy legitimate kernel code. HookSafe [31] is capable of blocking \r\nthe execution of malware that modifies legitimate function poin\u0002ters to force a control transfer to the malicious code. However, \r\nHookSafe cannot prevent KQ hooking attacks because they do not \r\nmodify existing and legitimate kernel function pointers but in\u0002stead supply malicious function pointers in their own memory \r\n(i.e., the KQ request data structures). \r\nCFI (Control Flow Integrity) [1] can ensure that control transfers \r\n(including invocations of function pointers) of a given program \r\nalways conform to a predefined control flow graph. Since KQs \r\ninvolve function pointers (i.e., the callback functions), CFI is a \r\nrelevant solution. However, CFI requires a fixed control flow \r\ngraph but the introduction of new device drivers definitely re\u0002quires a change to the control flow graph, so CFI does not satisfy \r\nthe extensibility requirement. SBCFI [22] performs a garbage\u0002collection style traversal of kernel data structures to verify that all \r\nfunction pointers encountered target trusted addresses in the ker\u0002nel, so SBCFI can potentially detect a callback-into-malware KQ \r\nattack. However, SBCFI is designed for persistent kernel control \r\nflow attacks (e.g., it only checks periodically) but KQ hijacking \r\nattacks are transient, so SBCFI may miss many of them. Moreo\u0002ver, SBCFI requires source code so it does not satisfy the inclu\u0002siveness requirement. IndexedHooks [16] provides an alternative \r\nimplementation of CFI for the FreeBSD 8.0 kernel by replacing \r\nfunction addresses with indexes into read-only tables, and it is \r\ncapable of supporting new device drivers. However, similar to \r\nSBCFI, IndexedHooks requires source code so it does not satisfy \r\nthe inclusiveness requirement. \r\nPLCP [32] is the most comprehensive defense against KQ hijack\u0002ing attacks so far, capable of defeating both callback-into\u0002malware and callback-into-libc attacks. The basic idea of PLCP is \r\nto check the legitimacy of every pending KQ request before ser\u0002vicing it; the check is performed not only on the callback function \r\nbut also on all possible function pointers reachable from the con\u0002textual data by the control flow of the callback function. In order \r\nto identify all such “check points” as well as the white list for \r\neach “check point”, PLCP employs static program analysis (e.g., \r\npoints-to analysis and transitive closure analysis) of the kernel \r\nsource code. However, PLCP has some limitations: it does not \r\nsatisfy the inclusiveness requirement due to its reliance on source \r\ncode; it has high performance overhead so it does not satisfy the \r\nefficiency requirement. For example, in the worst case, it can \r\ncause 15 times slowdown to the applications. \r\n7. Conclusion \r\nKernel Queue (KQ) Hijack Attacks are a significant problem. We \r\noutlined 11 real world malware attacks [2][4][8][9][11][13][15] \r\n[20][23] and 9 synthetic attacks to cover all the KQs in the WRK. \r\nIt is important for a solution to have 5 requirements: efficiency \r\n(low overhead), effectiveness (precision and recall of attack de\u0002tection), coverage (protecting all KQs), extensibility (accommo\u0002dation of new KQs) and inclusiveness (protection of kernels with \r\nand without source code). Current kernel protection solutions \r\nhave difficulties with simultaneous satisfaction of all four re\u0002quirements. \r\nWe describe the KQguard approach to defend kernels against KQ \r\nHijack Attacks. The design of KQguard is independent of specific \r\ndetails of the attacks. Consequently, KQguard is able to defend \r\nagainst not only known attacks, but also anticipated future attacks \r\non currently unscathed KQs. We evaluated the WRK implementa\u0002tion of KQguard, demonstrating the effectiveness and efficiency \r\nof KQguard by running a number of representative application \r\nbenchmarks. In effectiveness, KQguard achieves zero false nega\u0002tives (detecting all the 11 real world malware and 9 synthetic \r\nattacks) and zero false positives (no false alarms after a proper \r\ntraining process). In performance, KQguard introduces only a \r\nsmall overhead of about 100 microseconds per validation and up \r\nto 5% slowdown for resource-intensive application benchmarks \r\ndue to heap object tracking. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/eec66a3b-43e7-4985-8991-445db76f4b65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=173e4dc176056ec108f8ce98d681e8db80f4f416f68812f1f454f2f07887a295",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 871
      },
      {
        "segments": [
          {
            "segment_id": "eec66a3b-43e7-4985-8991-445db76f4b65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "12 \r\nTable 7: Performance Overhead Measured by PostMark \r\nWorkload Original \r\n(MB/s) \r\nKQ Guarding \r\n(MB/s) \r\nOverhead \r\nRead 855 MB data 3.41±0.11 3.29±0.07 3.5%\r\nWrite 1,600 MB data 6.38±0.20 6.13±0.23 3.9%\r\nTable 8: Frequency and intensity of KQ invocation in WRK \r\nK-Queue Name Max. \r\nLength \r\nFrequency of dis\u0002patch (per minute) \r\nPer-stream context queue 0 0 \r\nI/O timer queue 8 181 \r\nFile system registration \r\nchange notification queue \r\n9 2 \r\nProcess Creation/Deletion \r\nnotification queue \r\n7 3 \r\nDriver Reinitialize routine \r\nqueue \r\n8 0 \r\nBoot driver Reinitialize rou\u0002tine queue 5 0 \r\nThread Creation/Deletion \r\nnotification queue \r\n0 0 \r\nRegistryCallback queue 0 0 \r\nLoad image notification \r\nqueue \r\n0 0 \r\nBug check reason callback \r\nqueue \r\n1 0 \r\nCallback object queue 4 0 \r\nWaiting IRP queue 0 0 \r\nIRP waiting lock queue 0 0 \r\nFirmware table providers \r\nqueue \r\n0 0 \r\nBugCheckCallback routine \r\nqueue \r\n7 0 \r\nDeferred write queue 0 0 \r\nChange directory notification \r\nqueue \r\n0 0 \r\nAPC \r\nqueue \r\nKernelRoutine 476 312 \r\nNormalRoutine 203 60 \r\nDPC queue 127 226 \r\nSystem worker thread queue 15 3 \r\nTotal 870 787 \r\n6. Related Work \r\nIn this section, we survey related work that can potentially solve \r\nthe KQ hijacking problem and satisfy the five design requirement: \r\nefficiency, effectiveness, coverage, extensibility, and inclusive\u0002ness (Section 2.3). \r\nSecVisor [25] or NICKLE [24] are designed to preserve kernel \r\ncode integrity or block the execution of foreign code in the kernel. \r\nThey can defeat callback-into-malware KQ attacks because such \r\nattacks require that malicious functions be injected somewhere in \r\nthe kernel space. However, they cannot detect callback-into-libc \r\nattacks because such attacks do not inject malicious code or modi\u0002fy legitimate kernel code. HookSafe [31] is capable of blocking \r\nthe execution of malware that modifies legitimate function poin\u0002ters to force a control transfer to the malicious code. However, \r\nHookSafe cannot prevent KQ hooking attacks because they do not \r\nmodify existing and legitimate kernel function pointers but in\u0002stead supply malicious function pointers in their own memory \r\n(i.e., the KQ request data structures). \r\nCFI (Control Flow Integrity) [1] can ensure that control transfers \r\n(including invocations of function pointers) of a given program \r\nalways conform to a predefined control flow graph. Since KQs \r\ninvolve function pointers (i.e., the callback functions), CFI is a \r\nrelevant solution. However, CFI requires a fixed control flow \r\ngraph but the introduction of new device drivers definitely re\u0002quires a change to the control flow graph, so CFI does not satisfy \r\nthe extensibility requirement. SBCFI [22] performs a garbage\u0002collection style traversal of kernel data structures to verify that all \r\nfunction pointers encountered target trusted addresses in the ker\u0002nel, so SBCFI can potentially detect a callback-into-malware KQ \r\nattack. However, SBCFI is designed for persistent kernel control \r\nflow attacks (e.g., it only checks periodically) but KQ hijacking \r\nattacks are transient, so SBCFI may miss many of them. Moreo\u0002ver, SBCFI requires source code so it does not satisfy the inclu\u0002siveness requirement. IndexedHooks [16] provides an alternative \r\nimplementation of CFI for the FreeBSD 8.0 kernel by replacing \r\nfunction addresses with indexes into read-only tables, and it is \r\ncapable of supporting new device drivers. However, similar to \r\nSBCFI, IndexedHooks requires source code so it does not satisfy \r\nthe inclusiveness requirement. \r\nPLCP [32] is the most comprehensive defense against KQ hijack\u0002ing attacks so far, capable of defeating both callback-into\u0002malware and callback-into-libc attacks. The basic idea of PLCP is \r\nto check the legitimacy of every pending KQ request before ser\u0002vicing it; the check is performed not only on the callback function \r\nbut also on all possible function pointers reachable from the con\u0002textual data by the control flow of the callback function. In order \r\nto identify all such “check points” as well as the white list for \r\neach “check point”, PLCP employs static program analysis (e.g., \r\npoints-to analysis and transitive closure analysis) of the kernel \r\nsource code. However, PLCP has some limitations: it does not \r\nsatisfy the inclusiveness requirement due to its reliance on source \r\ncode; it has high performance overhead so it does not satisfy the \r\nefficiency requirement. For example, in the worst case, it can \r\ncause 15 times slowdown to the applications. \r\n7. Conclusion \r\nKernel Queue (KQ) Hijack Attacks are a significant problem. We \r\noutlined 11 real world malware attacks [2][4][8][9][11][13][15] \r\n[20][23] and 9 synthetic attacks to cover all the KQs in the WRK. \r\nIt is important for a solution to have 5 requirements: efficiency \r\n(low overhead), effectiveness (precision and recall of attack de\u0002tection), coverage (protecting all KQs), extensibility (accommo\u0002dation of new KQs) and inclusiveness (protection of kernels with \r\nand without source code). Current kernel protection solutions \r\nhave difficulties with simultaneous satisfaction of all four re\u0002quirements. \r\nWe describe the KQguard approach to defend kernels against KQ \r\nHijack Attacks. The design of KQguard is independent of specific \r\ndetails of the attacks. Consequently, KQguard is able to defend \r\nagainst not only known attacks, but also anticipated future attacks \r\non currently unscathed KQs. We evaluated the WRK implementa\u0002tion of KQguard, demonstrating the effectiveness and efficiency \r\nof KQguard by running a number of representative application \r\nbenchmarks. In effectiveness, KQguard achieves zero false nega\u0002tives (detecting all the 11 real world malware and 9 synthetic \r\nattacks) and zero false positives (no false alarms after a proper \r\ntraining process). In performance, KQguard introduces only a \r\nsmall overhead of about 100 microseconds per validation and up \r\nto 5% slowdown for resource-intensive application benchmarks \r\ndue to heap object tracking. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/eec66a3b-43e7-4985-8991-445db76f4b65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=173e4dc176056ec108f8ce98d681e8db80f4f416f68812f1f454f2f07887a295",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 871
      },
      {
        "segments": [
          {
            "segment_id": "aecede04-92d1-4944-b21f-596161b1293c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "13 \r\n8. REFERENCES \r\n[1] Abadi, M., Budiu, M., Erlingsson, U., and Ligatti, J. 2005. \r\nControl-flow integrity. Proceedings of the 12th ACM Confe\u0002rence on Computer and Communications Security, Nov. \r\n2005. \r\n[2] Anselmi, D., Boscovich, R., Campana, T. J., Doerr, S., Lau\u0002ricella, M., Petrovsky, O., Saade, T., Stewart, H. 2011. Bat\u0002tling the Rustock Threat. Microsoft Security Intelligence Re\u0002port, Special Edition, January 2010 through May 2011. \r\n[3] Baliga, A., Ganapathy, V., and Iftode, L. 2008. Automatic \r\ninference and enforcement of kernel data structure inva\u0002riants. In ACSAC ’08: Proceedings of the 2008 Annual Com\u0002puter Security Applications Conference, pages 77–86. IEEE \r\nComputer Society. \r\n[4] Boldewin, F. 2007. Peacomm.C - Cracking the nutshell. Anti \r\nRootkit, September 2007. \r\nhttp://www.antirootkit.com/articles/eye-of-the-storm\u0002worm/Peacomm-C-Cracking-the-nutshell.html. \r\n[5] Brumley, D. 1999. Invisible intruders: rootkits in practice. \r\n;login:, 24, Sept. 1999. \r\n[6] Castro, M., Costa, M., Harris, T. 2006. Securing Software by \r\nEnforcing Data-flow Integrity. In Proceedings of OSDI'06. \r\n[7] Chiang, K., Lloyd, L. 2007. A Case Study of the Rustock \r\nRootkit and Spam Bot. Proceedings of the First Workshop \r\non Hot Topics in Understanding Botnets (HotBots'07), April \r\n2007. \r\n[8] Decker, A., Sancho, D., Kharouni, L., Goncharov, M., and \r\nMcArdle, R. 2009. Pushdo/Cutwail: A Study Of The Push\u0002do/Cutwail Botnet. Trend Micro Technical Report, May \r\n2009. \r\n[9] Giuliani, M. ZeroAccess – an advanced kernel mode rootkit, \r\nrev 1.2. www.prevxresearch.com/zeroaccess_analysis.pdf \r\n[10] Hayes, B. 2010. Who Goes There? An Introduction to On\u0002Access Virus Scanning, Part One. Symantec Connect Com\u0002munity. http://www.symantec.com/connect/articles/who\u0002goes-there-introduction-access-virus-scanning-part-one \r\n[11] Kapoor, A. and Mathur, R. 2011. Predicting the future of \r\nstealth attacks. Virus Bulletin 2011, Barcelona. \r\n[12] Kaspersky Lab. The Mystery of Duqu: Part One. \r\nhttp://www.securelist.com/en/blog/208193182/The_Mystery\r\n_of_Duqu_Part_One \r\n[13] Kaspersky Lab. The Mystery of Duqu: Part Five. \r\nhttp://www.securelist.com/en/blog/606/The_Mystery_of_Du\r\nqu_Part_Five \r\n[14] Kil, C., Sezer, E., Azab, A., Ning, P., and Zhang, X. 2009. \r\nRemote attestation to dynamic system properties: Towards \r\nproviding complete system integrity evidence. Proceedings \r\nof the 39th Annual IEEE/IFIP International Conference on \r\nDependable Systems and Networks (DSN’09), Lisbon, Por\u0002tugal. \r\n[15] Kwiatek, L. and Litawa, S. 2008. Yet another Rustock analy\u0002sis... Virus Bulletin, August 2008. \r\n[16] Li, J., Wang, Z., Bletsch, T., Srinivasan, D., Grace, M., and \r\nJiang, X. 2011. Comprehensive and Efficient Protection of \r\nKernel Control Data. IEEE Transactions on Information Fo\u0002rensics and Security, 6(2), June 2011. \r\n[17] Microsoft. Using Timer Objects. \r\nhttp://msdn.microsoft.com/en-us/library/ff565561.aspx. \r\n[18] Microsoft. Checked Build of Windows. \r\nhttp://msdn.microsoft.com/en\u0002us/library/windows/hardware/ff543457%28v=vs.85%29.aspx \r\n[19] Necula, G. C., McPeak, S., Rahul, S. P. and Weimer, W. \r\n2002. CIL: Intermediate language and tools for analysis and \r\ntransformation of C programs. Proceedings of Conference on \r\nCompiler Construction (CC), Grenoble, France, Apr. 2002. \r\n[20] OffensiveComputing. Storm Worm Process Injection from \r\nthe Windows Kernel. \r\nhttp://offensivecomputing.net/papers/storm-3-9-2008.pdf \r\n[21] Petroni, N., Fraser, T., Molina, J., Arbaugh, W. A. 2004. \r\nCopilot—a coprocessor-based kernel runtime integrity moni\u0002tor. Proceedings of the 13th USENIX Security Symposium, \r\nSan Diego, CA, Aug. 2004. \r\n[22] Petroni, N. and Hicks, M. 2007. Automated detection of \r\npersistent kernel control-flow attacks. Proceedings of ACM \r\nConference on Computer and Communications Security \r\n(CCS’07). \r\n[23] Prakash, C. 2008. What makes the Rustocks tick! Proceed\u0002ings of the 11th Association of anti-Virus Asia Researchers \r\nInternational Conference (AVAR’08), New Delhi, India. \r\nhttp://www.sunbeltsecurity.com/dl/WhatMakesRustocksTick\r\n.pdf \r\n[24] Riley, R., Jiang, X., and Xu, D. 2008. Guest-transparent \r\nprevention of kernel rootkits with VMM-Based memory \r\nshadowing. Proceedings of the 11th International Sympo\u0002sium on Recent Advances in Intrusion Detection (RAID’08). \r\n[25] Seshadri, A., Luk, M., Qu, N., and Perrig, A. 2007. SecVi\u0002sor: A tiny hypervisor to provide lifetime kernel code integri\u0002ty for commodity OSes. Proceedings of ACM Symposium on \r\nOperating Systems Principles (SOSP’07). \r\n[26] Smalley, S., Vance, C., and Salamon, W. 2002. Implement\u0002ing SELinux as a Linux Security Module. In Technical Re\u0002port. NSA, May 2002. \r\n[27] Solar Designer. Bugtraq: Getting around non-executable \r\nstack (and fix). Website. \r\nhttp://seclists.org/bugtraq/1997/Aug/63, accessed March \r\n2011. \r\n[28] Super PI. http://www.superpi.net/ \r\n[29] Symantec Connect Community. W32.Duqu: The Precursor \r\nto the Next Stuxnet. Oct. 2011. \r\nhttp://www.symantec.com/connect/w32_duqu_precursor_ne\r\nxt_stuxnet \r\n[30] Tran, M., Etheridge, M., Bletsch, T., Jiang, X., Freeh, V. W., \r\nand Ning, P. 2011. On the Expressiveness of Return-into-libc \r\nAttacks. Proceedings of the 14th International Symposium \r\non Recent Advances in Intrusion Detection (RAID 2011), \r\nMenlo Park, California, September 2011. \r\n[31] Wang, Z., Jiang, X., Cui, W., and Ning, P. 2009. Countering \r\nkernel rootkits with lightweight hook protection. Proceed\u0002ings of ACM Conference on Computer and Communications \r\nSecurity (CCS ’09).\r\n[32] Wei, J., and Pu, C. 2012. Towards a General Defense against \r\nKernel Queue Hooking Attacks. Elsevier Journal of Com-",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/aecede04-92d1-4944-b21f-596161b1293c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=22cc2cdabd24287d6b11661593b10780e597a718cb0d95d145481c70b102b8b3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 708
      },
      {
        "segments": [
          {
            "segment_id": "aecede04-92d1-4944-b21f-596161b1293c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "13 \r\n8. REFERENCES \r\n[1] Abadi, M., Budiu, M., Erlingsson, U., and Ligatti, J. 2005. \r\nControl-flow integrity. Proceedings of the 12th ACM Confe\u0002rence on Computer and Communications Security, Nov. \r\n2005. \r\n[2] Anselmi, D., Boscovich, R., Campana, T. J., Doerr, S., Lau\u0002ricella, M., Petrovsky, O., Saade, T., Stewart, H. 2011. Bat\u0002tling the Rustock Threat. Microsoft Security Intelligence Re\u0002port, Special Edition, January 2010 through May 2011. \r\n[3] Baliga, A., Ganapathy, V., and Iftode, L. 2008. Automatic \r\ninference and enforcement of kernel data structure inva\u0002riants. In ACSAC ’08: Proceedings of the 2008 Annual Com\u0002puter Security Applications Conference, pages 77–86. IEEE \r\nComputer Society. \r\n[4] Boldewin, F. 2007. Peacomm.C - Cracking the nutshell. Anti \r\nRootkit, September 2007. \r\nhttp://www.antirootkit.com/articles/eye-of-the-storm\u0002worm/Peacomm-C-Cracking-the-nutshell.html. \r\n[5] Brumley, D. 1999. Invisible intruders: rootkits in practice. \r\n;login:, 24, Sept. 1999. \r\n[6] Castro, M., Costa, M., Harris, T. 2006. Securing Software by \r\nEnforcing Data-flow Integrity. In Proceedings of OSDI'06. \r\n[7] Chiang, K., Lloyd, L. 2007. A Case Study of the Rustock \r\nRootkit and Spam Bot. Proceedings of the First Workshop \r\non Hot Topics in Understanding Botnets (HotBots'07), April \r\n2007. \r\n[8] Decker, A., Sancho, D., Kharouni, L., Goncharov, M., and \r\nMcArdle, R. 2009. Pushdo/Cutwail: A Study Of The Push\u0002do/Cutwail Botnet. Trend Micro Technical Report, May \r\n2009. \r\n[9] Giuliani, M. ZeroAccess – an advanced kernel mode rootkit, \r\nrev 1.2. www.prevxresearch.com/zeroaccess_analysis.pdf \r\n[10] Hayes, B. 2010. Who Goes There? An Introduction to On\u0002Access Virus Scanning, Part One. Symantec Connect Com\u0002munity. http://www.symantec.com/connect/articles/who\u0002goes-there-introduction-access-virus-scanning-part-one \r\n[11] Kapoor, A. and Mathur, R. 2011. Predicting the future of \r\nstealth attacks. Virus Bulletin 2011, Barcelona. \r\n[12] Kaspersky Lab. The Mystery of Duqu: Part One. \r\nhttp://www.securelist.com/en/blog/208193182/The_Mystery\r\n_of_Duqu_Part_One \r\n[13] Kaspersky Lab. The Mystery of Duqu: Part Five. \r\nhttp://www.securelist.com/en/blog/606/The_Mystery_of_Du\r\nqu_Part_Five \r\n[14] Kil, C., Sezer, E., Azab, A., Ning, P., and Zhang, X. 2009. \r\nRemote attestation to dynamic system properties: Towards \r\nproviding complete system integrity evidence. Proceedings \r\nof the 39th Annual IEEE/IFIP International Conference on \r\nDependable Systems and Networks (DSN’09), Lisbon, Por\u0002tugal. \r\n[15] Kwiatek, L. and Litawa, S. 2008. Yet another Rustock analy\u0002sis... Virus Bulletin, August 2008. \r\n[16] Li, J., Wang, Z., Bletsch, T., Srinivasan, D., Grace, M., and \r\nJiang, X. 2011. Comprehensive and Efficient Protection of \r\nKernel Control Data. IEEE Transactions on Information Fo\u0002rensics and Security, 6(2), June 2011. \r\n[17] Microsoft. Using Timer Objects. \r\nhttp://msdn.microsoft.com/en-us/library/ff565561.aspx. \r\n[18] Microsoft. Checked Build of Windows. \r\nhttp://msdn.microsoft.com/en\u0002us/library/windows/hardware/ff543457%28v=vs.85%29.aspx \r\n[19] Necula, G. C., McPeak, S., Rahul, S. P. and Weimer, W. \r\n2002. CIL: Intermediate language and tools for analysis and \r\ntransformation of C programs. Proceedings of Conference on \r\nCompiler Construction (CC), Grenoble, France, Apr. 2002. \r\n[20] OffensiveComputing. Storm Worm Process Injection from \r\nthe Windows Kernel. \r\nhttp://offensivecomputing.net/papers/storm-3-9-2008.pdf \r\n[21] Petroni, N., Fraser, T., Molina, J., Arbaugh, W. A. 2004. \r\nCopilot—a coprocessor-based kernel runtime integrity moni\u0002tor. Proceedings of the 13th USENIX Security Symposium, \r\nSan Diego, CA, Aug. 2004. \r\n[22] Petroni, N. and Hicks, M. 2007. Automated detection of \r\npersistent kernel control-flow attacks. Proceedings of ACM \r\nConference on Computer and Communications Security \r\n(CCS’07). \r\n[23] Prakash, C. 2008. What makes the Rustocks tick! Proceed\u0002ings of the 11th Association of anti-Virus Asia Researchers \r\nInternational Conference (AVAR’08), New Delhi, India. \r\nhttp://www.sunbeltsecurity.com/dl/WhatMakesRustocksTick\r\n.pdf \r\n[24] Riley, R., Jiang, X., and Xu, D. 2008. Guest-transparent \r\nprevention of kernel rootkits with VMM-Based memory \r\nshadowing. Proceedings of the 11th International Sympo\u0002sium on Recent Advances in Intrusion Detection (RAID’08). \r\n[25] Seshadri, A., Luk, M., Qu, N., and Perrig, A. 2007. SecVi\u0002sor: A tiny hypervisor to provide lifetime kernel code integri\u0002ty for commodity OSes. Proceedings of ACM Symposium on \r\nOperating Systems Principles (SOSP’07). \r\n[26] Smalley, S., Vance, C., and Salamon, W. 2002. Implement\u0002ing SELinux as a Linux Security Module. In Technical Re\u0002port. NSA, May 2002. \r\n[27] Solar Designer. Bugtraq: Getting around non-executable \r\nstack (and fix). Website. \r\nhttp://seclists.org/bugtraq/1997/Aug/63, accessed March \r\n2011. \r\n[28] Super PI. http://www.superpi.net/ \r\n[29] Symantec Connect Community. W32.Duqu: The Precursor \r\nto the Next Stuxnet. Oct. 2011. \r\nhttp://www.symantec.com/connect/w32_duqu_precursor_ne\r\nxt_stuxnet \r\n[30] Tran, M., Etheridge, M., Bletsch, T., Jiang, X., Freeh, V. W., \r\nand Ning, P. 2011. On the Expressiveness of Return-into-libc \r\nAttacks. Proceedings of the 14th International Symposium \r\non Recent Advances in Intrusion Detection (RAID 2011), \r\nMenlo Park, California, September 2011. \r\n[31] Wang, Z., Jiang, X., Cui, W., and Ning, P. 2009. Countering \r\nkernel rootkits with lightweight hook protection. Proceed\u0002ings of ACM Conference on Computer and Communications \r\nSecurity (CCS ’09).\r\n[32] Wei, J., and Pu, C. 2012. Towards a General Defense against \r\nKernel Queue Hooking Attacks. Elsevier Journal of Com-",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/aecede04-92d1-4944-b21f-596161b1293c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=22cc2cdabd24287d6b11661593b10780e597a718cb0d95d145481c70b102b8b3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 708
      },
      {
        "segments": [
          {
            "segment_id": "b9ad6ca6-dfb9-4295-ae4d-eb75a9507b86",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "14 \r\nputers & Security, Volume 31, Issue 2, pp. 176-191, March \r\n2012. doi:10.1016/j.cose.2011.12.007. \r\n[33] Windows Research Kernel v1.2. \r\nhttps://www.facultyresourcecenter.com/curriculum/pfv.aspx?\r\nID=7366&c1=en-us&c2=0 \r\n9. APPENDIX \r\nTable 9: A List of Automatically-Detected KQs for the WRK \r\nK-Queue Name Data Structure Type Queue header name (global \r\nvariable) \r\n# param. \r\ntainted (static) \r\nName of Request Insertion Function(s) \r\nI/O timer queue IO_TIMER IopTimerQueueHead 2 IoInitializeTimer \r\nFile system regis\u0002tration change noti\u0002fication queue \r\nNOTIFICA\u0002TION_PACKET IopFsNotifyChange\u0002QueueHead 0 IoRegisterFsRegistrationChange, IoUnregis\u0002terFsRegistrationChange \r\nProcess crea\u0002tion/deletion notifi\u0002cation queue \r\nArray of \r\nEX_CALLBACK \r\nPspCreateProcessNotify\u0002Routine 0 PsSetCreateProcessNotifyRoutine \r\nDriver reinitialize \r\nroutine queue \r\nREINIT_PACKET IopDriverReinitialize\u0002QueueHead 3 IoRegisterDriverReinitialization \r\nBoot driver reini\u0002tialize routine \r\nqueue \r\nREINIT_PACKET IopBootDriverReinitialize\u0002QueueHead 3 IoRegisterBootDriverReinitialization \r\nThread Crea\u0002tion/Deletion notifi\u0002cation queue \r\nArray of \r\nEX_CALLBACK \r\nPspCreateThreadNotifyRou\u0002tine 0 PsSetCreateThreadNotifyRoutine, PsRemo\u0002veCreateThreadNotifyRoutine \r\nRegistryCallback \r\nqueue \r\nArray of \r\nEX_CALLBACK \r\nCmpCallBackVector 1 CmRegisterCallback, CmUnRegisterCall\u0002back \r\nLoad image notifi\u0002cation queue Array of \r\nEX_CALLBACK \r\nPspLoadImageNotifyRou\u0002tine 0 PsSetLoadImageNotifyRoutine, PsRemove\u0002LoadImageNotifyRoutine \r\nBug check reason \r\ncallback queue \r\nKBUG\u0002CHECK_REASON_CA\r\nLLBACK_RECORD \r\nKeBugCheckReasonCall\u0002backListHead 1 KeRegisterBugCheckReasonCallback \r\nCallback object \r\nqueue \r\nCALL\u0002BACK_REGISTRATIO\r\nN \r\nExpInitializeCallback 1 ExRegisterCallback, ExUnregisterCallback \r\nWaiting IRP queue WAITING_IRP Queue head not a global \r\nvariable, instead one field of \r\nany opportunistic lock ob\u0002ject \r\n2 FsRtlWaitOnIrp \r\nIRP waiting lock \r\nqueue \r\nWAITING_LOCK FsRtlFileLockCancelColli\u0002deList, FsRtlWaitingLock\u0002LookasideList \r\n2 FsRtlPrivateLock \r\nFirmware table \r\nproviders queue \r\nSYS\u0002TEM_FIRMWARE_TA\r\nBLE_HANDLER_NOD\r\nE \r\nExpFirmwareTableProvi\u0002derListHead 1 ExpRegisterFirmwareTableInformation\u0002Handler \r\nBugCheckCallback \r\nroutine queue \r\nKBUG\u0002CHECK_CALLBACK_\r\nRECORD \r\nKeBugCheckCallbackList\u0002Head 2 KeRegisterBugCheckCallback \r\nDeferred write \r\nqueue \r\nDEFERRED_WRITE CcDeferredWrites 2 CcDeferWrite \r\nPer-stream context \r\nqueue \r\nFSRTL_PER_STREAM\r\n_CONTEXT \r\nFSRTL_ADVANCED_FCB\r\n_HEADER structure with a \r\nfile stream, no global header\r\n1 FsRtlInsertPerStreamContext \r\nChange directory \r\nnotification queue \r\nNOTIFY_CHANGE A notify list associated with \r\na file system, no global \r\nheader \r\n3 FsRtlNotifyFilterChangeDirectory \r\nSystem worker \r\nthread queue \r\nWORK_QUEUE_ITEM ExWorkerQueue[3] 1 ExQueueWorkItem \r\nAPC queue APC Not found yet 5,1,3 KeInitializeApc \r\nDPC queue DPC Not found yet 3 KiInitializeDpc ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/b9ad6ca6-dfb9-4295-ae4d-eb75a9507b86.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8c882532bea9c2bdc10d464891185d20ea2ed685cb1a647754cc0d82899c9b47",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 259
      },
      {
        "segments": [
          {
            "segment_id": "d90da1aa-554f-43cd-8220-a4f81c37976d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "15 \r\nTable 10: A List of 22 Automatically-Detected KQs for Linux Kernel 2.4.32 \r\nK-Queue Name Data Structure Type Queue Header Name \r\n(global variable) \r\n# param. \r\ntainted \r\n(static) \r\nName of Dispatch Func\u0002tion(s) Name of Request Insertion \r\nFunction(s) \r\nACPI bus driver \r\nqueue \r\nstruct acpi_driver (struct \r\nlist_head) \r\nacpi_bus_drivers 0 acpi_bus_find_driver acpi_bus_register_driver, \r\nacpi_bus_unregister_driver\r\nTask queue struct tq_struct (struct \r\nlist_head) \r\nNo single global \r\nqueue header; device \r\ndrivers can declare \r\ntheir own queue \r\nheader. \r\n1 run_task_queue queue_task \r\nSoft timer queue struct timer_list (struct \r\nlist_head) \r\ntvecs[] 1 run_timer_list add_timer, del_timer, \r\nmod_timer \r\nTasklet queue struct tasklet_struct (next \r\n* to self) \r\ntasklet_vec[], task\u0002let_hi_vec[] 1 tasklet_action, task\u0002let_hi_action tasklet_schedule, task\u0002let_hi_schedule \r\nPacket type queue struct packet_type (next * \r\nto self) \r\nptype_all, \r\nptype_base[], \r\n1 dev_queue_xmit_nit, ne\u0002tif_receive_skb dev_add_pack, \r\ndev_remove_pack \r\nIRQ action queue struct irqaction (next * to \r\nself) \r\nirq_desc[].action 1 handle_IRQ_event request_irq, free_irq \r\nBinary formats \r\nhandler queue \r\nstruct linux_binfmt (next \r\n* to self) \r\nformats 0 sys_uselib, \r\nsearch_binary_handler \r\nregister_binfmt, unregis\u0002ter_binfmt \r\nPC Card client \r\ndriver queue \r\ndriver_info_t (next * to \r\nself) \r\nroot_driver 0 bind_request register_pccard_driver, \r\nunregister_pccard_driver \r\nIP socket interfac\u0002es queue struct inet_protosw (struct \r\nlist_head) \r\ninetsw[] 0 inet_create inet_register_protosw, \r\ninet_unregister_protosw \r\nPower manage\u0002ment notification \r\nqueue \r\nstruct pm_dev (struct \r\nlist_head) \r\npm_devs 1 pm_send_all pm_register, \r\npm_unregister, \r\n__pm_unregister, \r\npm_unregister_all \r\nPCI driver queue struct pci_driver (struct \r\nlist_head) \r\npci_drivers 1 pci_announce_device_to_dri\r\nvers \r\npci_register_driver, \r\npci_unregister_driver \r\nDead destination \r\ncache queue \r\nstruct dst_entry (next * to \r\nself) \r\ndst_garbage_list 1 dst_run_gc dst_free \r\nINET protocol \r\nhandlers queue \r\nstruct inet_protocol (next \r\n* to self) \r\ninet_protos[] 0 ip_local_deliver_finish, \r\nicmp_unreach, \r\ninet_add_protocol, in\u0002et_del_protocol \r\nConsole drivers \r\nqueue \r\nstruct console (next * to \r\nself) \r\nconsole_drivers 1; 0; 1; call_console_drivers, con\u0002sole_unblank, tty_open register_console, unregis\u0002ter_console \r\nPanic notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\npanic_notifier_list 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nReboot notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\nreboot_notifier_list 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nNetwork notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\nnetdev_chain 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nNetwork link no\u0002tifiers queue struct notifier_block (next \r\n* to self) \r\nnetlink_chain 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nIPv4 Interface \r\naddress notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\ninetaddr_chain 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nIPv6 Interface \r\naddress notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\ninet6addr_chain 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nADB device no\u0002tifiers queue struct notifier_block (next \r\n* to self) \r\nadb_client_list 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister \r\nHCI notifiers \r\nqueue \r\nstruct notifier_block (next \r\n* to self) \r\nhci_notifier 1 notifier_call_chain notifier_chain_register, \r\nnotifier_chain_unregister ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/20f1eac8-4aad-4adc-903d-777bbb9d6ef1/images/d90da1aa-554f-43cd-8220-a4f81c37976d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041505Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3a294adb4a84697c9dc13003a328d07c5d519301bfd1f769f0ffd84bc5f2b344",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 367
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No response"
        }
      ]
    }
  }
}