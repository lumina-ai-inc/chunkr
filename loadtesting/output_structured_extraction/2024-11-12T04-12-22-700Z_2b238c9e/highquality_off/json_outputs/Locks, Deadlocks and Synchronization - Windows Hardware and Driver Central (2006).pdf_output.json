{
  "file_name": "Locks, Deadlocks and Synchronization - Windows Hardware and Driver Central (2006).pdf.docx",
  "task_id": "5f4b29f9-37ea-44e0-ba7b-f4579ef353ed",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "ea8c0fc2-ee8c-4872-a736-0738405fbe0f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and \r\nSynchronization\r\nApril 5, 2006\r\nAbstract\r\nThis paper explains how to use synchronization mechanisms to protect shared \r\nmemory locations in kernel-mode drivers for the Microsoft® Windows® family of \r\noperating systems. By following the guidelines in this paper, driver writers will be \r\nable to determine when synchronization is required, what synchronization \r\nmechanisms are provided by the operating system, and how each type of \r\nsynchronization mechanism is used.\r\nThis paper builds on topics that are introduced in the companion white paper \r\n“Scheduling, Thread Context, and IRQL” at \r\nhttp://www.microsoft.com/whdc/hwdev/driver/IRQL.mspx. Readers of this paper \r\nshould be familiar with the information presented there.\r\nContents\r\nIntroduction..............................................................................................................................4\r\nChoosing a Synchronization Mechanism.................................................................................5\r\nInterlocked Operations...................................................................................................6\r\nMutexes..........................................................................................................................6\r\nShared/Exclusive Locks.................................................................................................7\r\nCounted Semaphores....................................................................................................7\r\nWindows Synchronization Mechanisms...................................................................................7\r\nInterlockedXxx Routines..........................................................................................................8\r\nSpin Locks...............................................................................................................................9\r\nOrdinary Spin Locks..........................................................................................................10\r\nQueued Spin Locks...........................................................................................................10\r\nInterrupt Spin Locks..........................................................................................................10\r\nExInterlockedXxx Routines....................................................................................................11",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/ea8c0fc2-ee8c-4872-a736-0738405fbe0f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bc800ae102244a8be66ea836c74860cbeed8a412f8be6145edcb0ce0894a842f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "316180c2-c3ef-4cd7-b356-727e809792c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 2\r\nFast Mutexes.........................................................................................................................13\r\nKernel Dispatcher Objects.....................................................................................................14\r\nCommon Features............................................................................................................15\r\nIRQL Restrictions.........................................................................................................16\r\nAlerts and Wait Modes.................................................................................................16\r\nEvents...............................................................................................................................18\r\nNotification Events........................................................................................................18\r\nSynchronization Events................................................................................................19\r\nSynchronizing with User-Mode Applications................................................................19\r\nKernel Mutexes.................................................................................................................20\r\nSemaphores......................................................................................................................21\r\nTimers...............................................................................................................................22\r\nThreads, Processes, and Files..........................................................................................23\r\nExecutive Resources.............................................................................................................23\r\nCallback Objects....................................................................................................................26\r\nDriver-Defined Locks.............................................................................................................26\r\nUsing Multiple Synchronization Mechanisms Simultaneously...............................................26\r\nPreventing Deadlocks............................................................................................................27\r\nSecurity Issues.......................................................................................................................28\r\nPerformance Issues...............................................................................................................28\r\nBest Practices for Driver Synchronization..............................................................................29\r\nCall to Action and Resources.................................................................................................30\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/316180c2-c3ef-4cd7-b356-727e809792c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fafad79cf5826bf4ae6adf1615db321e3940bc9e3f383fd2db9571f7e34ba95f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 200
      },
      {
        "segments": [
          {
            "segment_id": "93ed1a47-759d-4366-87ca-11bab5dbb331",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 3\r\nDisclaimer\r\nThis is a preliminary document and may be changed substantially prior to final commercial release of the\r\nsoftware described herein. \r\nThe information contained in this document represents the current view of Microsoft Corporation on the \r\nissues discussed as of the date of publication. Because Microsoft must respond to changing market \r\nconditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot\r\nguarantee the accuracy of any information presented after the date of publication.\r\nThis White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, \r\nEXPRESS, IMPLIED OR STATUTORY, AS TO THE INFORMATION IN THIS DOCUMENT.\r\nComplying with all applicable copyright laws is the responsibility of the user. Without limiting the rights \r\nunder copyright, no part of this document may be reproduced, stored in or introduced into a retrieval \r\nsystem, or transmitted in any form or by any means (electronic, mechanical, photocopying, recording, or \r\notherwise), or for any purpose, without the express written permission of Microsoft Corporation. \r\nMicrosoft may have patents, patent applications, trademarks, copyrights, or other intellectual property \r\nrights covering subject matter in this document. Except as expressly provided in any written license \r\nagreement from Microsoft, the furnishing of this document does not give you any license to these \r\npatents, trademarks, copyrights, or other intellectual property.\r\nUnless otherwise noted, the example companies, organizations, products, domain names, e-mail \r\naddresses, logos, people, places and events depicted herein are fictitious, and no association with any \r\nreal company, organization, product, domain name, email address, logo, person, place or event is \r\nintended or should be inferred. \r\n© 2004 Microsoft Corporation. All rights reserved.\r\nMicrosoft, Windows, and Windows Vista are either registered trademarks or trademarks of Microsoft \r\nCorporation in the United States and/or other countries.\r\nThe names of actual companies and products mentioned herein may be the trademarks of their \r\nrespective owners.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/93ed1a47-759d-4366-87ca-11bab5dbb331.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=da756403be6ec3dce03ae29f04eb892cf6242e5141771cc6160f57df92821332",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 317
      },
      {
        "segments": [
          {
            "segment_id": "cb77d63f-08c1-407d-87bf-bb3e6eb1d741",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 4\r\n1 Introduction\r\nThe Microsoft® Windows® family of operating systems provides a variety of \r\nmechanisms that drivers can use for synchronization. Synchronization is required \r\nfor:\r\n Any shared data that multiple threads might access, unless all threads access it\r\nin a read-only manner.\r\n A set of operations that must be performed atomically.\r\nTo understand why synchronization is important, consider a situation in which two \r\nthreads attempt to add one to the same global variable. This operation might \r\nrequire three processor instructions:\r\n1. Read MyVar into a register.\r\n2. Add 1 to the value in the register.\r\n3. Write the value of the register into MyVar.\r\nIf the two threads run simultaneously on a multiprocessor system with no locks or \r\nother synchronization, the results of an update could be lost. For example, assume \r\nthat the initial value of MyVar is 0 and that the operations proceed in the order \r\nshown below.\r\nThreads Using No Locks on a Multiprocessor System\r\nThread A on Processor 1 Thread B on Processor 2\r\nRead MyVar into register on \r\nProcessor 1.\r\nRead MyVar into register on \r\nProcessor 2.\r\nAdd 1 to Processor 2 register.\r\nWrite Processor 2 register into \r\nMyVar.\r\nAdd 1 to Processor 1 register.\r\nWrite Processor 1 register into \r\nMyVar.\r\nAfter both threads have updated MyVar, its value should be 2. However, the \r\nThread B update is lost when Thread A increments the original value of MyVar and \r\nthen overwrites the variable. Problems like this are often called race conditions.\r\nOn a single-processor system, thread pre-emption can also cause race conditions. \r\nAt any time, the operating system may temporarily stop running a thread and \r\ninstead run a different, higher-priority thread. When the system pre-empts a thread, \r\nthe operating system saves the values of the processor’s registers in the thread and\r\nrestores them when the thread runs again.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/cb77d63f-08c1-407d-87bf-bb3e6eb1d741.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3a3d28dfac4c9732f336e692274d3874171850a7865f87c0822ab380581f82cb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 315
      },
      {
        "segments": [
          {
            "segment_id": "eccc3ccf-e554-4cdf-9116-3aa240b76f80",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 5\r\nThe following example shows how a race condition can result from thread pre\u0002emption. As in the previous example, assume that the initial value of MyVar is 0.\r\nThreads Using No Locks on a Single Processor System\r\nThread A Thread B\r\nRead MyVar into register.\r\nPre-empt Thread A; run Thread B.\r\nRead MyVar into register.\r\nAdd 1 to register.\r\nWrite register into MyVar.\r\nPre-empt Thread B; run Thread A.\r\nAdd 1 to register.\r\nWrite register into MyVar.\r\nAs in the multiprocessor example, the resulting value in MyVar is 1 instead of 2.\r\nIn both examples, using a lock to synchronize access to the variable would prevent \r\nthe race condition. The lock ensures that Thread A has finished its update before \r\nThread B accesses the variable, as shown in the following example.\r\nThreads Using a Lock on Any System\r\nThread A Thread B\r\nAcquire lock.\r\nRead MyVar into register.\r\nAdd 1 to register.\r\nWrite register into MyVar.\r\nRelease lock. Acquire lock.\r\nRead MyVar into register.\r\nAdd 1 to register.\r\nWrite register into MyVar.\r\nRelease lock.\r\nThe lock ensures that one thread’s read and write operations are complete before \r\nanother thread can access the variable. With locks in place, the final value of MyVar\r\nafter these two code sequences complete is 2, which is the correct, intended result \r\nof the operation.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/eccc3ccf-e554-4cdf-9116-3aa240b76f80.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=99d82066d00d54ccf94569a41c4a83d8b26260a49d78c5ba6469898b16f38085",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 230
      },
      {
        "segments": [
          {
            "segment_id": "7fc914f1-e35a-4756-91f4-88705e9f827c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 6\r\n2 Choosing a Synchronization Mechanism\r\nThe best way to synchronize access in any particular situation depends on the \r\noperations that require synchronization. Synchronization methods fall into several \r\nbroad categories. Within each category, Windows provides one or more specific \r\nmechanisms that drivers can use. Table 1 is a list of common synchronization \r\nmethods.\r\nTable 1. Common Synchronization Methods\r\nSynchronization \r\nmethod\r\nDescription Windows mechanisms\r\nInterlocked \r\noperations\r\nProvides atomic logical, \r\narithmetic, and list \r\nmanipulation operations that \r\nare both thread-safe and \r\nmultiprocessor safe.\r\nInterlockedXxx and \r\nExInterlockedXxx routines\r\nMutexes Provides (mutually) exclusive\r\naccess to memory.\r\nSpin locks, fast mutexes, kernel \r\nmutexes, synchronization \r\nevents\r\nShared/exclusive lock Allows one thread to write or \r\nmany threads to read the \r\nprotected data.\r\nExecutive resources\r\nCounted semaphore Allows a fixed number of \r\nacquisitions.\r\nSemaphores\r\nThe following sections provide additional details about each of these \r\nsynchronization methods.\r\n2.1.1 Interlocked Operations\r\nAn interlocked operation completes a common task atomically. Windows provides \r\ninterlocked routines to perform arithmetic and logical operations and to manipulate \r\nlists.\r\n2.1.2 Mutexes\r\nA mutex ensures mutually exclusive access; that is, while one thread has the \r\nmutex, all other threads are excluded from using it. A thread acquires the mutex \r\nbefore accessing the protected data and releases the mutex when access is \r\ncomplete. If the mutex is acquired, other threads must either spin or wait until it is \r\nreleased before they can acquire it.\r\nAny lock that grants mutually exclusive access can be considered a mutex. For \r\nexample, spin locks and synchronization events are both mutexes because only \r\none thread can acquire a spin lock at a time and only one thread becomes eligible \r\nfor execution when a synchronization event is signaled, The type of mutex that is \r\nappropriate for any particular situation depends on where and how the mutex will be\r\nused. When you are selecting a mutex, consider the following:\r\n At what IRQLs can the mutex be acquired and released?\r\n Does acquiring the mutex raise the current IRQL? If so, where is the old IRQL \r\nstored?\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/7fc914f1-e35a-4756-91f4-88705e9f827c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b87778d73c9e18b28b1b982511ea168ab37f97f2dc6c08f5b96b373295fd0d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 342
      },
      {
        "segments": [
          {
            "segment_id": "c39072a1-991c-4125-96f3-540e157c974c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 7\r\n Must the mutex be released on the same thread that acquired it?\r\n Can the mutex be acquired recursively? (That is, can a thread acquire the same\r\nmutex more than once without releasing it?)\r\n What happens to a mutex if the thread that is holding it is terminated? (This \r\nissue applies primarily to the mutexes that are used in user-mode applications.)\r\nTable 2 is a list of the types of mutexes that are used in Windows drivers, along with\r\ntheir characteristics. Detailed information about each of the Windows mechanisms \r\nappears later in this paper.\r\nTable 2. Windows Mutex Mechanisms\r\nType of mutex IRQL considerations Recursion and thread \r\ndetails\r\nInterrupt spin \r\nlock\r\nAcquisition raises IRQL to DIRQ and \r\nreturns previous IRQL to caller.\r\nNot recursive.\r\nRelease on same thread as \r\nacquire.\r\nSpin lock Acquisition raises IRQL to \r\nDISPATCH_LEVEL and returns \r\nprevious IRQL to caller.\r\nNot recursive.\r\nRelease on same thread as \r\nacquire.\r\nQueued spin lock Acquisition raises IRQL to \r\nDISPATCH_LEVEL and stores \r\nprevious IRQL in lock owner handle.\r\nNot recursive.\r\nRelease on same thread as \r\nacquire.\r\nFast mutex Acquisition raises IRQL to \r\nAPC_LEVEL and stores previous \r\nIRQL in lock.\r\nNot recursive.\r\nRelease on same thread as \r\nacquire.\r\nKernel mutex (a \r\nkernel dispatcher\r\nobject)\r\nEnters critical region upon acquisition\r\nand leaves critical region upon \r\nrelease.\r\nRecursive.\r\nRelease on same thread as \r\nacquire.\r\nSynchronization \r\nevent (a kernel \r\ndispatcher \r\nobject)\r\nAcquisition does not change IRQL. \r\nWait at IRQL <= APC_LEVEL and \r\nsignal at IRQL <= \r\nDISPATCH_LEVEL.\r\nNot recursive.\r\nRelease on the same thread\r\nor on a different thread.\r\nUnsafe fast \r\nmutex\r\nAcquisition does not change IRQL. \r\nAcquire and release at IRQL <= \r\nAPC_LEVEL.\r\nNot recursive.\r\nRelease on same thread as \r\nacquire.\r\n2.1.3 Shared/Exclusive Locks\r\nShared/exclusive locks, also called read/write locks, allow one thread to have \r\nexclusive access to shared data or allow many threads to share access to the same\r\ndata. The thread that has exclusive access can write the data; threads that share \r\naccess can only read the data.\r\nIn Windows, executive resources provide a shared/exclusive lock.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/c39072a1-991c-4125-96f3-540e157c974c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=95225521d84c801dcd49dc2e882ba4045480ca00bccc6ae0b0b849709b60d533",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 348
      },
      {
        "segments": [
          {
            "segment_id": "f88b47e9-d886-4ca2-8f90-aad3446c7db8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 8\r\n2.1.4 Counted Semaphores\r\nA counted semaphore is similar to a mutex, except that multiple threads can \r\nsimultaneously acquire a semaphore. Counted semaphores are useful for \r\nprotecting a set of identical data structures that are shared among several threads.\r\nIn Windows, the semaphore (a kernel dispatcher object) is a counted semaphore.\r\n3 Windows Synchronization Mechanisms\r\nWindows provides a variety of synchronization mechanisms, many of which are \r\nsubject to IRQL restrictions. Therefore, you must consider the effects of thread \r\ninterruption and understand the IRQLs at which your code might run.\r\nWhen the operating system interrupts a thread, it forces that thread to temporarily \r\nrun code at a higher interrupt request level (IRQL). (In other words, interruption is \r\nsimilar to a forced procedure call.)\r\nConsider the case where code running at a low IRQL successfully acquires a lock, \r\nbut the thread is interrupted to run code at a higher IRQL. If the higher-IRQL code \r\ntries to acquire the same lock, the thread may hang forever. The lower-IRQL code \r\ncannot run until the higher-IRQL code exits, but the higher-IRQL code cannot exit \r\nuntil the lower-IRQL code releases the lock. Only a single thread is involved. To \r\nprevent this problem, code that acquires a lock usually raises its IRQL to the \r\nhighest IRQL at which any driver code that acquires the lock can run.\r\nTable 3 is a list of the synchronization mechanisms available in Windows and the \r\nIRQL restrictions for each. Note that kernel dispatcher objects provide several types\r\nof synchronization that have a common structure and similar interfaces. The \r\nsections that follow this one describe each of the Windows mechanisms in detail.\r\nTable 3. Summary of Windows Synchronization Mechanisms\r\nWindows \r\nsynchronization \r\nmechanism\r\nDescription IRQL restrictions\r\nInterlockedXxx routines Perform atomic logical and \r\narithmetic operations on \r\npageable data.\r\nCall at any IRQL.\r\nSpin locks Allow exclusive access to \r\ndata in nonpaged memory.\r\nAcquire at IRQL <= \r\nDISPATCH_LEVEL.\r\nExInterlockedXxx\r\nroutines\r\nPerform atomic logical, \r\narithmetic, and list \r\nmanipulation operations that\r\nare thread-safe and \r\nmultiprocessor safe.\r\nCall SList routines at IRQL \r\n<= DISPATCH_LEVEL; call \r\nother routines at any IRQL.\r\nFast mutexes Protect data at APC_LEVEL,\r\npreventing thread \r\nsuspension.\r\nAcquire at IRQL <= \r\nAPC_LEVEL.\r\nExecutive resources Allow one thread to write or \r\nmany threads to read the \r\nprotected data.\r\nAcquire at \r\nIRQL<=APC_LEVEL.\r\nKernel dispatcher objects Provide various types of Wait at IRQL <= \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/f88b47e9-d886-4ca2-8f90-aad3446c7db8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=267230187d9b0b8d5cd83fa96027d91ca7ce866a384b1eccd9b86d8c3029af0e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 396
      },
      {
        "segments": [
          {
            "segment_id": "b0c114a7-0590-4989-be92-b0cb03a5194b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 9\r\nWindows \r\nsynchronization \r\nmechanism\r\nDescription IRQL restrictions\r\n(events, kernel mutexes, \r\nsemaphores, timers, files, \r\nthreads, processes)\r\nsynchronization at \r\nIRQL<=APC_LEVEL; can be\r\nused for synchronizing with \r\nuser-mode applications.\r\nAPC_LEVEL; signal at IRQL\r\n<= DISPATCH_LEVEL.\r\nCallback objects Provides kernel-mode code \r\nsynchronization at \r\nIRQL<=DISPATCH_LEVEL; \r\ncan be used to synchronize \r\nactivity between drivers.\r\nNotify at IRQL <= \r\nDISPATCH_LEVEL; \r\ncallback routines are called \r\nin the context of the notifying\r\nthread at the same IRQL at \r\nwhich notification occurred.\r\n4 InterlockedXxx Routines\r\nThe InterlockedXxx routines perform common arithmetic and logical operations \r\natomically, ensuring correct results on SMP systems. Whenever possible, drivers \r\nshould use these routines. Most of them are native processor instructions and \r\ntherefore do not require a lock.\r\nThe InterlockedXxx routines can be used with pageable data. They are usually \r\nimplemented inline by the compiler and can be called at any IRQL.\r\n5 Spin Locks\r\nA spin lock does exactly what its name implies: while one thread owns a spin lock, \r\nany other threads that are waiting to acquire the lock “spin” on a memory location in\r\na busy wait until the lock is available. The threads do not block—that is, they are not\r\nsuspended or paged out; they retain control of the CPU, thus preventing execution \r\nof other code at the same or a lower IRQL.\r\nSpin locks are opaque objects of type KSPIN_LOCK. They must be allocated from \r\nnonpaged memory, such as the device extension of a driver-created device object \r\nor nonpaged pool allocated by the caller. Windows defines several types of spin \r\nlocks, as described in Table 4.\r\nTable 4. Windows Spin Locks\r\nType of spin lock Description\r\nOrdinary spin lock Protects shared data at DISPATCH_LEVEL or higher. \r\nUsed with ExInterlockedXxx routines and elsewhere \r\nthroughout drivers. (Drivers for Windows XP or later \r\nversions of Windows should use queued spin locks \r\ninstead of ordinary spin locks.)\r\nQueued spin lock Protects shared data at DISPATCH_LEVEL or higher. \r\nUsed with ExInterlockedXxx routines and elsewhere \r\nthroughout drivers. Queued spin locks are supported on\r\nWindows XP and later versions of Windows.\r\nInterrupt spin lock Protects shared data at DIRQL. Used in \r\nInterruptService and SynchCritSection routines.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/b0c114a7-0590-4989-be92-b0cb03a5194b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b4b3297a47d0a1402fe8a04c87893e29900a24b183daab4e338357433bc9947",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 358
      },
      {
        "segments": [
          {
            "segment_id": "ae1cb58f-ef98-4120-95ce-1c488d2926d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 10\r\nAll types of spin locks raise the IRQL to DISPATCH_LEVEL or higher. Spin locks \r\nare the only synchronization mechanism that can be used at IRQL >= \r\nDISPATCH_LEVEL. Code that holds a spin lock runs at IRQL >= \r\nDISPATCH_LEVEL, which means that the system’s thread switching code (the \r\ndispatcher) cannot run and, therefore, the current thread cannot be pre-empted. \r\nTherefore, drivers should hold spin locks for only the minimum required amount of \r\ntime and eliminate from the locked code path any tasks that do not require locking. \r\nHolding a spin lock for an unnecessarily long duration can hurt performance \r\nsystem-wide.\r\nAll code within the spin lock must conform to the guidelines for running at IRQL >= \r\nDISPATCH_LEVEL. Every driver writer should understand these rules. For \r\nexample, code within the spin lock must not cause a page fault because at IRQL >=\r\nDISPATCH_LEVEL, the operating system cannot wait for the kernel dispatcher \r\nevent that is set internally when paging I/O completes. A page fault within a spin \r\nlock causes the system to crash with the bug check value \r\nIRQL_NOT_LESS_OR_EQUAL. Additional restrictions also apply. For complete \r\ninformation about these guidelines, see the companion white paper “Thread \r\nContext, Scheduling, and IRQL,” which is available at \r\nhttp://www.microsoft.com/whdc/hwdev/driver/IRQL.mspx.\r\nTo implement spin locks on a single-processor system, the operating system has \r\nonly to raise the IRQL, which prevents pre-emption of the current thread. Because \r\nno other threads can run concurrently, raising the IRQL is adequate to protect any \r\nshared structures. (Note, however, that the checked build of the operating system \r\nuses spin locks, even on single-processor systems.) On an SMP system, the \r\noperating system raises the IRQL and then spins by testing and setting a variable \r\nusing an interlocked instruction.\r\n5.1 Ordinary Spin Locks\r\nOrdinary spin locks work at DISPATCH_LEVEL. To create an ordinary spin lock, a \r\ndriver allocates a KSPIN_LOCK structure in nonpaged memory and then calls \r\nKeInitializeSpinLock to initialize it. Code that runs at IRQL < DISPATCH_LEVEL \r\nmust acquire and release the lock by calling KeAcquireSpinLock and \r\nKeReleaseSpinLock. These routines raise the IRQL before acquiring the lock and \r\nthen lower the IRQL upon release of the lock.\r\nCode that is already running at IRQL = DISPATCH_LEVEL should call \r\nKeAcquireSpinLockAtDpcLevel and KeReleaseSpinLockFromDpcLevel\r\ninstead. These routines do not change the IRQL.\r\n5.2 Queued Spin Locks\r\nQueued spin locks are a more efficient variation of ordinary spin locks. Queued spin\r\nlocks are available in Windows XP and later releases of Windows. Whenever \r\nmultiple threads request the same queued spin lock, the waiting threads are queued\r\nin order of their request. In addition, queued spin locks test and set a variable that is\r\nlocal to the current CPU, so they generate less bus traffic and are more efficient on \r\nnon-uniform memory architectures (NUMA).\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/ae1cb58f-ef98-4120-95ce-1c488d2926d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d2a113c0473bd907dffd31f7579080ca11b1bdf7975084c004ff3a4a8d58b395",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "5b009f94-25e8-4f6c-8879-1b61750dc433",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 11\r\nA queued spin lock requires a KLOCK_QUEUE_HANDLE structure in addition to a \r\nKSPIN_LOCK structure. The KLOCK_QUEUE_HANDLE structure provides storage\r\nfor a handle to the queue and the associated lock. This structure can be allocated \r\non the stack. To initialize a queued spin lock, the driver calls KeInitializeSpinLock.\r\nTo ensure that the IRQL is properly raised and lowered, driver routines that run at \r\nPASSIVE_LEVEL or APC_LEVEL must call KeAcquireInStackQueuedSpinLock\r\nand KeReleaseInStackQueuedSpinLock to acquire and release these locks \r\nDriver routines that run at DISPATCH_LEVEL should call \r\nKeAcquireInStackQueuedSpinLockAtDpcLevel and \r\nKeReleaseInStackQueuedSpinLockFromDpcLevel instead. These routines do \r\nnot raise and lower the IRQL.\r\n5.3 Interrupt Spin Locks\r\nAn interrupt spin lock protects data such as device registers that a driver’s \r\nInterruptService routine and SynchCritSection routine access at DIRQL. When a \r\ndevice driver connects its interrupt object, the operating system creates an interrupt \r\nspin lock associated with that interrupt object. The driver is not required to allocate \r\nstorage for the spin lock or to initialize it.\r\nWhen an interrupt occurs, the system raises the IRQL on the processor to DIRQL \r\nfor the interrupting device, acquires the default interrupt spin lock associated with \r\nthe interrupt object, and then calls the driver’s InterruptService routine. While the \r\nInterruptService routine is running, the processor IRQL remains at DIRQL and the \r\noperating system holds the corresponding interrupt spin lock. When the \r\nInterruptService routine exits, the operating system releases the lock and lowers the\r\nIRQL (unless another interrupt is pending at that level).\r\nThe system also acquires the default interrupt spin lock when a driver calls \r\nKeSynchronizeExecution to run a SynchCritSection routine. The operating system\r\nraises the IRQL to DIRQL for the device, acquires the lock, and invokes the \r\nSynchCritSection routine. When the routine exits, the operating system releases the\r\nlock and lowers the IRQL. Other driver routines that share data with the \r\nInterruptService routine or SynchCritSection routine must call \r\nKeAcquireInterruptSpinLock to acquire this lock before they can access the \r\nshared data. KeAcquireInterruptSpinLock is available on Windows XP and later \r\nreleases of Windows.\r\nSome types of devices can generate multiple interrupts at different levels. Examples\r\ninclude devices that support PCI 3.0 MSI-X, which generate message-signaled \r\ninterrupts (MSI), and a few older devices that interrupt at more than one IRQL. \r\nDrivers that support such devices must serialize access to data among two or more \r\nInterruptService routines.\r\nIn this case, the driver must create a spin lock to protect shared data at the highest \r\nDIRQL at which any interrupt may arrive. When the driver connects its interrupt \r\nobjects, it passes a pointer to the driver-allocated KSPIN_LOCK structure, along \r\nwith the highest DIRQL at which the device interrupts. The operating system \r\nassociates the driver-created spin lock and the DIRQL with the interrupt object.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/5b009f94-25e8-4f6c-8879-1b61750dc433.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d7b0056d0986c5713b41186ec833b355353a303191c87c75a9d87bfa4f15e081",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 459
      },
      {
        "segments": [
          {
            "segment_id": "06fdebcf-4e9e-4135-adcb-00ce91cb2a99",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 12\r\nWhen the operating system calls the InterruptService routines, it raises the IRQL to \r\nthe DIRQL specified with the interrupt object and acquires the driver-created spin \r\nlock. The system also uses this lock when it runs a SynchCritSection routine. Other \r\ndriver routines that share data with the InterruptService or SynchCritSection routine \r\nmust call KeAcquireInterruptSpinLock to acquire this lock before they can access\r\nthe shared data.\r\nNote\r\nThe next version of Windows, Microsoft Vista™ includes significant changes to the \r\ninterrupt architecture to support message-signaled interrupts. Specifically, the \r\nIoConnectInterrupt routine is deprecated. You should use its replacement, \r\nIoConnectInterruptEx in new drivers, and older versions of drivers should be \r\nupdated to use this new routine if possible. The Windows DDL provides this routine \r\nfor use in Windows 2000 and later releases of Windows. For more information \r\nabout these upcoming changes, see the white paper “Interrupt Architecture \r\nEnhancements in Microsoft Windows Vista,” which is available at \r\nhttp://www.microsoft.com/whdc/hwdev/bus/pci/MSI.mspx.\r\n6 ExInterlockedXxx Routines\r\nThe ExInterlockedXxx routines perform arithmetic and list manipulation operations.\r\nAll of these routines (except for ExInterlockedAddLargeStatistic) use a driver\u0002allocated spin lock.\r\nThe ExInterlockedXxx routines are coded in assembly language and usually \r\ndisable interrupts at the processor; in effect, they run at IRQL = HIGH_LEVEL. To \r\nprotect data on SMP systems, the operating system raises the IRQL and acquires \r\nthe spin lock before performing the operation. When the routine completes, the \r\noperating system releases the lock and returns the IRQL to its original value. Like \r\nother routines that run at IRQL>= DISPATCH_LEVEL, ExInterlockedXxx routines \r\ncan operate only on data in nonpaged memory. Therefore, any parameter passed \r\nto one of these routines must be allocated on the kernel stack, from nonpaged pool,\r\nor in the device extension of the device object.\r\nUse the ExInterlockedXxx routines to perform arithmetic operations on a shared \r\nvariable that a driver also accesses elsewhere, perhaps as part of a larger structure\r\nor in a longer sequence of tasks. For example, assume that a driver maintains a \r\nstructure that contains status information about its device. The driver’s DpcForIsr\r\nroutine accesses this structure, as do several routines that run at IRQL = \r\nPASSIVE_LEVEL. Therefore, the driver must protect the structure with a spin lock. \r\nTo update several fields of the structure in a tight code path, the driver acquires the \r\nspin lock and assigns new values to the fields. To update the value of a single field, \r\nthe driver uses an ExInterlockedXxx routine, passing the spin lock that protects \r\nthe structure.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/06fdebcf-4e9e-4135-adcb-00ce91cb2a99.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1f78eb2dce2a96895095508daa4945f36bb02d89a00986a516ff3706b61aaa35",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 419
      },
      {
        "segments": [
          {
            "segment_id": "b07e884c-618a-4049-88a5-5303b280d664",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 13\r\nIn addition to routines for arithmetic operations, Windows includes \r\nExInterlockedXxx routines for managing three types of lists:\r\n Singly linked lists\r\n Doubly linked lists\r\n S-lists (sequenced, singly linked lists)\r\nDrivers often maintain internal lists of IRPs, buffers, or other objects. If two or more \r\nthreads have access to a list, the driver must protect the list while items are inserted\r\nand removed. For singly linked and doubly linked lists, the system provides both \r\ninterlocked and non-interlocked versions of the manipulation routines, as shown in \r\nTable 5.\r\nTable 5. List Manipulation Routines\r\nPurpose Noninterlocked routine Interlocked routine\r\nInsert entry at front of \r\nsingly linked list.\r\nPushEntryList ExInterlockedPushEntryList\r\nRemove entry from front \r\nof singly linked list.\r\nPopEntryList ExInterlockedPopEntryList\r\nInsert entry at front of \r\ndoubly linked list.\r\nInsertHeadList ExInterlockedInsertHeadList\r\nRemove entry from front \r\nof doubly linked list.\r\nRemoveHeadList ExInterlockedRemoveHeadList\r\nInsert entry at end of \r\ndoubly linked list.\r\nInsertTailList ExInterlockedInsertTailList\r\nRemove entry from end \r\nof doubly linked list.\r\nRemoveTailList None.\r\nInitialize doubly linked \r\nlist.\r\nInitializeListHead None.\r\nCheck whether list has \r\nentries.\r\nIsListEmpty None.\r\nRemove entry from \r\ndoubly linked list.\r\nRemoveListEntry None.\r\nInitialize S-list. None. ExInitializeSListHead\r\nInsert entry at front of \r\nS-list.\r\nNone. ExInterlockedPushEntrySList\r\nRemove entry from end \r\nof S-list.\r\nNone. ExInterlockedPopEntrySList\r\nRemove all entries from \r\nan S-list.\r\nNone. ExInterlockedFlushSList\r\nThe ExInterlockedXxxList routines use a driver-allocated spin lock. These routines\r\ncan be called at any IRQL, provided that the driver always accesses a given list by \r\nusing the ExInterlockedXxxList routines.\r\nThe ExInterlockedXxxSList routines manipulate S-lists. An S-list is a sequenced, \r\ninterlocked, singly linked list that is both thread-safe and multiprocessor safe. Every \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/b07e884c-618a-4049-88a5-5303b280d664.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=71af6c38f0b3fe9c0ca6d73ae6ef8f425993a8d762024ba45b21d0654c36b959",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 271
      },
      {
        "segments": [
          {
            "segment_id": "cd72dbd1-a426-45b2-b990-323f37cee924",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 14\r\nS-list has an associated spin lock and a sequence number. The spin lock is used to \r\nprotect the list while entries are inserted or deleted. The sequence number is \r\nincremented each time an entry is inserted or deleted. On some hardware \r\narchitectures, using a sequence number enables these routines to avoid using a \r\nspin lock.\r\nA driver must be running at IRQL <= DISPATCH_LEVEL to call the S-list routines. \r\nS-lists are useful for maintaining caches because a driver can simply and quickly \r\nremove the most recently used item from the list. Internally, Windows uses S-lists to\r\nimplement lookaside lists.\r\n7 Fast Mutexes\r\nFast mutexes, also called executive mutexes, enable a driver to protect a region for \r\nexclusive access. While a thread holds a fast mutex, no other thread can acquire \r\nthe mutex. A fast mutex is an opaque structure of type FAST_MUTEX, which must \r\nbe allocated from nonpaged memory.\r\nFast mutexes have low overhead and do not require the use of the system-wide \r\ndispatcher lock. As their name implies, fast mutexes are faster and more efficient \r\nthan kernel mutexes.\r\nCode paths that are protected by a fast mutex run at IRQL=APC_LEVEL, thus \r\ndisabling delivery of all APCs and preventing the thread from suspension. Table 6 is\r\na summary of the fast mutex acquisition routines.\r\nTable 6. Fast Mutex Acquisition Routines\r\nRoutine Description\r\nExAcquireFastMutex Raises the IRQL to APC_LEVEL before acquiring the fast\r\nmutex. Blocks until the mutex is available.\r\nExAcquireFastMutexUnsaf\r\ne\r\nAcquires the mutex at the current IRQL. Blocks until the \r\nmutex is available.\r\nExTryToAcquireFastMutex Raises the IRQL to APC_LEVEL before acquiring the fast\r\nmutex. Does not block if the mutex is not available.\r\nExAcquireFastMutex and ExAcquireFastMutexUnsafe cause the thread to block \r\nuntil the mutex is available. ExTryToAcquireFastMutex returns FALSE \r\nimmediately if another thread has already acquired the mutex. Both \r\nExAcquireFastMutex and ExTryToAcquireFastMutex raise the IRQL to \r\nAPC_LEVEL before acquiring the fast mutex. Drivers should use \r\nExAcquireFastMutexUnsafe (which does not raise the IRQL) only if either of the \r\nfollowing is true:\r\n The thread is already running at APC_LEVEL.\r\n The thread acquires the mutex within a critical region that was previously \r\nentered by a call to KeEnterCriticalRegion or FsRtlEnterFileSystem.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/cd72dbd1-a426-45b2-b990-323f37cee924.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0637802cbde0c0e4583d66e9124e8e7a864ae2d7bfbea32f104a579193fae340",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 372
      },
      {
        "segments": [
          {
            "segment_id": "5464bc64-4ecf-4cac-87f7-84070360f624",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 15\r\nIn either of these situations, user-mode and normal kernel-mode APC delivery has \r\nalready been disabled for the thread.\r\nTo use a fast mutex, a driver must:\r\n1. Allocate a structure of type FAST_MUTEX from nonpaged pool.\r\n2. Initialize the fast mutex by calling ExInitializeFastMutex.\r\n3. Immediately before accessing the protected region, acquire the fast mutex by \r\ncalling ExAcquireFastMutex, ExAcquireFastMutexUnsafe, or \r\nExTryToAcquireFastMutex.\r\n4. Perform the required operations on the protected data.\r\n5. Release the fast mutex by calling ExReleaseFastMutex or \r\nExReleaseFastMutexUnsafe.\r\nFast mutexes have the following limitations:\r\n Fast mutexes cannot be acquired recursively. Attempting to do so causes a \r\ndeadlock.\r\n Driver code that holds a fast mutex runs at IRQL=APC_LEVEL. Therefore, such\r\ncode cannot call routines that can be called only at IRQL=PASSIVE_LEVEL, \r\nsuch as IoBuildDeviceIoControlRequest.\r\n Fast mutexes are not kernel dispatcher objects. Therefore, a driver cannot use \r\nthe KeWaitForMultipleObjects routine to wait for a fast mutex and a kernel \r\ndispatcher object simultaneously.\r\n8 Kernel Dispatcher Objects\r\nThe operating system defines several types of kernel dispatcher objects, which \r\nprovide various types of synchronization. Kernel dispatcher objects are relatively \r\nsimple to use and provide locks that can be held at IRQL=PASSIVE_LEVEL. \r\nTable 7 is a summary of the kernel dispatcher object types.\r\nTable 7. Kernel Dispatcher Object Types\r\nObject type Description IRQL restrictions\r\nKernel mutex Provides mutually exclusive \r\naccess to data at \r\nPASSIVE_LEVEL or \r\nAPC_LEVEL.\r\nWait at IRQL \r\n<=APC_LEVEL.\r\nEvent Provides synchronization \r\nunder driver-determined \r\nconditions; can be used to \r\nsynchronize with user-mode \r\napplications.\r\nWait at \r\nIRQL<=APC_LEVEL; set at \r\nIRQL<=DISPATCH_LEVEL.\r\nSemaphore Protects a group of identical \r\nobjects.\r\nWait at \r\nIRQL<=APC_LEVEL; set at \r\nIRQL<=DISPATCH_LEVEL.\r\nTimer Provides notification or Wait at IRQL \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/5464bc64-4ecf-4cac-87f7-84070360f624.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f57def20534e5cca5a8d37c221bbe8a39218f3e8e0d605eb0ce90d6fe409947d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 282
      },
      {
        "segments": [
          {
            "segment_id": "b6f49e32-00ae-4d3c-b607-0dac10544bf1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 16\r\nObject type Description IRQL restrictions\r\nsynchronization at an \r\nabsolute or relative time.\r\n<=APC_LEVEL; set at IRQL \r\n<=DISPATCH_LEVEL.\r\nThreads, processes, and \r\nfiles\r\nSynchronizes with the \r\ncreation or termination of a \r\nthread or process, or the \r\ncompletion of I/O to a file.\r\nWait at IRQL \r\n<=APC_LEVEL.\r\nA driver can pass a kernel dispatcher object to the KeWaitForSingleObject and \r\nKeWaitForMultipleObject routines. Using these routines, a driver can wait with a \r\nspecified time-out and can wait for one or more objects simultaneously.\r\n8.1 Common Features\r\nThe operating system manages all kernel dispatcher objects in the kernel’s \r\ndispatcher database (hence their name). To manipulate any of these objects, the \r\nsystem must raise the IRQL to DISPATCH_LEVEL and acquire the system-wide \r\ndispatcher lock, which protects the dispatcher database. However, the dispatcher \r\nlock is used frequently by many components, so sometimes the system must wait \r\nfor it. Such waits can slow driver performance. For this reason, drivers should use \r\nexecutive resources or fast mutexes instead of kernel dispatcher objects whenever \r\npossible.\r\nKernel dispatcher objects are all based on the same common header \r\n(DISPATCHER_HEADER), but each type of object has its own object-type-specific \r\ninitialization and release routines. Kernel dispatcher objects must be allocated from \r\nnonpaged pool or in the device extension of the device object.\r\nA driver can refer to a kernel dispatcher object by using either a handle or a pointer.\r\nIf a driver uses a handle to refer to a kernel dispatcher object that it created in an \r\narbitrary thread context, that driver must set the OBJ_KERNEL_HANDLE attribute \r\nfor the object. Setting this attribute protects system security by preventing user\u0002mode threads from accessing the handle.\r\nDrivers usually use kernel dispatcher objects to wait for the results of a \r\nsynchronous I/O operation. Highest-level drivers that create and send IRPs to \r\nlower-level drivers wait in the context of the thread that issued the I/O request. \r\nLower-level drivers sometimes must wait in an arbitrary thread context to \r\nsynchronize execution among driver routines that run at IRQL PASSIVE_LEVEL or \r\nAPC_LEVEL. For example, a driver might wait in its DispatchPnP routine for an \r\nevent that is set when certain device operations are complete. As a general rule, \r\nhowever, drivers should avoid blocking any thread other than the thread that \r\ninitiated the current I/O request.\r\nKernel dispatcher objects have two states: signaled and not signaled. Signaling \r\nindicates that the object is available for acquisition. Thus, an object in the signaled \r\nstate is not owned (acquired) by any thread. An object in the not-signaled state is \r\nowned by one or more threads. The type of object determines the state to which the\r\nobject is initially set. For example, kernel mutexes are set to the signaled state \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/b6f49e32-00ae-4d3c-b607-0dac10544bf1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1cc6300bc344f552781825fb2c4fe76f250693700c278dabed52cbe950b6ab80",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 455
      },
      {
        "segments": [
          {
            "segment_id": "532d6fe7-69f2-4a33-b4df-e31d554e58cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 17\r\nimmediately upon initialization, but events must be explicitly signaled by a call to the\r\nKeSetEvent routine.\r\nAlthough each type of object has its own type-specific initialization and release \r\nroutines, drivers use KeWaitForSingleObject and KeWaitForMultipleObjects to \r\nacquire any kernel dispatcher object. Using KeWaitForSingleObject, a driver can \r\nwait for a single kernel dispatcher object. Using KeWaitForMultipleObjects, a \r\ndriver can wait for more than one kernel dispatcher object; the objects need not be \r\nof the same type. Each of these routines takes as parameters:\r\n A pointer to the object(s) that are to be acquired.\r\n A reason for the wait. Drivers that are waiting on behalf of a user request in the \r\ncontext of a user thread should specify UserRequest; otherwise, drivers should\r\nspecify Executive. The value of this field is informational only.\r\n A Boolean value (Alertable) that indicates whether the thread should be \r\nalertable while it is waiting. For drivers, this is usually FALSE.\r\n A wait mode (WaitMode), either KernelMode or UserMode. For drivers, this is \r\nusually KernelMode. If one or more of the objects is a mutex, this value must\r\nbe KernelMode.\r\n An optional time-out value, which indicates how long the thread is to wait before\r\nit times out.\r\n8.1.1 IRQL Restrictions\r\nA thread can signal a kernel dispatcher object at IRQL <= DISPATCH_LEVEL, but it\r\ncan wait for such an object only at IRQL <= APC_LEVEL. This IRQL restriction \r\nmeans that a driver cannot wait for an event or other dispatcher object in an \r\nIoCompletion routine, in a StartIo routine, or in any deferred procedure call (DPC) \r\nroutine, because these routines can be called at DISPATCH_LEVEL. Highest-level \r\ndrivers that are called in the context of the user thread that made the I/O request \r\ncan wait for kernel dispatcher objects in their read and write dispatch routines. \r\nLower-level drivers should not wait in these routines; the read and write dispatch \r\nroutines of some lower-level drivers, particularly in the storage and USB stacks, can\r\nbe called at IRQL = DISPATCH_LEVEL.\r\nHowever, a thread can acquire a kernel dispatcher object at DISPATCH_LEVEL if it\r\ndoes not wait for the object. To acquire a kernel dispatcher object without waiting, a \r\nthread sets the time-out value to zero in its call to KeWaitForSingleObject or \r\nKeWaitForMultipleObjects. A time-out value equal to zero means that the driver \r\ndoes not wait for the object to be signaled; instead, the call returns immediately with\r\na status that indicates whether an object was available and acquired or is not \r\ncurrently available. Because no waiting is involved, such a call is valid at \r\nDISPATCH_LEVEL.\r\nThis feature is useful for testing whether an object has been signaled. For example, \r\na DPC routine that must perform a task in synchronization with some other routine \r\nmight check to see whether the object has been signaled. If so, the DPC can \r\nperform the task. If not, the DPC can do some other, unrelated task, or it can queue\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/532d6fe7-69f2-4a33-b4df-e31d554e58cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=14138c4d31de0ab3c82a16e05d19af0cd4f35d928e39ca4c77521de3187750de",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 499
      },
      {
        "segments": [
          {
            "segment_id": "87e44617-2808-4997-bf73-167e545b9f29",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 18\r\na work item to perform the original task. Because the work item runs in a thread at \r\nIRQL=PASSIVE_LEVEL, the work item can wait for a nonzero period.\r\n8.1.2 Alerts and Wait Modes\r\nThe Alertable and WaitMode parameters to KeWaitForSingleObject and \r\nKeWaitForMultipleObjects determine how the system handles user-mode APCs \r\nwhile the thread is waiting. Table 8 is a summary of the effects of these parameters \r\non APC delivery.\r\nTable 8. Effects of the Alertable and WaitMode Parameters on APC Delivery\r\nValue of \r\nAlertable\r\nand \r\nWaitMode\r\nparameter\r\ns\r\nSpecial \r\nkernel-mode APC\r\nNormal \r\nkernel-mode APC User-mode APC\r\nTerminat\r\ne wait?\r\nDeliver \r\nand run \r\nAPC?\r\nTerminate \r\nwait?\r\nDeliver \r\nand run \r\nAPC?\r\nTerminat\r\ne wait?\r\nDeliver and\r\nrun APC?\r\nAlertable = \r\nTRUE\r\nWaitMode\r\n= \r\nUserMode\r\nNo If (A*), \r\nthen Yes\r\nNo If (B**), \r\nthen Yes\r\nYes Yes, after \r\nthread \r\nreturns to \r\nuser mode\r\nAlertable = \r\nTRUE\r\nWaitMode\r\n= \r\nKernelMod\r\ne\r\nNo If (A), \r\nthen Yes\r\nNo If (B), \r\nthen Yes\r\nNo No\r\nAlertable = \r\nFALSE\r\nWaitMode\r\n= \r\nUserMode\r\nNo If (A), \r\nthen Yes\r\nNo If (B), \r\nthen Yes\r\nNo No (with \r\nexceptions,\r\nsuch as \r\nCTRL+C to\r\nterminate)\r\nAlertable = \r\nFALSE\r\nWaitMode\r\n= \r\nKernelMod\r\ne\r\nNo If (A), \r\nthen Yes\r\nNo If (B), \r\nthen Yes\r\nNo No\r\n *A: IRQL < APC_LEVEL.\r\n**B: IRQL < APC_LEVEL, thread not already in an APC, and thread not in a critical region.\r\nThe system delivers most user-mode APCs when a thread unwinds from kernel \r\nmode back to user mode after an alertable wait. User-mode APCs do not interrupt \r\nuser-mode code. After an application queues a user-mode APC to a thread, the \r\napplication can cause the system to deliver the APCs by calling a wait function with \r\nthe Alertable parameter set to TRUE. (The user-mode terminate APC is an \r\nexception. This APC is queued to terminate a thread, and the system delivers it \r\nwhenever the thread unwinds back to user mode from kernel mode, not only after \r\nan alertable wait.)\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/87e44617-2808-4997-bf73-167e545b9f29.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e7a3afa319d70e35544c8d659c2fb1d417446a4532099b9f05fb573462b8dd11",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 331
      },
      {
        "segments": [
          {
            "segment_id": "92474f5e-aa30-4498-a772-315d955517af",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 19\r\nIf a driver calls either KeWaitForSingleObject or KeWaitForMultipleObjects with \r\nthe Alertable parameter set to TRUE and the WaitMode parameter set to \r\nUserMode, the wait aborts with STATUS_USER_APC or STATUS_ALERTED \r\nwhenever a user-mode APC (or an alert) is pending. When the thread returns to \r\nuser mode, the system automatically delivers the user-mode APC. Drivers should \r\nnot call either of the KeWaitXxx routines with Alertable set to TRUE and WaitMode\r\nset to UserMode unless the application has explicitly requested delivery of user\u0002mode APCs during the wait.\r\nIf a driver calls KeWaitForSingleObject or KeWaitForMultipleObjects with \r\nWaitMode set to UserMode, but Alertable set to FALSE, the wait will abort with \r\nSTATUS_USER_APC if the thread is being terminated. However, the driver must \r\nbe waiting at IRQL = PASSIVE_LEVEL and must not be in a critical region.\r\nThe wait mode also determines whether the thread’s kernel-mode stack can be \r\npaged out while waiting. If WaitMode is set to UserMode, the system pages out the \r\nkernel-mode stack while the thread is waiting. Waiting in UserMode is safe only if \r\nthe waiting driver is the only driver on the stack. If one or more other drivers is on \r\nthe stack, one of those drivers might try to update a stack variable, thereby causing \r\na page fault. If that driver is running at IRQL=DISPATCH_LEVEL or higher, the \r\npage fault will cause the system to crash. Because PnP driver stacks often include \r\nfilter drivers, PnP drivers rarely set WaitMode to UserMode.\r\nNote\r\nFor more information about alertable waits, APCs, and the rules for operating at \r\nIRQL=DISPATCH_LEVEL, see the companion white paper “Scheduling, Thread \r\nContext, and IRQL” and the section “Do Waiting Threads Receive Alerts and APCs”\r\nunder “Kernel-Mode Driver Architecture” in the Windows DDK.\r\n8.2 Events\r\nDrivers use events to synchronize activities between kernel-mode threads or \r\nbetween kernel-mode threads and user-mode applications. Both user-mode and \r\nkernel-mode code can create events. Windows also defines several standard event \r\nobjects in the \\\\KernelObject object directory. Drivers can wait on these standard \r\nevents.\r\nAn event is a synchronization object of type KEVENT, which must be allocated in \r\nnonpaged memory. Events can be either named or unnamed. Drivers usually use \r\nnamed events only to synchronize with external processes, such a user-mode \r\napplication or another driver. Internally, drivers use unnamed events. Windows \r\nsupports two types of events, notification events and synchronization events. The \r\ntwo types of event differ in the actions taken when they are signaled, as described \r\nlater under “Notification Events” and “Synchronization Events.”\r\nTo create and initialize an unnamed event of either type, a driver allocates an object\r\nof type KEVENT in nonpaged memory. The driver then calls KeInitializeEvent and \r\nspecifies the type of event as a parameter in the call. To create and initialize a \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/92474f5e-aa30-4498-a772-315d955517af.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2374a83a8c5ce9d9fef5fca487f17e2fce72c2ebe85d0dff75c976f452b91b26",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 464
      },
      {
        "segments": [
          {
            "segment_id": "6d4a3d64-94e2-4c84-b691-fe73c23751fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 20\r\nnamed event, the driver calls IoCreateNotificationEvent or \r\nIoCreateSynchronizationEvent.\r\nTo wait for an event, a driver calls KeWaitForSingleObject or \r\nKeWaitForMultipleObjects, as described previously under “Kernel Dispatcher \r\nObjects.”\r\nTo signal an event, a driver calls KeSetEvent, which has three parameters: a \r\npointer to the event, a priority boost, and the Boolean Wait. Setting Wait to TRUE \r\nindicates that the thread intends to call KeWaitXxx immediately after KeSetEvent\r\nreturns. This parameter provides an optimization in the cases where the driver \r\nintends to wait for another kernel dispatcher object immediately.\r\nNormally, drivers call KeSetEvent with Wait set to FALSE. When Wait is FALSE, \r\nKeSetEvent raises the IRQL to DISPATCH_LEVEL, acquires the dispatcher lock, \r\nmodifies the signaled-state of the event object, satisfies any outstanding waits, \r\nunlocks the dispatcher database, lowers the IRQL to its original value, and returns.\r\nIf the Wait parameter is TRUE, however, KeSetEvent does not release the \r\ndispatcher lock or lower the IRQL. This optimization can prevent unnecessary \r\ncontext switches because the caller thus signals the event and waits in one atomic \r\noperation. If a driver uses this feature, it must call KeSetEvent from IRQL < \r\nDISPATCH_LEVEL and in a non-arbitrary thread context.\r\nA driver routine that operates in a producer/consumer scenario might use this \r\nfeature. Such a driver usually works with two events in the following way. The driver\r\nroutine that produces data signals the first event to indicate that it is ready to send \r\ndata. It then immediately waits for the second event to be signaled by another \r\nthread. The second thread sets the second event to indicate it has received the \r\ndata and is ready for more. Drivers should use this feature only in the context of the \r\nthread that requested the I/O operation; a driver should avoid blocking an unrelated \r\nthread.\r\n8.2.1 Notification Events\r\nA notification event wakes every waiting thread and remains in the signaled state \r\nuntil it is explicitly reset by a call to KeResetEvent. In the Win32® API, notification \r\nevents are called manual reset events.\r\nDrivers typically use notification events to wait for the completion of IRPs that they \r\nallocate and send. For example, a driver might send an I/O control code (IOCTL) to \r\nlower drivers in its device stack by calling IoBuildDeviceIoControlRequest. One of\r\nthe parameters to this routine is a pointer to an event object. After the driver routine \r\ncreates and sends the IRP, it waits on the event object. When the IRP is complete, \r\nthe I/O Manager signals the event, thus satisfying the wait. The event remains \r\nsignaled until a call to KeResetEvent returns it to the non-signaled state.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/6d4a3d64-94e2-4c84-b691-fe73c23751fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c4f728ecd4ab1e5f7ea13601aaee7878876b4659390cdb0eed22383e1fa9716f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 439
      },
      {
        "segments": [
          {
            "segment_id": "737f47a1-3143-4c55-84c3-dca46358b4b1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 21\r\n8.2.2 Synchronization Events\r\nSynchronization events, also called auto-resetting events, wake a single thread and\r\nimmediately return to the non-signaled state. Drivers use synchronization events \r\nless frequently than notification events.\r\nA driver for a device that requires a long time to initialize might wait on a \r\nsynchronization event in its StartDevice routine to ensure that its device is fully \r\ninitialized. The driver’s DpcForIsr routine signals the event after the device has \r\ninterrupted and any additional processing at IRQL DISPATCH_LEVEL is complete. \r\nControl then returns to the StartDevice routine, which can continue with device and \r\ndriver initialization. Similarly, a driver might wait on a synchronization event in its \r\nDispatchPnp routine to ensure that I/O has completed before stopping or removing \r\nthe device.\r\n8.2.3 Synchronizing with User-Mode Applications\r\nKernel-mode drivers cannot make calls to user-mode routines. However, a kernel\u0002mode driver with a closely-coupled application might sometimes need to notify the \r\napplication about a device- or driver-related occurrence. There are several ways to \r\nimplement such notification; two recommended methods are outlined in this section.\r\nOne way to coordinate activities between a kernel-mode driver and a user-mode \r\napplication is to share an event. In the driver:\r\n1. Define a private I/O control code (IOCTL) with which a user-mode application \r\ncan pass an event.\r\n2. Provide a DispatchDeviceControl routine that handles the private IOCTL \r\nsupplied in IRP_MJ_DEVICE_CONTROL requests.\r\n3. Validate the handle received in the IOCTL by calling \r\nObReferenceObjectByHandle. In the DesiredAccess parameter, specify \r\nSYNCHRONIZE access, and in the ObjectType parameter, specify \r\n*ExEventObjectType.\r\n6. To signal the event, call KeSetEvent; to reset a notification event, call \r\nKeResetEvent.\r\n7. Call ObDereferenceObject to free the handle when the event is no longer \r\nneeded.\r\nIn the user-mode application:\r\n1. Create a named event by calling CreateEvent.\r\n2. Pass the handle to the event to the driver by calling DeviceIoControl, \r\nspecifying the driver-defined IOCTL.\r\n3. To wait for the kernel-mode driver to signal the event, call \r\nWaitForSingleObject or WaitForMultipleObjects.\r\n4. Delete the event object before exiting by calling CloseHandle.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/737f47a1-3143-4c55-84c3-dca46358b4b1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8a583b553fa7e4646da9541a42e97754c4d8f7e31200f833cea69a0bf7cd7d30",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 341
      },
      {
        "segments": [
          {
            "segment_id": "edf4ec93-6697-4bd9-94f1-faf6d1bc4ca2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 22\r\nThis technique is suitable in situations where the driver routine and the user-mode \r\nthread that share the event always run in the same process context. However, in \r\nthe layered WDM driver model, lower-level driver routines are not usually called in \r\nthe context of the requesting thread or process.\r\nA more general approach that eliminates thread context problems is to use a \r\nDeviceIoControl request without an event. In this technique, the driver defines a \r\nprivate IOCTL for the I/O request. The application creates a dedicated thread that \r\nsends the DeviceIoControl request to the driver, which returns \r\nSTATUS_PENDING. To notify the user-mode application, the driver completes the \r\nrequest. Because this technique does not depend upon the validity of user-mode \r\ndata, it is suitable for use in lower-level drivers.\r\nFor an example of both of these techniques, see the event sample (src\\general\\\r\nevent) in the Windows DDK.\r\n8.3 Kernel Mutexes\r\nKernel mutexes, often just called mutexes, are useful for synchronizing access to \r\nmemory in pageable code or over a relatively long period of time. A kernel mutex \r\nensures that a thread has exclusive access to the protected data. Drivers can use \r\nkernel mutexes at IRQL <= APC_LEVEL.\r\nKernel mutexes depend on thread context. Driver routines that use kernel mutexes \r\nare usually highest-level driver routines that run in the context of the thread that \r\nrequested the I/O operation. A driver routine that acquires a mutex should release it\r\nwithin the same thread context.\r\nKernel mutexes differ from fast mutexes in the following ways:\r\n Kernel mutexes can be acquired recursively; fast mutexes cannot.\r\n Kernel mutexes are acquired by using KeWaitForSingleObject, \r\nKeWaitForMultipleObjects, and KeWaitForMutexObject. Fast mutexes are \r\nacquired by using ExAcquireFastMutex, ExTryToAcquireFastMutex, and \r\nExAcquireFastMutexUnsafe.\r\n Kernel mutexes require the use of the system-wide dispatcher lock. Therefore, \r\nthey have greater overhead and are less efficient than fast mutexes.\r\nTo use a kernel mutex, a driver must:\r\n1. Allocate a KMUTEX data structure in nonpaged memory such as the device \r\nextension of a driver-created device object or nonpaged pool.\r\n2. Initialize the mutex by calling KeInitializeMutex, passing a pointer to the \r\npreviously allocated data structure. (The Level parameter is ignored.)\r\n3. Wait for the mutex by calling KeWaitForSingleObject, \r\nKeWaitForMultipleObjects, or KeWaitForMutexObject.\r\n4. Perform the required operations on the protected data.\r\n5. Release the mutex by calling KeReleaseMutex.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/edf4ec93-6697-4bd9-94f1-faf6d1bc4ca2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be050a3f9d32d501968d189c99d587f417161c8291b1b0636e6b01621d7ad395",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 393
      },
      {
        "segments": [
          {
            "segment_id": "5200ab01-d6ef-48d0-9033-d3a5f8abbbcc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 23\r\nThe operating system initializes every kernel mutex to the signaled state. \r\nConsequently, the first thread’s initial call to wait for the mutex succeeds \r\nimmediately and returns.\r\nDriver routines should always specify KernelMode when they are waiting for a \r\nkernel mutex. Waiting in kernel mode prevents the thread’s kernel-mode stack from \r\nbeing paged out and disables the delivery of user-mode and normal kernel-mode \r\nAPCs, thus preventing thread termination and suspension. Special kernel-mode \r\nAPCs, such as the special kernel-mode APC for I/O completion, can still be \r\ndelivered. Internally, acquiring a kernel mutex calls KeEnterCriticalRegion. If the \r\nthread is running at PASSIVE_LEVEL when it acquires the mutex, this call disables \r\nthe delivery of normal kernel-mode APCs until the thread releases the mutex. If the \r\nthread is running at APC_LEVEL when it acquires the mutex, entering a critical \r\nregion has no effect because normal kernel-mode APC delivery is already disabled.\r\nA thread that holds a mutex must release the mutex before any transition to user \r\nmode; the system crashes if a thread holds a mutex during the transition. For \r\nexample, a highest-level driver that acquires a mutex while servicing a user-mode \r\nI/O request must release the mutex before returning to the user-mode code.\r\nWhen a thread releases a mutex, it passes a Wait parameter. The Wait parameter \r\nhas the same meaning in KeReleaseMutex as in KeSetEvent; see the section \r\n“Events” for details.\r\nA thread that acquires a mutex recursively must release the mutex the same \r\nnumber of times as it acquired the mutex. The operating system does not signal the\r\nmutex or call KeLeaveCriticalRegion until all acquisitions have been released.\r\n8.4 Semaphores\r\nA semaphore is similar to a mutex, except that multiple threads can simultaneously \r\nacquire a semaphore. Semaphores are useful for protecting a set of identical data \r\nstructures that are shared among several threads.\r\nEvery semaphore has a limit and a count. The limit is the maximum number of \r\nthreads that can acquire the semaphore at a time, and the count is the number of \r\nthreads that can currently acquire the semaphore.\r\nFor example, a driver might allocate several buffers for I/O and protect them with a \r\nsemaphore. The semaphore’s limit is the number of buffers. When a driver routine \r\nneeds an I/O buffer, it waits for the semaphore. If the semaphore’s count is equal to\r\nzero, all buffers are in use. If the count is equal to its limit, all buffers are free.\r\nTo use a semaphore, a driver must:\r\n1. Allocate a KSEMAPHORE data structure in the device extension of a driver\u0002created device object or in nonpaged pool allocated by the caller.\r\n2. Initialize the semaphore by calling KeInitializeSemaphore, specifying the \r\nsemaphore’s count and limit. Setting the count to 0 initializes the semaphore in \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/5200ab01-d6ef-48d0-9033-d3a5f8abbbcc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=49268e47098ff47e4e847859200390401302cf344e7627bc7b0736aaff5807c2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 465
      },
      {
        "segments": [
          {
            "segment_id": "bbb6a2b4-e806-4d8f-ac92-e6ed5be8d951",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 24\r\nthe not-signaled state; setting the count greater than 0 signals the semaphore \r\nand indicates how many threads can acquire it initially.\r\n3. Wait for the semaphore by calling KeWaitForSingleObject or \r\nKeWaitForMultipleObjects.\r\n4. Perform the required operations on the protected data.\r\n5. Release the semaphore by calling KeReleaseSemaphore, passing a value to \r\nadd to the current count.\r\nIf a driver increases the count of a semaphore above the semaphore’s limit, the \r\nsystem raises an exception. Such an error could occur if the driver attempts to \r\nrelease the semaphore too many times. This behavior is different from that of \r\nevents; setting an already signaled event has no effect.\r\nWhen a thread releases a semaphore, it can also specify a Wait parameter. The \r\nWait parameter has the same effect for a semaphore as for a mutex or for an event;\r\nsee the section “Events” for details.\r\nA thread can determine whether a semaphore is signaled or not signaled by calling \r\nKeReadStateSemaphore.\r\n8.5 Timers\r\nDrivers often use timers for polling and handling device time-outs. Like events, \r\ntimers can be used for synchronization or for notification. A driver creates a \r\nnotification timer by calling KeInitializeTimer; it can create either a notification timer\r\nor a synchronization timer by calling KeInitializeTimerEx.\r\nBoth types of timers expire after a specified interval at either an absolute or relative \r\ntime. Absolute times are measured in 100-nanosecond units starting on January 1, \r\n1601. This time is tied to the calendar—advancing the clock by one hour brings the \r\nexpiration time one hour closer. Relative times are negative numbers measured in \r\n100-nanosecond units from the moment the timer was started. Relative time is \r\nmeasured in machine running time and is unaffected by system clock changes. \r\nRelative time includes time spent sleeping. When the computer awakens, the \r\noperating system adjusts the internal machine time to include the time that the \r\ncomputer was asleep. As a result, many timers expire simultaneously as soon as \r\nthe operating system resumes. When a notification timer expires, all waiting threads\r\nare released. The timer remains in the signaled state until a thread explicitly resets \r\nby calling KeSetTimer. When a synchronization timer expires, a single waiting \r\nthread is released and the operating system immediately resets the timer to the \r\nnon-signaled state.\r\nA driver can wait on a timer object at IRQL <= APC_LEVEL, or it can specify a \r\nCustomTimerDpc routine to be called when the timer expires. Drivers can use \r\nCustomTimerDpc routines instead of driver-created threads to perform short-lived \r\noperations. CustomTimerDpc routines are also used to time out a request at \r\nIRQL=DISPATCH_LEVEL.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/bbb6a2b4-e806-4d8f-ac92-e6ed5be8d951.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=619bba1bb1fb4c533372d572ab326bb1d457020b898073c81ad48c57ad579fbb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 434
      },
      {
        "segments": [
          {
            "segment_id": "feabf587-9e1c-4ac3-8bf4-774d482ba4ca",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 25\r\nTo use a timer, a driver should do the following, as necessary:\r\n1. Allocate a structure of type KTIMER in nonpaged memory.\r\n2. Create and initialize the timer by calling KeInitializeTimer or \r\nKeInitializeTimerEx. KeInitializeTimer creates a notification timer. \r\nKeInitializeTimerEx creates a notification timer or a synchronization timer.\r\n3. To associate the timer with a CustomTimerDpc routine, call KeInitializeDpc to \r\ninitialize a DPC object and register the CustomTimerDpc routine.\r\n4. Set the timer by calling KeSetTimer or KeSetTimerEx, specifying the interval \r\nat which the timer expires. To queue the CustomTimerDpc routine when the \r\ntimer expires, include the optional Dpc parameter.\r\n5. To wait on a timer object, call KeWaitForSingleObject or \r\nKeWaitForMultipleObjects.\r\n6. To cancel a timer before it expires, call KeCancelTimer.\r\n7. To reset a notification timer after it expires, call KeSetTimer.\r\nBoth notification and synchronization timers can be recurring (or periodic) timers. As\r\nsoon as a periodic timer’s interval expires, the operating system immediately \r\nqueues the timer again. Consequently, a DPC routine that is associated with a \r\nperiodic timer can run simultaneously on more than one CPU in an SMP system. \r\nSuch simultaneous execution can occur, for example, if the DPC routine takes \r\nlonger to run than the timer interval or if its execution is delayed because other \r\nDPCs precede it in the DPC queue. Because the DPC routines run at IRQL = \r\nDISPATCH_LEVEL, drivers must use spin locks to protect any data that these \r\nroutines share.\r\nIf your driver uses more than one timer object, DPC object, or CustomTimerDpc\r\nroutine, you should understand the order in which the operating system signals the \r\nobjects and queues the DPCs, the consequences of using these objects in varying \r\ncombinations, and the effects of canceling one or more of the timers. See “Using a \r\nCustomTimerDpc Routine” in the “Kernel Mode Drivers Architecture Design Guide” \r\nsection of the Windows DDK for details.\r\n8.6 Threads, Processes, and Files\r\nThreads, processes, and files are also kernel dispatcher objects. Drivers can use \r\nthe KeWaitXxx routines to synchronize actions with the termination of a thread or \r\nprocess or with the completion of I/O to a file. In addition, a driver can request \r\nnotification when a new thread or process is created.\r\nTo synchronize with a particular process, thread, or file, the driver must get a \r\npointer to the object that represents that process, thread, or file. A driver that \r\ncreates a thread can pass the handle returned by the PsCreateSystemThread\r\nroutine to ObReferenceObjectByHandle to get a pointer to the thread object. \r\nSimilarly, a driver can get a pointer to a file object by passing a file handle to \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/feabf587-9e1c-4ac3-8bf4-774d482ba4ca.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=66ea37d1dd6253cd2be14c3630358411887f1a8d48f1d5a88bcc9c5694ce4b02",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 442
      },
      {
        "segments": [
          {
            "segment_id": "8d52f81e-1c50-4db6-bd38-9bcf56930d2f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 26\r\nObReferenceObjectByHandle. The resulting object pointers can then be passed \r\nto KeWaitXxx.\r\nTo wait on a thread, process, or file object, a kernel-mode driver must specify a \r\nKernelMode wait. Waiting in kernel mode prevents paging of the waiting thread’s \r\nstack and disables user-mode and normal kernel-mode APCs. The wait is satisfied \r\nwhen the thread or process terminates or when the current file I/O operation is \r\ncomplete.\r\nA file I/O operation (a single IRP) is complete when the operating system signals an\r\ninternal event that is embedded in the file object. Every file object has such an \r\nembedded event. The event is a synchronization (auto-reset) event; that is, the \r\nevent is reset as soon as a waiting thread is notified. Applications and file system \r\ndrivers that implement asynchronous I/O can wait on the file event to find out when \r\nthe I/O operation completes.\r\nSynchronizing with a specific thread is generally useful only in drivers that create \r\ndevice-dedicated or other driver-specific threads. Most driver routines, except for \r\nthe I/O dispatch routines of highest-level drivers, are called in the context of an \r\narbitrary thread. Consequently, synchronizing driver activity with the current thread \r\ncontext is rarely meaningful.\r\nA driver can also request notification whenever a thread or process is created or \r\ndeleted system-wide. To do so, the driver sets a callback routine by calling \r\nPsSetCreateProcessNotifyRoutine or PsSetCreateThreadNotifyRoutine. The \r\noperating system calls the routine any time a process or thread is created or \r\ndeleted. A driver that establishes thread or process callback routines must not exit \r\nbefore the operating system shuts down.\r\n9 Executive Resources\r\nBy using an executive resource, a driver can implement a read/write lock. Executive\r\nresources are designed for use with data structures that require exclusive access \r\nfor writing but that can be read by several threads concurrently. Executive \r\nresources are not maintained in the system’s dispatcher database, so they usually \r\nare faster and more efficient than kernel dispatcher objects. A thread can acquire \r\nan executive resource for exclusive (write) access or for shared (read) access. \r\nCode that runs at IRQL=PASSIVE_LEVEL or APC_LEVEL can use executive \r\nresources.\r\nAn executive resource is a structure of type ERESOURCE, which must be allocated\r\nin nonpaged memory (for example, the device extension of the device object or \r\nnonpaged pool). An ERESOURCE structure must be naturally aligned; that is, the \r\nstructure must be aligned on a 4-byte boundary on a 32-bit system and on an 8-\r\nbyte boundary on a 64-bit system. The ERESOURCE structure itself is opaque to \r\ndriver writers.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/8d52f81e-1c50-4db6-bd38-9bcf56930d2f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=66d81adb54750bfc08108821c7a15a5263e3ff9bfbcc49fabef08e7d469b23d2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 425
      },
      {
        "segments": [
          {
            "segment_id": "e9df21f8-4d7a-4cdf-b155-0ae142868b1d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 27\r\nTable 9 is a summary of the acquisition routines for executive resources. It includes \r\nthe type of access that each routine provides and when such access is granted.\r\nTable 9. Executive Resource Acquisition Routines\r\nRoutine Type of \r\naccess\r\nConditions\r\nExAcquireResourceSharedLite Shared Acquires resource if either:\r\nThe resource is not already \r\nacquired exclusively and no thread \r\nis waiting to acquire exclusive \r\naccess.\r\n or\r\nThe requesting thread already has \r\nshared or exclusive access.\r\nExAcquireResourceExclusiveLite Exclusiv\r\ne\r\nAcquires resource if the resource is \r\nnot already acquired for shared or \r\nexclusive access.\r\nExAcquireSharedStarveExclusive Shared Acquires resource if either:\r\nThe resource is not already \r\nacquired exclusively.\r\n or\r\nThe requesting thread already has \r\nshared or exclusive access.\r\nThreads waiting for exclusive \r\naccess continue to wait.\r\nExAcquireSharedWaitForExclusive Shared Same as \r\nExAcquireResourceSharedLite \r\nexcept that:\r\nIf the requesting thread already has \r\naccess to the resource and one or \r\nmore threads are waiting for \r\nexclusive access, the recursive \r\nrequest blocks until the exclusive \r\nrequests have been satisfied.\r\nExclusiv\r\ne\r\nSame as \r\nExAcquireResourceExclusiveLite,\r\nbut it does not block if access is not \r\navailable.\r\nIf a thread acquires a resource for exclusive access, it can later convert to shared \r\naccess. However, a thread cannot convert shared access to exclusive access. The \r\nExConvertExclusiveToSharedLite routine changes a thread’s access from \r\nExclusive to Shared and grants shared access to any additional threads that are \r\nwaiting for shared access. On a checked build, the system ASSERTs if the \r\nrequesting thread does not own exclusive access to the resource.\r\nOne thread can release a resource on behalf of another by calling the routine \r\nExReleaseResourceForThread. File system drivers use this routine when one \r\nthread acquires a resource, partially processes an I/O request, and then posts the \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/e9df21f8-4d7a-4cdf-b155-0ae142868b1d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=564e6451127a47ee13b10c46a54d67a0df7cc67b6fc07eb3931eb56a2c4004b0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 290
      },
      {
        "segments": [
          {
            "segment_id": "925a7864-016c-468b-a468-5f964a20e249",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 28\r\nI/O request to another thread. In this case, the thread that completes the I/O \r\nrequest can call this routine to release the resource on behalf of the first thread.\r\nA driver can determine whether a resource has already been acquired by any \r\nthread using the utility routines ExIsResourceAcquiredLite, \r\nExIsResourceAcquiredSharedLite, and ExIsResourceAcquiredExclusiveLite. \r\nIn addition, a driver can determine how many other threads are waiting for either \r\nshared or exclusive access to a resource by calling ExGetSharedWaiterCount or \r\nExGetExclusiveWaiterCount.\r\nSuspending a thread that owns an executive resource can cause a deadlock. For \r\nexample, assume that Thread 1 has shared access to a resource and that Thread 2\r\nis waiting for exclusive access to the same resource. If Thread 1 is suspended, \r\nThread 2 could wait forever for the resource. A malicious user could intentionally \r\ncreate a deadlock in this manner to mount a denial-of-service attack on the driver \r\nand, perhaps, on the entire operating system. For this reason, drivers must prevent \r\nthread suspension while holding an executive resource. For details, see “Security \r\nIssues” later in this paper.\r\n10 To use an executive resource, a driver must:\r\n1. Allocate an ERESOURCE structure from nonpaged pool.\r\n2. Initialize the resource by calling ExInitializeResourceLite, usually from a \r\nDriverEntry or AddDevice routine.\r\n3. Disable normal kernel-mode APCs before acquiring the resource. A device \r\ndriver calls KeEnterCriticalRegion; a file system driver calls \r\nFsRtlEnterFileSystem. If the driver routine is running in the context of a \r\nsystem thread, however, it generally does not need to disable APCs because \r\nthe thread is unlikely to be suspended.\r\n4. Acquire the resource by calling one of the resource acquisition routines listed in \r\nTable 9.\r\n5. Perform the required operations on the protected data.\r\n6. Release the resource by calling ExReleaseResourceLite.\r\n7. Re-enable normal kernel-mode APCs by calling KeLeaveCriticalRegion or \r\nFsRtlLeaveFileSystem.\r\nAll of the resource acquisition routines return a Boolean value that indicates \r\nwhether acquisition succeeded. When the thread acquires the resource, the \r\nacquisition routine returns TRUE. If the driver does not block and the resource is \r\nnot available, the routine returns FALSE.\r\nUnlike fast mutexes and spin locks, executive resources can be acquired \r\nrecursively. A thread that acquires an executive resource recursively must release \r\nthe resource as many times as it was acquired. Recursive acquisition of resources \r\nis common in file system drivers. For example, a file system driver might implement \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/925a7864-016c-468b-a468-5f964a20e249.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b81a3375f5aad30f801e46b49e8926a765b70e82c0a71be38feebd74933bb568",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 401
      },
      {
        "segments": [
          {
            "segment_id": "ec84c5dd-1f0b-43f8-a418-2a79aabf7b90",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 29\r\na cache by mapping files into a reserved area in virtual memory. The driver holds \r\ncertain locks while it processes the cached data. If that processing causes a page \r\nfault, the operating system generates an additional I/O request, which is sent to the \r\nsame file system driver and interrupts that driver’s processing of the cached I/O. To \r\nhandle the additional I/O request, the file system driver must recursively acquire \r\nsome of the same locks it uses when processing the cached I/O.\r\nExecutive resources are similar to fast mutexes in that a thread that tries to acquire \r\na resource while another thread has exclusive access to it will block. While this \r\nthread is waiting, other threads in the Ready state run.\r\n11 Callback Objects\r\nCallback objects are useful for synchronization and notification between kernel\u0002mode routines. Callback objects are kernel-mode only; they cannot be shared with \r\nuser-mode applications.\r\nA driver creates a callback object by calling ExCreateCallback. Users of the object \r\nregister a callback routine by calling ExRegisterCallback. When the driver\u0002specified callback conditions occur, the driver calls ExNotifyCallback to request \r\nthat the callback routines be run. ExNotifyCallback can be called at \r\nIRQL<=DISPATCH_LEVEL, and the callback routines are called at the same IRQL \r\nat which ExNotifyCallback was called, in the context of the notifying thread. If your \r\ndriver registers a callback routine, be sure that you know the IRQL at which \r\nnotification takes place and code the callback routine appropriately.\r\n12 Driver-Defined Locks\r\nIn addition to the synchronization mechanisms provided by the operating system, \r\ndrivers can define their own locks. If you implement a driver-defined lock, you must \r\nkeep in mind that optimizing compilers and certain hardware architectures \r\nsometimes reorder read and write instructions to improve performance. To prevent\r\nsuch reordering, driver code sometimes requires a memory barrier.\r\nA memory barrier is a processor instruction that preserves the ordering of read and \r\nwrite operations, as seen from the perspective of any other processor. The \r\noperating system’s locking mechanisms (spin locks, fast mutexes, kernel dispatcher\r\nobjects, and executive resources) all have implied memory barriers that preserve \r\nthe ordering of instructions.\r\nIf you create your own locks, you might need to put memory barriers in the locked \r\ncode to ensure the correct results. The ExInterlockedXxx and InterlockedXxx\r\nroutines and the KeMemoryBarrier and KeMemoryBarrierWithoutFence routines\r\ninsert memory barriers to prevent such reordering.\r\nFor details about memory barriers and processor reordering, see the white paper \r\n“Memory Barriers on Multiprocessor Architectures,” which is available at \r\nwww.microsoft.com/hwdev.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/ec84c5dd-1f0b-43f8-a418-2a79aabf7b90.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7611fc6e5a11cc09b14f9eea6b79e2467c4dfe2d748cbd4597c8839fa06101c2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 420
      },
      {
        "segments": [
          {
            "segment_id": "21cb4981-0195-42b4-8e8f-02a659b82593",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 30\r\n13 Using Multiple Synchronization Mechanisms \r\nSimultaneously\r\nAttempting to acquire two or more synchronization mechanisms at once can cause \r\na deadlock if this is done improperly. For this reason, the Windows DDK advises \r\ndriver writers to never acquire more than one lock at a time. However, in some \r\nsituations, using multiple locks is appropriate, or even necessary.\r\nFor example, a driver might maintain two lists that require protection at IRQL \r\nDISPATCH_LEVEL. Most code accesses only one of the lists at any given time. \r\nOccasionally, however, a driver routine must move an item from one list to another. \r\nUsing a single spin lock to protect both lists is inefficient. If a driver routine running \r\nin Thread 1 acquires the lock to update the first list, another driver routine running in\r\nThread 2 must wait to access the second list.\r\nA better solution is to protect each list with its own spin lock. Code that accesses \r\nList A acquires the spin lock for List A. Code that accesses List B acquires the spin \r\nlock for List B. Code that accesses both lists acquires both locks. To prevent \r\ndeadlocks, code that acquires both locks must always acquire the locks in the same\r\norder.\r\nTo determine the proper order for acquiring the locks, you should establish a lock \r\nhierarchy for your code. The hierarchy ranks the locks in order of increasing IRQL. \r\nList the lock that requires the lowest IRQL first, the second lowest IRQL next, and \r\nso forth. When driver code must acquire multiple locks at once, it should acquire \r\nthem in order of increasing IRQL. A code sequence that requires more than one \r\nlock at the same IRQL should acquire the most frequently used lock first.\r\nSimilarly, a code sequence that uses multiple locks should release them in the \r\ninverse of the order in which it acquired them. That is, it should release the most \r\nrecently acquired lock first.\r\nIf the driver follows the locking hierarchy consistently, deadlocks will not occur. \r\nHowever, if the driver violates the hierarchy, deadlocks are inevitable.\r\n14 Preventing Deadlocks\r\nA deadlock occurs when a thread waits for something it can never acquire. For \r\nexample, a thread that holds a spin lock cannot recursively acquire the same spin \r\nlock. The thread will spin forever waiting for itself to release the lock.\r\nTwo threads can create a mutual deadlock (sometimes called a deadly embrace) if \r\neach holds a lock that the other is trying to acquire. For example, assume a driver \r\nhas created spin locks to protect two structures, A and B. Thread 1 acquires the \r\nlock that protects Structure A and Thread 2 acquires the lock that protects \r\nStructure B. If Thread 1 now attempts to acquire the lock for B, and Thread 2 \r\nattempts to acquire the lock for A, the threads deadlock. Neither can acquire the \r\nsecond lock until the other thread releases it. Establishing and following lock \r\nhierarchies prevents deadly embraces.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/21cb4981-0195-42b4-8e8f-02a659b82593.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dfe3358159cca50ba96a4091826e6b46f3ee1a785ad81d56413916eedc4cf010",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 497
      },
      {
        "segments": [
          {
            "segment_id": "2f6da7f5-9d82-4e8b-adc5-5c21c0f46726",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 31\r\nFollow these guidelines to prevent deadlocks:\r\n Never wait on a kernel dispatcher object in any driver routine that can be called \r\nat IRQL>=DISPATCH_LEVEL. Routines that can be called at \r\nIRQL>=DISPATCH_LEVEL include IoCompletion routines and the I/O dispatch \r\nroutines of storage drivers and USB hub drivers. If in doubt, use the ASSERT() \r\nmacro on a checked build to test for the IRQL at which the routine is called.\r\n Disable normal kernel-mode APC delivery before calling any of the executive \r\nresource acquisition routines and before calling KeWaitXxx to wait on an event,\r\nsemaphore, timer, thread, file object, or process. In a device driver, call \r\nKeEnterCriticalRegion and KeLeaveCriticalRegion to disable and \r\nsubsequently re-enable APC delivery. In a file system driver, call \r\nFsRtlEnterFileSystem and FsRtlLeaveFileSystem.\r\n Use the Driver Verifier (verifier.exe) Deadlock Detection option to find potential \r\ndeadlocks. This option is available on Windows XP and later releases of \r\nWindows.\r\n Always establish and follow a lock hierarchy in code that acquires more than \r\none lock at any given time.\r\n15 Security Issues\r\nDrivers that use locks at IRQL PASSIVE_LEVEL outside a critical region are open \r\nto denial of service attacks if the thread that holds the lock is suspended. This \r\nproblem occurs because Windows queues a normal kernel-mode APC to suspend \r\nthe thread. Even if the driver specifies a KernelMode wait, normal kernel-mode \r\nAPCs are delivered whenever all of the following are true:\r\n The target thread is running at IRQL < APC_LEVEL.\r\n The target thread is not already running an APC.\r\n The target thread is not in a critical region; that is, it did not call \r\nKeEnterCriticalRegion before calling KeWaitXxx.\r\nNote\r\nKernel mutexes and fast mutexes do not have this problem. The operating system \r\nenters a critical region before it acquires a fast mutex or kernel mutex on behalf of a\r\nthread.\r\nConsider the following scenario:\r\nWhile it is handling an I/O request from a user-mode application, a driver waits for a\r\nkernel dispatcher object (other than a mutex) or acquires an executive resource. \r\nThe driver requests a KernelMode wait that is not alertable: that is, the WaitMode\r\nparameter is KernelMode and the Alertable parameter is FALSE.\r\nAssume that the requesting application has a second thread running. If the second \r\nthread acquires a handle to the thread that requested the I/O operation, it can \r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/2f6da7f5-9d82-4e8b-adc5-5c21c0f46726.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=652d0a7b8737ba80d986953733455a2547ad03dea8651305c9e454751bbf175b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 398
      },
      {
        "segments": [
          {
            "segment_id": "e8059fd9-4dbb-47d3-818f-ceecff121014",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 32\r\nsuspend the requesting thread, thus rendering the driver – and possibly the whole \r\nsystem—unusable.\r\nTo eliminate this possible security threat, a driver should enter a critical region \r\n(disable APCs) before calling KeWaitXxx. To disable and subsequently re-enable \r\nAPCs, a device driver calls KeEnterCriticalRegion and KeLeaveCriticalRegion; a\r\nfile system driver calls the FsRtlEnterFileSystem and FsRtlLeaveFileSystem\r\nmacros. A driver can check whether normal kernel-mode APCs are disabled by \r\ncalling KeAreApcsDisabled. KeAreApcsDisabled is available on Windows XP \r\nand later releases of Windows.\r\n16 Performance Issues\r\nAlthough nearly every driver requires spin locks and other synchronization \r\nmechanisms, these mechanisms by their very nature can cause performance \r\nbottlenecks. Follow these guidelines to improve performance in synchronization \r\ncode:\r\n Use locks only when necessary. For example, to gather statistical information, \r\nuse per-processor data structures instead of a single, system-wide data \r\nstructure that requires a lock.\r\n Use executive resources (ERESOURCE structures) to protect read/write data at\r\nIRQL < DISPATCH_LEVEL, so that multiple readers can be active at once.\r\n Use fast mutexes or executive resources instead of kernel dispatcher objects \r\nwhenever possible. Because fast mutexes and executive resources are not \r\nmaintained in the dispatcher database, the system can acquire them without \r\nusing the dispatcher lock. As a result, they are faster and contribute to better \r\nperformance system-wide.\r\n Use the InterlockedXxx routines whenever possible. These routines do not \r\nacquire a spin lock and are therefore relatively fast.\r\n Use an in-stack queued spin lock instead of an ordinary spin lock whenever \r\nseveral components might frequently contend for the lock\r\n Use the ExTryToAcquireXxx routines to acquire a lock whenever possible, \r\nparticularly if you have established a locking hierarchy and are using multiple, \r\nnested locks. If you need to wait for the second or third lock in a hierarchy, \r\nconsider releasing the locks that you have already acquired so that another \r\nthread that might need fewer locks can proceed, and then later reacquire the \r\nlocks from the top of the hierarchy.\r\n Minimize the number of times your driver calls routines that use the dispatcher \r\nlock. Such routines include those to wait on a dispatcher object \r\n(KeWaitForSingleObject, KeWaitForMultipleObjects, and \r\nKeWaitForMutexObject) and calls that set and release dispatcher objects \r\n(KeSetEvent, KeReleaseSemaphore, and so forth). Frequent use of the \r\ndispatcher lock can slow performance system-wide because calls that require it \r\nmust sometimes spin.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/e8059fd9-4dbb-47d3-818f-ceecff121014.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be33ba0d79e3ee1939422a91744215323442ce25b4505d65432b7feea5c006c5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 396
      },
      {
        "segments": [
          {
            "segment_id": "02114bc2-8a02-4bca-803c-03d39b2b4757",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 33\r\n Hold each spin lock for the minimum amount of time necessary, particularly if \r\nthe lock is frequently required by other code. For example, traversing a long, \r\nlinked list in a linear order while holding a heavily used spin lock can cause a \r\nperformance bottleneck.\r\n17 Best Practices for Driver Synchronization\r\nTo avoid problems related to synchronization in drivers, adopt these practices:\r\n Determine the highest IRQL at which any code can access the data.\r\n If any code that accesses the data runs at IRQL>=DISPATCH_LEVEL, you \r\nmust use a spin lock.\r\n If all code runs at IRQL PASSIVE_LEVEL or APC_LEVEL, you can use an \r\nexecutive resource, a fast mutex, or one of the kernel dispatcher objects—\r\nwhichever is best suited to the driver’s requirements.\r\n To synchronize driver execution with a user-mode application, define a private \r\nIOCTL and use either an event that is defined by the user-mode application or \r\nan I/O request that the driver completes to notify the application.\r\n To prevent thread suspension, a driver should enter a critical region before \r\nacquiring an executive resource or waiting for a kernel-dispatcher object (other \r\nthan a mutex) at IRQL=PASSIVE_LEVEL.\r\n To manage lists or to perform arithmetic or logical operations on a single \r\nmemory location, use the ExInterlockedXxx and the InterlockedXxx routines.\r\n Test every driver on as many different hardware configurations as possible. \r\nAlways test drivers on multiprocessor systems to find errors that are related to \r\nlocking, multi-threading, and concurrency.\r\n Use Driver Verifier (verifier.exe) to test for IRQL and synchronization issues. \r\nUse the Forced IRQL Checking option to ensure that spin locks are not used at \r\nthe wrong IRQL.\r\n Use the Driver Verifier global counters to monitor IRQL raises and spin lock \r\nacquisitions.\r\n Use Call Usage Verifier (CUV) to check whether the spin locks are allocated \r\nand used consistently.\r\n18 Call to Action and Resources\r\n Take into account multiprocessor issues when you design and test drivers.\r\n Design drivers to minimize the need for locks.\r\n Follow the best practices for driver synchronization described in this paper.\r\n For more information about IRQL issues for drivers, see the companion paper \r\n“Scheduling, Thread Context, and IRQL,” at \r\nhttp://www.microsoft.com/whdc/hwdev/driver/IRQL.mspx.\r\n For other related information, see:\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/02114bc2-8a02-4bca-803c-03d39b2b4757.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=40b2f97ecb6f76685feeb2999d5544c44a44a52e9a171fce4befec2c70f67bcf",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d1d965f3-e54a-4925-9132-32bdfb0b1d54",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "Locks, Deadlocks, and Synchronization- 34\r\n “Memory Barriers on Multiprocessor Architectures” at \r\nhttp://www.microsoft.com/whdc/hwdev/driver/mpmem-barrier.mspx.\r\n “Interrupt Architecture Enhancements in Microsoft Windows Vista” at \r\nhttp://www.microsoft.com/whdc/hwdev/bus/pci/MSI.mspx.\r\n Microsoft Windows Driver Development Kit (DDK) at \r\nhttp://www.microsoft.com/ddk/.\r\n Inside Microsoft Windows 2000, Third Edition. Solomon, David A. and Mark\r\nRussinovich. Redmond, WA: Microsoft Press, 2000.\r\n Designed for Microsoft Windows XP Application Specification at \r\nhttp://www.microsoft.com/winlogo/software/windowsxp-sw.mspx.\r\n Microsoft Windows Logo Program System and Device Requirements, \r\n Version 2.1a at http://www.microsoft.com/winlogo/hardware/default.mspx.\r\n© 2004 Microsoft Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/5f4b29f9-37ea-44e0-ba7b-f4579ef353ed/images/d1d965f3-e54a-4925-9132-32bdfb0b1d54.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041422Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3e65cbf1efa50dbcab1a2e56e7351f632ce7f1572fdfc58290fb7eba0a789a34",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 463
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\n  \"title\": \"Locks, Deadlocks, and Synchronization\"\n}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "Microsoft Corporation\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "2004-04-05\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "Redmond, WA\nUnited States"
        }
      ]
    }
  }
}