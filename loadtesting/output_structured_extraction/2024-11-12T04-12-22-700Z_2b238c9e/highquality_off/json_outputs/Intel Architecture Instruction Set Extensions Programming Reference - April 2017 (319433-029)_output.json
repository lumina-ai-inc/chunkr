{
  "file_name": "Intel Architecture Instruction Set Extensions Programming Reference - April 2017 (319433-029).pdf",
  "task_id": "6b7e14a7-c9c1-498f-86e7-70adb20bfd65",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "ef553867-ef77-487d-acda-14c624e0d1f4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Architecture\r\nInstruction Set Extensions Programming\r\nReference\r\n319433-029\r\nAPRIL 2017",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ef553867-ef77-487d-acda-14c624e0d1f4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3eb1534452d276eae2809089025b23b755fe6a907b85a6e8b5923e10337cfe85",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "520d3967-262b-4a91-9d31-449d3567f07c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "ii Ref. # 319433-029\r\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\r\nmore at intel.com, or from the OEM or retailer.\r\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\r\nfrom such losses.\r\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\r\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\r\nmatter disclosed herein.\r\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\r\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica\u0002tions. Current characterized errata are available on request.\r\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\r\nwithout notice. Intel does not guarantee the availability of these interfaces in any future product. Contact your Intel representative to obtain the\r\nlatest Intel product specifications and roadmaps.\r\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\r\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\r\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\r\nand/or other countries.\r\n*Other names and brands may be claimed as the property of others.\r\nCopyright © 1997-2017, Intel Corporation. All Rights Reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/520d3967-262b-4a91-9d31-449d3567f07c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=95c7f849c4da0741d1e687d4bf6fa945df15b04f0fb6692e05a221931853ecdb",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "febd2f4f-bd70-443f-9c8c-c5836ba0b2a5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 iii\r\nRevision History\r\nRevision Description Date\r\n-025\r\n• Removed instructions that now reside in the Intel® 64 and \r\nIA-32 Architectures Software Developer’s Manual.\r\n• Minor updates to chapter 1.\r\n• Updates to Table 2-1, Table 2-2 and Table 2-8 (leaf 07H) to \r\nindicate support for AVX512_4VNNIW and AVX512_4FMAPS.\r\n• Minor update to Table 2-8 (leaf 15H) regarding ECX \r\ndefinition.\r\n• Minor updates to Section 4.6.2 and Section 4.6.3 to clarify \r\nthe effects of “suppress all exceptions”.\r\n• Footnote addition to CLWB instruction indicating operand \r\nencoding requirement.\r\n• Removed PCOMMIT.\r\nSeptember 2016\r\n-026\r\n• Removed CLWB instruction; it now resides in the Intel® 64 \r\nand IA-32 Architectures Software Developer’s Manual.\r\n• Added additional 512-bit instruction extensions in chapter 6.\r\nOctober 2016\r\n-027\r\n• Added TLB CPUID leaf in chapter 2.\r\n• Added VPOPCNTD/Q instruction in chapter 6,and CPUID \r\ndetails in chapter 2.\r\nDecember 2016\r\n-028 • Updated intrinsics for VPOPCNTD/Q instruction in chapter 6. December 2016\r\n-029\r\n• Corrected typo in CPUID leaf 18H.\r\n• Updated operand encoding table format; extracted tuple \r\ninformation from operand encoding.\r\n• Added VPERMB back into chapter 5; inadvertently removed.\r\n• Moved all instructions from chapter 6 to chapter 5.\r\n• Updated operation section of VPMULTISHIFTQB.\r\nApril 2017",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/febd2f4f-bd70-443f-9c8c-c5836ba0b2a5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a298a61140093d980746bb0b990d72cdefd34cb4a310d7ac4609b1e00bc939a1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "465a9411-36c7-46b5-bdab-d72f9b42f861",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "iv Ref. # 319433-029",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/465a9411-36c7-46b5-bdab-d72f9b42f861.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=465816c4d0b23657ae266399e3db983a4b07c49daf7fca99076c56949fe996e5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 494
      },
      {
        "segments": [
          {
            "segment_id": "ef96b43e-0c3f-476a-a452-d93da0079f8d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 v\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Intel® AVX-512 Instructions Architecture Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2.1 512-Bit Wide SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.2 32 SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.3 Eight Opmask Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.4 Instruction Syntax Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.5 EVEX Instruction Encoding Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-3\r\nCHAPTER 2\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.1 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\n2.2 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\n2.3 Detection of Intel AVX-512 Instruction Groups Operating at 256 and 128-bit Vector Lengths . . . . . . . . . . . . . . . . . . . . . . . . . 2-3\r\n2.4 Accessing XMM, YMM AND ZMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2.5 Enhanced Vector Programming Environment Using EVEX Encoding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-5\r\n2.5.1 OPMASK Register to Predicate Vector Data Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\n2.5.1.1 Opmask Register K0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\r\n2.5.1.2 Example of Opmask Usages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\r\n2.5.2 OpMask Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\r\n2.5.3 Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\n2.5.4 STATIC ROUNDING MODE AND SUPPRESS ALL EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\n2.5.5 Compressed Disp8*N Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-9\r\n2.6 Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2.7 SIMD Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2.8 Instruction Exception Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2.9 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\nCHAPTER 3 \r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\n3.1 AVX-512 State, EVEX Prefix and Supported Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2 AVX-512 State Management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2.1 Detection of ZMM and Opmask State Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-1\r\n3.2.2 Enabling of ZMM and Opmask Register State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-2\r\n3.2.3 Enabling of SIMD Floating-Exception Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.2.4 The Layout of XSAVE Sate Save Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.2.5 XSAVE/XRSTOR Interaction with YMM State and MXCSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-5\r\n3.2.6 XSAVE/XRSTOR/XSAVEOPT and Managing ZMM and Opmask States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-6\r\n3.3 Reset Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n3.4 Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n3.5 Writing floating-point exception handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\nCHAPTER 4\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.1 Overview Section. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.2 Instruction Format and EVEX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.3 Register Specifier Encoding and EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4.3.1 Opmask Register Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\r\n4.4 MAsking support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5 Compressed displacement (disp8*N) support in EVEX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.6 EVEX encoding of broadcast/Rounding/SAE Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.6.1 Embedded Broadcast Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-6\r\n4.6.2 Static Rounding Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-6\r\n4.6.3 SAE Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ef96b43e-0c3f-476a-a452-d93da0079f8d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f7d7d4fcdd1a68fbd710306ef2ede0e5413f9d2dc6fc25a61a79eeda2668b3b7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3768
      },
      {
        "segments": [
          {
            "segment_id": "ef96b43e-0c3f-476a-a452-d93da0079f8d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 v\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Intel® AVX-512 Instructions Architecture Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2.1 512-Bit Wide SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.2 32 SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.3 Eight Opmask Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.4 Instruction Syntax Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-2\r\n1.2.5 EVEX Instruction Encoding Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-3\r\nCHAPTER 2\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.1 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\n2.2 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\n2.3 Detection of Intel AVX-512 Instruction Groups Operating at 256 and 128-bit Vector Lengths . . . . . . . . . . . . . . . . . . . . . . . . . 2-3\r\n2.4 Accessing XMM, YMM AND ZMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2.5 Enhanced Vector Programming Environment Using EVEX Encoding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-5\r\n2.5.1 OPMASK Register to Predicate Vector Data Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\n2.5.1.1 Opmask Register K0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\r\n2.5.1.2 Example of Opmask Usages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\r\n2.5.2 OpMask Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\r\n2.5.3 Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\n2.5.4 STATIC ROUNDING MODE AND SUPPRESS ALL EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\n2.5.5 Compressed Disp8*N Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-9\r\n2.6 Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2.7 SIMD Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2.8 Instruction Exception Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2.9 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\nCHAPTER 3 \r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\n3.1 AVX-512 State, EVEX Prefix and Supported Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2 AVX-512 State Management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2.1 Detection of ZMM and Opmask State Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-1\r\n3.2.2 Enabling of ZMM and Opmask Register State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-2\r\n3.2.3 Enabling of SIMD Floating-Exception Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.2.4 The Layout of XSAVE Sate Save Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.2.5 XSAVE/XRSTOR Interaction with YMM State and MXCSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-5\r\n3.2.6 XSAVE/XRSTOR/XSAVEOPT and Managing ZMM and Opmask States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-6\r\n3.3 Reset Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n3.4 Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n3.5 Writing floating-point exception handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\nCHAPTER 4\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.1 Overview Section. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.2 Instruction Format and EVEX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.3 Register Specifier Encoding and EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4.3.1 Opmask Register Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\r\n4.4 MAsking support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5 Compressed displacement (disp8*N) support in EVEX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.6 EVEX encoding of broadcast/Rounding/SAE Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.6.1 Embedded Broadcast Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-6\r\n4.6.2 Static Rounding Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-6\r\n4.6.3 SAE Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ef96b43e-0c3f-476a-a452-d93da0079f8d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f7d7d4fcdd1a68fbd710306ef2ede0e5413f9d2dc6fc25a61a79eeda2668b3b7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3768
      },
      {
        "segments": [
          {
            "segment_id": "60c9672f-815b-46fb-970e-fcc080b76e3e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "vi Ref. # 319433-029\r\n4.6.4 Vector Length Orthogonality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7 #UD equations for EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7.1 State Dependent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7.2 Opcode Independent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4.7.3 Opcode Dependent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4.8 Device Not Available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4.9 Scalar Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4.10 Exception Classifications of EVEX-Encoded instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4.10.1 Exceptions Type E1 and E1NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\r\n4.10.2 Exceptions Type E2 of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\r\n4.10.3 Exceptions Type E3 and E3NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\r\n4.10.4 Exceptions Type E4 and E4NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\r\n4.10.5 Exceptions Type E5 and E5NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\r\n4.10.6 Exceptions Type E6 and E6NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\r\n4.10.7 Exceptions Type E7NM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-24\r\n4.10.8 Exceptions Type E9 and E9NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25\r\n4.10.9 Exceptions Type E10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-27\r\n4.10.10 Exception Type E11 (EVEX-only, mem arg no AC, floating-point exceptions) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-29\r\n4.10.11 Exception Type E12 and E12NP (VSIB mem arg, no AC, no floating-point exceptions). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-30\r\n4.11 Exception Classifications of Opmask instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-32\r\nCHAPTER 5 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n5.1 Interpreting InstructIon Reference Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.1 Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\nADDPS—Add Packed Single-Precision Floating-Point Values (THIS IS AN EXAMPLE). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.2 Opcode Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.3 Instruction Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.1.4 64/32 bit Mode Support column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.1.5 CPUID Support column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.1.5.1 Operand Encoding Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.2 Summary of Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\r\n5.3 Ternary Bit Vector Logic Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\r\n5.4 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations). . . . . . . . . . . . . 5-9\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . . 5-11\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations). . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations). . . . . . . . . . . . . 5-15\r\nVPERMB—Permute Packed Bytes Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\r\nVPERMI2B—Full Permute of Bytes from Two Tables Overwriting the Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\r\nVPERMT2B—Full Permute of Bytes from Two Tables Overwriting a Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\r\nSee Exceptions Type E4NF.nb.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\r\nVPERMT2W/D/Q/PS/PD—Full Permute from Two Tables Overwriting one Table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\r\nVPMADD52LUQ—Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword \r\nAccumulators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\r\nVPMADD52HUQ—Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit \r\nAccumulators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-30\r\nVPMULTISHIFTQB – Select Packed Unaligned Bytes from Quadword Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-32\r\nVPOPCNTD/VPOPCNTQ — Return the Count of Number of Bits Set to 1 in DWORD/QWORD . . . . . . . . . . . . . . . . . . . . . . . 5-34",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/60c9672f-815b-46fb-970e-fcc080b76e3e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f5bf54219e7fe844aa27c2085b01a7a6948e4d8918089e30a01c43cf7021f673",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3178
      },
      {
        "segments": [
          {
            "segment_id": "60c9672f-815b-46fb-970e-fcc080b76e3e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "vi Ref. # 319433-029\r\n4.6.4 Vector Length Orthogonality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7 #UD equations for EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7.1 State Dependent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4.7.2 Opcode Independent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4.7.3 Opcode Dependent #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4.8 Device Not Available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4.9 Scalar Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4.10 Exception Classifications of EVEX-Encoded instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4.10.1 Exceptions Type E1 and E1NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\r\n4.10.2 Exceptions Type E2 of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\r\n4.10.3 Exceptions Type E3 and E3NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\r\n4.10.4 Exceptions Type E4 and E4NF of EVEX-Encoded Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\r\n4.10.5 Exceptions Type E5 and E5NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\r\n4.10.6 Exceptions Type E6 and E6NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\r\n4.10.7 Exceptions Type E7NM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-24\r\n4.10.8 Exceptions Type E9 and E9NF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25\r\n4.10.9 Exceptions Type E10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-27\r\n4.10.10 Exception Type E11 (EVEX-only, mem arg no AC, floating-point exceptions) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-29\r\n4.10.11 Exception Type E12 and E12NP (VSIB mem arg, no AC, no floating-point exceptions). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-30\r\n4.11 Exception Classifications of Opmask instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-32\r\nCHAPTER 5 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n5.1 Interpreting InstructIon Reference Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.1 Instruction Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\nADDPS—Add Packed Single-Precision Floating-Point Values (THIS IS AN EXAMPLE). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.2 Opcode Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.1.3 Instruction Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.1.4 64/32 bit Mode Support column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.1.5 CPUID Support column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.1.5.1 Operand Encoding Column in the Instruction Summary Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\r\n5.2 Summary of Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\r\n5.3 Ternary Bit Vector Logic Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\r\n5.4 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations). . . . . . . . . . . . . 5-9\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . . 5-11\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations). . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations). . . . . . . . . . . . . 5-15\r\nVPERMB—Permute Packed Bytes Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\r\nVPERMI2B—Full Permute of Bytes from Two Tables Overwriting the Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\r\nVPERMT2B—Full Permute of Bytes from Two Tables Overwriting a Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\r\nSee Exceptions Type E4NF.nb.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\r\nVPERMT2W/D/Q/PS/PD—Full Permute from Two Tables Overwriting one Table. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\r\nVPMADD52LUQ—Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword \r\nAccumulators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\r\nVPMADD52HUQ—Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit \r\nAccumulators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-30\r\nVPMULTISHIFTQB – Select Packed Unaligned Bytes from Quadword Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-32\r\nVPOPCNTD/VPOPCNTQ — Return the Count of Number of Bits Set to 1 in DWORD/QWORD . . . . . . . . . . . . . . . . . . . . . . . 5-34",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/60c9672f-815b-46fb-970e-fcc080b76e3e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f5bf54219e7fe844aa27c2085b01a7a6948e4d8918089e30a01c43cf7021f673",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3178
      },
      {
        "segments": [
          {
            "segment_id": "6eea286f-81ee-4de5-9756-f943b9159654",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 vii\r\nTABLES\r\nPAGE\r\n2-1 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\n2-2 Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2-3 Instruction Mnemonics That Do Not Support EVEX.128 Encoding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2-4 Characteristics of Three Rounding Control Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8\r\n2-5 Static Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9\r\n2-7 Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-6 SIMD Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-8 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\r\n2-9 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\n2-10 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\r\n2-11 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29\r\n2-12 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\n2-13 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-33\r\n2-14 Structured Extended Feature Leaf, Function 0, EBX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-36\r\n2-15 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\n2-16 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-41\r\n3-1 XCR0 Processor State Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\n3-2 CR4 Bits for AVX-512 Foundation Instructions Technology Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\r\n3-3 Layout of XSAVE Area For Processor Supporting YMM State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-4 XSAVE Header Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-5 XSAVE Save Area Layout for YMM_Hi128 State (Ext_Save_Area_2). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-6 XSAVE Save Area Layout for Opmask Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-7 XSAVE Save Area Layout for ZMM State of the High 256 Bits of ZMM0-ZMM15 Registers . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-8 XSAVE Save Area Layout for ZMM State of ZMM16-ZMM31 Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-9 XRSTOR Action on MXCSR, XMM Registers, YMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\r\n3-10 XSAVE Action on MXCSR, XMM, YMM Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\r\n3-11 Processor Supplied Init Values XRSTOR May Use. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n4-1 EVEX Prefix Bit Field Functional Grouping. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4-2 32-Register Support in 64-bit Mode Using EVEX with Embedded REX Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4-3 EVEX Encoding Register Specifiers in 32-bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-4 Opmask Register Specifier Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-5 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4-6 EVEX DISP8*N For Instructions Not Affected by Embedded Broadcast. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4-7 EVEX Embedded Broadcast/Rounding/SAE and Vector Length on Vector Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4-8 OS XSAVE Enabling Requirements of Instruction Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-9 Opcode Independent, State Dependent EVEX Bit Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-10 #UD Conditions of Operand-Encoding EVEX Prefix Bit Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-11 #UD Conditions of Opmask Related Encoding Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4-12 #UD Conditions Dependent on EVEX.b Context. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4-13 EVEX-Encoded Instruction Exception Class Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4-14 EVEX Instructions in each Exception Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\r\n4-15 Type E1 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\r\n4-16 Type E1NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\r\n4-17 Type E2 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\r\n4-18 Type E3 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\r\n4-19 Type E3NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\r\n4-20 Type E4 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\r\n4-21 Type E4NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-19\r\n4-22 Type E5 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\r\n4-23 Type E5NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\r\n4-24 Type E6 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\r\n4-25 Type E6NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\r\n4-26 Type E7NM Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-24\r\n4-27 Type E9 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25\r\n4-28 Type E9NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-26",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6eea286f-81ee-4de5-9756-f943b9159654.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdb6a9acc79807ea7763c482d8b2b7adec47a6aace8a3b5a66f9b532f8d16c04",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3739
      },
      {
        "segments": [
          {
            "segment_id": "6eea286f-81ee-4de5-9756-f943b9159654",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 vii\r\nTABLES\r\nPAGE\r\n2-1 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\n2-2 Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2-3 Instruction Mnemonics That Do Not Support EVEX.128 Encoding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-4\r\n2-4 Characteristics of Three Rounding Control Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8\r\n2-5 Static Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9\r\n2-7 Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-6 SIMD Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-8 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\r\n2-9 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\n2-10 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\r\n2-11 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29\r\n2-12 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\n2-13 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-33\r\n2-14 Structured Extended Feature Leaf, Function 0, EBX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-36\r\n2-15 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\n2-16 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-41\r\n3-1 XCR0 Processor State Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\n3-2 CR4 Bits for AVX-512 Foundation Instructions Technology Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\r\n3-3 Layout of XSAVE Area For Processor Supporting YMM State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-4 XSAVE Header Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-5 XSAVE Save Area Layout for YMM_Hi128 State (Ext_Save_Area_2). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-4\r\n3-6 XSAVE Save Area Layout for Opmask Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-7 XSAVE Save Area Layout for ZMM State of the High 256 Bits of ZMM0-ZMM15 Registers . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-8 XSAVE Save Area Layout for ZMM State of ZMM16-ZMM31 Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5\r\n3-9 XRSTOR Action on MXCSR, XMM Registers, YMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\r\n3-10 XSAVE Action on MXCSR, XMM, YMM Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\r\n3-11 Processor Supplied Init Values XRSTOR May Use. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7\r\n4-1 EVEX Prefix Bit Field Functional Grouping. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4-2 32-Register Support in 64-bit Mode Using EVEX with Embedded REX Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4-3 EVEX Encoding Register Specifiers in 32-bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-4 Opmask Register Specifier Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-5 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4-6 EVEX DISP8*N For Instructions Not Affected by Embedded Broadcast. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4-7 EVEX Embedded Broadcast/Rounding/SAE and Vector Length on Vector Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\r\n4-8 OS XSAVE Enabling Requirements of Instruction Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-9 Opcode Independent, State Dependent EVEX Bit Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-10 #UD Conditions of Operand-Encoding EVEX Prefix Bit Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\r\n4-11 #UD Conditions of Opmask Related Encoding Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4-12 #UD Conditions Dependent on EVEX.b Context. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\r\n4-13 EVEX-Encoded Instruction Exception Class Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\r\n4-14 EVEX Instructions in each Exception Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\r\n4-15 Type E1 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\r\n4-16 Type E1NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\r\n4-17 Type E2 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\r\n4-18 Type E3 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\r\n4-19 Type E3NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\r\n4-20 Type E4 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\r\n4-21 Type E4NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-19\r\n4-22 Type E5 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\r\n4-23 Type E5NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\r\n4-24 Type E6 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\r\n4-25 Type E6NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\r\n4-26 Type E7NM Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-24\r\n4-27 Type E9 Class Exception Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-25\r\n4-28 Type E9NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-26",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6eea286f-81ee-4de5-9756-f943b9159654.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdb6a9acc79807ea7763c482d8b2b7adec47a6aace8a3b5a66f9b532f8d16c04",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3739
      },
      {
        "segments": [
          {
            "segment_id": "2b704a0c-8a89-43d5-8b1d-e1dcdd5a0f8e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "viii Ref. # 319433-029\r\n4-29 Type E10 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-27\r\n4-30 Type E10NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-28\r\n4-31 Type E11 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-29\r\n4-32 Type E12 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-30\r\n4-33 Type E12NP Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-31\r\n4-34 TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg) . . . . . . . . . . . . . . . . . . . . . . . . . . 4-32\r\n4-35 TYPE K21 Exception Definition (VEX-Encoded OpMask Instructions Addressing Memory) . . . . . . . . . . . . . . . . . . . . . . . 4-33\r\n5-1 Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-7\r\n5-2 Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/2b704a0c-8a89-43d5-8b1d-e1dcdd5a0f8e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6158e8eef09eeafcb4700bc08c9158b53a2f6bc809994e43f4775e649888d66c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 563
      },
      {
        "segments": [
          {
            "segment_id": "2b704a0c-8a89-43d5-8b1d-e1dcdd5a0f8e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "viii Ref. # 319433-029\r\n4-29 Type E10 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-27\r\n4-30 Type E10NF Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-28\r\n4-31 Type E11 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-29\r\n4-32 Type E12 Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-30\r\n4-33 Type E12NP Class Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-31\r\n4-34 TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg) . . . . . . . . . . . . . . . . . . . . . . . . . . 4-32\r\n4-35 TYPE K21 Exception Definition (VEX-Encoded OpMask Instructions Addressing Memory) . . . . . . . . . . . . . . . . . . . . . . . 4-33\r\n5-1 Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-7\r\n5-2 Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/2b704a0c-8a89-43d5-8b1d-e1dcdd5a0f8e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6158e8eef09eeafcb4700bc08c9158b53a2f6bc809994e43f4775e649888d66c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 563
      },
      {
        "segments": [
          {
            "segment_id": "3fe34242-e090-47cf-ac8f-061b513df53e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 ix\r\nFIGURES\r\nPAGE\r\nFigure 1-1. 512-Bit Wide Vectors and SIMD Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-2\r\nFigure 2-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nFigure 2-2. Procedural Flow of Application Detection of 512-bit Instruction Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\nFigure 2-3. Procedural Flow of Application Detection of Intel AVX-512 Instructions Operating at Vector Lengths < 512. . . . . . 2-3\r\nFigure 2-4. Version Information Returned by CPUID in EAX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\r\nFigure 2-5. Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29\r\nFigure 2-6. Feature Information Returned in the EDX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\nFigure 2-7. Determination of Support for the Processor Brand String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\nFigure 2-8. Algorithm for Extracting Maximum Processor Frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-40\r\nFigure 3-1. Bit Vector and XCR0 Layout of Extended Processor State Components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\nFigure 4-1. AVX-512 Instruction Format and the EVEX Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\nFigure 4-2. Bit Field Layout of the EVEX Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\nFigure 5-1. Register Source-Block Dot Product of Two Signed Word Operands with Doubleword Accumulation. . . . . . . . . . . . . . 5-13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3fe34242-e090-47cf-ac8f-061b513df53e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=838e88f220d2e51441f12b20f03b9bb93b8dd4457095b4836072b975d807f771",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 775
      },
      {
        "segments": [
          {
            "segment_id": "3fe34242-e090-47cf-ac8f-061b513df53e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 ix\r\nFIGURES\r\nPAGE\r\nFigure 1-1. 512-Bit Wide Vectors and SIMD Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-2\r\nFigure 2-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nFigure 2-2. Procedural Flow of Application Detection of 512-bit Instruction Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\nFigure 2-3. Procedural Flow of Application Detection of Intel AVX-512 Instructions Operating at Vector Lengths < 512. . . . . . 2-3\r\nFigure 2-4. Version Information Returned by CPUID in EAX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\r\nFigure 2-5. Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-29\r\nFigure 2-6. Feature Information Returned in the EDX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\nFigure 2-7. Determination of Support for the Processor Brand String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\nFigure 2-8. Algorithm for Extracting Maximum Processor Frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-40\r\nFigure 3-1. Bit Vector and XCR0 Layout of Extended Processor State Components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\nFigure 4-1. AVX-512 Instruction Format and the EVEX Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\nFigure 4-2. Bit Field Layout of the EVEX Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\nFigure 5-1. Register Source-Block Dot Product of Two Signed Word Operands with Doubleword Accumulation. . . . . . . . . . . . . . 5-13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3fe34242-e090-47cf-ac8f-061b513df53e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=838e88f220d2e51441f12b20f03b9bb93b8dd4457095b4836072b975d807f771",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 775
      },
      {
        "segments": [
          {
            "segment_id": "55b74226-ac55-418f-8460-e06316ae10b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "x Ref. # 319433-029",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/55b74226-ac55-418f-8460-e06316ae10b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=17f55c5e1b2ce65a269787788b4cb9efdce5414131b7d0a9e72cee9919035a69",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ea8da876-ce6b-4660-a649-0cdd115a97bc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 1-1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n1.1 ABOUT THIS DOCUMENT\r\nThis document describes the software programming interfaces of Intel® architecture instruction extensions\r\nwhich may be included in future Intel processor generations. Intel does not guarantee the availability of these\r\ninterfaces in any future product. \r\nThe instruction set extensions cover a diverse range of application domains and programming usages. The 512-\r\nbit SIMD vector SIMD extensions, referred to as Intel® Advanced Vector Extensions 512 (Intel® AVX-512) in\u0002structions, deliver comprehensive set of functionality and higher performance than Intel® AVX and Intel® AVX2\r\ninstructions. Intel AVX, Intel AVX2 and many Intel AVX-512 instructions are covered in Intel® 64 and IA-32 Ar\u0002chitectures Software Developer’s Manual sets. The reader can refer to them for basic and more background in\u0002formation related to various features referenced in this document.\r\nThe base of the 512-bit SIMD instruction extensions are referred to as Intel AVX-512 Foundation instructions.\r\nThey include extensions of the AVX and AVX2 family of SIMD instructions but are encoded using a new encoding\r\nscheme with support for 512-bit vector registers, up to 32 vector registers in 64-bit mode, and conditional pro\u0002cessing using opmask registers. \r\nChapters 2 through 5 are devoted to the programming interfaces of the AVX-512 Foundation instruction set, ad\u0002ditional 512-bit instruction extensions in the Intel AVX-512 family targeting broad application domains, and in\u0002struction set extensions encoded using the EVEX prefix encoding scheme to operate at vector lengths smaller\r\nthan 512-bits. \r\nChapter 6 describes instruction set extensions that offer software tools with capability to address memory pro\u0002tection issues such as buffer overruns. \r\n1.2 INTEL® AVX-512 INSTRUCTIONS ARCHITECTURE OVERVIEW\r\nIntel AVX-512 Foundation instructions are a natural extension to AVX and AVX2. It introduces the following ar\u0002chitectural enhancements:\r\n• Support for 512-bit wide vectors and SIMD register set. 512-bit register state is managed by the operating \r\nsystem using XSAVE/XRSTOR instructions introduced in 45 nm Intel 64 processors (see Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual, Volume 2C, and Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual, Volume 3A). \r\n• Support for 16 new, 512-bit SIMD registers (for a total of 32 SIMD registers, ZMM0 through ZMM31) in 64-bit \r\nmode. The extra 16 registers state is managed by the operating system using XSAVE/XRSTOR/XSAVEOPT.\r\n• Support for 8 new opmask registers (k0 through k7) used for conditional execution and efficient merging of \r\ndestination operands. Again, the opmask register state is managed by the operating system using \r\nXSAVE/XRSTOR/XSAVEOPT instructions\r\n• A new encoding prefix (referred to as EVEX) to support additional vector length encoding up to 512 bits. The \r\nEVEX prefix builds upon the foundations of VEX prefix, to provide compact, efficient encoding for functionality \r\navailable to VEX encoding plus the following enhanced vector capabilities: \r\n• opmasks\r\n• embedded broadcast\r\n• instruction prefix-embedded rounding control\r\n• compressed address displacements",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ea8da876-ce6b-4660-a649-0cdd115a97bc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fa08fe6e252eeb7bbaa2d4329e283c79c2aaa9e1592a7cb129894d56bae1f173",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 474
      },
      {
        "segments": [
          {
            "segment_id": "209e482a-4263-4c55-ad33-73b73df88fda",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "1-2 Ref. # 319433-029\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n1.2.1 512-Bit Wide SIMD Register Support\r\nAVX-512 instructions support 512-bit wide SIMD registers (ZMM0-ZMM31). The lower 256-bits of the ZMM regis\u0002ters are aliased to the respective 256-bit YMM registers and the lower 128-bit are aliased to the respective 128-bit \r\nXMM registers.\r\n1.2.2 32 SIMD Register Support\r\nAVX-512 instructions also support for 32 SIMD registers in 64-bit mode (XMM0-XMM31, YMM0-YMM31 and ZMM0-\r\nZMM31). The number of available vector registers in 32-bit mode is still 8.\r\n1.2.3 Eight Opmask Register Support\r\nAVX-512 instructions support 8 opmask registers (k0-k7). The width of each opmask register is architecturally \r\ndefined of size MAX_KL (64 bits). Seven of the eight opmask registers (k1-k7) can be used in conjunction with \r\nEVEX-encoded AVX-512 Foundation instructions to provide conditional execution and efficient merging of data \r\nelements in the destination operand. The encoding of opmask register k0 is typically used when all data elements \r\n(unconditional processing) are desired. Additionally, the opmask registers are also used as vector flags/element\u0002level vector sources to introduce novel SIMD functionality as seen in new instructions such as VCOMPRESSPS.\r\n1.2.4 Instruction Syntax Enhancement\r\nThe architecture of EVEX encoding enhances vector instruction encoding scheme in the following way: \r\n• 512-bit vector-length, up to 32 ZMM registers, and enhanced vector programming environment are supported \r\nusing the enhanced VEX (EVEX).\r\nThe EVEX prefix provides more encodable bit fields than VEX prefix. In addition to encoding 32 ZMM registers in 64-\r\nbit mode, instruction encoding using the EVEX can directly encode 7 (out of 8) opmask register operands to provide \r\nconditional processing in vector instruction programming. The enhanced vector programming environment can be \r\nexplicitly expressed in the instruction syntax to include the following elements: \r\n• An opmask operand: the opmask registers are expressed using the notation “k1” through “k7”. An EVEX\u0002encoded instruction supporting conditional vector operation using the opmask register k1 is expressed by \r\nattaching the notation {k1} next to the destination operand. The use of this feature is optional for most instruc\u0002tions. There are two types of masking (merging and zeroing) differentiated using the EVEX.z bit ({z} in \r\ninstruction signature).\r\nFigure 1-1. 512-Bit Wide Vectors and SIMD Register Set\r\n. . .\r\nZMM31 XMM31\r\nBit#\r\n511 256 255 0\r\nYMM31\r\n128 127\r\nZMM1 YMM1 XMM1\r\nZMM0 YMM0 XMM0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/209e482a-4263-4c55-ad33-73b73df88fda.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f3ec63c20ff990a4982751c291d0d779944c31630de7589085edf346a33fb7bc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 378
      },
      {
        "segments": [
          {
            "segment_id": "8909893c-1177-41c0-8b3f-440699c5dc4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 1-3\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n• Embedded broadcast may be supported for some instructions on the source operand that can be encoded as a \r\nmemory vector. Data elements of a memory vector may be conditionally fetched or written to.\r\n• For instruction syntax that operates only on floating-point data in SIMD registers with rounding semantics, the \r\nEVEX can provide explicit rounding control within the EVEX bit fields at either scalar or 512-bit vector length. \r\nIn AVX-512 instructions, vector addition of all elements of the source operands can be expressed in the same \r\nsyntax as AVX instruction:\r\nVADDPS zmm1, zmm2, zmm3\r\nAdditionally, the EVEX encoding scheme of AVX-512 Foundation can express conditional vector addition as\r\nVADDPS zmm1 {k1}{z}, zmm2, zmm3\r\nwhere \r\n• conditional processing and updates to destination is expressed with an opmask register,\r\n• zeroing behavior of the opmask selected destination element is expressed by the {z} modifier (with merging \r\nas the default if no modifier specified),\r\nNote that some SIMD instructions supporting three-operand syntax but processing only less or equal than 128-bits \r\nof data are considered part of the 512-bit SIMD instruction set extensions, because bits MAX_VL-1:128 of the \r\ndestination register are zeroed by the processor. The same rule applies to instructions operating on 256-bits of data \r\nwhere bits MAX_VL-1:256 of the destination register are zeroed.\r\n1.2.5 EVEX Instruction Encoding Support\r\nIntel AVX-512 instructions employ a new encoding prefix, referred to as EVEX, in the Intel 64 and IA-32 instruction \r\nencoding format. Instruction encoding using the EVEX prefix provides the following capabilities:\r\n• Direct encoding of a SIMD register operand within EVEX (similar to VEX). This provides instruction syntax \r\nsupport for three source operands. \r\n• Compaction of REX prefix functionality and extended SIMD register encoding: The equivalent REX-prefix \r\ncompaction functionality offered by the VEX prefix is provided within EVEX. Furthermore, EVEX extends the \r\noperand encoding capability to allow direct addressing of up to 32 ZMM registers in 64-bit mode.\r\n• Compaction of SIMD prefix functionality and escape byte encoding: The functionality of SIMD prefix (66H, F2H, \r\nF3H) on opcode is equivalent to an opcode extension field to introduce new processing primitives. This \r\nfunctionality is provided in the VEX prefix encoding scheme and employed within the EVEX prefix. Similarly, the \r\nfunctionality of the escape opcode byte (0FH) and two-byte escape (0F38H, 0F3AH) are also compacted within \r\nthe EVEX prefix encoding. \r\n• Most EVEX-encoded SIMD numeric and data processing instruction semantics with memory operand have \r\nrelaxed memory alignment requirements than instructions encoded using SIMD prefixes (see Section 2.6, \r\n“Memory Alignment”).\r\n• Direct encoding of a opmask operand within the EVEX prefix. This provides instruction syntax support for \r\nconditional vector-element operation and merging of destination operand using an opmask register (k1-k7).\r\n• Direct encoding of a broadcast attribute for instructions with a memory operand source. This provides \r\ninstruction syntax support for elements broadcasting of the second operand before being used in the actual \r\noperation.\r\n• Compressed memory address displacements for a more compact instruction encoding byte sequence.\r\nEVEX encoding applies to SIMD instructions operating on XMM, YMM and ZMM registers. EVEX is not supported for \r\ninstructions operating on MMX or x87 registers. Details of EVEX instruction encoding are discussed in Chapter 4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/8909893c-1177-41c0-8b3f-440699c5dc4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e76a0efdf48f74edbc3bb7b4224982464254f103b3c821178c0c8a75c191b328",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 534
      },
      {
        "segments": [
          {
            "segment_id": "8909893c-1177-41c0-8b3f-440699c5dc4c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 1-3\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS\r\n• Embedded broadcast may be supported for some instructions on the source operand that can be encoded as a \r\nmemory vector. Data elements of a memory vector may be conditionally fetched or written to.\r\n• For instruction syntax that operates only on floating-point data in SIMD registers with rounding semantics, the \r\nEVEX can provide explicit rounding control within the EVEX bit fields at either scalar or 512-bit vector length. \r\nIn AVX-512 instructions, vector addition of all elements of the source operands can be expressed in the same \r\nsyntax as AVX instruction:\r\nVADDPS zmm1, zmm2, zmm3\r\nAdditionally, the EVEX encoding scheme of AVX-512 Foundation can express conditional vector addition as\r\nVADDPS zmm1 {k1}{z}, zmm2, zmm3\r\nwhere \r\n• conditional processing and updates to destination is expressed with an opmask register,\r\n• zeroing behavior of the opmask selected destination element is expressed by the {z} modifier (with merging \r\nas the default if no modifier specified),\r\nNote that some SIMD instructions supporting three-operand syntax but processing only less or equal than 128-bits \r\nof data are considered part of the 512-bit SIMD instruction set extensions, because bits MAX_VL-1:128 of the \r\ndestination register are zeroed by the processor. The same rule applies to instructions operating on 256-bits of data \r\nwhere bits MAX_VL-1:256 of the destination register are zeroed.\r\n1.2.5 EVEX Instruction Encoding Support\r\nIntel AVX-512 instructions employ a new encoding prefix, referred to as EVEX, in the Intel 64 and IA-32 instruction \r\nencoding format. Instruction encoding using the EVEX prefix provides the following capabilities:\r\n• Direct encoding of a SIMD register operand within EVEX (similar to VEX). This provides instruction syntax \r\nsupport for three source operands. \r\n• Compaction of REX prefix functionality and extended SIMD register encoding: The equivalent REX-prefix \r\ncompaction functionality offered by the VEX prefix is provided within EVEX. Furthermore, EVEX extends the \r\noperand encoding capability to allow direct addressing of up to 32 ZMM registers in 64-bit mode.\r\n• Compaction of SIMD prefix functionality and escape byte encoding: The functionality of SIMD prefix (66H, F2H, \r\nF3H) on opcode is equivalent to an opcode extension field to introduce new processing primitives. This \r\nfunctionality is provided in the VEX prefix encoding scheme and employed within the EVEX prefix. Similarly, the \r\nfunctionality of the escape opcode byte (0FH) and two-byte escape (0F38H, 0F3AH) are also compacted within \r\nthe EVEX prefix encoding. \r\n• Most EVEX-encoded SIMD numeric and data processing instruction semantics with memory operand have \r\nrelaxed memory alignment requirements than instructions encoded using SIMD prefixes (see Section 2.6, \r\n“Memory Alignment”).\r\n• Direct encoding of a opmask operand within the EVEX prefix. This provides instruction syntax support for \r\nconditional vector-element operation and merging of destination operand using an opmask register (k1-k7).\r\n• Direct encoding of a broadcast attribute for instructions with a memory operand source. This provides \r\ninstruction syntax support for elements broadcasting of the second operand before being used in the actual \r\noperation.\r\n• Compressed memory address displacements for a more compact instruction encoding byte sequence.\r\nEVEX encoding applies to SIMD instructions operating on XMM, YMM and ZMM registers. EVEX is not supported for \r\ninstructions operating on MMX or x87 registers. Details of EVEX instruction encoding are discussed in Chapter 4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/8909893c-1177-41c0-8b3f-440699c5dc4c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e76a0efdf48f74edbc3bb7b4224982464254f103b3c821178c0c8a75c191b328",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 534
      },
      {
        "segments": [
          {
            "segment_id": "9b53a8c2-beaa-4e86-ad4f-bbe62dac62b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "1-4 Ref. # 319433-029\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9b53a8c2-beaa-4e86-ad4f-bbe62dac62b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a903f91512a8618a2016f57f374ee972f7f8f02aeec545d153b6d79df4b6fbdf",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b14616b7-d67f-4c7e-8f1a-f54f6a85689a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-1\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nCHAPTER 2\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nThe application programming model for AVX-512 Foundation instructions and several member groups of the Intel®\r\nAVX-512 family (described in Chapter 5) extend from that of Intel AVX and Intel AVX2 with differences detailed in \r\nthis chapter.\r\n2.1 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS \r\nThe majority of AVX-512 Foundation instructions are encoded using the EVEX encoding scheme. EVEX-encoded \r\ninstructions can operate on the 512-bit ZMM register state plus 8 opmask registers. The opmask instructions in \r\nAVX-512 Foundation instructions operate only on opmask registers or with a general purpose register. System \r\nsoftware requirements to support ZMM state and opmask instructions are described in Chapter 3, “System \r\nProgramming For Intel® AVX-512”.\r\nProcessor support of AVX-512 Foundation instructions is indicated by CPUID.(EAX=07H, ECX=0):EBX.AVX512F[bit \r\n16] = 1. Detection of AVX-512 Foundation instructions operating on ZMM states and opmask registers need to \r\nfollow the general procedural flow in Figure 2-1.\r\nPrior to using AVX-512 Foundation instructions, the application must identify that the operating system supports \r\nthe XGETBV instruction, the ZMM register state, in addition to processor’s support for ZMM state management \r\nusing XSAVE/XRSTOR and AVX-512 Foundation instructions. The following simplified sequence accomplishes both \r\nand is strongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use1).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Detect CPUID.0x7.0:EBX.AVX512F[bit 16] = 1.\r\nFigure 2-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions\r\n1. If CPUID.01H:ECX.OSXSAVE reports 1, it also indirectly implies the processor supports XSAVE, XRSTOR, XGETBV, processor \r\nextended state bit vector XCR0 register. Thus an application may streamline the checking of CPUID feature flags for XSAVE and OSX\u0002SAVE. XSETBV is a privileged instruction.\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F flag \r\nCheck feature flag\r\nCPUID.1H:ECX.OSXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b14616b7-d67f-4c7e-8f1a-f54f6a85689a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f30d5c82c8261686d052cafb4998a062c5ef0555ab2fb1ae59615aa05950f2d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 360
      },
      {
        "segments": [
          {
            "segment_id": "288016d7-2e73-4f41-9a6b-58efc463be80",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "2-2 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.2 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 \r\nFAMILY\r\nIn addition to the Intel AVX-512 Foundation instructions, Intel AVX-512 family provides several additional 512-bit \r\nextensions in groups of instructions, each group is enumerated by a CPUID leaf 7 feature flag and can be encoded \r\nvia EVEX.L’L field to support operation at vector lengths smaller than 512 bits. These instruction groups are listed \r\nin Table 2-1.\r\nSoftware must follow the detection procedure for the 512-bit AVX-512 Foundation instructions as described in \r\nSection 2.1.\r\nDetection of other 512-bit sibling instruction groups listed in Table 2-1 (excluding AVX512F) follows the procedure \r\ndescribed in Figure 2-2:\r\nTable 2-1. 512-bit Instruction Groups in the Intel AVX-512 Family\r\nCPUID Leaf 7 Feature Flag Bit Feature Flag abbreviation of 512-bit Instruction Group SW Detection Flow\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 16] AVX512F (AVX-512 Foundation) Figure 2-1\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 17] AVX512DQ Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 21] AVX512IFMA Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 28] AVX512CD Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 30] AVX512BW Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 01] AVX512VBMI Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 14] AVX512_VPOPCNTDQ Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):EDX[bit 02] AVX512_4VNNIW Figure 2-2\r\nCPUID.(EAX=07H, ECX=0):EDX[bit 03] AVX512_4FMAPS Figure 2-2\r\nFigure 2-2. Procedural Flow of Application Detection of 512-bit Instruction Groups\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F and\r\na sibling 512-bit flag\r\nCheck feature flag\r\nCPUID.1H:ECX.OXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/288016d7-2e73-4f41-9a6b-58efc463be80.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b4b14166593fc9463e46355e6660268cf5089607716cde1403f838f5b0de1d56",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 248
      },
      {
        "segments": [
          {
            "segment_id": "68a633e4-effa-4615-acc8-17dfde3c966c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-3\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nTo illustrated the detection procedure for 512-bit instructions enumerated by AVX512CD, the following sequence is \r\nstrongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Verify both CPUID.0x7.0:EBX.AVX512F[bit 16] = 1, CPUID.0x7.0:EBX.AVX512CD[bit 28] = 1.\r\nSimilarly, the detection procedure for enumerating 512-bit instructions reported by AVX512DW follows the same \r\nflow.\r\n2.3 DETECTION OF INTEL AVX-512 INSTRUCTION GROUPS OPERATING AT 256 \r\nAND 128-BIT VECTOR LENGTHS\r\nFor each of the 512-bit instruction groups in the Intel AVX-512 family listed in Table 2-1, EVEX encoding scheme \r\nmay support a vast majority of these instructions operating at 256-bit or 128-bit (if applicable) vector lengths. This \r\nencoding support for vector lengths smaller than 512-bits is indicated by CPUID.(EAX=07H, ECX=0):EBX[bit 31], \r\nabbreviated as AVX512VL.\r\nThe AVX512VL flag alone is never sufficient to determine a given Intel AVX-512 instruction may be encoded at \r\nvector lengths smaller than 512 bits. Software must use the procedure described in Figure 2-3 and Table 2-2:\r\nTo illustrate the procedure described in Figure 2-3 and Table 2-2 for software to use EVEX.256 encoded VPCON\u0002FLICT, the following sequence is strongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use)\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Verify CPUID.0x7.0:EBX.AVX512F[bit 16] = 1, CPUID.0x7.0:EBX.AVX512CD[bit 28] = 1, and \r\nCPUID.0x7.0:EBX.AVX512VL[bit 31] = 1.\r\nFigure 2-3. Procedural Flow of Application Detection of Intel AVX-512 Instructions Operating at Vector Lengths < \r\n512\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck applicable collection of\r\nCPUID flags listed in Table 2-2\r\nCheck feature flag\r\nCPUID.1H:ECX.OXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/68a633e4-effa-4615-acc8-17dfde3c966c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=04eb0eb524d47f5e1ae3f88334422c82f2328f03eecefd9843e591e12e044f67",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 352
      },
      {
        "segments": [
          {
            "segment_id": "a84de978-6c0c-4468-af93-18dc31b3b165",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "2-4 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nIn some specific cases, AVX512VL may only support EVEX.256 encoding but not EVEX.128. These are listed in Table \r\n2-3.\r\n2.4 ACCESSING XMM, YMM AND ZMM REGISTERS\r\nThe lower 128 bits of a YMM register is aliased to the corresponding XMM register. Legacy SSE instructions (i.e. \r\nSIMD instructions operating on XMM state but not using the VEX prefix, also referred to non-VEX encoded SIMD \r\ninstructions) will not access the upper bits (MAX_VL-1:128) of the YMM registers. AVX and FMA instructions with a \r\nVEX prefix and vector length of 128-bits zeroes the upper 128 bits of the YMM register.\r\nUpper bits of YMM registers (255:128) can be read and written by many instructions with a VEX.256 prefix. \r\nXSAVE and XRSTOR may be used to save and restore the upper bits of the YMM registers. \r\nThe lower 256 bits of a ZMM register are aliased to the corresponding YMM register. Legacy SSE instructions (i.e. \r\nSIMD instructions operating on XMM state but not using the VEX prefix, also referred to non-VEX encoded SIMD \r\ninstructions) will not access the upper bits (MAX_VL-1:128) of the ZMM registers, where MAX_VL is maximum \r\nvector length (currently 512 bits). AVX and FMA instructions with a VEX prefix and vector length of 128-bits zero \r\nthe upper 384 bits of the ZMM register, while VEX prefix and vector length of 256-bits zeros the upper 256 bits of \r\nthe ZMM register.\r\nUpper bits of ZMM registers (511:256) can be read and written by instructions with an EVEX.512 prefix. \r\nTable 2-2. Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group \r\nUsage of 256/128 Vector Lengths Feature Flag Collection to Verify\r\nAVX512F AVX512F & AVX512VL\r\nAVX512CD AVX512F & AVX512CD & AVX512VL\r\nAVX512DQ AVX512F & AVX512DQ & AVX512VL\r\nAVX512BW AVX512F & AVX512BW & AVX512VL\r\nAVX512IFMA AVX512F & AVX512IFMA & AVX512VL\r\nAVX512VBMI AVX512F & AVX512VBMI & AVX512VL\r\nAVX512_4FMAPS AVX512F & AVX512_4FMAPS & AVX512VL\r\nAVX512_4VNNIW AVX512F & AVX512_4VNNIW & AVX512VL\r\nAVX512_VPOPCNTDQ AVX512F & AVX512_VPOPCNTDQ & AVX512VL\r\nTable 2-3. Instruction Mnemonics That Do Not Support EVEX.128 Encoding \r\nInstruction Group Instruction Mnemonics Supporting EVEX.256 Only Using AVX512VL\r\nAVX512F VBROADCASTSD, VBROADCASTF32X4, VEXTRACTI32X4, VINSERTF32X4, VINSERTI32X4, VPERMD, \r\nVPERMPD, VPERMPS, VPERMQ, VSHUFF32X4, VSHUFF64X2, VSHUFI32X4, VSHUFI64X2\r\nAVX512CD\r\nAVX512DQ VBROADCASTF32X2, VBROADCASTF64X2, VBROADCASTI32X4, VBROADCASTI64X2, VEXTRACTI64X2, \r\nVINSERTF64X2, VINSERTI64X2, \r\nAVX512BW",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a84de978-6c0c-4468-af93-18dc31b3b165.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d915d5a426ce67d52465c9542d35092fdc0c8370754888bdcb4c3bfa3a78429",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 375
      },
      {
        "segments": [
          {
            "segment_id": "b1ec68e4-23b4-44fe-a16d-3f183ab55852",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-5\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.5 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX \r\nENCODING\r\nEVEX-encoded AVX-512 instructions support an enhanced vector programming environment. The enhanced vector \r\nprogramming environment uses the combination of EVEX bit-field encodings and a set of eight opmask registers to \r\nprovide the following capabilities:\r\n• Conditional vector processing of EVEX-encoded instruction. Opmask registers k1 through k7 can be used to \r\nconditionally govern the per-data-element computational operation and the per-element updates to the \r\ndestination operand of an AVX-512 Foundation instruction. Each bit of the opmask register governs one vector \r\nelement operation (a vector element can be of 32 bits or 64 bits). \r\n• In addition to providing predication control on vector instructions via EVEX bit-field encoding, the opmask \r\nregisters can also be used similarly to general-purpose registers as source/destination operands using modR/M \r\nencoding for non-mask-related instructions. In this case, an opmask register k0 through k7 can be selected.\r\n• In 64-bit mode, 32 vector registers can be encoded using EVEX prefix.\r\n• Broadcast may be supported for some instructions on the operand that can be encoded as a memory vector. \r\nThe data elements of a memory vector may be conditionally fetched or written to, and the vector size is \r\ndependent on the data transformation function.\r\n• Flexible rounding control for register-to-register flavor of EVEX encoded 512-bit and scalar instructions. Four \r\nrounding modes are supported by direct encoding within the EVEX prefix overriding MXCSR settings.\r\n• Broadcast of one element to the rest of the destination vector register.\r\n• Compressed 8-bit displacement encoding scheme to increase the instruction encoding density for instructions \r\nthat normally require disp32 syntax.\r\n2.5.1 OPMASK Register to Predicate Vector Data Processing\r\nAVX-512 instructions using EVEX encodes a predicate operand to conditionally control per-element computational \r\noperation and updating of result to the destination operand. The predicate operand is known as the opmask \r\nregister. The opmask is a set of eight architectural registers of size MAX_KL (64-bit). Note that from this set of 8 \r\narchitectural registers, only k1 through k7 can be addressed as predicate operand. k0 can be used as a regular \r\nsource or destination but cannot be encoded as a predicate operand. Note also that a predicate operand can be \r\nused to enable memory fault-suppression for some instructions with a memory operand (source or destination). \r\nAs a predicate operand, the opmask registers contain one bit to govern the operation/update to each data element \r\nof a vector register. In general, opmask registers can support instructions with element sizes: single-precision \r\nfloating-point (float32), integer doubleword(int32), double-precision floating-point (float64), integer quadword \r\n(int64). The length of a opmask register, MAX_KL, is sufficient to handle up to 64 elements with one bit per \r\nelement, i.e. 64 bits. Masking is supported in most of the AVX-512 instructions. For a given vector length, each \r\ninstruction accesses only the number of least significant mask bits that are needed based on its data type. For \r\nexample, AVX-512 Foundation instructions operating on 64-bit data elements with a 512-bit vector length, only \r\nuse the 8 least significant bits of the opmask register.\r\nAn opmask register affects an AVX-512 instruction at per-element granularity. So, any numeric or non-numeric \r\noperation of each data element and per-element updates of intermediate results to the destination operand are \r\npredicated on the corresponding bit of the opmask register. \r\nAn opmask serving as a predicate operand in AVX-512 obeys the following properties:\r\n• The instruction’s operation is not performed for an element if the corresponding opmask bit is not set. This \r\nimplies that no exception or violation can be caused by an operation on a masked-off element. Consequently, \r\nno MXCSR exception flag is updated as a result of a masked-off operation.\r\n• A destination element is not updated with the result of the operation if the corresponding writemask bit is not \r\nset. Instead, the destination element value must be preserved (merging-masking) or it must be zeroed out \r\n(zeroing-masking). \r\n• For some instructions with a memory operand, memory faults are suppressed for elements with a mask bit of \r\n0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b1ec68e4-23b4-44fe-a16d-3f183ab55852.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=56544817234facb6d46abd4ed04e8586eb6fd9f4b48de963ee5589ed4e027e3e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 667
      },
      {
        "segments": [
          {
            "segment_id": "b1ec68e4-23b4-44fe-a16d-3f183ab55852",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-5\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.5 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX \r\nENCODING\r\nEVEX-encoded AVX-512 instructions support an enhanced vector programming environment. The enhanced vector \r\nprogramming environment uses the combination of EVEX bit-field encodings and a set of eight opmask registers to \r\nprovide the following capabilities:\r\n• Conditional vector processing of EVEX-encoded instruction. Opmask registers k1 through k7 can be used to \r\nconditionally govern the per-data-element computational operation and the per-element updates to the \r\ndestination operand of an AVX-512 Foundation instruction. Each bit of the opmask register governs one vector \r\nelement operation (a vector element can be of 32 bits or 64 bits). \r\n• In addition to providing predication control on vector instructions via EVEX bit-field encoding, the opmask \r\nregisters can also be used similarly to general-purpose registers as source/destination operands using modR/M \r\nencoding for non-mask-related instructions. In this case, an opmask register k0 through k7 can be selected.\r\n• In 64-bit mode, 32 vector registers can be encoded using EVEX prefix.\r\n• Broadcast may be supported for some instructions on the operand that can be encoded as a memory vector. \r\nThe data elements of a memory vector may be conditionally fetched or written to, and the vector size is \r\ndependent on the data transformation function.\r\n• Flexible rounding control for register-to-register flavor of EVEX encoded 512-bit and scalar instructions. Four \r\nrounding modes are supported by direct encoding within the EVEX prefix overriding MXCSR settings.\r\n• Broadcast of one element to the rest of the destination vector register.\r\n• Compressed 8-bit displacement encoding scheme to increase the instruction encoding density for instructions \r\nthat normally require disp32 syntax.\r\n2.5.1 OPMASK Register to Predicate Vector Data Processing\r\nAVX-512 instructions using EVEX encodes a predicate operand to conditionally control per-element computational \r\noperation and updating of result to the destination operand. The predicate operand is known as the opmask \r\nregister. The opmask is a set of eight architectural registers of size MAX_KL (64-bit). Note that from this set of 8 \r\narchitectural registers, only k1 through k7 can be addressed as predicate operand. k0 can be used as a regular \r\nsource or destination but cannot be encoded as a predicate operand. Note also that a predicate operand can be \r\nused to enable memory fault-suppression for some instructions with a memory operand (source or destination). \r\nAs a predicate operand, the opmask registers contain one bit to govern the operation/update to each data element \r\nof a vector register. In general, opmask registers can support instructions with element sizes: single-precision \r\nfloating-point (float32), integer doubleword(int32), double-precision floating-point (float64), integer quadword \r\n(int64). The length of a opmask register, MAX_KL, is sufficient to handle up to 64 elements with one bit per \r\nelement, i.e. 64 bits. Masking is supported in most of the AVX-512 instructions. For a given vector length, each \r\ninstruction accesses only the number of least significant mask bits that are needed based on its data type. For \r\nexample, AVX-512 Foundation instructions operating on 64-bit data elements with a 512-bit vector length, only \r\nuse the 8 least significant bits of the opmask register.\r\nAn opmask register affects an AVX-512 instruction at per-element granularity. So, any numeric or non-numeric \r\noperation of each data element and per-element updates of intermediate results to the destination operand are \r\npredicated on the corresponding bit of the opmask register. \r\nAn opmask serving as a predicate operand in AVX-512 obeys the following properties:\r\n• The instruction’s operation is not performed for an element if the corresponding opmask bit is not set. This \r\nimplies that no exception or violation can be caused by an operation on a masked-off element. Consequently, \r\nno MXCSR exception flag is updated as a result of a masked-off operation.\r\n• A destination element is not updated with the result of the operation if the corresponding writemask bit is not \r\nset. Instead, the destination element value must be preserved (merging-masking) or it must be zeroed out \r\n(zeroing-masking). \r\n• For some instructions with a memory operand, memory faults are suppressed for elements with a mask bit of \r\n0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b1ec68e4-23b4-44fe-a16d-3f183ab55852.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=56544817234facb6d46abd4ed04e8586eb6fd9f4b48de963ee5589ed4e027e3e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 667
      },
      {
        "segments": [
          {
            "segment_id": "465d9702-2663-4df7-8643-ebb04448c38d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "2-6 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nNote that this feature provides a versatile construct to implement control-flow predication as the mask in effect \r\nprovides a merging behavior for AVX-512 vector register destinations. As an alternative the masking can be used \r\nfor zeroing instead of merging, so that the masked out elements are updated with 0 instead of preserving the old \r\nvalue. The zeroing behavior is provided to remove the implicit dependency on the old value when it is not needed.\r\nMost instructions with masking enabled accept both forms of masking. Instructions that must have EVEX.aaa bits \r\ndifferent than 0 (gather and scatter) and instructions that write to memory only accept merging-masking. \r\nIt’s important to note that the per-element destination update rule also applies when the destination operand is a \r\nmemory location. Vectors are written on a per element basis, based on the opmask register used as a predicate \r\noperand. \r\nThe value of an opmask register can be:\r\n• generated as a result of a vector instruction (e.g. CMP)\r\n• loaded from memory\r\n• loaded from GPR register\r\n• or modified by mask-to-mask operations\r\nOpmask registers can be used for purposes outside of predication. For example, they can be used to manipulate \r\nsparse sets of elements from a vector or used to set the EFLAGS based on the 0/0xFFFFFFFFFFFFFFFF/other status \r\nof the OR of two opmask registers.\r\n2.5.1.1 Opmask Register K0\r\nThe only exception to the opmask rules described above is that opmask k0 can not be used as a predicate operand. \r\nOpmask k0 cannot be encoded as a predicate operand for a vector operation; the encoding value that would select \r\nopmask k0 will instead selects an implicit opmask value of 0xFFFFFFFFFFFFFFFF, thereby effectively disabling \r\nmasking. Opmask register k0 can still be used for any instruction that takes opmask register(s) as operand(s) \r\n(either source or destination).\r\nNote that certain instructions implicitly use the opmask as an extra destination operand. In such cases, trying to \r\nuse the “no mask” feature will translate into a #UD fault being raised.\r\n2.5.1.2 Example of Opmask Usages\r\nThe example below illustrates predicated vector add operation and predicated updates of added results into the \r\ndestination operand. The initial state of vector registers zmm0, zmm1, and zmm2 and k3 are:\r\nMSB........................................LSB\r\nzmm0 =\r\n[ 0x00000003 0x00000002 0x00000001 0x00000000 ] (bytes 15 through 0)\r\n[ 0x00000007 0x00000006 0x00000005 0x00000004 ] (bytes 31 through 16)\r\n[ 0x0000000B 0x0000000A 0x00000009 0x00000008 ] (bytes 47 through 32)\r\n[ 0x0000000F 0x0000000E 0x0000000D 0x0000000C ] (bytes 63 through 48)\r\nzmm1 = \r\n[ 0x0000000F 0x0000000F 0x0000000F 0x0000000F ] (bytes 15 through 0)\r\n[ 0x0000000F 0x0000000F 0x0000000F 0x0000000F ] (bytes 31 through 16)\r\n[ 0x0000000F 0x0000000F 0x0000000F 0x0000000F ] (bytes 47 through 32)\r\n[ 0x0000000F 0x0000000F 0x0000000F 0x0000000F ] (bytes 63 through 48)\r\nzmm2 = \r\n[ 0xAAAAAAAA 0xAAAAAAAA 0xAAAAAAAA 0xAAAAAAAA ] (bytes 15 through 0)\r\n[ 0xBBBBBBBB 0xBBBBBBBB 0xBBBBBBBB 0xBBBBBBBB ] (bytes 31 through 16)\r\n[ 0xCCCCCCCC 0xCCCCCCCC 0xCCCCCCCC 0xCCCCCCCC ] (bytes 47 through 32)\r\n[ 0xDDDDDDDD 0xDDDDDDDD 0xDDDDDDDD 0xDDDDDDDD ] (bytes 63 through 48)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/465d9702-2663-4df7-8643-ebb04448c38d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6979767b06ef8e12b1059be908ef7d6eda51350b76b14d34abe3ab571f75efd9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 502
      },
      {
        "segments": [
          {
            "segment_id": "a7e73f89-467b-4c39-a0e7-5df787388ad5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-7\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nk3 = 0x8F03 (1000 1111 0000 0011)\r\nAn opmask register serving as a predicate operand is expressed as a curly-braces-enclosed decorator following the \r\nfirst operand in the Intel assembly syntax. Given this state, we will execute the following instruction:\r\nvpaddd zmm2 {k3}, zmm0, zmm1\r\nThe vpaddd instruction performs 32-bit integer additions on each data element conditionally based on the corre\u0002sponding bit value in the predicate operand k3. Since per-element operations are not operated if the corresponding \r\nbit of the predicate mask is not set, the intermediate result is:\r\n[ ********** ********** 0x00000010 0x0000000F ] (bytes 15 through 0)\r\n[ ********** ********** ********** ********** ] (bytes 31 through 16)\r\n[ 0x0000001A 0x00000019 0x00000018 0x00000017 ] (bytes 47 through 32)\r\n[ 0x0000001E ********** ********** ********** ] (bytes 63 through 48)\r\nwhere ”**********” indicates that no operation is performed.\r\nThis intermediate result is then written into the destination vector register, zmm2, using the opmask register k3 as \r\nthe writemask, producing the following final result:\r\nzmm2 =\r\n[ 0xAAAAAAAA 0xAAAAAAAA 0x00000010 0x0000000F ] (bytes 15 through 0)\r\n[ 0xBBBBBBBB 0xBBBBBBBB 0xBBBBBBBB 0xBBBBBBBB ] (bytes 31 through 16)\r\n[ 0x0000001A 0x00000019 0x00000018 0x00000017 ] (bytes 47 through 32)\r\n[ 0x0000001E 0xDDDDDDDD 0xDDDDDDDD 0xDDDDDDDD ] (bytes 63 through 48)\r\nNote that for a 64-bit instruction (say vaddpd), only the 8 LSB of mask k3 (0x03) would be used to identify the \r\npredicate operation on each one of the 8 elements of the source/destination vectors.\r\n2.5.2 OpMask Instructions \r\nAVX-512 Foundation instructions provide a collection of opmask instructions that allow programmers to set, copy, \r\nor operate on the contents of a given opmask register. There are three types of opmask instructions:\r\n• Mask read/write instructions: These instructions move data between a general-purpose integer register or \r\nmemory and an opmask mask register, or between two opmask registers. For example:\r\n• kmovw k1, ebx; move lower 16 bits of ebx to k1.\r\n• Flag instructions: This category, consisting of instructions that modify EFLAGS based on the content of \r\nopmask registers.\r\n• kortestw k1, k2; OR registers k1 and k2 and updated EFLAGS accordingly.\r\n• Mask logical instructions: These instructions perform standard bitwise logical operations between opmask \r\nregisters. \r\n• kandw k1, k2, k3; AND lowest 16 bits of registers k2 and k3, leaving the result in k1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a7e73f89-467b-4c39-a0e7-5df787388ad5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bd4aaf6389e41475a52947d5d41b6e4bbcf8f8b92d43c8a6aaab3acd41e481cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 385
      },
      {
        "segments": [
          {
            "segment_id": "1edeca95-2f3c-4e6f-8eac-d2df955a9793",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "2-8 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.5.3 Broadcast\r\nEVEX encoding provides a bit-field to encode data broadcast for some load-op instructions, i.e. instructions that \r\nload data from memory and perform some computational or data movement operation. A source element from \r\nmemory can be broadcasted (repeated) across all the elements of the effective source operand (up to 16 times for \r\n32-bit data element, up to 8 times for 64-bit data element). The is useful when we want to reuse the same scalar \r\noperand for all the operations in a vector instruction. Broadcast is only enabled on instructions with an element size \r\nof 32 bits or 64 bits. Byte and word instructions do not support embedded broadcast.\r\nThe functionality of data broadcast is expressed as a curly-braces-enclosed decorator following the last \r\nregister/memory operand in the Intel assembly syntax.\r\nFor instance:\r\nvmulps zmm1, zmm2, [rax] {1to16}\r\nThe {1to16} primitive loads one float32 (single precision) element from memory, replicates it 16 times to form a \r\nvector of 16 32-bit floating-point elements, multiplies the 16 float32 elements with the corresponding elements in \r\nthe first source operand vector, and put each of the 16 results into the destination operand. \r\nAVX-512 instructions with store semantics and pure load instructions do not support broadcast primitives. \r\nvmovaps [rax] {k3}, zmm19\r\nIn contrast, the k3 opmask register is used as the predicate operand in the above example. Only the store opera\u0002tion on data elements corresponding to the non-zero bits in k3 will be performed.\r\n2.5.4 STATIC ROUNDING MODE AND SUPPRESS ALL EXCEPTIONS\r\nIn previous SIMD instruction extensions, rounding control is generally specified in MXCSR, with a handful of \r\ninstructions providing per-instruction rounding override via encoding fields within the imm8 operand. AVX-512 \r\noffers a more flexible encoding attribute to override MXCSR-based rounding control for floating-pointing instruction \r\nwith rounding semantic. This rounding attribute embedded in the EVEX prefix is called Static (per instruction) \r\nRounding Mode or Rounding Mode override. This attribute allows programmers to statically apply a specific arith\u0002metic rounding mode irrespective of the value of RM bits in MXCSR. It is available only to register-to-register \r\nflavors of EVEX-encoded floating-point instructions with rounding semantic. The differences between these three \r\nrounding control interfaces are summarized in Table 2-4. \r\nTable 2-4. Characteristics of Three Rounding Control Interfaces\r\nRounding Interface Static Rounding \r\nOverride\r\nImm8 Embedded Rounding \r\nOverride MXCSR Rounding Control\r\nSemantic Requirement FP rounding FP rounding FP rounding\r\nPrefix Requirement EVEX.B = 1 NA NA\r\nRounding Control EVEX.L’L IMM8[1:0] or MXCSR.RC\r\n(depending on IMM8[2])\r\nMXCSR.RC\r\nSuppress All Exceptions (SAE) Implied no no\r\nSIMD FP Exception #XF All suppressed Can raise #I, #P (unless SPE is set) MXCSR masking controls\r\nMXCSR flag update No yes (except PE if SPE is set) Yes\r\nPrecedence Above MXCSR.RC Above EVEX.L’L Default\r\nScope 512-bit, reg-reg, \r\nScalar reg-reg\r\nROUNDPx, ROUNDSx, \r\nVCVTPS2PH, VRNDSCALExx\r\nAll SIMD operands, vector lengths",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1edeca95-2f3c-4e6f-8eac-d2df955a9793.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=913e691ef8ca99478f3b8a44b3eca48c4abd6d83f2e3589680ef45741dec789d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 469
      },
      {
        "segments": [
          {
            "segment_id": "c37417d0-6254-4c95-9113-d38c2f0627b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-9\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nThe static rounding-mode override in AVX-512 also implies the “suppress-all-exceptions” (SAE) attribute. The SAE \r\neffect is as if all the MXCSR mask bits are set, and none of the MXCSR flags will be updated. Using static rounding\u0002mode via EVEX without SAE is not supported.\r\nStatic Rounding Mode and SAE control can be enabled in the encoding of the instruction by setting the EVEX.b bit \r\nto 1 in a register-register vector instruction. In such a case, vector length is assumed to be MAX_VL (512-bit in \r\ncase of AVX-512 packed vector instructions) or 128-bit for scalar instructions. Table 2-5 summarizes the possible \r\nstatic rounding-mode assignments in AVX-512 instructions.\r\nNote that some instructions already allow to specify the rounding mode statically via immediate bits. In such case, \r\nthe immediate bits take precedence over the embedded rounding mode (in the same vein that they take prece\u0002dence over whatever MXCSR.RM says).\r\nAn example of use would be in the following instructions:\r\nvaddps zmm7 {k6}, zmm2, zmm4, {rd-sae}\r\nWhich would perform the single-precision floating-point addition of vectors zmm2 and zmm4 with round-towards\u0002minus-infinity, leaving the result in vector zmm7 using k6 as conditional writemask.\r\nNote that MXCSR.RM bits are ignored and unaffected by the outcome of this instruction.\r\nExamples of instructions instances where the static rounding-mode is not allowed would be:\r\n; rounding-mode already specified in the instruction immediate\r\nvrndscaleps zmm7 {k6}, zmm2, 0x00\r\n; instructions with memory operands\r\nvmulps zmm7 {k6}, zmm2,[rax], {rd-sae}\r\n2.5.5 Compressed Disp8*N Encoding\r\nEVEX encoding supports a new displacement representation that allows for a more compact encoding of memory \r\naddressing commonly used in unrolled code, where an 8-bit displacement can address a range exceeding the \r\ndynamic range of an 8-bit value. This compressed displacement encoding is referred to as disp8*N, where N is a \r\nconstant implied by the memory operation characteristic of each instruction. \r\nThe compressed displacement is based on the assumption that the effective displacement (of a memory operand \r\noccurring in a loop) is a multiple of the granularity of the memory access of each iteration. Since the Base register \r\nin memory addressing already provides byte-granular resolution, the lower bits of the traditional disp8 operand \r\nbecomes redundant, and can be implied from the memory operation characteristic. \r\nThe memory operation characteristics depend on the following:\r\n• The destination operand is updated as a full vector, a single element, or multi-element tuples.\r\n• The memory source operand (or vector source operand if the destination operand is memory) is fetched (or \r\ntreated) as a full vector, a single element, or multi-element tuples.\r\nTable 2-5. Static Rounding Mode\r\nFunction Description\r\n{rn-sae} Round to nearest (even) + SAE\r\n{rd-sae} Round down (toward -inf) + SAE\r\n{ru-sae} Round up (toward +inf) + SAE\r\n{rz-sae} Round toward zero (Truncate) + SAE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/c37417d0-6254-4c95-9113-d38c2f0627b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ae03dda834a0d5a17e42d94459c851c711a0b84e8f083200d63ad06a73a07f8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 462
      },
      {
        "segments": [
          {
            "segment_id": "1dd63cb3-d3e4-426c-aee7-f882c7920247",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "2-10 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nFor example,\r\nvaddps zmm7, zmm2, disp8[membase + index*8]\r\nThe destination zmm7 is updated as a full 512-bit vector, and 64-bytes of data are fetched from memory as a full \r\nvector; the next unrolled iteration may fetch from memory in 64-byte granularity per iteration. There are 6 bits of \r\nlowest address that can be compressed, hence N = 2^6 = 64. The contribution of “disp8” to effective address \r\ncalculation is 64*disp8.\r\nvbroadcastf32x4 zmm7, disp8[membase + index*8]\r\nIn VBROADCASTF32x4, memory is fetched as a 4tuple of 4 32-bit entities. Hence the common lowest address bits \r\nthat can be compressed is 4, corresponding to the 4tuple width of 2^4 = 16 bytes (4x32 bits). Therefore, N = 2^4.\r\nFor EVEX encoded instructions that update only one element in the destination, or source element is fetched indi\u0002vidually, the number of lowest address bits that can be compressed is generally the width in bytes of the data \r\nelement, hence N = 2^(width).\r\n2.6 MEMORY ALIGNMENT \r\nMemory alignment requirements on EVEX-encoded SIMD instructions are similar to VEX-encoded SIMD instruc\u0002tions. Memory alignment applies to EVEX-encoded SIMD instructions in three categories:\r\n• Explicitly-aligned SIMD load and store instructions accessing 64 bytes of memory with EVEX prefix encoded \r\nvector length of 512 bits (e.g., VMOVAPD, VMOVAPS, VMOVDQA, etc.). These instructions always require \r\nmemory address to be aligned on 64-byte boundary.\r\n• Explicitly-unaligned SIMD load and store instructions accessing 64 bytes or less of data from memory (e.g. \r\nVMOVUPD, VMOVUPS, VMOVDQU, VMOVQ, VMOVD, etc.). These instructions do not require memory address \r\nto be aligned on natural vector-length byte boundary.\r\n• Most arithmetic and data processing instructions encoded using EVEX support memory access semantics. \r\nWhen these instructions access from memory, there are no alignment restrictions.\r\nSoftware may see performance penalties when unaligned accesses cross cacheline boundaries or vector-length \r\nnaturally-aligned boundaries, so reasonable attempts to align commonly used data sets should continue to be \r\npursued.\r\nAtomic memory operation in Intel 64 and IA-32 architecture is guaranteed only for a subset of memory operand \r\nsizes and alignment scenarios. The guaranteed atomic operations are described in Section 7.1.1 of IA-32 Intel®\r\nArchitecture Software Developer’s Manual, Volumes 3A. AVX and FMA instructions do not introduce any new guar\u0002anteed atomic memory operations.\r\nAVX-512 instructions may generate an #AC(0) fault on misaligned 4 or 8-byte memory references in Ring-3 when \r\nCR0.AM=1. 16, 32 and 64-byte memory references will not generate #AC(0) fault. See Table 2-7 for details.\r\nCertain AVX-512 Foundation instructions always require 64-byte alignment (see the complete list of VEX and EVEX \r\nencoded instructions in Table 2-6). These instructions will #GP(0) if not aligned to 64-byte boundaries.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1dd63cb3-d3e4-426c-aee7-f882c7920247.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=afb991fa0cefc4c91e579c3b2e5af672addb4bfde989ba02cd69d63eb7fd6b1f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 440
      },
      {
        "segments": [
          {
            "segment_id": "6654162f-0753-404e-aac8-1d30bb4a449b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-11\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.7 SIMD FLOATING-POINT EXCEPTIONS\r\nAVX-512 instructions can generate SIMD floating-point exceptions (#XM) if embedded “suppress all exceptions” \r\n(SAE) in EVEX is not set. When SAE is not set, these instructions will respond to exception masks of MXCSR in the \r\nsame way as VEX-encoded AVX instructions. When CR4.OSXMMEXCPT=0 any unmasked FP exceptions generate \r\nan Undefined Opcode exception (#UD).\r\n2.8 INSTRUCTION EXCEPTION SPECIFICATION\r\nException behavior of VEX-encoded Intel AVX and Intel AVX2 instructions are described in Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual, Volume 2A. Exception behavior of AVX-512 Foundation instructions \r\nand additional 512-bit extensions are described in Section 4.10, “Exception Classifications of EVEX-Encoded \r\ninstructions” and Section 4.11, “Exception Classifications of Opmask instructions”.\r\nTable 2-6. SIMD Instructions Requiring Explicitly Aligned Memory\r\nRequire 16-byte alignment Require 32-byte alignment Require 64-byte alignment*\r\n(V)MOVDQA xmm, m128 VMOVDQA ymm, m256 VMOVDQA zmm, m512\r\n(V)MOVDQA m128, xmm VMOVDQA m256, ymm VMOVDQA m512, zmm\r\n(V)MOVAPS xmm, m128 VMOVAPS ymm, m256 VMOVAPS zmm, m512\r\n(V)MOVAPS m128, xmm VMOVAPS m256, ymm VMOVAPS m512, zmm\r\n(V)MOVAPD xmm, m128 VMOVAPD ymm, m256 VMOVAPD zmm, m512\r\n(V)MOVAPD m128, xmm VMOVAPD m256, ymm VMOVAPD m512, zmm\r\n(V)MOVNTDQA xmm, m128 VMOVNTPS m256, ymm VMOVNTPS m512, zmm\r\n(V)MOVNTPS m128, xmm VMOVNTPD m256, ymm VMOVNTPD m512, zmm\r\n(V)MOVNTPD m128, xmm VMOVNTDQ m256, ymm VMOVNTDQ m512, zmm\r\n(V)MOVNTDQ m128, xmm VMOVNTDQA ymm, m256 VMOVNTDQA zmm, m512\r\nTable 2-7. Instructions Not Requiring Explicit Memory Alignment\r\n(V)MOVDQU xmm, m128 VMOVDQU ymm, m256 VMOVDQU zmm, m512\r\n(V)MOVDQU m128, m128 VMOVDQU m256, ymm VMOVDQU m512, zmm\r\n(V)MOVUPS xmm, m128 VMOVUPS ymm, m256 VMOVUPS zmm, m512\r\n(V)MOVUPS m128, xmm VMOVUPS m256, ymm VMOVUPS m512, zmm\r\n(V)MOVUPD xmm, m128 VMOVUPD ymm, m256 VMOVUPD zmm, m512\r\n(V)MOVUPD m128, xmm VMOVUPD m256, ymm VMOVUPD m512, zmm",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6654162f-0753-404e-aac8-1d30bb4a449b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=54a3459ccab9db680200feb763ed9c279d5fd98c635c6fd0c53063cb10d356fb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 290
      },
      {
        "segments": [
          {
            "segment_id": "69e29987-c1ef-4344-bb1a-7e64cd56a6f4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "2-12 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n2.9 CPUID INSTRUCTION \r\nCPUID—CPU Identification\r\nDescription\r\nThe ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can \r\nset and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction oper\u0002ates the same in non-64-bit modes and 64-bit mode.\r\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The \r\ninstruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). \r\nFor example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value \r\nand the Vendor Identification String in the appropriate registers:\r\nMOV EAX, 00H\r\nCPUID\r\nTable 2-8 shows information returned, depending on the initial value loaded into the EAX register. Table 2-9 shows \r\nthe maximum CPUID input value recognized for each family of IA-32 processors on which CPUID is implemented. \r\nTwo types of information are returned: basic and extended function information. If a value is entered for \r\nCPUID.EAX is invalid for a particular processor, the data for the highest basic information leaf is returned. For \r\nexample, using the Intel Core 2 Duo E6850 processor, the following is true:\r\nCPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *) \r\nCPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) \r\nCPUID.EAX = 0BH (* INVALID: Returns the same information as CPUID.EAX = 0AH. *) \r\nCPUID.EAX = 80000008H (* Returns virtual/physical address size data. *)\r\nCPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0AH. *)\r\nWhen CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence \r\non input ECX value in the basic leaf is honored.\r\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution \r\nguarantees that any modifications to flags, registers, and memory for previous instructions are completed before \r\nthe next instruction is fetched and executed.\r\nSee also:\r\n“Serializing Instructions” in Chapter 8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 3A\r\n\"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architectures Software Devel\u0002oper’s Manual, Volume 3A.\r\nOpcode Instruction 64-Bit Mode Compat/\r\nLeg Mode Description\r\n0F A2 CPUID Valid Valid Returns processor identification and feature information to the EAX, \r\nEBX, ECX, and EDX registers, as determined by input entered in EAX \r\n(in some cases, ECX as well).\r\n1. On Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/69e29987-c1ef-4344-bb1a-7e64cd56a6f4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7ed3d9038ab4129f34b0f7e13b0787dc94bf5248c422124870a340f061002843",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 428
      },
      {
        "segments": [
          {
            "segment_id": "3c256fa6-09ad-4e97-b450-e5f8b1f09086",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-13\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nTable 2-8. Information Returned by CPUID Instruction\r\nInitial EAX \r\nValue Information Provided about the Processor\r\nBasic CPUID Information\r\n0H EAX\r\nEBX\r\nECX\r\nEDX\r\nMaximum Input Value for Basic CPUID Information (see Table 2-9)\r\n“Genu”\r\n“ntel”\r\n“ineI”\r\n01H EAX\r\nEBX\r\nECX\r\nEDX\r\nVersion Information: Type, Family, Model, and Stepping ID (see Figure 2-4)\r\nBits 7-0: Brand Index\r\nBits 15-8: CLFLUSH line size (Value ∗ 8 = cache line size in bytes)\r\nBits 23-16: Maximum number of addressable IDs for logical processors in this physical package*. \r\nBits 31-24: Initial APIC ID\r\nFeature Information (see Figure 2-5 and Table 2-11)\r\nFeature Information (see Figure 2-6 and Table 2-12)\r\nNOTES: \r\n* The nearest power-of-2 integer that is not smaller than EBX[23:16] is the maximum number of \r\nunique initial APIC IDs reserved for addressing different logical processors in a physical package.\r\n02H EAX\r\nEBX\r\nECX\r\nEDX\r\nCache and TLB Information (see Table 2-13)\r\nCache and TLB Information\r\nCache and TLB Information\r\nCache and TLB Information\r\n03H EAX Reserved.\r\nEBX Reserved.\r\nECX Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nEDX Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nNOTES: \r\nProcessor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models,\r\nuse the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. \r\nCPUID leaves > 3 < 80000000 are visible only when IA32_MISC_ENABLES.BOOT_NT4[bit 22] = 0 (default).\r\nDeterministic Cache Parameters Leaf \r\n04H NOTES:\r\nLeaf 04H output depends on the initial value in ECX. \r\nSee also: “INPUT EAX = 4: Returns Deterministic Cache Parameters for each level on page 2-35.\r\nEAX Bits 4-0: Cache Type Field\r\n0 = Null - No more caches\r\n1 = Data Cache \r\n2 = Instruction Cache\r\n3 = Unified Cache\r\n4-31 = Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3c256fa6-09ad-4e97-b450-e5f8b1f09086.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a6671ca89837e06cd7d15ae2a04b6534392ef6e73ba5279ddfc26b773e02747f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 329
      },
      {
        "segments": [
          {
            "segment_id": "c4c990e6-7332-42c4-904a-323b08faba4f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "2-14 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nBits 7-5: Cache Level (starts at 1) \r\nBits 8: Self Initializing cache level (does not need SW initialization)\r\nBits 9: Fully Associative cache\r\nBits 13-10: Reserved\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this cache*, ** \r\nBits 31-26: Maximum number of addressable IDs for processor cores in the physical \r\npackage*, ***, ****\r\nEBX Bits 11-00: L = System Coherency Line Size*\r\nBits 21-12: P = Physical Line partitions*\r\nBits 31-22: W = Ways of associativity*\r\nECX Bits 31-00: S = Number of Sets*\r\nEDX Bit 0: WBINVD/INVD behavior on lower level caches\r\nBit 10: Write-Back Invalidate/Invalidate\r\n0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads \r\nsharing this cache\r\n1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads \r\nsharing this cache.\r\nBit 1: Cache Inclusiveness\r\n0 = Cache is not inclusive of lower cache levels.\r\n1 = Cache is inclusive of lower cache levels.\r\nBit 2: Complex cache indexing\r\n0 = Direct mapped cache\r\n1 = A complex function is used to index the cache, potentially using\r\nall address bits.\r\nBits 31-03: Reserved = 0\r\nNOTES:\r\n* Add one to the return value to get the result. \r\n** The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique\r\ninitial APIC IDs reserved for addressing different logical processors sharing this cache\r\n*** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of\r\nunique Core_IDs reserved for addressing different processor cores in a physical package. Core ID is\r\na subset of bits of the initial APIC ID. \r\n****The returned value is constant for valid initial values in ECX. Valid ECX values start from 0. \r\nMONITOR/MWAIT Leaf \r\n05H EAX Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nEBX Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nECX Bits 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported\r\nBits 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled\r\nBits 31 - 02: Reserved \r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/c4c990e6-7332-42c4-904a-323b08faba4f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b92b8ee28df9f568528069d053c361819601c8c9324fa8dabac0d20f868ac1a8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 384
      },
      {
        "segments": [
          {
            "segment_id": "ab7b6585-9923-4309-bf6b-cc4182412b72",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-15\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nEDX Bits 03 - 00: Number of C0* sub C-states supported using MWait\r\nBits 07 - 04: Number of C1* sub C-states supported using MWAIT\r\nBits 11 - 08: Number of C2* sub C-states supported using MWAIT\r\nBits 15 - 12: Number of C3* sub C-states supported using MWAIT\r\nBits 19 - 16: Number of C4* sub C-states supported using MWAIT\r\nBits 23 - 20: Number of C5* sub C-states supported using MWAIT\r\nBits 27 - 24: Number of C6* sub C-states supported using MWAIT\r\nBits 31 - 28: Number of C7* sub C-states supported using MWAIT\r\nNOTE:\r\n* The definition of C0 through C7 states for MWAIT extension are processor-specific C-states, not\r\nACPI C-states.\r\nThermal and Power Management Leaf \r\n06H EAX\r\nEBX\r\nBit 00: Digital temperature sensor is supported if set\r\nBit 01: Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLE[38]).\r\nBit 02: ARAT. APIC-Timer-always-running feature is supported if set.\r\nBit 03: Reserved \r\nBit 04: PLN. Power limit notification controls are supported if set.\r\nBit 05: ECMD. Clock modulation duty cycle extension is supported if set.\r\nBit 06: PTM. Package thermal management is supported if set.\r\nBit 07: HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, \r\nIA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.\r\nBit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.\r\nBit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.\r\nBit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.\r\nBit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.\r\nBit 12: Reserved.\r\nBit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs \r\nare supported if set.\r\nBits 31 - 15: Reserved \r\nBits 03 - 00: Number of Interrupt Thresholds in Digital Thermal Sensor\r\nBits 31 - 04: Reserved \r\nECX Bit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The \r\ncapability to provide a measure of delivered processor performance (since last reset of the coun\u0002ters), as a percentage of the expected processor performance when running at the TSC frequency.\r\nBits 02 - 01: Reserved = 0\r\nBit 03: The processor supports performance-energy bias preference if\r\nCPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a\r\nnew architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)\r\nBits 31 - 04: Reserved = 0\r\nEDX Reserved = 0\r\nStructured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)\r\n07H NOTES:\r\nLeaf 07H main leaf (ECX = 0). \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. \r\nEAX Bits 31-00: Reports the maximum number sub-leaves that are supported in leaf 07H.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ab7b6585-9923-4309-bf6b-cc4182412b72.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b68fd318fcc7f63a83278005ed3b7966d19a7a38154e5890fe46d53be72af23",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 434
      },
      {
        "segments": [
          {
            "segment_id": "1c3bc9ab-4e7d-4899-9fc1-cce28756e42f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "2-16 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nEBX Bit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.\r\nBit 01: IA32_TSC_ADJUST MSR is supported if 1.\r\nBit 02: SGX\r\nBit 03: BMI1\r\nBit 04: HLE\r\nBit 05: AVX2\r\nBit 07: SMEP. Supports Supervisor Mode Execution Protection if 1.\r\nBit 06: Reserved\r\nBit 08: BMI2\r\nBit 09: ERMS\r\nBit 10: INVPCID\r\nBit 11: RTM\r\nBit 12: Supports Platform Quality of Service Monitoring (PQM) capability if 1.\r\nBit 13: Deprecates FPU CS and FPU DS values if 1.\r\nBit 14: Intel Memory Protection Extensions\r\nBit 15: Supports Platform Quality of Service Enforcement (PQE) capability if 1.\r\nBit 16: AVX512F\r\nBit 17: AVX512DQ\r\nBit 18: RDSEED\r\nBit 19: ADX\r\nBit 20: SMAP\r\nBit 21: AVX512IFMA\r\nBit 22: Reserved\r\nBit 23: CLFLUSHOPT\r\nBit 24: CLWB\r\nBit 25: Intel Processor Trace\r\nBit 26: AVX512PF\r\nBit 27: AVX512ER\r\nBit 28: AVX512CD\r\nBit 29: SHA\r\nBit 30: AVX512BW\r\nBit 31: AVX512VL\r\nECX Bit 00: PREFETCHWT1\r\nBit 01: AVX512VBMI\r\nBit 02: UMIP. Supports user-mode instruction prevention if 1.\r\nBit 03: PKU. Supports protection keys for user-mode pages if 1.\r\nBit 04: OSPKE. If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instruc\u0002tions).\r\nBits 13 - 05: Reserved\r\nBit 14: AVX512_VPOPCNTDQ\r\nBits 16 - 15: Reserved\r\nBits 21 - 17: The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.\r\nBit 22: RDPID. Supports Read Processor ID if 1.\r\nBits 29 - 23: Reserved.\r\nBit 30: SGX_LC. Supports SGX Launch Configuration if 1.\r\nBit 31: Reserved. \r\nEDX Bits 01 - 00: Reserved\r\nBit 02: AVX512_4VNNIW (Vector instructions for deep learning enhanced word variable precision.)\r\nBit 03: AVX512_4FMAPS (Vector instructions for deep learning floating-point single precision.)\r\nBits 31-04: Reserved\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1c3bc9ab-4e7d-4899-9fc1-cce28756e42f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=caca5ca0458bb50a19b09236e72a14045abdb8c29d08ac64b0cc8d23a744c3dc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 301
      },
      {
        "segments": [
          {
            "segment_id": "5274b07a-e598-47b5-be4c-16c1bde4af31",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-17\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nStructured Extended Feature Enumeration Sub-leaves (EAX = 07H, ECX = n, n ≥ 1)\r\n07H NOTES:\r\nLeaf 07H output depends on the initial value in ECX. \r\nIf ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.\r\nEAX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEBX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nECX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nDirect Cache Access Information Leaf \r\n09H EAX\r\nEBX\r\nECX\r\nEDX\r\nValue of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)\r\nReserved \r\nReserved \r\nReserved \r\nArchitectural Performance Monitoring Leaf \r\n0AH EAX Bits 07 - 00: Version ID of architectural performance monitoring\r\nBits 15- 08: Number of general-purpose performance monitoring counter per logical processor\r\nBits 23 - 16: Bit width of general-purpose, performance monitoring counter \r\nBits 31 - 24: Length of EBX bit vector to enumerate architectural performance monitoring events\r\nEBX Bit 00: Core cycle event not available if 1\r\nBit 01: Instruction retired event not available if 1\r\nBit 02: Reference cycles event not available if 1\r\nBit 03: Last-level cache reference event not available if 1\r\nBit 04: Last-level cache misses event not available if 1\r\nBit 05: Branch instruction retired event not available if 1\r\nBit 06: Branch mispredict retired event not available if 1\r\nBits 31- 07: Reserved = 0\r\nECX\r\nEDX\r\nReserved = 0\r\nBits 04 - 00: Number of fixed-function performance counters (if Version ID > 1)\r\nBits 12- 05: Bit width of fixed-function performance counters (if Version ID > 1)\r\nReserved = 0\r\nExtended Topology Enumeration Leaf \r\n0BH NOTES:\r\nMost of Leaf 0BH output depends on the initial value in ECX. \r\nThe EDX output of leaf 0BH is always valid and does not vary with input value in ECX.\r\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\r\nFor sub-leaves that returns an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\r\nIf an input value N in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with\r\nECX > N also return 0 in ECX[15:8]\r\nEAX Bits 04-00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level \r\ntype*. All logical processors with the same next level ID share current level.\r\nBits 31-5: Reserved.\r\nEBX Bits 15 - 00: Number of logical processors at this level type. The number reflects configuration as \r\nshipped by Intel**.\r\nBits 31- 16: Reserved.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/5274b07a-e598-47b5-be4c-16c1bde4af31.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=44d438151e47103339bc0a2d2ae67c105d4ce0ee918b5c36fd0f65f55e9b4c93",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 464
      },
      {
        "segments": [
          {
            "segment_id": "0792e302-9241-4609-bab1-25ff739543ff",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "2-18 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nECX Bits 07 - 00: Level number. Same value in ECX input.\r\nBits 15 - 08: Level type***.\r\nBits 31 - 16: Reserved.\r\nEDX Bits 31- 00: x2APIC ID the current logical processor.\r\nNOTES:\r\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\r\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in \r\nthis field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical \r\nprocessors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depend\u0002ing on software and platform hardware configurations.\r\n*** The value of the “level type” field is not related to level numbers in any way, higher “level type” \r\nvalues do not mean higher levels. Level type field has the following encoding:\r\n0: invalid\r\n1: SMT\r\n2: Core\r\n3-255: Reserved\r\nProcessor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)\r\n0DH NOTES:\r\nLeaf 0DH main leaf (ECX = 0). \r\nEAX Bits 31-00: Reports the valid bit fields of the lower 32 bits of the XFEATURE_ENABLED_MASK regis\u0002ter. If a bit is 0, the corresponding bit field in XCR0 is reserved.\r\nBit 00: legacy x87 \r\nBit 01: 128-bit SSE\r\nBit 02: 256-bit AVX\r\nBits 04 - 03: MPX state\r\nBit 07 - 05: AVX-512 state\r\nBit 08: Used for IA32_XSS\r\nBit 09: PKRU state\r\nBits 31-10: Reserved\r\nEBX Bits 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by \r\nenabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save \r\narea are not enabled.\r\nECX Bit 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the \r\nXSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit \r\nfields in XCR0. \r\nEDX Bit 31-0: Reports the valid bit fields of the upper 32 bits of the XCR0 register. If a bit is 0, the corre\u0002sponding bit field in XCR0 is reserved \r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/0792e302-9241-4609-bab1-25ff739543ff.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4d08a87c91288138a7ae9f342f7f305a5858c1929534ecb0ad97bec23ae57028",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 353
      },
      {
        "segments": [
          {
            "segment_id": "d95a716b-507c-4b67-9a49-bb680e82344a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-19\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX\r\nEBX\r\nECX\r\nEDX\r\nBit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nBits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nBits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 31-10: Reserved\r\nBits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-0: The size in bytes (from the offset specified in EBX) of the save area for an extended state \r\nfeature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-0: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31:02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nPlatform QoS Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\r\nEAX Reserved.\r\nEBX Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.\r\nECX Reserved.\r\nEDX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Monitoring if 1.\r\nBits 31 - 02: Reserved\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/d95a716b-507c-4b67-9a49-bb680e82344a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fdbd8c92ae6cc2b64235dce38f908bf17ba755d76bd70a17513d8ff8766c17e2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 533
      },
      {
        "segments": [
          {
            "segment_id": "d95a716b-507c-4b67-9a49-bb680e82344a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-19\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX\r\nEBX\r\nECX\r\nEDX\r\nBit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nBits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nBits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 31-10: Reserved\r\nBits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-0: The size in bytes (from the offset specified in EBX) of the save area for an extended state \r\nfeature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-0: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31:02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nPlatform QoS Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\r\nEAX Reserved.\r\nEBX Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.\r\nECX Reserved.\r\nEDX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Monitoring if 1.\r\nBits 31 - 02: Reserved\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/d95a716b-507c-4b67-9a49-bb680e82344a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fdbd8c92ae6cc2b64235dce38f908bf17ba755d76bd70a17513d8ff8766c17e2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 533
      },
      {
        "segments": [
          {
            "segment_id": "5e54d6e4-9f55-4713-9081-0e8d52dcd07b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "2-20 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nL3 Cache QoS Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nEAX Reserved.\r\nEBX Bits 31-0: Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).\r\nECX Maximum range (zero-based) of RMID of this resource type.\r\nEDX Bit 00: Supports L3 occupancy monitoring if 1.\r\nBits 31:01: Reserved\r\nPlatform QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = 0)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource identification (ResID) starting at bit position 1 of EBX.\r\nEAX Reserved.\r\nEBX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Enforcement if 1.\r\nBits 31 - 02: Reserved.\r\nECX Reserved.\r\nEDX Reserved.\r\nL3 Cache QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = ResID =1)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nEAX Bits 4:0: Length of the capacity bit mask for the corresponding ResID.\r\nBits 31:05: Reserved\r\nEBX Bits 31-0: Bit-granular map of isolation/contention of allocation units.\r\nECX Bit 00: Reserved.\r\nBit 01: Updates of COS should be infrequent if 1.\r\nBit 02: Code and Data Prioritization Technology supported if 1.\r\nBits 31:03: Reserved\r\nEDX Bits 15:0: Highest COS number supported for this ResID.\r\nBits 31:16: Reserved\r\nIntel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)\r\n14H NOTES:\r\nLeaf 14H main leaf (ECX = 0). \r\nEAX Bits 31-0: Reports the maximum sub-leaf supported in leaf 14H.\r\nEBX Bit 00: If 1, Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that \r\nIA32_RTIT_CR3_MATCH MSR can be accessed.\r\nBits 01: If 1, Indicates support of Configurable PSB and Cycle-Accurate Mode.\r\nBits 02: If 1, Indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs \r\nacross warm reset.\r\nBits 03: If 1, Indicates support of MTC timing packet and suppression of COFI-based packets.\r\nBits 31: 04: Reserved \r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/5e54d6e4-9f55-4713-9081-0e8d52dcd07b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c7caeb7daf16bc3508751cce85bb67a528ffbaebf837d984cdd8923bc908399",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 342
      },
      {
        "segments": [
          {
            "segment_id": "2c65f475-4460-4799-a4c0-63d8fa50fc5e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-21\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nECX Bit 00: If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output \r\nscheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.\r\nBit 01: If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the \r\nMaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS.\r\nBits 02: If 1, Indicates support of Single-Range Output scheme.\r\nBits 03: If 1, Indicates support of output to Trace Transport subsystem.\r\nBit 30:04: Reserved\r\nBit 31: If 1, Generated packets which contain IP payloads have LIP values, which include the CS base \r\ncomponent.\r\nEDX Bits 31- 00: Reserved \r\nIntel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)\r\n14H EAX Bits 2:0: Number of configurable Address Ranges for filtering.\r\nBits 15-03: Reserved\r\nBit 31:16: Bitmap of supported MTC period encodings\r\nEBX Bits 15-0: Bitmap of supported Cycle Threshold value encodings\r\nBit 31:16: Bitmap of supported Configurable PSB frequency encodings\r\nECX Bits 31-00: Reserved\r\nEDX Bits 31- 00: Reserved\r\nTime Stamp Counter and Core Crystal Clock Information Leaf \r\n15H NOTES:\r\nIf EBX[31:0] is 0, the TSC and ”core crystal clock” ratio is not enumerated.\r\nEBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock fre\u0002quency.\r\nIf ECX is 0, the core crystal clock frequency is not enumerated.\r\n“TSC frequency” = “core crystal clock frequency” * EBX/EAX.\r\nThe core crystal clock may differ from the reference clock, bus clock, or core clock frequencies.\r\nEAX Bits 31:0: An unsigned integer which is the denominator of the TSC/”core crystal clock” ratio.\r\nEBX Bits 31-0: An unsigned integer which is the numerator of the TSC/”core crystal clock” ratio.\r\nECX Bits 31:0: An unsigned integer which is the nominal frequency of the core crystal clock in Hz.\r\nEDX Bits 31:0: Reserved = 0.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/2c65f475-4460-4799-a4c0-63d8fa50fc5e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0b45a89c253faa8ac911eb1bd94d30407d4ed6af8e2827712128bc93055ef9be",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 316
      },
      {
        "segments": [
          {
            "segment_id": "de4860f1-7c58-42b3-8a2c-d645d41d33f7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "2-22 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nProcessor Frequency Information Leaf \r\n16H EAX\r\nEBX\r\nECX\r\nEDX\r\nBits 15:0: Processor Base Frequency (in MHz).\r\nBits 31:16: Reserved =0\r\nBits 15:0: Maximum Frequency (in MHz).\r\nBits 31:16: Reserved = 0\r\nBits 15:0: Bus (Reference) Frequency (in MHz).\r\nBits 31:16: Reserved = 0\r\nReserved \r\nNOTES:\r\n* Data is returned from this interface in accordance with the processor's specification and does not \r\nreflect actual values. Suitable use of this data includes the display of processor information in like \r\nmanner to the processor brand string and for determining the appropriate range to use when \r\ndisplaying processor information e.g. frequency history graphs. The returned information should not \r\nbe used for any other purpose as the returned information does not accurately correlate to \r\ninformation / counters returned by other processor interfaces. \r\nWhile a processor may support the Processor Frequency Information leaf, fields that return a value \r\nof zero are not supported.\r\nSystem-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)\r\n17H NOTES:\r\nLeaf 17H main leaf (ECX = 0).\r\nLeaf 17H output depends on the initial value in ECX.\r\nLeaf 17H sub-leaves 1 through 3 reports SOC Vendor Brand String.\r\nLeaf 17H is valid if MaxSOCID_Index >= 3.\r\nLeaf 17H sub-leaves 4 and above are reserved.\r\nEAX Bits 31 - 00: MaxSOCID_Index. Reports the maximum input value of supported sub-leaf in leaf 17H.\r\nEBX Bits 15 - 00: SOC Vendor ID.\r\nBit 16: IsVendorScheme. If 1, the SOC Vendor ID field is assigned via an industry standard \r\nenumeration\r\nscheme. Otherwise, the SOC Vendor ID field is assigned by Intel.\r\nBits 31 - 17: Reserved = 0.\r\nECX Bits 31 - 00: Project ID. A unique number an SOC vendor assigns to its SOC projects.\r\nEDX Bits 31 - 00: Stepping ID. A unique number within an SOC project that an SOC vendor assigns.\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)\r\n17H EAX Bit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEBX Bit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\r\nECX Bit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEDX Bit 31 - 00: SOC Vendor Brand String. UTF-8 encoded string.\r\nNOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nSOC Vendor Brand String is a UTF-8 encoded string padded with trailing bytes of 00H.\r\nThe complete SOC Vendor Brand String is constructed by concatenating in ascending order of\r\nEAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/de4860f1-7c58-42b3-8a2c-d645d41d33f7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0300a76f0e00dad2b9d6d4b9ccaea2ddcd333c97425b95de3327dd54567722d5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 436
      },
      {
        "segments": [
          {
            "segment_id": "199a3a58-3ab8-4c04-a9bb-51f714d62403",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-23\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)\r\n17H NOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nEAX Bits 31 - 00: Reserved = 0.\r\nEBX Bits 31 - 00: Reserved = 0.\r\nECX Bits 31 - 00: Reserved = 0.\r\nEDX Bits 31 - 00: Reserved = 0.\r\nDeterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)\r\n18H NOTES:\r\nEach sub-leaf enumerates a different address translations structure. Valid sub-leaves do not need \r\nto be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than \r\nan invalid sub-leaf or than a valid sub-leaf of a higher or lower-level structure. \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31 - 00: Reports the maximum input value of supported sub-leaf in leaf 18H.\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07 - 04: Reserved.\r\nBits 10 - 08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15 - 11: Reserved.\r\nBits 31 - 16: W = Ways of associativity.\r\nECX Bits 31 - 00: S = Number of Sets.\r\nEDX Bits 04 - 00: Translation cache type field.\r\n00000b: Null (indicates this sub-leaf is not valid).\r\n00001b: Data TLB.\r\n00010b: Instruction TLB.\r\n00011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07 - 05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13 - 09: Reserved.\r\nBits 25- 14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31 - 26: Reserved.\r\nDeterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX ≥ 1)\r\n18H NOTES:\r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31 - 00: Reserved.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/199a3a58-3ab8-4c04-a9bb-51f714d62403.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=488bb95a30dd9158a50b25657d70928926b91763856feb7c45b54bcb89791e7b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 406
      },
      {
        "segments": [
          {
            "segment_id": "b5fc7dc8-d77b-4a66-b450-4630a1e65c7d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "2-24 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07 - 04: Reserved.\r\nBits 10 - 08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15 - 11: Reserved.\r\nBits 31 - 16: W = Ways of associativity.\r\nECX Bits 31 - 00: S = Number of Sets.\r\nEDX Bits 04 - 00: Translation cache type field.\r\n0000b: Null (indicates this sub-leaf is not valid).\r\n0001b: Data TLB.\r\n0010b: Instruction TLB.\r\n0011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07 - 05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13 - 09: Reserved.\r\nBits 25- 14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31 - 26: Reserved.\r\nUnimplemented CPUID Leaf Functions\r\n40000000H \r\n-\r\n4FFFFFFFH\r\nInvalid. No existing or future CPU will return processor identification or feature information if the \r\ninitial EAX value is in the range 40000000H to 4FFFFFFFH.\r\nExtended Function CPUID Information\r\n80000000H EAX Maximum Input Value for Extended Function CPUID Information (see \r\nTable 2-9).\r\nEBX\r\nECX\r\nEDX\r\nReserved\r\nReserved\r\nReserved\r\n80000001H EAX\r\nEBX\r\nECX\r\nExtended Processor Signature and Feature Bits.\r\nReserved\r\nBit 0: LAHF/SAHF available in 64-bit mode\r\nBits 4-1: Reserved\r\nBit 5: LZCNT available\r\nBits 7-6 Reserved\r\nBit 8: PREFETCHW\r\nBits 31-9: Reserved\r\nEDX Bits 10-0: Reserved\r\nBit 11: SYSCALL/SYSRET available (when in 64-bit mode)\r\nBits 19-12: Reserved = 0\r\nBit 20: Execute Disable Bit available\r\nBits 25-21: Reserved = 0\r\nBit 26: 1-GByte pages are available if 1\r\nBit 27: RDTSCP and IA32_TSC_AUX are available if 1\r\nBits 28: Reserved = 0\r\nBit 29: Intel® 64 Architecture available if 1\r\nBits 31-30: Reserved = 0\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b5fc7dc8-d77b-4a66-b450-4630a1e65c7d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0592455b0bdfeb0c68da68d46f2259123332887150309d18e2afc3f467b6cb51",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 333
      },
      {
        "segments": [
          {
            "segment_id": "868a055c-664b-4c0f-8f7b-e3494abc9287",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-25\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n80000002H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000003H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000004H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000005H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\n80000006H EAX\r\nEBX\r\nReserved = 0\r\nReserved = 0\r\nECX\r\nEDX\r\nBits 7-0: Cache Line size in bytes\r\nBits 11-08: Reserved\r\nBits 15-12: L2 Associativity field *\r\nBits 31-16: Cache size in 1K units\r\nReserved = 0\r\nNOTES:\r\n* L2 associativity field encodings:\r\n00H - Disabled\r\n01H - Direct mapped\r\n02H - 2-way\r\n04H - 4-way\r\n06H - 8-way\r\n08H - 16-way\r\n0FH - Fully associative\r\n80000007H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nBits 07-00: Reserved = 0\r\nBit 08: Invariant TSC available if 1\r\nBits 31-09: Reserved = 0\r\n80000008H EAX Virtual/Physical Address size \r\nBits 7-0: #Physical Address Bits*\r\nBits 15-8: #Virtual Address Bits\r\nBits 31-16: Reserved = 0\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nNOTES:\r\n* If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported\r\nshould come from this field.\r\nTable 2-8. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/868a055c-664b-4c0f-8f7b-e3494abc9287.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=79e847d33c125a20abb8dfb8bde7a9e2e15ce9585a2067cedb7f6237132dcc91",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 249
      },
      {
        "segments": [
          {
            "segment_id": "cdb26884-0f68-46bb-94ad-10434d59a6c9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "2-26 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 0H: Returns CPUID’s Highest Value for Basic Processor Information and the Vendor Identification \r\nString\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the CPUID recognizes for \r\nreturning basic processor information. The value is returned in the EAX register (see Table 2-9) and is processor \r\nspecific.\r\nA vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is “Genuin\u0002eIntel” and is expressed:\r\nEBX ← 756e6547h (* \"Genu\", with G in the low 4 bits of BL *)\r\nEDX ← 49656e69h (* \"ineI\", with i in the low 4 bits of DL *)\r\nECX ← 6c65746eh (* \"ntel\", with n in the low 4 bits of CL *)\r\nINPUT EAX = 80000000H: Returns CPUID’s Highest Value for Extended Processor Information\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the processor recognizes for \r\nreturning extended processor information. The value is returned in the EAX register (see Table 2-9) and is \r\nprocessor specific.\r\nIA32_BIOS_SIGN_ID Returns Microcode Update Signature\r\nFor processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update \r\nsignature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 10 in \r\nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. \r\nTable 2-9. Highest CPUID Source Operand for Intel 64 and IA-32 Processors \r\nIntel 64 or IA-32 Processors Highest Value in EAX\r\nBasic Information Extended Function Information\r\nEarlier Intel486 Processors CPUID Not Implemented CPUID Not Implemented\r\nLater Intel486 Processors and Pentium \r\nProcessors\r\n01H Not Implemented\r\nPentium Pro and Pentium II Processors, \r\nIntel®\r\n Celeron® Processors\r\n02H Not Implemented\r\nPentium III Processors 03H Not Implemented\r\nPentium 4 Processors 02H 80000004H\r\nIntel Xeon Processors 02H 80000004H\r\nPentium M Processor 02H 80000004H\r\nPentium 4 Processor supporting Hyper\u0002Threading Technology05H 80000008H\r\nPentium D Processor (8xx) 05H 80000008H\r\nPentium D Processor (9xx) 06H 80000008H\r\nIntel Core Duo Processor 0AH 80000008H\r\nIntel Core 2 Duo Processor 0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5300 \r\nSeries\r\n0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5200, \r\n5300, 5400 Series\r\n0AH 80000008H\r\nIntel Core 2 Duo Processor 8000 Series 0DH 80000008H\r\nIntel Xeon Processor 5200, 5400 Series 0AH 80000008H",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/cdb26884-0f68-46bb-94ad-10434d59a6c9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4ce38a760640da25734341a6cc5abce6d8acb438099da8d8b0791626ea84adee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 375
      },
      {
        "segments": [
          {
            "segment_id": "6dbe26aa-3eba-4f1b-a67d-1280044fede8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-27\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 01H: Returns Model, Family, Stepping Information\r\nWhen CPUID executes with EAX set to 01H, version information is returned in EAX (see Figure 2-4). For example: \r\nmodel, family, and processor type for the Intel Xeon processor 5100 series is as follows:\r\n• Model — 1111B\r\n• Family — 0101B\r\n• Processor Type — 00B\r\nSee Table 2-10 for available processor type values. Stepping IDs are provided as needed.\r\nNOTE\r\nSee \"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A, and Chapter 16 in the Intel® 64 and IA-32 Archi\u0002tectures Software Developer’s Manual, Volume 1, for information on identifying earlier IA-32 \r\nprocessors.\r\nThe Extended Family ID needs to be examined only when the Family ID is 0FH. Integrate the fields into a display \r\nusing the following rule:\r\nIF Family_ID ≠ 0FH\r\nTHEN Displayed_Family = Family_ID;\r\nELSE Displayed_Family = Extended_Family_ID + Family_ID;\r\n(* Right justify and zero-extend 4-bit field. *)\r\nFI;\r\n(* Show Display_Family as HEX field. *)\r\nFigure 2-4. Version Information Returned by CPUID in EAX\r\nTable 2-10. Processor Type Field\r\nType Encoding\r\nOriginal OEM Processor 00B\r\nIntel OverDrive® Processor 01B\r\nDual processor (not applicable to Intel486 processors) 10B\r\nIntel reserved 11B\r\nProcessor Type \r\n31 28 27 20 19 16 15 14 13 12 11 8 7 4 3 0\r\nEAX\r\nFamily (0FH for the Pentium 4 Processor Family)\r\nModel \r\nExtended\r\nFamily ID\r\nExtended\r\nModel ID\r\nFamily\r\nID Model Stepping\r\nID\r\nExtended Family ID (0)\r\nExtended Model ID (0)\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6dbe26aa-3eba-4f1b-a67d-1280044fede8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e680beaa262e7e4cb34609877893526280c0307a258a08b90f1fa5aa587b02fe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 260
      },
      {
        "segments": [
          {
            "segment_id": "fdb0d71d-8e0e-4007-8e09-cb1d655544f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "2-28 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nThe Extended Model ID needs to be examined only when the Family ID is 06H or 0FH. Integrate the field into a \r\ndisplay using the following rule:\r\nIF (Family_ID = 06H or Family_ID = 0FH)\r\nTHEN Displayed_Model = (Extended_Model_ID << 4) + Model_ID;\r\n(* Right justify and zero-extend 4-bit field; display Model_ID as HEX field.*)\r\nELSE Displayed_Model = Model_ID;\r\nFI;\r\n(* Show Display_Model as HEX field. *)\r\nINPUT EAX = 01H: Returns Additional Information in EBX\r\nWhen CPUID executes with EAX set to 01H, additional information is returned to the EBX register: \r\n• Brand index (low byte of EBX) — this number provides an entry into a brand string table that contains brand \r\nstrings for IA-32 processors. More information about this field is provided later in this section. \r\n• CLFLUSH instruction cache line size (second byte of EBX) — this number indicates the size of the cache line \r\nflushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.\r\n• Local APIC ID (high byte of EBX) — this number is the 8-bit ID that is assigned to the local APIC on the \r\nprocessor during power up. This field was introduced in the Pentium 4 processor.\r\nINPUT EAX = 01H: Returns Feature Information in ECX and EDX\r\nWhen CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX.\r\n• Figure 2-5 and Table 2-11 show encodings for ECX.\r\n• Figure 2-6 and Table 2-12 show encodings for EDX.\r\nFor all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.\r\nNOTE\r\nSoftware must confirm that a processor feature is present using feature flags returned by CPUID \r\nprior to using the feature. Software should not depend on future offerings retaining all features.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/fdb0d71d-8e0e-4007-8e09-cb1d655544f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cacefe5ff663beb21c78792d5284a72d5709606a9250ef92fbf4f23f24e78bac",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 307
      },
      {
        "segments": [
          {
            "segment_id": "25f4c259-392b-407b-8336-117d68f3603d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-29\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nFigure 2-5. Feature Information Returned in the ECX Register\r\nTable 2-11. Feature Information Returned in the ECX Register \r\nBit # Mnemonic Description\r\n0 SSE3 Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\r\n1 PCLMULQDQ A value of 1 indicates the processor supports PCLMULQDQ instruction.\r\n2 DTES64 64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout.\r\n3 MONITOR MONITOR/MWAIT. A value of 1 indicates the processor supports this feature. \r\n4 DS-CPL CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the \r\nDebug Store feature to allow for branch message storage qualified by CPL.\r\n5 VMX Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.\r\n6 SMX Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See \r\nChapter 6, “Safer Mode Extensions Reference”.\r\n7 EST Enhanced Intel SpeedStep® Technology. A value of 1 indicates that the processor supports this \r\ntechnology.\r\n8 TM2 Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology. \r\n9 SSSE3 A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A \r\nvalue of 0 indicates the instruction extensions are not present in the processor.\r\nCNXT-ID — L1 Context ID\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nECX\r\nTM2 — Thermal Monitor 2\r\nEST — Enhanced Intel SpeedStep® Technology\r\nDS-CPL — CPL Qualified Debug Store\r\nMONITOR — MONITOR/MWAIT\r\nPCLMULQDQ — Carryless Multiplication\r\nReserved\r\nCMPXCHG16B\r\nSMX — Safer Mode Extensions\r\nxTPR Update Control\r\nSSSE3 — SSSE3 Extensions\r\nPDCM — Perf/Debug Capability MSR\r\nVMX — Virtual Machine Extensions\r\nSSE4_1 — SSE4.1\r\nOSXSAVE\r\nSSE4_2 — SSE4.2\r\nDCA — Direct Cache Access\r\nx2APIC\r\nPOPCNT\r\nXSAVE\r\nAVX\r\nAES\r\nFMA — Fused Multiply Add\r\nSSE3 — SSE3 Extensions\r\nPCID — Process-context Identifiers\r\n0\r\nDTES64 — 64-bit DS Area\r\nMOVBE\r\nTSC-Deadline\r\nF16C\r\nRDRAND\r\nSDBG",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/25f4c259-392b-407b-8336-117d68f3603d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=97298d362432bcd4a59fa176226e13cb7ce6a503bf3696eb3084d8c4af987a1a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 351
      },
      {
        "segments": [
          {
            "segment_id": "a47a8aa9-09ce-4cdd-9ddb-6f031522e242",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "2-30 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n10 CNXT-ID\r\nL1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or \r\nshared mode. A value of 0 indicates this feature is not supported. See definition of the \r\nIA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\r\n11 SDBG A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.\r\n12 FMA A value of 1 indicates the processor supports FMA extensions using YMM state.\r\n13 CMPXCHG16B CMPXCHG16B Available. A value of 1 indicates that the feature is available.\r\n14 xTPR Update \r\nControl\r\nxTPR Update Control. A value of 1 indicates that the processor supports changing \r\nIA32_MISC_ENABLES[bit 23]. \r\n15 PDCM Perfmon and Debug Capability. A value of 1 indicates the processor supports the performance and \r\ndebug feature indication MSR IA32_PERF_CAPABILITIES.\r\n16 Reserved Reserved\r\n17 PCID Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and that \r\nsoftware may set CR4.PCIDE to 1.\r\n18 DCA A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped \r\ndevice.\r\n19 SSE4.1 A value of 1 indicates that the processor supports SSE4.1. \r\n20 SSE4.2 A value of 1 indicates that the processor supports SSE4.2. \r\n21 x2APIC A value of 1 indicates that the processor supports x2APIC feature.\r\n22 MOVBE A value of 1 indicates that the processor supports MOVBE instruction.\r\n23 POPCNT A value of 1 indicates that the processor supports the POPCNT instruction.\r\n24 TSC-Deadline A value of 1 indicates that the processor’s local APIC timer supports one-shot operation using a TSC \r\ndeadline value.\r\n25 AES A value of 1 indicates that the processor supports the AESNI instruction extensions.\r\n26 XSAVE A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states \r\nfeature, the XSETBV/XGETBV instructions, and XCR0.\r\n27 OSXSAVE\r\nA value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV \r\ninstructions to access XCR0 and to support processor extended state management using \r\nXSAVE/XRSTOR.\r\n28 AVX A value of 1 indicates that processor supports AVX instructions operating on 256-bit YMM state, and \r\nthree-operand encoding of 256-bit and 128-bit SIMD instructions.\r\n29 F16C A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.\r\n30 RDRAND A value of 1 indicates that processor supports RDRAND instruction.\r\n31 Not Used Always return 0.\r\nTable 2-11. Feature Information Returned in the ECX Register (Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a47a8aa9-09ce-4cdd-9ddb-6f031522e242.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0f59945181b39422fb4dd60b49ee72be3977ac5da351b216154abf487e0f2035",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 413
      },
      {
        "segments": [
          {
            "segment_id": "e8f493a2-4a66-4cb5-bdc9-1dddecd99472",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-31\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nFigure 2-6. Feature Information Returned in the EDX Register\r\nTable 2-12. More on Feature Information Returned in the EDX Register\r\nBit # Mnemonic Description\r\n0 FPU Floating-point Unit On-Chip. The processor contains an x87 FPU.\r\n1 \r\nVME \r\nVirtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the \r\nfeature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS \r\nwith the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags. \r\n2 DE Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional \r\ntrapping of accesses to DR4 and DR5. \r\n3 \r\nPSE \r\nPage Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the \r\nfeature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and \r\nPTEs. \r\n4 TSC Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\r\n5 MSR Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are \r\nsupported. Some of the MSRs are implementation dependent.\r\nPBE–Pend. Brk. EN.\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nEDX\r\nTM–Therm. Monitor\r\nHTT–Multi-threading\r\nSS–Self Snoop\r\nSSE2–SSE2 Extensions\r\nSSE–SSE Extensions\r\nFXSR–FXSAVE/FXRSTOR\r\nMMX–MMX Technology\r\nACPI–Thermal Monitor and Clock Ctrl\r\nDS–Debug Store\r\nCLFSH–CFLUSH instruction\r\nPSN–Processor Serial Number\r\nPSE-36 – Page Size Extension\r\nPAT–Page Attribute Table\r\nCMOV–Conditional Move/Compare Instruction\r\nMCA–Machine Check Architecture\r\nPGE–PTE Global Bit\r\nMTRR–Memory Type Range Registers\r\nSEP–SYSENTER and SYSEXIT\r\nAPIC–APIC on Chip\r\nCX8–CMPXCHG8B Inst.\r\nMCE–Machine Check Exception\r\nPAE–Physical Address Extensions\r\nMSR–RDMSR and WRMSR Support\r\nTSC–Time Stamp Counter\r\nPSE–Page Size Extensions\r\nDE–Debugging Extensions\r\nVME–Virtual-8086 Mode Enhancement\r\nFPU–x87 FPU on Chip\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/e8f493a2-4a66-4cb5-bdc9-1dddecd99472.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cfdf11b107169004df851b23fff592e244344bf9d24fe6cc05fa6311db78f9bf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 296
      },
      {
        "segments": [
          {
            "segment_id": "1535e3cd-9539-4139-bec5-24f4ddad7d2d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "2-32 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n6 \r\nPAE \r\nPhysical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 \r\nMCE \r\nMachine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 \r\nAPIC \r\nAPIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 \r\nMTRR \r\nMemory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 \r\nMCA \r\nMachine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual, Volume 3C).\r\n22 \r\nACPI\r\nThermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 \r\nFXSR \r\nFXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\nTable 2-12. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1535e3cd-9539-4139-bec5-24f4ddad7d2d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=94cdd7a15c2f3d07fddc7244ebb509e1c32b0405999360b7603c7ad46191f790",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 637
      },
      {
        "segments": [
          {
            "segment_id": "1535e3cd-9539-4139-bec5-24f4ddad7d2d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "2-32 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n6 \r\nPAE \r\nPhysical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 \r\nMCE \r\nMachine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 \r\nAPIC \r\nAPIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 \r\nMTRR \r\nMemory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 \r\nMCA \r\nMachine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual, Volume 3C).\r\n22 \r\nACPI\r\nThermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 \r\nFXSR \r\nFXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\nTable 2-12. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1535e3cd-9539-4139-bec5-24f4ddad7d2d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=94cdd7a15c2f3d07fddc7244ebb509e1c32b0405999360b7603c7ad46191f790",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 637
      },
      {
        "segments": [
          {
            "segment_id": "1b86a8a3-51b2-4fc6-b43d-e8d7e63ac536",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-33\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal caches \r\nand TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 2-13 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31\r\nPBE\r\nPending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 2-13. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 2-12. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1b86a8a3-51b2-4fc6-b43d-e8d7e63ac536.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5de7d4b89cf2b0a7481f6e1a8a5cfc3f8ef2af1be5eec23192528aff61b90eab",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 580
      },
      {
        "segments": [
          {
            "segment_id": "1b86a8a3-51b2-4fc6-b43d-e8d7e63ac536",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-33\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal caches \r\nand TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 2-13 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31\r\nPBE\r\nPending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 2-13. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 2-12. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1b86a8a3-51b2-4fc6-b43d-e8d7e63ac536.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5de7d4b89cf2b0a7481f6e1a8a5cfc3f8ef2af1be5eec23192528aff61b90eab",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 580
      },
      {
        "segments": [
          {
            "segment_id": "9a872011-0cfe-43d0-98d8-62b78d8fd2cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "2-34 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7AH 2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7BH 2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7CH 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7DH 2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\r\n7FH 2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\r\n82H 2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\r\nTable 2-13. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9a872011-0cfe-43d0-98d8-62b78d8fd2cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2106530f03c50c3f1b5d7f090b5ef6b4690bb71536207257488d940c20629382",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 522
      },
      {
        "segments": [
          {
            "segment_id": "9a872011-0cfe-43d0-98d8-62b78d8fd2cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "2-34 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7AH 2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7BH 2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7CH 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7DH 2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\r\n7FH 2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\r\n82H 2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\r\nTable 2-13. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9a872011-0cfe-43d0-98d8-62b78d8fd2cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2106530f03c50c3f1b5d7f090b5ef6b4690bb71536207257488d940c20629382",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 522
      },
      {
        "segments": [
          {
            "segment_id": "767f7478-8e10-4dc8-8bad-df808125d547",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-35\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nExample 2-1. Example of Cache and TLB Interpretation\r\nThe first member of the family of Pentium 4 processors returns the following information about caches and TLBs \r\nwhen the CPUID executes with an input value of 2:\r\nEAX 66 5B 50 01H\r\nEBX 0H\r\nECX 0H\r\nEDX 00 7A 70 00H\r\nWhich means:\r\n• The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed \r\nonce with an input value of 2 to retrieve complete information about caches and TLBs.\r\n• The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register \r\ncontains valid 1-byte descriptors.\r\n• Bytes 1, 2, and 3 of register EAX indicate that the processor has:\r\n— 50H - a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages.\r\n— 5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages.\r\n— 66H - an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.\r\n• The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.\r\n• Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has:\r\n— 00H - NULL descriptor.\r\n— 70H - Trace cache: 12 K-μop, 8-way set associative.\r\n— 7AH - a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size.\r\n— 00H - NULL descriptor.\r\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\r\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data \r\nthat describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid \r\nindex values start from 0.\r\nSoftware can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an \r\nindex value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally \r\ndefined fields reported by deterministic cache parameters are documented in Table 2-8.\r\n83H 2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size\r\n84H 2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size\r\n85H 2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size\r\n86H 2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size\r\n87H 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size\r\nB0H Instruction TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB1H Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries\r\nB3H Data TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB4H Data TLB1: 4 KByte pages, 4-way associative, 256 entries\r\nF0H 64-Byte prefetching\r\nF1H 128-Byte prefetching\r\nTable 2-13. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/767f7478-8e10-4dc8-8bad-df808125d547.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d5218114602cff77ba1c00565fe7b71a43d9ccd04caf38f3a183a9a3e8ad2c79",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 479
      },
      {
        "segments": [
          {
            "segment_id": "eb4ac8b4-d640-4dca-9eb6-cfa5fbfda89b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "2-36 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nThe CPUID leaf 4 also reports data that can be used to derive the topology of processor cores in a physical package. \r\nThis information is constant for all valid index values. Software can query the raw data reported by executing \r\nCPUID with EAX=04H and ECX=0H and use it as part of the topology enumeration algorithm described in Chapter \r\n8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A.\r\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features\r\nWhen CPUID executes with EAX set to 05H, the processor returns information about features available to \r\nMONITOR/MWAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with \r\nMWAIT instruction. The MWAIT instruction optionally provides additional extensions for advanced power manage\u0002ment. See Table 2-8. \r\nINPUT EAX = 06H: Returns Thermal and Power Management Features\r\nWhen CPUID executes with EAX set to 06H, the processor returns information about thermal and power manage\u0002ment features. See Table 2-8. \r\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information\r\nWhen CPUID executes with EAX set to 07H and ECX = 0H, the processor returns information about the maximum \r\nnumber of sub-leaves that contain extended feature flags. See Table 2-8. \r\nWhen CPUID executes with EAX set to 07H and ECX = n (n > 1and less than the number of non-zero bits in \r\nCPUID.(EAX=07H, ECX= 0H).EAX, the processor returns information about extended feature flags. See Table 2-8. \r\nIn sub-leaf 0, only EAX has the number of sub-leaves. In sub-leaf 0, EBX, ECX & EDX all contain extended feature \r\nflags.\r\nINPUT EAX = 09H: Returns Direct Cache Access Information\r\nWhen CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabili\u0002ties. See Table 2-8. \r\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features\r\nWhen CPUID executes with EAX set to 0AH, the processor returns information about support for architectural \r\nperformance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see Table \r\n2-8) is greater than Pn 0. See Table 2-8.\r\nFor each version of architectural performance monitoring capability, software must enumerate this leaf to discover \r\nthe programming facilities and the architectural performance events available in the processor. The details are \r\ndescribed in Chapter 17, “Debug, Branch Profile, TSC, and Quality of Service,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A.\r\nINPUT EAX = 0BH: Returns Extended Topology Information\r\nWhen CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumera\u0002tion data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported \r\nby CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 2-8.\r\nTable 2-14. Structured Extended Feature Leaf, Function 0, EBX Register \r\nBit # Mnemonic Description\r\n0 RWFSGSBASE A value of 1 indicates the processor supports RD/WR FSGSBASE instructions\r\n1-31 Reserved Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/eb4ac8b4-d640-4dca-9eb6-cfa5fbfda89b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b69cac6bae001f8f322d981e3ac3dca59932e66226ed2f466ca82989a11265a2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 484
      },
      {
        "segments": [
          {
            "segment_id": "3e142df9-896c-4f22-8e79-b8a58c93a582",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-37\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 2-8. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 2-8. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Platform Quality of Service (PQoS) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 2-8.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Platform Quality of Service (PQoS) Enforcement Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 2-8.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 2-8. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 2-8. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp \r\nCounter and Core Crystal Clock. See Table 2-8.\r\nINPUT EAX = 16H: Returns Processor Frequency Information\r\nWhen CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Informa\u0002tion. See Table 2-8. \r\nINPUT EAX = 17H: Returns System-On-Chip Information\r\nWhen CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor \r\nAttribute Enumeration. See Table 2-8. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3e142df9-896c-4f22-8e79-b8a58c93a582.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19fe312faf2300c86010cb90de7a0d6aed5ae72dc2a056fff610a0cac54ce523",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 626
      },
      {
        "segments": [
          {
            "segment_id": "3e142df9-896c-4f22-8e79-b8a58c93a582",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-37\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 2-8. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 2-8. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Platform Quality of Service (PQoS) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 2-8.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Platform Quality of Service (PQoS) Enforcement Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 2-8.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 2-8. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 2-8. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp \r\nCounter and Core Crystal Clock. See Table 2-8.\r\nINPUT EAX = 16H: Returns Processor Frequency Information\r\nWhen CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Informa\u0002tion. See Table 2-8. \r\nINPUT EAX = 17H: Returns System-On-Chip Information\r\nWhen CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor \r\nAttribute Enumeration. See Table 2-8. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3e142df9-896c-4f22-8e79-b8a58c93a582.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19fe312faf2300c86010cb90de7a0d6aed5ae72dc2a056fff610a0cac54ce523",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 626
      },
      {
        "segments": [
          {
            "segment_id": "ef6cb258-c1a7-48b2-b56b-d019337b1189",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "2-38 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nINPUT EAX = 18H: Returns Deterministic Address Translation Parameters Information\r\nWhen CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address \r\nTranslation Parameters. See Table 2-8. \r\nMETHODS FOR RETURNING BRANDING INFORMATION\r\nUse the following techniques to access branding information:\r\n1. Processor brand string method; this method also returns the processor’s maximum operating frequency\r\n2. Processor brand index; this method uses a software supplied brand string table.\r\nThese two methods are discussed in the following sections. For methods that are available in early processors, see \r\nSection: “Identification of Earlier IA-32 Processors” in Chapter 16 of the Intel® 64 and IA-32 Architectures Soft\u0002ware Developer’s Manual, Volume 1.\r\nThe Processor Brand String Method\r\nFigure 2-7 describes the algorithm used for detection of the brand string. Processor brand identification software \r\nshould execute this algorithm on all Intel 64 and IA-32 processors. \r\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum \r\noperating frequency of the processor to the EAX, EBX, ECX, and EDX registers.\r\nHow Brand Strings Work\r\nTo use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input \r\nvalue, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL-termi\u0002nated.\r\nTable 2-15 shows the brand string that is returned by the first processor in the Pentium 4 processor family.\r\nFigure 2-7. Determination of Support for the Processor Brand String\r\nIF (EAX & 0x80000000)\r\nCPUID\r\nIF (EAX Return Value \r\n = 0x80000004)\r\nCPUID \r\nFunction\r\nSupported\r\nTrue = \r\nExtended\r\nEAX Return Value =\r\nMax. Extended CPUID\r\nFunction Index\r\nInput: EAX= \r\n0x80000000\r\nProcessor Brand\r\nString Not\r\nSupported\r\nFalse\r\nProcessor Brand\r\nString Supported\r\nTrue",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ef6cb258-c1a7-48b2-b56b-d019337b1189.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7ec91725e64aff5b266c3c04b3d758f7ebf5a4b2023c844b922cd1f6c33d6177",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "88b92cf8-4dcf-4d09-ae75-19a741383021",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-39\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nExtracting the Maximum Processor Frequency from Brand Strings\r\nFigure 2-8 provides an algorithm which software can use to extract the maximum processor operating frequency \r\nfrom the processor brand string.\r\nTable 2-15. Processor Brand String Returned with Pentium 4 Processor \r\nEAX Input Value Return Values ASCII Equivalent\r\n80000002H EAX = 20202020H\r\nEBX = 20202020H\r\nECX = 20202020H\r\nEDX = 6E492020H\r\n“ ” \r\n“ ”\r\n“ ”\r\n“nI ”\r\n80000003H EAX = 286C6574H\r\nEBX = 50202952H\r\nECX = 69746E65H\r\nEDX = 52286D75H\r\n“(let”\r\n“P )R”\r\n“itne”\r\n“R(mu”\r\n80000004H EAX = 20342029H\r\nEBX = 20555043H\r\nECX = 30303531H\r\nEDX = 007A484DH\r\n“ 4 )”\r\n“ UPC”\r\n“0051”\r\n“\\0zHM”",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/88b92cf8-4dcf-4d09-ae75-19a741383021.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4c20e197e6a9149330a4aefd7822b66dc8411b2aebf6058df1ee6f297aa6121c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 403
      },
      {
        "segments": [
          {
            "segment_id": "a50c7021-fd6a-4c9c-b19d-08d9b371c416",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "2-40 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nNOTE\r\nWhen a frequency is given in a brand string, it is the maximum qualified frequency of the processor, \r\nnot the frequency at which the processor is currently running.\r\nThe Processor Brand Index Method\r\nThe brand index method (introduced with Pentium® III Xeon® processors) provides an entry point into a brand \r\nidentification table that is maintained in memory by system software and is accessible from system- and user-level \r\ncode. In this table, each brand index is associate with an ASCII brand identification string that identifies the official \r\nIntel family and model number of a processor.\r\nWhen CPUID executes with EAX set to 01H, the processor returns a brand index to the low byte in EBX. Software \r\ncan then use this index to locate the brand identification string for the processor in the brand identification table. \r\nThe first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do \r\nnot support the brand identification feature. Starting with processor signature family ID = 0FH, model = 03H, \r\nbrand index method is no longer supported. Use brand string method instead.\r\nFigure 2-8. Algorithm for Extracting Maximum Processor Frequency\r\nIF Substring Matched\r\n\"zHM\", or \r\n\"zHG\", or \r\n\"zHT\"\r\nTrue\r\nDetermine \"Multiplier\"\r\nScan \"Brand String\" in\r\nReverse Byte Order\r\nReport Error\r\nFalse\r\nScan Digits \r\nUntil Blank\r\nMatch\r\nSubstring\r\nDetermine \"Freq\" Reverse Digits\r\nTo Decimal Value\r\nMax. Qualified\r\nFrequency =\r\n\"Freq\" x \"Multiplier\" \"Freq\" = X.YZ if\r\nDigits = \"ZY.X\"\r\nIn Reverse Order\r\nIf \"zHM\"\r\nIf \"zHG\"\r\nIf \"zHT\"\r\nMultiplier = 1 x 1012\r\nMultiplier = 1 x 109\r\nMultiplier = 1 x 106",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a50c7021-fd6a-4c9c-b19d-08d9b371c416.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c2335f8cea20a096e6b5b7e5041f32f71ee6941f393a3051719d46f2408d347",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 272
      },
      {
        "segments": [
          {
            "segment_id": "b19639f4-e2e7-462f-9028-4e2310ec5589",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-41\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nTable 2-16 shows brand indices that have identification strings associated with them.\r\nIA-32 Architecture Compatibility\r\nCPUID is not supported in early models of the Intel486 processor or in any IA-32 processor earlier than the \r\nIntel486 processor.\r\nOperation\r\nIA32_BIOS_SIGN_ID MSR ← Update with installed microcode revision number;\r\nCASE (EAX) OF\r\nEAX = 0:\r\nEAX ← Highest basic function input value understood by CPUID;\r\nEBX ← Vendor identification string;\r\nEDX ← Vendor identification string;\r\nECX ← Vendor identification string;\r\nBREAK;\r\nEAX = 1H:\r\nEAX[3:0] ← Stepping ID; \r\nTable 2-16. Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings\r\nBrand Index Brand String\r\n00H This processor does not support the brand identification feature\r\n01H Intel(R) Celeron(R) processor1\r\n02H Intel(R) Pentium(R) III processor1\r\n03H Intel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) \r\nprocessor\r\n04H Intel(R) Pentium(R) III processor\r\n06H Mobile Intel(R) Pentium(R) III processor-M\r\n07H Mobile Intel(R) Celeron(R) processor1\r\n08H Intel(R) Pentium(R) 4 processor\r\n09H Intel(R) Pentium(R) 4 processor\r\n0AH Intel(R) Celeron(R) processor1\r\n0BH Intel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP\r\n0CH Intel(R) Xeon(R) processor MP\r\n0EH Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor\r\n0FH Mobile Intel(R) Celeron(R) processor1\r\n11H Mobile Genuine Intel(R) processor\r\n12H Intel(R) Celeron(R) M processor\r\n13H Mobile Intel(R) Celeron(R) processor1\r\n14H Intel(R) Celeron(R) processor\r\n15H Mobile Genuine Intel(R) processor\r\n16H Intel(R) Pentium(R) M processor\r\n17H Mobile Intel(R) Celeron(R) processor1\r\n18H – 0FFH RESERVED\r\nNOTES:\r\n1.Indicates versions of these processors that were introduced after the Pentium III ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b19639f4-e2e7-462f-9028-4e2310ec5589.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a7112b8487996bd825b1bf543a06b42a7627365fba61047173347190d8af771c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 266
      },
      {
        "segments": [
          {
            "segment_id": "17e1c0bf-5a22-4bdb-bba8-3bad78041e64",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "2-42 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nEAX[7:4] ← Model; \r\nEAX[11:8] ← Family; \r\nEAX[13:12] ← Processor type; \r\nEAX[15:14] ← Reserved;\r\nEAX[19:16] ← Extended Model;\r\nEAX[27:20] ← Extended Family;\r\nEAX[31:28] ← Reserved;\r\nEBX[7:0] ← Brand Index; (* Reserved if the value is zero. *)\r\nEBX[15:8] ← CLFLUSH Line Size;\r\nEBX[16:23] ← Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)\r\nEBX[24:31] ← Initial APIC ID;\r\nECX ← Feature flags; (* See Figure 2-5. *)\r\nEDX ← Feature flags; (* See Figure 2-6. *)\r\nBREAK;\r\nEAX = 2H:\r\nEAX ← Cache and TLB information; \r\n EBX ← Cache and TLB information; \r\n ECX ← Cache and TLB information; \r\nEDX ← Cache and TLB information; \r\nBREAK;\r\nEAX = 3H:\r\nEAX ← Reserved; \r\n EBX ← Reserved; \r\n ECX ← ProcessorSerialNumber[31:0]; \r\n(* Pentium III processors only, otherwise reserved. *)\r\nEDX ← ProcessorSerialNumber[63:32]; \r\n(* Pentium III processors only, otherwise reserved. *\r\nBREAK\r\nEAX = 4H:\r\nEAX ← Deterministic Cache Parameters Leaf; (* See Table 2-8. *)\r\nEBX ← Deterministic Cache Parameters Leaf; \r\n ECX ← Deterministic Cache Parameters Leaf; \r\nEDX ← Deterministic Cache Parameters Leaf; \r\nBREAK;\r\nEAX = 5H:\r\nEAX ← MONITOR/MWAIT Leaf; (* See Table 2-8. *)\r\n EBX ← MONITOR/MWAIT Leaf; \r\n ECX ← MONITOR/MWAIT Leaf; \r\nEDX ← MONITOR/MWAIT Leaf; \r\nBREAK;\r\nEAX = 6H:\r\nEAX ← Thermal and Power Management Leaf; (* See Table 2-8. *)\r\n EBX ← Thermal and Power Management Leaf; \r\n ECX ← Thermal and Power Management Leaf; \r\nEDX ← Thermal and Power Management Leaf; \r\nBREAK;\r\nEAX = 7H:\r\nEAX ← Structured Extended Feature Leaf; (* See Table 2-8. *);\r\n EBX ← Structured Extended Feature Leaf; \r\n ECX ← Structured Extended Feature Leaf; \r\nEDX ← Structured Extended Feature Leaf; \r\nBREAK;\r\nEAX = 8H:\r\nEAX ← Reserved = 0;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/17e1c0bf-5a22-4bdb-bba8-3bad78041e64.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4a073fddd8b4694293d5669833d3bebf23cf0d3a069172a398c6b810696a3072",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 286
      },
      {
        "segments": [
          {
            "segment_id": "c7c53ee3-c935-43b9-a85a-c46501ab7b88",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-43\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 9H:\r\nEAX ← Direct Cache Access Information Leaf; (* See Table 2-8. *)\r\n EBX ← Direct Cache Access Information Leaf; \r\n ECX ← Direct Cache Access Information Leaf; \r\nEDX ← Direct Cache Access Information Leaf; \r\nBREAK;\r\nEAX = AH:\r\nEAX ← Architectural Performance Monitoring Leaf; (* See Table 2-8. *)\r\n EBX ← Architectural Performance Monitoring Leaf; \r\n ECX ← Architectural Performance Monitoring Leaf; \r\nEDX ← Architectural Performance Monitoring Leaf; \r\nBREAK\r\nEAX = BH:\r\nEAX ← Extended Topology Enumeration Leaf; (* See Table 2-8. *)\r\nEBX ← Extended Topology Enumeration Leaf; \r\n ECX ← Extended Topology Enumeration Leaf; \r\nEDX ← Extended Topology Enumeration Leaf; \r\nBREAK;\r\nEAX = CH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = DH:\r\nEAX ← Processor Extended State Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← Processor Extended State Enumeration Leaf; \r\n ECX ← Processor Extended State Enumeration Leaf; \r\nEDX ← Processor Extended State Enumeration Leaf; \r\nBREAK;\r\nEAX = EH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = FH:\r\nEAX ← Platform Quality of Service Monitoring Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\n ECX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nEDX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nBREAK;\r\nEAX = 10H:\r\nEAX ← Platform Quality of Service Enforcement Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\n ECX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nEDX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nBREAK;\r\nEAX = 14H:\r\nEAX ← Intel Processor Trace Enumeration Leaf; (* See Table 2-8. *)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/c7c53ee3-c935-43b9-a85a-c46501ab7b88.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fc7e0167bc27ea037f82e90f5964f397842d95bb7dff1630c93f504665a1a2c4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 318
      },
      {
        "segments": [
          {
            "segment_id": "daeaf33f-77ca-4d94-b405-e35d596599e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "2-44 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\n EBX ← Intel Processor Trace Enumeration Leaf; \r\n ECX ← Intel Processor Trace Enumeration Leaf; \r\nEDX ← Intel Processor Trace Enumeration Leaf; \r\nBREAK;\r\nEAX = 15H:\r\nEAX ← Time Stamp Counter and Core Crystal Clock Information Leaf; (* See Table 2-8. *)\r\n EBX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\n ECX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nEDX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nBREAK;\r\nEAX = 16H:\r\nEAX ← Processor Frequency Information Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← Processor Frequency Information Enumeration Leaf; \r\n ECX ← Processor Frequency Information Enumeration Leaf; \r\nEDX ← Processor Frequency Information Enumeration Leaf; \r\nBREAK;\r\nEAX = 17H:\r\nEAX ← System-On-Chip Vendor Attribute Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\n ECX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nEDX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nBREAK;\r\nEAX = 18H:\r\nEAX ← Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 2-8. *)\r\n EBX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\n ECX ←Deterministic Address Translation Parameters Enumeration Leaf; \r\nEDX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\nBREAK;\r\nEAX = 80000000H:\r\nEAX ← Highest extended function input value understood by CPUID;\r\nEBX ← Reserved; \r\nECX ← Reserved; \r\nEDX ← Reserved; \r\nBREAK;\r\nEAX = 80000001H:\r\nEAX ← Reserved; \r\nEBX ← Reserved; \r\nECX ← Extended Feature Bits (* See Table 2-8.*); \r\nEDX ← Extended Feature Bits (* See Table 2-8. *); \r\nBREAK;\r\nEAX = 80000002H:\r\nEAX ← Processor Brand String; \r\nEBX ← Processor Brand String, continued;\r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000003H:\r\nEAX ← Processor Brand String, continued; \r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000004H:\r\nEAX ← Processor Brand String, continued; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/daeaf33f-77ca-4d94-b405-e35d596599e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=270b004fee243ec584b767e2630edd5d37564c3501268631e86162d0e1984705",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 314
      },
      {
        "segments": [
          {
            "segment_id": "01ef5e3f-c449-4596-8841-6d76533a28f2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 2-45\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL\r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued;\r\nBREAK;\r\nEAX = 80000005H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000006H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Cache information; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000007H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000008H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nDEFAULT: (* EAX = Value outside of recognized range for CPUID. *)\r\n(* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)\r\nEAX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEBX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nECX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEDX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nBREAK;\r\nESAC;\r\nFlags Affected\r\nNone.\r\nExceptions (All Operating Modes)\r\n#UD If the LOCK prefix is used.\r\nIn earlier IA-32 processors that do not support the CPUID instruction, execution of the instruction results in an \r\ninvalid opcode (#UD) exception being generated.§",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/01ef5e3f-c449-4596-8841-6d76533a28f2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9aa72b899cdac0dce8f0b5180ddde6f28ee91a9e02949ab8f1a24ea1bb452e3c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "632aa99f-22d5-45c3-9b2a-abcf3251399f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "2-46 Ref. # 319433-029\r\nINTEL® AVX-512 APPLICATION PROGRAMMING MODEL",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/632aa99f-22d5-45c3-9b2a-abcf3251399f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1840556a4512aa879233526f1a18db83deb22e3b8f73dea84cab2dece5f0ecd4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 248
      },
      {
        "segments": [
          {
            "segment_id": "f58f6966-4f19-4c2f-99de-a4091c6b7b8f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 3-1\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nCHAPTER 3\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThis chapter describes the operating system programming considerations for supporting the following extended \r\nprocessor states: 512-bit ZMM registers and opmask k-registers. These system programming requirements apply \r\nto AVX-512 Foundation instructions and other 512-bit instructions described in Chapter 5.\r\nThe basic requirements for an operating system using XSAVE/XRSTOR to manage processor extended states, e.g. \r\nYMM registers, can be found in Chapter 13 of Intel 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolumes 3A. This chapter covers additional requirements for OS to support ZMM and opmask register states.\r\n3.1 AVX-512 STATE, EVEX PREFIX AND SUPPORTED OPERATING MODES\r\nAVX-512 instructions are encoded using EVEX prefix. The EVEX encoding scheme can support 512-bit, 256-bit and \r\n128-bit instructions that operate on opmask register, ZMM, YMM and XMM states. \r\nFor processors that support AVX-512 family of instructions, the extended processor states (ZMM and opmask \r\nregisters) exist in all operating modes. However, the access to those states may vary in different modes. The \r\nprocessor's support for instruction extensions that employ EVEX prefix encoding is independent of the processor's \r\nsupport for using XSAVE/XRSTOR/XSAVEOPT to those states.\r\nInstructions requiring EVEX prefix encoding generally are supported in 64-bit, 32-bit modes, and 16-bit protected \r\nmode. They are not supported in Real mode, Virtual-8086 mode or entering into SMM mode.\r\nNote that bits MAX_VL-1:256 (511:256) of ZMM register state are maintained across transitions into and out of \r\nthese modes. Because the XSAVE/XRSTOR/XSAVEOPT instruction can operate in all operating modes, it is possible \r\nthat the processor's ZMM register state can be modified by software in any operating mode by executing XRSTOR. \r\nThe ZMM registers can be updated by XRSTOR using the state information stored in the XSAVE/XRSTOR area \r\nresiding in memory.\r\n3.2 AVX-512 STATE MANAGEMENT\r\nOperating systems must use the XSAVE/XRSTOR/XSAVEOPT instructions for ZMM and opmask state management. \r\nAn OS must enable its ZMM and opmask state management to support AVX-512 Foundation instructions. Other\u0002wise, an attempt to execute an instruction in AVX-512 Foundation instructions (including a scalar 128-bit SIMD \r\ninstructions using EVEX encoding) will cause a #UD exception. An operating system, which enabled AVX-512 state \r\nto support AVX-512 Foundation instructions, is also sufficient to support the rest of AVX-512 family of instructions.\r\n3.2.1 Detection of ZMM and Opmask State Support\r\nHardware support of the extended state components for executing AVX-512 Foundation instructions is queried \r\nthrough the main leaf of CPUID leaf function 0DH with index ECX = 0. Specifically, the return value in EDX:EAX of \r\nCPUID.(EAX=0DH, ECX=0) provides a 64-bit wide bit vector of hardware support of processor state components, \r\nbeginning with bit 0 of EAX corresponding to x87 FPU state, CPUID.(EAX=0DH, ECX=0):EAX[1] corresponding to \r\nSSE state (XMM registers and MXCSR), CPUID.(EAX=0DH, ECX=0):EAX[2] corresponding to YMM states.\r\nThe ZMM and opmaks states consist of three additional components in the XSAVE/XRSTOR state save area:\r\n• The opmask register state component represents eight 64-bit opmask registers. Processor support for this \r\ncomponent state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[5].\r\n• The ZMM_Hi256 component represents the high 256 bits of the low 16 ZMM registers, i.e. ZMM0..15[511:256]. \r\nProcessor support for this component state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[6].\r\n• The Hi16_ZMM component represents the full 512 bits of the high 16 ZMM registers, i.e. ZMM16..31[511:0]. \r\nProcessor support for this component state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[7].",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f58f6966-4f19-4c2f-99de-a4091c6b7b8f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=610e8735cc24f4a353455bd5c143a20ac4a2e16f7f61ac2a92a8e72592586252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 554
      },
      {
        "segments": [
          {
            "segment_id": "f58f6966-4f19-4c2f-99de-a4091c6b7b8f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 3-1\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nCHAPTER 3\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThis chapter describes the operating system programming considerations for supporting the following extended \r\nprocessor states: 512-bit ZMM registers and opmask k-registers. These system programming requirements apply \r\nto AVX-512 Foundation instructions and other 512-bit instructions described in Chapter 5.\r\nThe basic requirements for an operating system using XSAVE/XRSTOR to manage processor extended states, e.g. \r\nYMM registers, can be found in Chapter 13 of Intel 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolumes 3A. This chapter covers additional requirements for OS to support ZMM and opmask register states.\r\n3.1 AVX-512 STATE, EVEX PREFIX AND SUPPORTED OPERATING MODES\r\nAVX-512 instructions are encoded using EVEX prefix. The EVEX encoding scheme can support 512-bit, 256-bit and \r\n128-bit instructions that operate on opmask register, ZMM, YMM and XMM states. \r\nFor processors that support AVX-512 family of instructions, the extended processor states (ZMM and opmask \r\nregisters) exist in all operating modes. However, the access to those states may vary in different modes. The \r\nprocessor's support for instruction extensions that employ EVEX prefix encoding is independent of the processor's \r\nsupport for using XSAVE/XRSTOR/XSAVEOPT to those states.\r\nInstructions requiring EVEX prefix encoding generally are supported in 64-bit, 32-bit modes, and 16-bit protected \r\nmode. They are not supported in Real mode, Virtual-8086 mode or entering into SMM mode.\r\nNote that bits MAX_VL-1:256 (511:256) of ZMM register state are maintained across transitions into and out of \r\nthese modes. Because the XSAVE/XRSTOR/XSAVEOPT instruction can operate in all operating modes, it is possible \r\nthat the processor's ZMM register state can be modified by software in any operating mode by executing XRSTOR. \r\nThe ZMM registers can be updated by XRSTOR using the state information stored in the XSAVE/XRSTOR area \r\nresiding in memory.\r\n3.2 AVX-512 STATE MANAGEMENT\r\nOperating systems must use the XSAVE/XRSTOR/XSAVEOPT instructions for ZMM and opmask state management. \r\nAn OS must enable its ZMM and opmask state management to support AVX-512 Foundation instructions. Other\u0002wise, an attempt to execute an instruction in AVX-512 Foundation instructions (including a scalar 128-bit SIMD \r\ninstructions using EVEX encoding) will cause a #UD exception. An operating system, which enabled AVX-512 state \r\nto support AVX-512 Foundation instructions, is also sufficient to support the rest of AVX-512 family of instructions.\r\n3.2.1 Detection of ZMM and Opmask State Support\r\nHardware support of the extended state components for executing AVX-512 Foundation instructions is queried \r\nthrough the main leaf of CPUID leaf function 0DH with index ECX = 0. Specifically, the return value in EDX:EAX of \r\nCPUID.(EAX=0DH, ECX=0) provides a 64-bit wide bit vector of hardware support of processor state components, \r\nbeginning with bit 0 of EAX corresponding to x87 FPU state, CPUID.(EAX=0DH, ECX=0):EAX[1] corresponding to \r\nSSE state (XMM registers and MXCSR), CPUID.(EAX=0DH, ECX=0):EAX[2] corresponding to YMM states.\r\nThe ZMM and opmaks states consist of three additional components in the XSAVE/XRSTOR state save area:\r\n• The opmask register state component represents eight 64-bit opmask registers. Processor support for this \r\ncomponent state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[5].\r\n• The ZMM_Hi256 component represents the high 256 bits of the low 16 ZMM registers, i.e. ZMM0..15[511:256]. \r\nProcessor support for this component state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[6].\r\n• The Hi16_ZMM component represents the full 512 bits of the high 16 ZMM registers, i.e. ZMM16..31[511:0]. \r\nProcessor support for this component state is indicated by CPUID.(EAX=0DH, ECX=0):EAX[7].",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f58f6966-4f19-4c2f-99de-a4091c6b7b8f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=610e8735cc24f4a353455bd5c143a20ac4a2e16f7f61ac2a92a8e72592586252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 554
      },
      {
        "segments": [
          {
            "segment_id": "1938cb8e-4092-409a-b9e4-705931fb5a08",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "3-2 Ref. # 319433-029\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nEach component state has a corresponding enable it in the XCR0 register. Operating system must use XSETBV to \r\nset these three enable bits to enable AVX-512 Foundation instructions to be decoded. The location of bit vector \r\nrepresenting the AVX-512 states, matching the layout of the XCR0 register, is provided in the following figure.\r\n3.2.2 Enabling of ZMM and Opmask Register State \r\nAn OS can enable ZMM and opmask register state support with the following steps:\r\n• Verify the processor supports XSAVE/XRSTOR/XSETBV/XGETBV instructions and the XCR0 register by checking \r\nCPUID.1.ECX.XSAVE[bit 26]=1. \r\n• Verify the processor supports SSE, YMM, ZMM_Hi256, Hi16_ZMM, and opmask states (i.e. bits 2:1 and 7:5 of \r\nXCR0 are valid) by checking CPUID.(EAX=0DH, ECX=0):EAX[7:5]. \r\nThe OS must determine the buffer size requirement for the XSAVE area that will be used by XSAVE/XRSTOR. \r\nNote that even though ZMM8-ZMM31 are not accessible in 32 bit mode, a 32 bit OS is still required to allocate \r\nthe buffer for the entire ZMM state.\r\n• Set CR4.OSXSAVE[bit 18]=1 to enable the use of XSETBV/XGETBV instructions to write/read the XCR0 register.\r\n• Supply an appropriate mask via EDX:EAX to execute XSETBV to enable the processor state components that \r\nthe OS wishes to manage using XSAVE/XRSTOR instruction. \r\nTo enable ZMM and opmask register state, system software must use a EDX:EAX mask of 111xx111b when\r\nexecuting XSETBV.\r\nFigure 3-1. Bit Vector and XCR0 Layout of Extended Processor State Components\r\nTable 3-1. XCR0 Processor State Components\r\nBit Meaning\r\n0 - x87 This bit 0 must be 1. An attempt to write 0 to this bit causes a #GP exception.\r\n1 - SSE If 1, the processor supports SSE state (MXCSR and XMM registers) management using XSAVE, XSAVEOPT, and \r\nXRSTOR. This bit must be set to ‘1’ to enable AVX-512 Foundation instructions.\r\n2 - YMM_Hi128 If 1, the processor supports YMM_hi128 state management (upper 128 bits of YMM0-15) using XSAVE, \r\nXSAVEOPT, and XRSTOR. This bit must be set to ‘1’ to enable AVX-512 Foundation instructions.\r\n3 - BNDREGS If 1, the processor supports Intel Memory Protection Extensions (Intel MPX) bound register state management \r\nusing XSAVE, XSAVEOPT, and XRSTOR. \r\n4 - BNDCSR If 1, the processor supports Intel MPX bound configuration and status management using XSAVE, XSAVEOPT, \r\nand XRSTOR. \r\n5 - Opmask If 1, the processor supports the opmask state management using XSAVE, XSAVEOPT, and XRSTOR. This bit \r\nmust be set to ‘1’ to enable AVX-512 Foundation instructions.\r\n63 765432 0 1\r\nreserved\r\nHi16_ZMM: ZMM16..31[511:0]\r\nZMM_Hi256: ZMM0..15[511:256]\r\nOpMask: k0..7[63:0]\r\nBNDCSR: \r\nBNDREGS: BND0..3[127:0]\r\nYMM_Hi128: YMM0..15[255:128]\r\nSSE: XMM0..15[127:0]\r\nX87: ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1938cb8e-4092-409a-b9e4-705931fb5a08.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be8904d0b2a0051099bd23254a69a654f1ba896de7a54361042e4927b5f33ffa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 427
      },
      {
        "segments": [
          {
            "segment_id": "ceaf5ddc-9fe7-4cc6-a337-c27079e9fbe7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 3-3\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\n3.2.3 Enabling of SIMD Floating-Exception Support\r\nAVX-512 Foundation instructions may generate SIMD floating-point exceptions. An OS must enable SIMD float\u0002ing-point exception support by setting CR4.OSXMMEXCPT[bit 10]=1.\r\nThe effect of CR4 setting that affects AVX-512 Foundation instructions is the same as for AVX and FMA enabling \r\nas listed in Table 3-2\r\n3.2.4 The Layout of XSAVE Sate Save Area\r\nThe OS must determine the buffer size requirement by querying CPUID with EAX=0DH, ECX=0. If the OS wishes \r\nto enable all processor extended state components in the XCR0, it can allocate the buffer size according to \r\nCPUID.(EAX=0DH, ECX=0):ECX. \r\nAfter the memory buffer for XSAVE is allocated, the entire buffer must be cleared prior to executing XSAVE. \r\nThe XSAVE area layout currently defined in Intel Architecture is listed in Table 3-3. The register fields of the first \r\n512 byte of the XSAVE area are identical to those of the FXSAVE/FXRSTOR area. \r\nThe layout of the XSAVE Area for additional processor components (512-bit ZMM register, 32 ZMM registers, \r\nopmask registers) are to be determined later.\r\n6 - ZMM_Hi256 If 1, the processor supports ZMM_Hi256 state (the upper 256 bits of the low 16 ZMM registers) management \r\nusing XSAVE, XSAVEOPT, and XRSTOR. This bit must be set to ‘1’ to enable AVX-512 Foundation instruc\u0002tions.\r\n7 - Hi16_ZMM If 1, the processor supports Hi16-_ZMM state (the full 512 bits of the high16 ZMM registers) management \r\nusing XSAVE, XSAVEOPT, and XRSTOR. This bit must be set to ‘1’ to enable AVX-512 Foundation instruc\u0002tions.\r\nTable 3-2. CR4 Bits for AVX-512 Foundation Instructions Technology Support\r\nBit Meaning\r\nCR4.OSXSAVE[bit 18] If set, the OS supports use of XSETBV/XGETBV instruction to access. the XCR0 register, \r\nXSAVE/XRSTOR to manage processor extended states. Must be set to ‘1’ to enable AVX-512 Founda\u0002tion, AVX2, FMA, and AVX instructions.\r\nCR4.OSXMMEXCPT[bit 10] Must be set to 1 to enable SIMD floating-point exceptions. This applies to SIMD floating-point instruc\u0002tions across AVX-512 Foundation, AVX and FMA, and legacy 128-bit SIMD floating-point instructions \r\noperating on XMM registers. \r\nCR4.OSFXSR[bit 9] Must be set to 1 to enable legacy 128-bit SIMD instructions operating on XMM state. \r\nNot needed to enable AVX-512 Foundation, AVX2, FMA, and AVX instructions.\r\nTable 3-1. XCR0 Processor State Components\r\nBit Meaning",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ceaf5ddc-9fe7-4cc6-a337-c27079e9fbe7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=17406b506d432496c4f2dbafdb48df4dba48a5c725efd7a2490a43d587eb05f9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 373
      },
      {
        "segments": [
          {
            "segment_id": "2009f2e1-9ca4-442e-a1ae-ce60b9a91e48",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "3-4 Ref. # 319433-029\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThe format of the header is as follows (see Table 3-4):\r\nThe layout of the Ext_Save_Area[YMM_Hi128] contains 16 of the upper 128-bits of the YMM registers, it is shown \r\nin Table 3-5. \r\nThe layout of the Ext_SAVE_Area_3[BNDREGS] contains bounds register state of the Intel Memory Protection \r\nExtensions (Intel MPX).\r\nThe layout of the Ext_SAVE_Area_4[BNDCSR] contains the processor state of bounds configuration and status of \r\nIntel MPX.\r\nThe layout of the Ext_SAVE_Area_5[Opmask] contains 8 64-bit mask register as shown in Table 3-6.\r\nTable 3-3. Layout of XSAVE Area For Processor Supporting YMM State\r\nSave Areas Offset (Byte) Size (Bytes)\r\nFPU/SSE SaveArea 0 512\r\nHeader 512 64\r\nExt_Save_Area_2 (YMM_Hi128) CPUID.(EAX=0DH, ECX=2):EBX CPUID.(EAX=0DH, ECX=2):EAX \r\nExt_Save_Area_3 (BNDREGS) CPUID.(EAX=0DH, ECX=3):EBX CPUID.(EAX=0DH, ECX=3):EAX \r\nExt_Save_Area_4 (BNDCSR) CPUID.(EAX=0DH, ECX=4):EBX CPUID.(EAX=0DH, ECX=4):EAX \r\nExt_Save_Area_5 (OPMASK) CPUID.(EAX=0DH, ECX=5):EBX CPUID.(EAX=0DH, ECX=5):EAX \r\nExt_Save_Area_6 (ZMM_Hi256) CPUID.(EAX=0DH, ECX=6):EBX CPUID.(EAX=0DH, ECX=6):EAX \r\nExt_Save_Area_7 (Hi16_ZMM) CPUID.(EAX=0DH, ECX=7):EBX CPUID.(EAX=0DH, ECX=7):EAX \r\nTable 3-4. XSAVE Header Format\r\n15:8 7:0 Byte Offset from Header Byte Offset from XSAVE Area\r\nReserved (Must be zero) XSTATE_BV 0 512\r\nReserved Reserved (Must be zero) 16 528\r\nReserved Reserved 32 544\r\nReserved Reserved 48 560\r\nTable 3-5. XSAVE Save Area Layout for YMM_Hi128 State (Ext_Save_Area_2)\r\n31 16 15 0 Byte Offset from YMM_Hi128_Save_Area Byte Offset from XSAVE Area\r\nYMM1[255:128] YMM0[255:128] 0 576\r\nYMM3[255:128] YMM2[255:128] 32 608\r\nYMM5[255:128] YMM4[255:128] 64 640\r\nYMM7[255:128] YMM6[255:128] 96 672\r\nYMM9[255:128] YMM8[255:128] 128 704\r\nYMM11[255:128] YMM10[255:128] 160 736\r\nYMM13[255:128] YMM12[255:128] 192 768\r\nYMM15[255:128] YMM14[255:128] 224 800",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/2009f2e1-9ca4-442e-a1ae-ce60b9a91e48.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f264fe34cbb72766d4c8b950bc82473f2ac1fc4265e50f5fe3082f2d8dd0b899",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 243
      },
      {
        "segments": [
          {
            "segment_id": "a9fc9ed1-aee2-4888-9bba-832b050cc0d9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 3-5\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThe layout of the Ext_SAVE_Area_6[ZMM_Hi256] is shown below in Table 3-7.\r\nThe layout of the Ext_SAVE_Area_7[Hi16_ZMM] corresponding to the upper new 16 ZMM registers is shown below \r\nin Table 3-8.\r\n3.2.5 XSAVE/XRSTOR Interaction with YMM State and MXCSR\r\nThe processor’s actions as a result of executing XRSTOR, on the MXCSR, XMM and YMM registers, are listed in Table \r\n3-9 The XMM registers may be initialized by the processor (See XRSTOR operation in Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 2B). When the MXCSR register is updated from memory, reserved bit \r\nchecking is enforced. XSAVE / XRSTOR will save / restore the MXCSR only if the AVX or SSE bits are set in the \r\nEDX:EAX mask. \r\nTable 3-6. XSAVE Save Area Layout for Opmask Registers\r\n15 8 7 0 Byte Offset from OPMASK_Save_Area Byte Offset from XSAVE Area\r\nK1[63:0] K0[63:0] 0 1088\r\nK3[63:0] K2[63:0] 16 1104\r\nK5[63:0] K4[63:0] 32 1120\r\nK7[63:0] K6[63:0] 48 1136\r\nTable 3-7. XSAVE Save Area Layout for ZMM State of the High 256 Bits of ZMM0-ZMM15 Registers\r\n63 32 31 0 Byte Offset from \r\nZMM_Hi256_Save_Area\r\nByte Offset from \r\nXSAVE Area\r\nZMM1[511:256] ZMM0[511:256] 0 1152\r\nZMM3[511:256] ZMM2[511:256] 64 1216\r\nZMM5[511:256] ZMM4[511:256] 128 1280\r\nZMM7[511:256] ZMM6[511:256] 192 1344\r\nZMM9[511:256] ZMM8[511:256] 256 1408\r\nZMM11[511:256] ZMM10[511:256] 320 1472\r\nZMM13[511:256] ZMM12[511:256] 384 1536\r\nZMM15[511:256] ZMM14[511:256] 448 1600\r\nTable 3-8. XSAVE Save Area Layout for ZMM State of ZMM16-ZMM31 Registers\r\n127 64 63 0 Byte Offset from \r\nHi16_ZMM_Save_Area\r\nByte Offset from \r\nXSAVE Area\r\nZMM17[511:0] ZMM16[511:0] 0 1664\r\nZMM19[511:0] ZMM18[511:0] 128 1792\r\nZMM21[511:0] ZMM20[511:0] 256 1920\r\nZMM23[511:0] ZMM22[511:0] 384 2048\r\nZMM25[511:0] ZMM24[511:0] 512 2176\r\nZMM27[511:0] ZMM26[511:0] 640 2304\r\nZMM29[511:0] ZMM28[511:0] 768 2432\r\nZMM31[511:0] ZMM30[511:0] 896 2560",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a9fc9ed1-aee2-4888-9bba-832b050cc0d9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=87e3e48068443a6c478f334972a14ef0d7e924bc5d58956cd9af5f24a1aff6f7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 283
      },
      {
        "segments": [
          {
            "segment_id": "3b8e2de7-6458-4792-85f8-e96d9f6df2f4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "3-6 Ref. # 319433-029\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThe action of XSAVE for managing YMM and MXCSR is listed in Table 3-10.\r\n3.2.6 XSAVE/XRSTOR/XSAVEOPT and Managing ZMM and Opmask States\r\nThe requirements for managing ZMM_Hi256, Hi16_ZMM and Opmask registers using XSAVE/XRSTOR/XSAVEOPT \r\nare simpler than those listed in Section 3.2.5. Because each of the three components (ZMM_Hi256, Hi16_ZMM and \r\nOpmask registers) can be managed independently of one another by XSAVE/XRSTOR/XSAVEOPT according to the \r\ncorresponding bits in the bit vectors: EDX:EAX, XSAVE_BV, XCR0_MASK, independent of MXCSR:\r\n• For using XSAVE with Opmask/ZMM_Hi256/Hi16_ZMM, XSAVE/XSAVEOPT will save the component to memory \r\nand mark the corresponding bits in the XSTATE_BV of the XSAVE header, if that component is specified in \r\nEDX:EAX as input to XSAVE/XSAVEOPT.\r\n• XRSTOR will restore the Opmask/ZMM_Hi256/Hi16_ZMM components by checking the corresponding bits in \r\nboth the input bit vector in EDX:EAX of XRSTOR and in XSTATE_BV of the header area in the following ways:\r\n— If the corresponding bit in EDX:EAX is set and XSTATE_BV is INIT, that component will be initialized,\r\n— If the corresponding bit in EDX:EAX is set and XSTATE_BV is set, that component will be restored from \r\nmemory,\r\n— If the corresponding bit in EDX:EAX is not set, that component will remain unchanged.\r\n• To enable AVX-512 Foundation instructions, all three components (Opmask/ZMM_Hi256/Hi16_ZMM) in XCR0 \r\nmust be set.\r\nTable 3-9. XRSTOR Action on MXCSR, XMM Registers, YMM Registers\r\nEDX:EAX XSTATE_BV\r\nMXCSR YMM_Hi128 \r\nRegisters XMM Registers Bit 2 Bit 1 Bit 2 Bit 1\r\n0 0 X X None None None\r\n0 1 X 0 Load/Check None Init by processor\r\n0 1 X 1 Load/Check None Load \r\n1 0 0 X Load/Check Init by processor None\r\n1 0 1 X Load/Check Load None\r\n1 1 0 0 Load/Check Init by processor Init by processor\r\n1 1 0 1 Load/Check Init by processor Load\r\n1 1 1 0 Load/Check Load Init by processor\r\n1 1 1 1 Load/Check Load Load\r\nTable 3-10. XSAVE Action on MXCSR, XMM, YMM Register \r\nEDX:EAX XCR0_MASK\r\nMXCSR YMM_H \r\nRegisters XMM Registers Bit 2 Bit 1 Bit 2 Bit 1\r\n0 0 X X None None None\r\n0 1 X 1 Store None Store \r\n0 1 X 0 None None None\r\n1 0 0 X None None None\r\n1 0 1 1 Store Store None\r\n1 1 0 0 None None None\r\n1 1 0 1 Store None Store\r\n1 1 1 1 Store Store Store",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3b8e2de7-6458-4792-85f8-e96d9f6df2f4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0b9532443e7b605aa9664fd361bdd555202b76d1f2538f9a1eaac9049e7fc4d7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 402
      },
      {
        "segments": [
          {
            "segment_id": "99204110-119a-49ff-9eed-6d5ca15537b2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 3-7\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512\r\nThe processor supplied INIT values for each processor state component used by XRSTOR is listed in Table 3-11.\r\n3.3 RESET BEHAVIOR\r\nAt processor reset\r\n• YMM0-15 bits[255:0] are set to zero. \r\n• ZMM0-15 bits [511:256] are set to zero.\r\n• ZMM16-31 are set to zero.\r\n• Opmask register K0-7 are set to 0x0H.\r\n• XCR0[2:1] is set to zero, XCR0[0] is set to 1.\r\n• XCR0[7:6] and is set to zero, XCR0[Opmask] is set to 0.\r\n• CR4.OSXSAVE[bit 18] (and its mirror CPUID.1.ECX.OSXSAVE[bit 27]) is set to 0.\r\n3.4 EMULATION\r\nSetting the CR0.EM bit to 1 provides a technique to emulate Legacy SSE floating-point instruction sets in software. \r\nThis technique is not supported with AVX instructions, nor FMA instructions. \r\nIf an operating system wishes to emulate AVX instructions, set XCR0[2:1] to zero. This will cause AVX instructions \r\nto #UD. Emulation of FMA by operating system can be done similarly as with emulating AVX instructions. \r\n3.5 WRITING FLOATING-POINT EXCEPTION HANDLERS\r\nAVX-512, AVX and FMA floating-point exceptions are handled in an entirely analogous way to Legacy SSE floating\u0002point exceptions. To handle unmasked SIMD floating-point exceptions, the operating system or executive must \r\nprovide an exception handler. The section titled “SSE and SSE2 SIMD Floating-Point Exceptions” in Chapter 11, \r\n“Programming with Streaming SIMD Extensions 2 (SSE2),” of the IA-32 Intel® Architecture Software Developer’s \r\nManual, Volume 1, describes the SIMD floating-point exception classes and gives suggestions for writing an excep\u0002tion handler to handle them.\r\nTo indicate that the operating system provides a handler for SIMD floating-point exceptions (#XM), the CR4.OSXM\u0002MEXCPT flag (bit 10) must be set.\r\nTable 3-11. Processor Supplied Init Values XRSTOR May Use\r\nProcessor State Component Processor Supplied Register Values\r\nx87 FPU State FCW ← 037FH; FTW ← 0FFFFH; FSW ← 0H; FPU CS ← 0H; FPU DS ← 0H; FPU IP ← 0H; FPU \r\nDP ← 0; ST0-ST7 ← 0;\r\nSSE State1\r\nNOTES:\r\n1. MXCSR state is not updated by processor supplied values. MXCSR state can only be updated by XRSTOR\r\nfrom state information stored in XSAVE/XRSTOR area.\r\nIf 64-bit Mode: XMM0-XMM15 ← 0H;\r\nElse XMM0-XMM7 ← 0H\r\nYMM_Hi128 State1 If 64-bit Mode: YMM0_H-YMM15_H ← 0H;\r\nElse YMM0_H-YMM7_H ← 0H\r\nOPMASK State1 If 64-bit Mode: K0-K7 ← 0H;\r\nZMM_Hi256 State1 If 64-bit Mode: ZMM0_H-ZMM15_H ← 0H;\r\nElse ZMM0_H-ZMM7_H ← 0H\r\nHi16_ZMM State1 If 64-bit Mode: ZMM16-ZMM31 ← 0H;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/99204110-119a-49ff-9eed-6d5ca15537b2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a211098bc49e880ba0ffbd9e54d258657c23514e74dfdba53891c60c9f82640",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6f6b2948-7be5-4393-ac79-5cd55102a187",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "3-8 Ref. # 319433-029\r\nSYSTEM PROGRAMMING FOR INTEL® AVX-512",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6f6b2948-7be5-4393-ac79-5cd55102a187.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=793203be4300ef427881254a2bc45a20daf6ac59308bf0b3391005f652987c74",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 404
      },
      {
        "segments": [
          {
            "segment_id": "24cb3fa4-caec-4832-b20f-9bc71da0b46d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-1\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nCHAPTER 4\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.1 OVERVIEW SECTION\r\nThis chapter describes the details of the Intel® AVX-512 instruction encoding system. The AVX-512 Foundation \r\ninstructions described in Chapter 5 use a new prefix (called EVEX). Opmask instructions described in Chapter 5 are \r\nencoded using the VEX prefix. The EVEX prefix has some parts resembling the instruction encoding scheme using \r\nthe VEX prefix, and many other capabilities not available with the VEX prefix. The EVEX encoding architecture also \r\napplies to other 512-bit instructions described in Chapter 5.\r\nThe significant feature differences between EVEX and VEX are summarized below.\r\n• EVEX is a 4-Byte prefix (the first byte must be 62H); VEX is either a 2-Byte (C5H is the first byte) or 3-Byte \r\n(C4H is the first byte) prefix.\r\n• EVEX prefix can encode 32 vector registers (XMM/YMM/ZMM) in 64-bit mode.\r\n• EVEX prefix can encode an opmask register for conditional processing or selection control in EVEX-encoded \r\nvector instructions; opmask instructions, whose source/destination operands are opmask registers and treat \r\nthe content of an opmask register as a single value, are encoded using the VEX prefix.\r\n• EVEX memory addressing with disp8 form uses a compressed disp8 encoding scheme to improve encoding \r\ndensity of the instruction byte stream.\r\n• EVEX prefix can encode functionality that are specific to instruction classes (e.g. packed instruction with \r\n“load+op” semantic can support embedded broadcast functionality, floating-point instruction with rounding \r\nsemantic can support static rounding functionality, floating-point instruction with non-rounding arithmetic \r\nsemantic can support “suppress all exceptions” functionality).\r\n4.2 INSTRUCTION FORMAT AND EVEX\r\nThe placement of the EVEX prefix in an IA instruction is represented in Figure 4-1:\r\nThe EVEX prefix is a 4-byte prefix, with the first two bytes derived from unused encoding form of the 32-bit-mode\u0002only BOUND instruction. The layout of the EVEX prefix is shown in Figure 4-2. The first byte must be 62H, followed \r\nby three payload bytes, denoted as P0, P1, and P2 individually or collectively as P[23:0] (see Figure 4-2).\r\nFigure 4-1. AVX-512 Instruction Format and the EVEX Prefix\r\n[Prefixes] EVEX Opcode ModR/M [SIB] [Disp32] [Immediate]\r\n# of bytes: 4 1 1 1 41\r\n[Disp8*N]\r\n1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/24cb3fa4-caec-4832-b20f-9bc71da0b46d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6bd23580cf0a6b18709ca9a7047aa516852995f2439cddc92a2507b99e7c536",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "7dde01e1-4d47-48dc-896a-e36d6e02b905",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "4-2 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nThe bit fields in P[23:0] are divided into the following functional groups (Table 4-1 provides a tabular summary):\r\n• Reserved bits: P[3:2] must be 0, otherwise #UD.\r\n• Fixed-value bit: P[10] must be 1, otherwise #UD.\r\n• Compressed legacy prefix/escape bytes: P[1:0] is identical to the lowest 2 bits of VEX.mmmmm; P[9:8] is \r\nidentical to VEX.pp.\r\n• Operand specifier modifier bits for vector register, general purpose register, memory addressing: P[7:5] allows \r\naccess to the next set of 8 registers beyond the low 8 registers when combined with ModR/M register specifiers. \r\n• Operand specifier modifier bit for vector register: P[4] (or EVEX.R’) allows access to the high 16 vector register \r\nset when combined with P[7] and ModR/M.reg specifier; P[6] can also provide access to a high 16 vector \r\nregister when SIB or VSIB addressing are not needed.\r\n• Non-destructive source /vector index operand specifier: P[19] and P[14:11] encode the second source vector \r\nregister operand in a non-destructive source syntax, vector index register operand can access an upper 16 \r\nvector register using P[19].\r\n• Op-mask register specifiers: P[18:16] encodes op-mask register set k0-k7 in instructions operating on vector \r\nregisters.\r\nFigure 4-2. Bit Field Layout of the EVEX Prefix\r\nTable 4-1. EVEX Prefix Bit Field Functional Grouping\r\nNotation Bit field Group Position Comment\r\n-- Reserved P[3 : 2] Must be 0\r\n-- Fixed Value P[10] Must be 1\r\nEVEX.mm Compressed legacy escape P[1: 0] Identical to low two bits of VEX.mmmmm\r\nEVEX.pp Compressed legacy prefix P[9 : 8] Identical to VEX.pp\r\nEVEX.RXB Next-8 register specifier modifier P[7 : 5] Combine with ModR/M.reg, ModR/M.rm (base, index/vidx)\r\nEVEXR’ High-16 register specifier modifier P[4] Combine with EVEX.R and ModR/M.reg\r\nEVEXX High-16 register specifier modifier P[6] Combine with EVEX.B and ModR/M.rm, when SIB/VSIB absent\r\nEVEX.vvvv NDS register specifier P[14 : 11] Same as VEX.vvvv\r\nEVEXV’ High-16 NDS/VIDX register specifier P[19] Combine with EVEX.vvvv or when VSIB present\r\nEVEX.aaa Embedded opmask register specifier P[18 : 16]\r\nEVEX.W Osize promotion/Opcode extension P[15]\r\nEVEX.z Zeroing/Merging P[23]\r\nEVEX.b Broadcast/RC/SAE Context P[20]\r\nEVEX.L’L Vector length/RC P[22 : 21]\r\nEVEX 62H P0 P1 P2\r\nP0\r\n765432 0 1\r\nR X B R’ 0 0 m m\r\nP1\r\n765432 0 1\r\nWv v v v 1 p p\r\nP2\r\n765432 0 1\r\nz L’ L b V’ a a a\r\nP[7:0]\r\nP[15:8]\r\nP[23:16]",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/7dde01e1-4d47-48dc-896a-e36d6e02b905.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=45b851b2590e0cee4a173db2dab6b0d88e01b66d6168a122c05cc6ac387d79af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 387
      },
      {
        "segments": [
          {
            "segment_id": "8bc1edec-21fb-4441-8570-8bf20fffb265",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-3\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n• EVEX.W: P[15] is similar to VEX.W which serves either as opcode extension bit or operand size promotion to \r\n64-bit in 64-bit mode.\r\n• Vector destination merging/zeroing: P[23] encodes the destination result behavior which either zeroes the \r\nmasked elements or leave masked element unchanged.\r\n• Broadcast/Static-rounding/SAE context bit: P[20] encodes multiple functionality, which differs across different \r\nclasses of instructions and can affect the meaning of the remaining field (EVEX.L’L). The functionality for the \r\nfollowing instruction classes are:\r\n— Broadcasting a single element across the destination vector register: this applies to the instruction class \r\nwith Load+Op semantic where one of the source operand is from memory. \r\n— Redirect L’L field (P[22:21]) as static rounding control for floating-point instructions with rounding \r\nsemantic. Static rounding control overrides MXCSR.RC field and implies “Suppress all exceptions” (SAE).\r\n— Enable SAE for floating -point instructions with arithmetic semantic that is not rounding.\r\n— For instruction classes outside of the afore-mentioned three classes, setting EVEX.b will cause #UD.\r\n• Vector length/rounding control specifier: P[22:21] can server one of three functionality:\r\n— vector length information for packed vector instructions, \r\n— ignored for instructions operating on vector register content as a single data element,\r\n— rounding control for floating-point instructions that have a rounding semantic and whose source and \r\ndestination operands are all vector registers.\r\n4.3 REGISTER SPECIFIER ENCODING AND EVEX\r\nEVEX-encoded instruction can access 8 opmask registers, 16 general-purpose registers and 32 vector registers in \r\n64-bit mode (8 general-purpose registers and 8 vector registers in non-64-bit modes). EVEX-encoding can support \r\ninstruction syntax that access up to 4 instruction operands. Normal memory addressing modes and VSIB memory \r\naddressing are supported with EVEX prefix encoding. The mapping of register operands used by various instruction \r\nsyntax and memory addressing in 64-bit mode are shown in Table 4-2. Opmask register encoding is described in \r\nSection 4.3.1.\r\nTable 4-2. 32-Register Support in 64-bit Mode Using EVEX with Embedded REX Bits\r\n41\r\nNOTES:\r\n1. Not applicable for accessing general purpose registers.\r\n3 [2:0] Reg. Type Common Usages \r\nREG EVEX.R’ REX.R modrm.reg GPR, Vector Destination or Source\r\nNDS/NDD EVEX.V’ EVEX.vvvv GPR, Vector 2ndSource or Destination\r\nRM EVEX.X EVEX.B modrm.r/m GPR, Vector !st Source or Destination\r\nBASE 0 EVEX.B modrm.r/m GPR memory addressing\r\nINDEX 0 EVEX.X sib.index GPR memory addressing\r\nVIDX EVEX.V’ EVEX.X sib.index Vector VSIB memory addressing\r\nIS4 Imm8[3] Imm8[7:4] Vector 3rd Source",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/8bc1edec-21fb-4441-8570-8bf20fffb265.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=964757678627517ae9d3ab0993aac0374b8cba8fc110df7c0b3fa8e7ddf5f9bf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 396
      },
      {
        "segments": [
          {
            "segment_id": "9b9d1252-1948-47af-a4b3-50a32820f7b2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "4-4 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nThe mapping of register operands used by various instruction syntax and memory addressing in 32-bit modes are \r\nshown in Table 4-3.\r\n4.3.1 Opmask Register Encoding\r\nThere are eight opmask registers, k0-k7. Opmask register encoding falls into two categories:\r\n• Opmask registers that are the source or destination operands of an instruction treating the content of opmask \r\nregister as a scalar value, are encoded using the VEX prefix scheme. It can support up to three operands using \r\nstandard modR/M byte’s reg field and rm field and VEX.vvvv. Such a scalar opmask instruction does not support \r\nconditional update of the destination operand.\r\n• An opmask register providing conditional processing and/or conditional update of the destination register of a \r\nvector instruction is encoded using EVEX.aaa field (see Section 4.4).\r\n• An opmask register serving as the destination or source operand of a vector instruction is encoded using \r\nstandard modR/M byte’s reg field and rm fields.\r\n4.4 MASKING SUPPORT IN EVEX\r\nEVEX can encode an opmask register to conditionally control per-element computational operation and updating of \r\nresult of an instruction to the destination operand. The predicate operand is known as the opmask register. The \r\nEVEX.aaa field, P[18:16] of the EVEX prefix, is used to encode one out of a set of eight 64-bit architectural regis\u0002ters. Note that from this set of 8 architectural registers, only k1 through k7 can be addressed as predicate oper\u0002ands. k0 can be used as a regular source or destination but cannot be encoded as a predicate operand. \r\nAVX-512 instructions support two types of masking with EVEX.z bit (P[23]) controlling the type of masking: \r\n• Merging-masking, which is the default type of masking for EVEX-encoded vector instructions, preserves the old \r\nvalue of each element of the destination where the corresponding mask bit has a 0. It corresponds to the case \r\nof EVEX.z = 0.\r\nTable 4-3. EVEX Encoding Register Specifiers in 32-bit Mode \r\n[2:0] Reg. Type Common Usages \r\nREG modrm.reg GPR, Vector Dest or Source\r\nNDS/NDD EVEX.vvv GPR, Vector 2ndSource or Dest\r\nRM modrm.r/m GPR, Vector !st Source or Dest\r\nBASE modrm.r/m GPR memory addressing\r\nINDEX sib.index GPR memory addressing\r\nVIDX sib.index Vector VSIB memory addressing\r\nIS4 Imm8[7:5] Vector 3rd Source\r\nTable 4-4. Opmask Register Specifier Encoding\r\n[2:0] Register Access Common Usages \r\nREG modrm.reg k0-k7 Source\r\nNDS VEX.vvv k0-k7 2ndSource \r\nRM modrm.r/m k0-7 !st Source \r\n{k1} EVEX.aaa k01-k7\r\nNOTES:\r\n1. instructions that overwrite the conditional mask in opmask do not permit using k0 as\r\nthe embedded mask.\r\nOpmask",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9b9d1252-1948-47af-a4b3-50a32820f7b2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c72aefcb5ca37757230219dad2785ab380f5d8f1a346af2c367ac944b0adcf39",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 416
      },
      {
        "segments": [
          {
            "segment_id": "fc17263b-75e2-4c99-a64a-5e428e81b202",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-5\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n• Zeroing-masking, is enabled by having the EVEX.z bit set to 1. In this case, an element of the destination is set \r\nto 0 when the corresponding mask bit has a 0 value. \r\nAVX-512 Foundation instructions can be divided in three different groups:\r\n• Instructions which support “zeroing-masking”.\r\n• Also allow merging-masking.\r\n• Instructions which require aaa = 000.\r\n• Do not allow any form of masking.\r\n• Instructions which allow merging-masking but do not allow zeroing-masking\r\n• Require EVEX.z to be set to 0 \r\n• This group is mostly composed of instructions that write to memory.\r\n• Instructions which require aaa <> 000 do not allow EVEX.z to be set to 1.\r\n• Allow merging-masking and do not allow zeroing-masking, e.g., gather instructions.\r\n4.5 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 4-5 and Table 4-6 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 4-5 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword (see Section 4.7). \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 4-6. Table 4-6 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 4-6. Instruction \r\nclassified in Table 4-6 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype abbreviation will be referenced in the instruction operand encoding table in the reference page of \r\neach instruction, providing the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 4-5. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull Vector \r\n(FV)\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf Vector \r\n(HV)\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/fc17263b-75e2-4c99-a64a-5e428e81b202.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ce85856df11fb8bb64d258950b583132dec0930686bac11eccbfc705197403af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "fc17263b-75e2-4c99-a64a-5e428e81b202",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-5\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n• Zeroing-masking, is enabled by having the EVEX.z bit set to 1. In this case, an element of the destination is set \r\nto 0 when the corresponding mask bit has a 0 value. \r\nAVX-512 Foundation instructions can be divided in three different groups:\r\n• Instructions which support “zeroing-masking”.\r\n• Also allow merging-masking.\r\n• Instructions which require aaa = 000.\r\n• Do not allow any form of masking.\r\n• Instructions which allow merging-masking but do not allow zeroing-masking\r\n• Require EVEX.z to be set to 0 \r\n• This group is mostly composed of instructions that write to memory.\r\n• Instructions which require aaa <> 000 do not allow EVEX.z to be set to 1.\r\n• Allow merging-masking and do not allow zeroing-masking, e.g., gather instructions.\r\n4.5 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 4-5 and Table 4-6 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 4-5 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword (see Section 4.7). \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 4-6. Table 4-6 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 4-6. Instruction \r\nclassified in Table 4-6 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype abbreviation will be referenced in the instruction operand encoding table in the reference page of \r\neach instruction, providing the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 4-5. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull Vector \r\n(FV)\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf Vector \r\n(HV)\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/fc17263b-75e2-4c99-a64a-5e428e81b202.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ce85856df11fb8bb64d258950b583132dec0930686bac11eccbfc705197403af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "7a276e40-d2d8-47b9-a96c-514198df994c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "4-6 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.6 EVEX ENCODING OF BROADCAST/ROUNDING/SAE SUPPORT\r\nEVEX.b can provide three types of encoding context, depending on the instruction classes:\r\n• Embedded broadcasting of one data element from a source memory operand to the destination for vector \r\ninstructions with “load+op” semantic.\r\n• Static rounding control overriding MXCSR.RC for floating-point instructions with rounding semantic.\r\n• “Suppress All exceptions” (SAE) overriding MXCSR mask control for floating-point arithmetic instructions that \r\ndo not have rounding semantic.\r\n4.6.1 Embedded Broadcast Support in EVEX\r\nEVEX encodes an embedded broadcast functionality that is supported on many vector instructions with 32-bit \r\n(double word or single-precision floating-point) and 64-bit data elements, and when the source operand is from \r\nmemory. EVEX.b (P[20]) bit is used to enable broadcast on load-op instructions. When enabled, only one element \r\nis loaded from memory and broadcasted to all other elements instead of loading the full memory size. \r\nThe following instruction classes do not support embedded broadcasting:\r\n• Instructions with only one scalar result is written to the vector destination.\r\n• Instructions with explicit broadcast functionality provided by its opcode.\r\n• Instruction semantic is a pure load or a pure store operation.\r\n4.6.2 Static Rounding Support in EVEX\r\nStatic rounding control embedded in the EVEX encoding system applies only to register-to-register flavor of \r\nfloating-point instructions with rounding semantic at two distinct vector lengths: (i) scalar, (ii) 512-bit. In both \r\nTable 4-6. EVEX DISP8*N For Instructions Not Affected by Embedded Broadcast\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nFull Vector Mem (FVM) N/A N/A 16 32 64 Load/store or subDword full vector\r\nTuple1 Scalar (T1S)\r\n8bit N/A 1 1 1\r\n1Tuple less than Full Vector\r\n16bit N/A 2 2 2\r\n32bit 0 4 4 4\r\n64bit 1 8 8 8\r\nTuple1 Fixed (T1F)\r\n32bit N/A 4 4 4 1 Tuple memsize not affected by \r\n64bit N/A 8 8 8 EVEX.W\r\nTuple2 (T2)\r\n32bit 0 8 8 8\r\nBroadcast (2 elements) 64bit 1 NA 16 16\r\nTuple4 (T4)\r\n32bit 0 NA 16 16\r\nBroadcast (4 elements) 64bit 1 NA NA 32\r\nTuple8 (T8) 32bit 0 NA NA 32 Broadcast (8 elements) \r\nHalf Mem (HVM) N/A N/A 8 16 32 SubQword Conversion\r\nQuarterMem (QVM) N/A N/A 4 8 16 SubDword Conversion\r\nOctMem (OVM) N/A N/A 2 4 8 SubWord Conversion\r\nMem128 (M128) N/A N/A 16 16 16 Shift count from memory\r\nMOVDDUP (DUP) N/A N/A 8 32 64 VMOVDDUP",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/7a276e40-d2d8-47b9-a96c-514198df994c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0953d2e296642e74c6578a3d1c698468d565b9bf05cc64fc710588ee01c8d2cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 404
      },
      {
        "segments": [
          {
            "segment_id": "30b6a570-7a13-483c-942f-6c07a8f926d4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-7\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\ncases, the field EVEX.L’L expresses rounding mode control overriding MXCSR.RC if EVEX.b is set. When EVEX.b is \r\nset, “suppress all exceptions” is implied. The processor behaves as if all MXCSR masking controls are set, and none \r\nof the MXCSR flags will be updated.\r\n4.6.3 SAE Support in EVEX\r\nThe EVEX encoding system allows arithmetic floating-point instructions without rounding semantic to be encoded \r\nwith the SAE attribute. This capability applies to scalar and 512-bit vector lengths, register-to-register only, by \r\nsetting EVEX.b. When EVEX.b is set, “suppress all exceptions” is implied. The processor behaves as if all MXCSR \r\nmasking controls are set, and none of the MXCSR flags will be updated.\r\n4.6.4 Vector Length Orthogonality \r\nThe architecture of EVEX encoding scheme can support SIMD instructions operating at multiple vector lengths. \r\nMany AVX-512 Foundation instructions operate at 512-bit vector length. The vector length of EVEX encoded vector \r\ninstructions are generally determined using the L’L field in EVEX prefix, except for 512-bit floating-point, reg-reg \r\ninstructions with rounding semantic. The table below shows the vector length corresponding to various values of \r\nthe L’L bits. When EVEX is used to encode scalar instructions, L’L is generally ignored.\r\nWhen EVEX.b bit is set for a register-register instructions with floating-point rounding semantic, the same two bits \r\nP2[6:5] specifies rounding mode for the instruction, with implied SAE behavior. The mapping of different instruc\u0002tion classes relative to the embedded broadcast/rounding/SAE control and the EVEX.L’L fields are summarized in \r\nTable 4-7. \r\n4.7 #UD EQUATIONS FOR EVEX\r\nInstructions encoded using EVEX can face three types of UD conditions: state dependent, opcode independent and \r\nopcode dependent.\r\n4.7.1 State Dependent #UD\r\nIn general, attempts of execute an instruction, which required OS support for incremental extended state compo\u0002nent, will #UD if required state components were not enabled by OS. Table 4-8 lists instruction categories with \r\nrespect to required processor state components. Attempts to execute a given category of instructions while \r\nenabled states were less than the required bit vector in XCR0 shown in Table 4-8 will cause #UD.\r\nTable 4-7. EVEX Embedded Broadcast/Rounding/SAE and Vector Length on Vector Instructions\r\nPosition P2[4] P2[6:5] P2[6:5]\r\nBroadcast/Rounding/SAE Context EVEX.b EVEX.L’L EVEX.RC\r\nReg-reg, FP Instructions w/ rounding semantic Enable static rounding \r\ncontrol (SAE implied)\r\nVector length Implied \r\n(512 bit or scalar)\r\n00b: SAE + RNE\r\n01b: SAE + RD\r\n10b: SAE + RU\r\n11b: SAE + RZ\r\nFP Instructions w/o rounding semantic, can cause #XF SAE control 00b: 128-bit\r\n01b: 256-bit\r\n10b: 512-bit\r\n11b: Reserved (#UD)\r\nNA\r\nLoad+op Instructions w/ memory source Broadcast Control NA\r\nOther Instructions (\r\nExplicit Load/Store/Broadcast/Gather/Scatter)\r\nMust be 0 (otherwise \r\n#UD)\r\nNA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/30b6a570-7a13-483c-942f-6c07a8f926d4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8df27f349b8d2dd2f5da32c1bd1f3d8dab667e5792ec9ec41ee4f439ec4168fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 435
      },
      {
        "segments": [
          {
            "segment_id": "5373d908-8757-4074-97db-6f83d0f89483",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "4-8 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.7.2 Opcode Independent #UD\r\nA number of bit fields in EVEX encoded instruction must obey mode-specific but opcode-independent patterns \r\nlisted in Table 4-9:\r\n4.7.3 Opcode Dependent #UD\r\nThis section describes legal values for the rest of the EVEX bit fields. Table 4-10 lists the #UD conditions of EVEX \r\nprefix bit fields which encodes or modifies register operands.\r\nTable 4-8. OS XSAVE Enabling Requirements of Instruction Categories\r\nInstruction Categories Vector Register State Access Required XCR0 Bit Vector [7:0]\r\nLegacy SIMD prefix encoded Instructions (e.g SSE) XMM xxxxxx11b\r\nVEX-encoded instructions operating on YMM YMM xxxxx111b\r\nEVEX-encoded 128-bit instructions ZMM 111xx111b\r\nEVEX-encoded 256-bit instructions ZMM 111xx111b\r\nEVEX-encoded 512-bit instructions ZMM 111xx111b\r\nVEX-encoded instructions operating on opmask k-reg xx1xxx11b\r\nTable 4-9. Opcode Independent, State Dependent EVEX Bit Fields\r\nPosition Notation 64-bit #UD Non-64-bit #UD\r\nP[3 : 2] -- if > 0 if > 0\r\nP[10] -- if 0 if 0\r\nP[1: 0] EVEX.mm if 00b if 00b\r\nP[7 : 6] EVEX.RX None (valid) None (BOUND if EVEX.RX != 11b)\r\nTable 4-10. #UD Conditions of Operand-Encoding EVEX Prefix Bit Fields \r\nNotation Position Operand Encoding 64-bit #UD Non-64-bit #UD\r\nEVEX.R P[7] ModRM.reg encodes k-reg if EVEX.R = 0 None (BOUND if \r\nEVEX.RX != 11b) ModRM.reg is opcode extension None (ignored)\r\nModRM.reg encodes all other registers None (valid)\r\nEVEX.X P[6] ModRM.r/m encodes ZMM/YMM/XMM None (valid)\r\nModRM.r/m encodes k-reg or GPR None (ignored)\r\nModRM.r/m without SIB/VSIB None (ignored)\r\nModRM.r/m with SIB/VSIB None (valid)\r\nEVEX.B P[5] ModRM.r/m encodes k-reg None (ignored) None (ignored)\r\nModRM.r/m encodes other registers None (valid)\r\nModRM.r/m base present None (valid)\r\nModRM.r/m base not present None (ignored)\r\nEVEXR’ P[4] ModRM.reg encodes k-reg or GPR if 0 None (ignored)\r\nModRM.reg is opcode extension None (ignored)\r\nModRM.reg encodes ZMM/YMM/XMM None (valid)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/5373d908-8757-4074-97db-6f83d0f89483.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6998ea184994ab364af58c4b784ef3decd4c66a003a0043989be8a7ca58479ad",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 291
      },
      {
        "segments": [
          {
            "segment_id": "826ad72f-f0ce-4857-b37f-9deed34b737b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-9\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nTable 4-11 lists the #UD conditions of instruction encoding of opmask register using EVEX.aaa and EVEX.z\r\nTable 4-12 lists the #UD conditions of EVEX bit fields that depends on the context of EVEX.b.\r\n4.8 DEVICE NOT AVAILABLE\r\nEVEX-encoded instructions follow the same rules when it comes to generating #NM (Device Not Available) excep\u0002tion. In particular, it is generated when CR0.TS[bit 3]= 1.\r\nEVEX.vvvv P[14 : 11] vvvv encodes ZMM/YMM/XMM None (valid) None (valid)\r\nP[14] ignored\r\notherwise if != 1111b if != 1111b\r\nEVEXV’ P[19] encodes ZMM/YMM/XMM None (valid) if 0\r\notherwise if 0 if 0\r\nTable 4-11. #UD Conditions of Opmask Related Encoding Field \r\nNotation Position Operand Encoding 64-bit #UD Non-64-bit #UD\r\nEVEX.aaa P[18 : 16] instructions do not use opmask for conditional processing1\r\nNOTES:\r\n1. E.g. VBROADCASTMxxx, VPMOVM2x, VPMOVx2M\r\nif aaa != 000b if aaa != 000b\r\nopmask used as conditional processing mask and updated \r\nat completion2\r\n2. E.g. Gather/Scatter family\r\nif aaa = 000b if aaa = 000b;\r\nopmask used as conditional processing None (valid3)\r\n3. aaa can take any value. A value of 000 indicates that there is no masking on the instruction; in this case, all\r\nelements will be processed as if there was a mask of ‘all ones’ regardless of the actual value in K0.\r\nNone (valid1)\r\nEVEX.z P[23] vector instruction using opmask as source or destination4\r\n4. E.g. VFPCLASSPD/PS, VCMPB/D/Q/W family, VPMOVM2x, VPMOVx2M\r\nif EVEX.z != 0 if EVEX.z != 0\r\nstore instructions or gather/scatter instructions if EVEX.z != 0 if EVEX.z != 0\r\ninstruction supporting conditional processing mask with \r\nEVEX.aaa = 000b\r\nif EVEX.z != 0 if EVEX.z != 0\r\nTable 4-12. #UD Conditions Dependent on EVEX.b Context\r\nNotation Position Operand Encoding 64-bit #UD Non-64-bit #UD\r\nEVEX.L’Lb P[22 : 20] reg-reg, FP instructions with rounding semantic None (valid1)\r\nNOTES:\r\n1. L’L specifies rounding control, see Table 4-7, supports {er} syntax.\r\nNone (valid1)\r\nother reg-reg, FP instructions that can cause #XF None (valid2)\r\n2. L’L specifies vector length, see Table 4-7, supports {sae} syntax.\r\nNone (valid2)\r\nother reg-mem instructions in Table 4-5 None (valid3)\r\n3. L’L specifies vector length, see Table 4-7, supports embedded broadcast syntax\r\nNone (valid3)\r\nother instruction classes4 in Table 4-6\r\n4. L’L specifies either vector length or ignored.\r\nif EVEX.b > 0 if EVEX.b > 0\r\nTable 4-10. #UD Conditions of Operand-Encoding EVEX Prefix Bit Fields (Continued)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/826ad72f-f0ce-4857-b37f-9deed34b737b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6d2b1e07ba041d9a4ff3bc1ba3baa8486b7d1d8cdd3da3ca1ad2ed3c6bcd2f45",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 395
      },
      {
        "segments": [
          {
            "segment_id": "98fe1d58-5e4f-4580-8b4e-db1c508bf3c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "4-10 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.9 SCALAR INSTRUCTIONS\r\nEVEX-encoded scalar SIMD instructions can access up to 32 registers in 64-bit mode. Scalar instructions support \r\nmasking (using the least significant bit of the opmask register), but broadcasting is not supported. \r\n4.10 EXCEPTION CLASSIFICATIONS OF EVEX-ENCODED INSTRUCTIONS\r\nThe exception behavior of EVEX-encoded instructions can be classified into the classes shown in the rest of this \r\nsection. The classification of EVEX-encoded instructions follow a similar framework as those of AVX and AVX2 \r\ninstructions using the VEX prefix. Exception types for EVEX-encoded instructions are named in the style of\r\n“E##” or with a suffix “E##XX”. The “##” designation generally follows that of AVX/AVX2 instructions. The \r\nmajority of EVEX encoded instruction with “Load+op” semantic supports memory fault suppression, which is repre\u0002sented by E##. The instructions with “Load+op” semantic but do not support fault suppression are named \r\n“E##NF”. A summary table of exception classes by class names are shown below.\r\nTable 4-13. EVEX-Encoded Instruction Exception Class Summary\r\nException Class Instruction set Mem arg (#XM)\r\nType E1 Vector Moves/Load/Stores explicitly aligned, w/ fault suppression none\r\nType E1NF Vector Non-temporal Stores explicitly aligned, no fault suppression none\r\nType E2 FP Vector Load+op Support fault suppression yes\r\nType E2NF FP Vector Load+op No fault suppression yes\r\nType E3 FP Scalar/Partial Vector, Load+Op Support fault suppression yes\r\nType E3NF FP Scalar/Partial Vector, Load+Op No fault suppression yes\r\nType E4 Integer Vector Load+op Support fault suppression no\r\nType E4NF Integer Vector Load+op No fault suppression no\r\nType E5 Legacy-like Promotion Varies, Support fault suppression no\r\nType E5NF Legacy-like Promotion Varies, No fault suppression no\r\nType E6 Post AVX Promotion Varies, w/ fault suppression no\r\nType E6NF Post AVX Promotion Varies, no fault suppression no\r\nType E7NM register-to-register op none none\r\nType E9NF Miscellaneous 128-bit Vector-length Specific, no fault suppression none\r\nType E10 Non-XF Scalar Vector Length ignored, w/ fault suppression none\r\nType E10NF Non-XF Scalar Vector Length ignored, no fault suppression none\r\nType E11 VCVTPH2PS Half Vector Length, w/ fault suppression yes\r\nType E11NF VCVTPS2PH Half Vector Length, no fault suppression yes\r\nType E12 Gather and Scatter Family VSIB addressing, w/ fault suppression none\r\nType E12NP Gather and Scatter Prefetch Family VSIB addressing, w/o page fault none",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/98fe1d58-5e4f-4580-8b4e-db1c508bf3c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d8efe0dea0fee29ee1b9079b99bc49838f63f244d5d2a65b6aeccacb77035667",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 369
      },
      {
        "segments": [
          {
            "segment_id": "a679f53d-4d17-4fcc-b31a-257c4875c274",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-11\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nTable 4-14 lists EVEX-encoded instruction mnemonic by exception classes.\r\nTable 4-14. EVEX Instructions in each Exception Class\r\nException Class Instruction\r\nType E1 VMOVAPD, VMOVAPS, VMOVDQA32, VMOVDQA64\r\nType E1NF VMOVNTDQ, VMOVNTDQA, VMOVNTPD, VMOVNTPS\r\nType E2\r\nVADDPD, VADDPS, VCMPPD, VCMPPS, VCVTDQ2PS, VCVTPD2DQ, VCVTPD2PS, VCVTPS2DQ, VCVTTPD2DQ, \r\nVCVTTPS2DQ, VDIVPD, VDIVPS, VFMADDxxxPD, VFMADDxxxPS, VFMSUBADDxxxPD, VFMSUBADDxxxPS, \r\nVFMSUBxxxPD, VFMSUBxxxPS, VFNMADDxxxPD, VFNMADDxxxPS, VFNMSUBxxxPD, VFNMSUBxxxPS, VMAXPD, \r\nVMAXPS, VMINPD, VMINPS, VMULPD, VMULPS, VSQRTPD, VSQRTPS, VSUBPD, VSUBPS\r\nVCVTPD2QQ, VCVTPD2UQQ, VCVTPD2UDQ, VCVTPS2UDQS, VCVTQQ2PD, VCVTQQ2PS, VCVTTPD2DQ, \r\nVCVTTPD2QQ, VCVTTPD2UDQ, VCVTTPD2UQQ, VCVTTPS2DQ, VCVTTPS2UDQ, VCVTUDQ2PS, VCVTUQQ2PD, \r\nVCVTUQQ2PS, VFIXUPIMMPD, VFIXUPIMMPS, VGETEXPPD, VGETEXPPS, VGETMANTPD, VGETMANTPS, VRANGEPD, \r\nVRANGEPS, VREDUCEPD, VREDUCEPS, VRNDSCALEPD, VRNDSCALEPS, VSCALEFPD, VSCALEFPS, VRCP28PD, \r\nVRCP28PS, VRSQRT28PD, VRSQRT28PS\r\nType E3\r\nVADDSD, VADDSS, VCMPSD, VCMPSS, VCVTPS2PD, VCVTSD2SS, VCVTSS2SD, VDIVSD, VDIVSS, VMAXSD, VMAXSS, \r\nVMINSD, VMINSS, VMULSD, VMULSS, VSQRTSD, VSQRTSS, VSUBSD, VSUBSS\r\nVCVTPS2QQ, VCVTPS2UQQ, VCVTTPS2QQ, VCVTTPS2UQQ, VFMADDxxxSD, VFMADDxxxSS, VFMSUBxxxSD, \r\nVFMSUBxxxSS, VFNMADDxxxSD, VFNMADDxxxSS, VFNMSUBxxxSD, VFNMSUBxxxSS, VFIXUPIMMSD, \r\nVFIXUPIMMSS, VGETEXPSD, VGETEXPSS, VGETMANTSD, VGETMANTSS, VRANGESD, VRANGESS, VREDUCESD, \r\nVREDUCESS, VRNDSCALESD, VRNDSCALESS, VSCALEFSD, VSCALEFSS, VRCP28SD, VRCP28SS, VRSQRT28SD, \r\nVRSQRT28SS\r\nType E3NF\r\nVCOMISD, VCOMISS, VCVTSD2SI, VCVTSI2SD, VCVTSI2SS, VCVTSS2SI, VCVTTSD2SI, VCVTTSS2SI, VUCOMISD, \r\nVUCOMISS\r\nVCVTSD2USI, VCVTTSD2USI, VCVTSS2USI, VCVTTSS2USI, VCVTUSI2SD, VCVTUSI2SS\r\nType E4\r\nVANDPD, VANDPS, VANDNPD, VANDNPS, VORPD, VORPS, VPABSD, VPABSQ, VPADDD, VPADDQ, VPANDD, VPANDQ, \r\nVPANDND, VPANDNQ, VPCMPEQD, VPCMPEQQ,VPCMPGTD, VPCMPGTQ, VPMAXSD, VPMAXSQ, VPMAXUD, \r\nVPMAXUQ, VPMINSD, VPMINSQ,VPMINUDVPMINUQ, VPMULLD, VPMULLQ, VPMULUDQ, VPMULDQ, VPORD, VPORQ, \r\nVPSUBD, VPSUBQ, VPXORD, VPXORQ, VXORPD, VXORPS, VPSLLVD, VPSLLVQ,\r\nVBLENDMPD, VBLENDMPS, VPBLENDMD, VPBLENDMQ, VFPCLASSPD, VFPCLASSPSVPCMPD, VPCMPQ,VPCMPUD, \r\nVPCMPUQ, VPLZCNTD, VPLZCNTQ, VPROLD, VPROLQ, (VPSLLD, VPSLLQ, VPSRAD, VPSRAQ, VPSRLD, VPSRLQ)1, \r\nVPTERNLOGD, VPTERNLOGQ,VPTESTMD, VPTESTMQ,VPTESTNMD, VPTESTNMQ, VRCP14PD, VRCP14PS, \r\nVRSQRT14PD, VRSQRT14PS, VPCONFLICTD, VPCONFLICTQ, VPSRAVW, VPSRAVD, VPSRAVW, VPSRAVQ, \r\nVPMADD52LUQ, VPMADD52HUQ\r\nE4.nb2\r\nVMOVUPD, VMOVUPS, VMOVDQU8, VMOVDQU16, VMOVDQU32, VMOVDQU64, VPCMPB, VPCMPW, VPCMPUB, \r\nVPCMPUW, VEXPANDPD, VEXPANDPS, VPCOMPRESSD, VPCOMPRESSQ, VPEXPANDD, VPEXPANDQ, \r\nVCOMPRESSPD, VCOMPRESSPS, VPABSB, VPABSW, VPADDB, VPADDW, VPADDSB, VPADDSW, VPADDUSB, \r\nVPADDUSW, VPAVGB, VPAVGW, VPCMPEQB, VPCMPEQW, VPCMPGTB, VPCMPGTW, VPMAXSB, VPMAXSW, \r\nVPMAXUB, VPMAXUW, VPMINSB, VPMINSW, VPMINUB, VPMINUW, VPMULHRSW, VPMULHUW, VPMULHW, \r\nVPMULLW, VPSUBB, VPSUBW, VPSUBSB, VPSUBSW, VPTESTMB, VPTESTMW, VPTESTNMB, VPTESTNMW, VPSLLW, \r\nVPSRAW, VPSRLW, VPSLLVW, VPSRLVW\r\nType E4NF\r\nVPACKSSDW, VPACKUSDW VPSHUFD, VPUNPCKHDQ, VPUNPCKHQDQ, VPUNPCKLDQ, VPUNPCKLQDQ, VSHUFPD, \r\nVSHUFPS, VUNPCKHPD, VUNPCKHPS, VUNPCKLPD, VUNPCKLPS, VPERMD, VPERMPS, VPERMPD, VPERMQ, \r\nVALIGND, VALIGNQ, VPERMI2D, VPERMI2PS, VPERMI2PD, VPERMI2Q, VPERMT2D, VPERMT2PS, VPERMT2Q, \r\nVPERMT2PD, VPERMILPD, VPERMILPS, VSHUFI32X4, VSHUFI64X2, VSHUFF32X4, VSHUFF64X2, \r\nVPMULTISHIFTQB\r\nE4NF.nb2\r\nVDBPSADBW, VPACKSSWB, VPACKUSWB, VPALIGNR, VPMADDWD, VPMADDUBSW, VMOVSHDUP, VMOVSLDUP, \r\nVPSADBW, VPSHUFB, VPSHUFHW, VPSHUFLW, VPSLLDQ, VPSRLDQ, VPSLLW, VPSRAW, VPSRLW, (VPSLLD, \r\nVPSLLQ, VPSRAD, VPSRAQ, VPSRLD, VPSRLQ)3, VPUNPCKHBW, VPUNPCKHWD, VPUNPCKLBW, VPUNPCKLWD, \r\nVPERMW, VPERMI2W, VPERMT2W, VPERMB, VPERMI2B, VPERMT2B",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a679f53d-4d17-4fcc-b31a-257c4875c274.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b7bd4379eadbe178a61ce9362ac651b259b449003b2d83090ad5bb60798355df",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 377
      },
      {
        "segments": [
          {
            "segment_id": "bdf3ad0f-9903-470c-90b0-ef980a5d9765",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "4-12 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nType E5\r\nVCVTDQ2PD, PMOVSXBW, PMOVSXBW, PMOVSXBD, PMOVSXBQ, PMOVSXWD, PMOVSXWQ, PMOVSXDQ, \r\nPMOVZXBW, PMOVZXBD, PMOVZXBQ, PMOVZXWD, PMOVZXWQ, PMOVZXDQ\r\nVCVTUDQ2PD \r\nType E5NF VMOVDDUP\r\nType E6\r\nVBROADCASTSS, VBROADCASTSD, VBROADCASTF32X4, VBROADCASTI32X4, VPBROADCASTB, VPBROADCASTD, \r\nVPBROADCASTW, VPBROADCASTQ, \r\nVBROADCASTF32X2, VBROADCASTF32X4, VBROADCASTF64X2, VBROADCASTF32X8, VBROADCASTF64X4, \r\nVBROADCASTI32X2, VBROADCASTI32X4, VBROADCASTI64X2, VBROADCASTI32X8, VBROADCASTI64X4, \r\nVFPCLASSSD, VFPCLASSSS, VPMOVQB, VPMOVSQB, VPMOVUSQB, VPMOVQW, VPMOVSQW, VPMOVUSQW, \r\nVPMOVQD, VPMOVSQD, VPMOVUSQD, VPMOVDB, VPMOVSDB, VPMOVUSDB, VPMOVDW, VPMOVSDW, \r\nVPMOVUSDW\r\nType E6NF\r\nVEXTRACTF32X4, VEXTRACTF64X2, VEXTRACTF32X8, VINSERTF32X4, VINSERTF64X2, VINSERTF64X4, \r\nVINSERTF32X8, VINSERTI32X4, VINSERTI64X2, VINSERTI64X4, VINSERTI32X8, VEXTRACTI32X4, \r\nVEXTRACTI64X2, VEXTRACTI32X8, VEXTRACTI64X4, VPBROADCASTMB2Q, VPBROADCASTMW2D, VPMOVWB, \r\nVPMOVSWB, VPMOVUSWB\r\nType \r\nE7NM.1284\r\nVMOVLHPS, VMOVHLPS\r\nType E7NM. (VPBROADCASTD, VPBROADCASTQ, VPBROADCASTB, VPBROADCASTW)5, VPMOVM2B, VPMOVM2D, VPMOVM2Q, \r\nVPMOVM2W, VPMOVB2M, VPMOVD2M, VPMOVQ2M, VPMOVW2M\r\nType E9NF VEXTRACTPS, VINSERTPS, VMOVHPD, VMOVHPS, VMOVLPD, VMOVLPS, VMOVD, VMOVQ, VPEXTRB, VPEXTRD, \r\nVPEXTRW, VPEXTRQ, VPINSRB, VPINSRD, VPINSRW, VPINSRQ\r\nType E10 VMOVSD, VMOVSS, VRCP14SD, VRCP14SS, VRSQRT14SD, VRSQRT14SS,\r\nType E10NF (VCVTSI2SD, VCVTUSI2SD)6\r\nType E11 VCVTPH2PS, VCVTPS2PH\r\nType E12\r\nVGATHERDPS, VGATHERDPD, VGATHERQPS, VGATHERQPD, VPGATHERDD, VPGATHERDQ, VPGATHERQD, \r\nVPGATHERQQ, VPSCATTERDD, VPSCATTERDQ, VPSCATTERQD, VPSCATTERQQ, VSCATTERDPD, VSCATTERDPS, \r\nVSCATTERQPD, VSCATTERQPS\r\nType E12NP\r\n VGATHERPF0DPD, VGATHERPF0DPS, VGATHERPF0QPD, VGATHERPF0QPS, VGATHERPF1DPD, VGATHERPF1DPS, \r\nVGATHERPF1QPD, VGATHERPF1QPS, VSCATTERPF0DPD, VSCATTERPF0DPS, VSCATTERPF0QPD, \r\nVSCATTERPF0QPS, VSCATTERPF1DPD, VSCATTERPF1DPS, VSCATTERPF1QPD, VSCATTERPF1QPS\r\nNOTES:\r\n1. Operand encoding FVI tupletype with immediate.\r\n2. Embedded broadcast is not supported with the “.nb” suffix.\r\n3. Operand encoding M128 tupletype.\r\n4. #UD raised if EVEX.L’L !=00b (VL=128).\r\n5. The source operand is a general purpose register.\r\n6. W0 encoding only.\r\nTable 4-14. EVEX Instructions in each Exception Class(Continued)\r\nException Class Instruction",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/bdf3ad0f-9903-470c-90b0-ef980a5d9765.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9cbff36cc2624c9f2f88dbf8299a35085df1246398b69dc926a147af55c4c8d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 229
      },
      {
        "segments": [
          {
            "segment_id": "15bde02c-eb84-4559-9d1b-276e2de8bb8a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-13\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.1 Exceptions Type E1 and E1NF of EVEX-Encoded Instructions\r\nEVEX-encoded instructions with memory alignment restrictions, and supporting memory fault suppression follow \r\nexception class E1.\r\nTable 4-15. Type E1 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, \r\n#UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Avail\u0002able, #NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is in \r\na non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX X\r\nEVEX.512: Memory operand is not 64-byte aligned.\r\nEVEX.256: Memory operand is not 32-byte aligned.\r\nEVEX.128: Memory operand is not 16-byte aligned.\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault \r\n#PF(fault-code) X X X If fault suppression not set, and a page fault.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/15bde02c-eb84-4559-9d1b-276e2de8bb8a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b015846ba08595759cc22839b9f8e88f8636735182d54669ccb8f4461bec862d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 297
      },
      {
        "segments": [
          {
            "segment_id": "570d5e0e-5a8e-48a9-aa83-55f212f887b1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "4-14 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded instructions with memory alignment restrictions, but do not support memory fault suppression \r\nfollow exception class E1NF.\r\nTable 4-16. Type E1NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, \r\n#UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Avail\u0002able, #NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX X\r\nEVEX.512: Memory operand is not 64-byte aligned.\r\nEVEX.256: Memory operand is not 32-byte aligned.\r\nEVEX.128: Memory operand is not 16-byte aligned.\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to FFFFH.\r\nPage Fault \r\n#PF(fault-code) X X X For a page fault.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/570d5e0e-5a8e-48a9-aa83-55f212f887b1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6539cb68526b32833c070d7b0502018dbbcc77eebb8d5a0b93f32c738577f835",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 260
      },
      {
        "segments": [
          {
            "segment_id": "49062710-2d4b-4781-95d0-f5e6134b7613",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-15\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.2 Exceptions Type E2 of EVEX-Encoded Instructions\r\nEVEX-encoded vector instructions with arithmetic semantic follow exception class E2.\r\nTable 4-17. Type E2 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 8086\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, \r\n#UD\r\nX X If EVEX prefix present.\r\nX X X X If an unmasked SIMD floating-point exception and CR4.OSXMMEXCPT[bit 10] = 0. \r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Avail\u0002able, #NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is in a \r\nnon-canonical form.\r\nGeneral Protec\u0002tion, #GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the CS, \r\nDS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault \r\n#PF(fault-code) X X X If fault suppression not set, and a page fault.\r\nSIMD Floating\u0002point Exception, \r\n#XM\r\nXX XX If an unmasked SIMD floating-point exception, {sae} or {er} not set, and CR4.OSXMMEX\u0002CPT[bit 10] = 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/49062710-2d4b-4781-95d0-f5e6134b7613.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cb5a683776df0d698ec63e54ec5fc95380f0bc97974760b15c4fc3dab2599389",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 299
      },
      {
        "segments": [
          {
            "segment_id": "6f5d49e6-de8b-41cb-ae04-beba0785341f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 84,
            "page_width": 612,
            "page_height": 792,
            "content": "4-16 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.3 Exceptions Type E3 and E3NF of EVEX-Encoded Instructions\r\nEVEX-encoded scalar instructions with arithmetic semantic that support memory fault suppression follow exception \r\nclass E3.\r\nTable 4-18. Type E3 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X X X If an unmasked SIMD floating-point exception and CR4.OSXMMEXCPT[bit 10] = 0. \r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in \r\nthe CS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes \r\nor less is made while the current privilege level is 3.\r\nSIMD Floating-point \r\nException, #XM X X XX If an unmasked SIMD floating-point exception, {sae} or {er} not set, and CR4.OSX\u0002MMEXCPT[bit 10] = 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6f5d49e6-de8b-41cb-ae04-beba0785341f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2f0b0ffc12ce1f4851b4479991cce26295c04429e0925627a05722354a58c986",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 335
      },
      {
        "segments": [
          {
            "segment_id": "d2fff16c-8a8e-493c-88be-711575f46cbf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-17\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded scalar instructions with arithmetic semantic that do not support memory fault suppression follow \r\nexception class E3NF.\r\nTable 4-19. Type E3NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X EVEX prefix.\r\nX X X X If an unmasked SIMD floating-point exception and CR4.OSXMMEXCPT[bit 10] = 0. \r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF(fault\u0002code) X X X For a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or less is made while the current privilege level is 3.\r\nSIMD Floating-point \r\nException, #XM X X XX If an unmasked SIMD floating-point exception, {sae} or {er} not set, and CR4.OSX\u0002MMEXCPT[bit 10] = 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/d2fff16c-8a8e-493c-88be-711575f46cbf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d33a74c9618b76bfcbd73aa8978e35e0a9dc0b1e7274856825ae52b16ad7c278",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 296
      },
      {
        "segments": [
          {
            "segment_id": "0341e9d0-4f5d-41c1-b64f-2f92f5307b17",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 86,
            "page_width": 612,
            "page_height": 792,
            "content": "4-18 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.4 Exceptions Type E4 and E4NF of EVEX-Encoded Instructions\r\nEVEX-encoded vector instructions that cause no SIMD FP exception and support memory fault suppression follow \r\nexception class E4.\r\nTable 4-20. Type E4 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0 and in E4.nb subclass (see E4.nb entries in Table 4-14).\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in \r\nthe CS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/0341e9d0-4f5d-41c1-b64f-2f92f5307b17.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d79e44eff4ed178945405d8b764d6c1062e9b84560b8f66a2a551e2bb37ae7db",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 287
      },
      {
        "segments": [
          {
            "segment_id": "9bc836de-df66-42be-a434-f877943345ba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 87,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-19\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded vector instructions that do not cause SIMD FP exception nor support memory fault suppression \r\nfollow exception class E4NF.\r\nTable 4-21. Type E4NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0 and in E4NF.nb subclass (see E4NF.nb entries in Table 4-14).\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF(fault\u0002code) X X X For a page fault.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9bc836de-df66-42be-a434-f877943345ba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e501565aad09ece585d01c821e61e28437ff291f12f3879e77d1542274c959d5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 249
      },
      {
        "segments": [
          {
            "segment_id": "fcc4d362-3e5e-4721-971f-17156ce9dce9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 88,
            "page_width": 612,
            "page_height": 792,
            "content": "4-20 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.5 Exceptions Type E5 and E5NF\r\nEVEX-encoded scalar/partial-vector instructions that cause no SIMD FP exception and support memory fault \r\nsuppression follow exception class E5.\r\nTable 4-22. Type E5 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or \r\nless is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/fcc4d362-3e5e-4721-971f-17156ce9dce9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c4fec4864e5b07b4636af91f0bb937cb6eb4e838bc5e2e70ad1cdbc2c5a75ac9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "f73731ba-572e-47ed-8c71-b64adf858a92",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 89,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-21\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded scalar/partial vector instructions that do not cause SIMD FP exception nor support memory fault \r\nsuppression follow exception class E5NF.\r\nTable 4-23. Type E5NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X If an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF(fault\u0002code) X X X For a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or less is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f73731ba-572e-47ed-8c71-b64adf858a92.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=32b4978508185d5e77cee0c07779ef4e4306855465d2c439be387b3b16bf5f96",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 269
      },
      {
        "segments": [
          {
            "segment_id": "33361d68-3b7a-4bfa-a015-fb2e68835f8e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 90,
            "page_width": 612,
            "page_height": 792,
            "content": "4-22 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.6 Exceptions Type E6 and E6NF\r\nTable 4-24. Type E6 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nPage Fault #PF(fault\u0002code) X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X X\r\nFor 4 or 8 byte memory references if alignment checking is enabled and an \r\nunaligned memory reference of 8 bytes or less is made while the current privilege \r\nlevel is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/33361d68-3b7a-4bfa-a015-fb2e68835f8e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d9041679153df2a384389fbbaf36a908ed845c8e5598192ddfdb1dcf67a2ed80",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "92701b26-34bd-4e95-9b53-02dd36e6fa75",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-23\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded instructions that do not cause SIMD FP exception nor support memory fault suppression follow \r\nexception class E6NF.\r\nTable 4-25. Type E6NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nPage Fault #PF(fault\u0002code) X X For a page fault.\r\nAlignment Check \r\n#AC(0) X X\r\nFor 4 or 8 byte memory references if alignment checking is enabled and an \r\nunaligned memory reference of 8 bytes or less is made while the current privilege \r\nlevel is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/92701b26-34bd-4e95-9b53-02dd36e6fa75.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9822789ad244df39858acb8147e15af9b082e61a7148f09870969764e0e2b652",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 511
      },
      {
        "segments": [
          {
            "segment_id": "e856ab2e-ff52-497c-b716-0f6fdc25787a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "4-24 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.7 Exceptions Type E7NM\r\nEVEX-encoded instructions that cause no SIMD FP exception and do not reference memory follow exception class \r\nE7NM.\r\nTable 4-26. Type E7NM Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• Instruction specific EVEX.L’L restriction not met.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X If CR0.TS[bit 3]=1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/e856ab2e-ff52-497c-b716-0f6fdc25787a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a24be33e1bd4fea248db085cf2a8a12d463a4709ca26597f901758c067b3b3e",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "bfd0a837-3350-4c96-8c8b-6611ceee6ecf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-25\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.8 Exceptions Type E9 and E9NF\r\nEVEX-encoded vector or partial-vector instructions that do not cause no SIMD FP exception and support memory \r\nfault suppression follow exception class E9.\r\nTable 4-27. Type E9 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 00b (VL=128).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or \r\nless is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/bfd0a837-3350-4c96-8c8b-6611ceee6ecf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f58e7bd39f848968f23d74cd3835dd91b80ac28852c45ac47384db7b6b6a38a2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 464
      },
      {
        "segments": [
          {
            "segment_id": "a9660443-f36d-4fa1-b9b5-ca4696c4d0cd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "4-26 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded vector or partial-vector instructions that must be encoded with VEX.L’L = 0, do not cause SIMD FP \r\nexception nor support memory fault suppression follow exception class E9NF.\r\nTable 4-28. Type E9NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 00b (VL=128).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X If an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF(fault\u0002code) X X X For a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a9660443-f36d-4fa1-b9b5-ca4696c4d0cd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=61f46f87280d7d1821a4a3f533d8a41119e985d85926f4c8e51c7d2ef8819c86",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 272
      },
      {
        "segments": [
          {
            "segment_id": "65ba26d5-7699-4257-927e-51c8e9d13959",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-27\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.9 Exceptions Type E10 \r\nEVEX-encoded scalar instructions that ignore EVEX.L’L vector length encoding and do not cause no SIMD FP excep\u0002tion, support memory fault suppression follow exception class E10.\r\nTable 4-29. Type E10 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or less is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/65ba26d5-7699-4257-927e-51c8e9d13959.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=14601ae64ae5e2e33590b46e53afcde5ef298c01e376af80278df0acf1489c1a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 302
      },
      {
        "segments": [
          {
            "segment_id": "7563ce9c-8640-4869-ba7d-8bbe5a65bb65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "4-28 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded scalar instructions that must be encoded with VEX.L’L = 0, do not cause SIMD FP exception nor \r\nsupport memory fault suppression follow exception class E10NF.\r\nTable 4-30. Type E10NF Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD\r\nX X If EVEX prefix present.\r\nX X\r\nIf CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0)\r\nX If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF(fault\u0002code) X X X If fault suppression not set, and a page fault.\r\nAlignment Check \r\n#AC(0) X XX If alignment checking is enabled and an unaligned memory reference of 8 bytes or less is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/7563ce9c-8640-4869-ba7d-8bbe5a65bb65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a4f131f0b225d1911f33bb5d9ea22ce2bb57333c7e10b748ed3c5906d66d401c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 299
      },
      {
        "segments": [
          {
            "segment_id": "ee516792-7573-44ac-846b-37f08bef5264",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-29\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.10 Exception Type E11 (EVEX-only, mem arg no AC, floating-point exceptions)\r\nEVEX-encoded instructions that can cause SIMD FP exception, memory operand support fault suppression but do \r\nnot cause #AC follow exception class E11.\r\nTable 4-31. Type E11 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X If EVEX prefix present.\r\nX X If CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a EVEX prefix.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nDevice Not Available, \r\n#NM\r\nX X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X If fault suppression not set, and an illegal address in the SS segment.\r\nX If fault suppression not set, and a memory address referencing the SS segment is \r\nin a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX If fault suppression not set, and an illegal memory operand effective address in the \r\nCS, DS, ES, FS or GS segments.\r\nX If fault suppression not set, and the memory address is in a non-canonical form.\r\nX X If fault suppression not set, and any part of the operand lies outside the effective \r\naddress space from 0 to FFFFH.\r\nPage Fault #PF (fault\u0002code)X X X If fault suppression not set, and a page fault.\r\nSIMD Floating-Point \r\nException, #XM\r\nX X X X If an unmasked SIMD floating-point exception, {sae} not set, and CR4.OSXMMEX\u0002CPT[bit 10] = 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ee516792-7573-44ac-846b-37f08bef5264.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ce63483e9df5840c73be7d25ff7277368849bc0234e398c37cb63487da6f135e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "9ea1a69b-fd52-467c-bd39-c02c38280afb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "4-30 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.10.11 Exception Type E12 and E12NP (VSIB mem arg, no AC, no floating-point exceptions)\r\nTable 4-32. Type E12 Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X If EVEX prefix present.\r\nX X If CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\n• If vvvv != 1111b.\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a VEX prefix.\r\nX X X NA If address size attribute is 16 bit.\r\nX X X X If ModR/M.mod = ‘11b’.\r\nX X X X If ModR/M.rm != ‘100b’.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nX X X X If k0 is used (gather or scatter operation).\r\nX X X X If index = destination register (gather operation).\r\nDevice Not Available, \r\n#NM\r\nX X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF (fault\u0002code)X X X For a page fault.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/9ea1a69b-fd52-467c-bd39-c02c38280afb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e8981e9663289b99a07ca451c4c7cc3e2c3ed5c02e55d25d0f730f47a73a9977",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 289
      },
      {
        "segments": [
          {
            "segment_id": "6529f0ad-7867-48a4-b338-3c9b87c3937b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 99,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-31\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nEVEX-encoded prefetch instructions that do not cause #PF follow exception class E12NP.\r\nTable 4-33. Type E12NP Class Exception Conditions\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X If EVEX prefix present.\r\nX X If CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\n• Opmask encoding #UD condition of Table 4-11.\r\n• If EVEX.b != 0.\r\n• If EVEX.L’L != 10b (VL=512).\r\nX X X X If preceded by a LOCK prefix (F0H).\r\nX X If any REX, F2, F3, or 66 prefixes precede a VEX prefix.\r\nX X X NA If address size attribute is 16 bit.\r\nX X X X If ModR/M.mod = ‘11b’.\r\nX X X X If ModR/M.rm != ‘100b’.\r\nX X X X If any corresponding CPUID feature flag is ‘0’.\r\nX X X X If k0 is used (gather or scatter operation).\r\nDevice Not Available, \r\n#NM\r\nX X X X If CR0.TS[bit 3]=1.\r\nStack, SS(0) X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6529f0ad-7867-48a4-b338-3c9b87c3937b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7f5aa243ed58ef981db426ccd70b7e5c81b39d327b617a553162c826b83f4b9f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c5be337f-121d-4eac-b410-ba7c2d8364e7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 100,
            "page_width": 612,
            "page_height": 792,
            "content": "4-32 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\n4.11 EXCEPTION CLASSIFICATIONS OF OPMASK INSTRUCTIONS\r\nThe exception behavior of VEX-encoded opmask instructions are listed below.\r\nException conditions of Opmask instructions that do not address memory are listed as Type K20.\r\nTable 4-34. TYPE K20 Exception Definition (VEX-Encoded OpMask Instructions w/o Memory Arg)\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X X X If relevant CPUID feature flag is ‘0’.\r\nX X If a VEX prefix is present.\r\nX X If CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\nX X If any REX, F2, F3, or 66 prefixes precede a VEX prefix.\r\nX X If ModRM:[7:6] != 11b.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/c5be337f-121d-4eac-b410-ba7c2d8364e7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3148cbe49725847164a54901cbd70b31928068acebf10300fbb02a2d2d4cea49",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 411
      },
      {
        "segments": [
          {
            "segment_id": "3d8df543-4ce5-4021-b9d3-b8ab84dea66e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 4-33\r\nINTEL® AVX-512 INSTRUCTION ENCODING\r\nException conditions of Opmask instructions that address memory are listed as Type K21.\r\nTable 4-35. TYPE K21 Exception Definition (VEX-Encoded OpMask Instructions Addressing Memory)\r\nException\r\nReal\r\nVirtual 80x86\r\nProtected and \r\nCompatibility\r\n64-bit \r\nCause of Exception\r\nInvalid Opcode, #UD X X X X If relevant CPUID feature flag is ‘0’.\r\nX X If a VEX prefix is present.\r\nX X If CR4.OSXSAVE[bit 18]=0.\r\nIf any one of following conditions applies: \r\n• State requirement, Table 4-8 not met.\r\n• Opcode independent #UD condition in Table 4-9.\r\n• Operand encoding #UD conditions in Table 4-10.\r\nDevice Not Available, \r\n#NM X X X X If CR0.TS[bit 3]=1.\r\nX X If any REX, F2, F3, or 66 prefixes precede a VEX prefix.\r\nStack, SS(0) X X X For an illegal address in the SS segment.\r\nX If a memory address referencing the SS segment is in a non-canonical form.\r\nGeneral Protection, \r\n#GP(0)\r\nX For an illegal memory operand effective address in the CS, DS, ES, FS or GS seg\u0002ments. \r\nIf the DS, ES, FS, or GS register is used to access memory and it contains a null \r\nsegment selector.\r\nX If the memory address is in a non-canonical form.\r\nX X If any part of the operand lies outside the effective address space from 0 to \r\nFFFFH.\r\nPage Fault #PF(fault\u0002code)X X X For a page fault.\r\nAlignment Check \r\n#AC(0)\r\nX X X If alignment checking is enabled and an unaligned memory reference of 8 bytes or \r\nless is made while the current privilege level is 3.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3d8df543-4ce5-4021-b9d3-b8ab84dea66e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b7d4543b981718558baf277fc753428d831415c756b1607962ca20c0f049f1d1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a8e7bb8d-8662-4872-a5cb-08f588234a35",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 102,
            "page_width": 612,
            "page_height": 792,
            "content": "4-34 Ref. # 319433-029\r\nINTEL® AVX-512 INSTRUCTION ENCODING",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a8e7bb8d-8662-4872-a5cb-08f588234a35.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8ded9a8a54a98cf037e8c1b15bd8357ba165699c9a644e26f4d504cf96f1fcf1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 267
      },
      {
        "segments": [
          {
            "segment_id": "cb32143a-0e04-4cd6-b3e3-986a8e0f24c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 103,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-1\r\nINSTRUCTION SET REFERENCE, A-Z\r\nCHAPTER 5\r\nINSTRUCTION SET REFERENCE, A-Z\r\nInstructions described in this document follow the general documentation convention established in Intel 64 and \r\nIA-32 Architectures Software Developer’s Manual Volume 2A. Additional notations and conventions adopted in this \r\ndocument are listed in Section 5.1. Section 5.1.5.1 covers supplemental information that applies to a specific \r\nsubset of instructions.\r\n5.1 INTERPRETING INSTRUCTION REFERENCE PAGES\r\nThis section describes the format of information contained in the instruction reference pages in this chapter. It \r\nexplains notational conventions and abbreviations used in these sections that are outside of those conventions \r\ndescribed in Section 3.1 of the Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 2A. \r\n5.1.1 Instruction Format\r\nThe following is an example of the format used for each instruction description in this chapter. The table below \r\nprovides an example summary table.\r\nADDPS—Add Packed Single-Precision Floating-Point Values (THIS IS AN EXAMPLE)\r\n5.1.2 Opcode Column in the Instruction Summary Table\r\nFor notation and conventions applicable to instructions that do not use VEX or EVEX prefixes, consult Section 3.1 \r\nof the Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 2A.\r\nIn the Instruction Summary Table, the Opcode column presents each instruction encoded using the VEX prefix in \r\nfollowing form (including the modR/M byte if applicable, the immediate byte if applicable):\r\nVEX.[NDS/NDD/DS].[128,256,L0,L1,LIG].[66,F2,F3].0F/0F3A/0F38.[W0,W1,WIG] opcode [/r] \r\n[ib,/is4]\r\nOpcode/\r\nInstruction\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID \r\nFeature \r\nFlag\r\nDescription\r\n0F 58 /r\r\nADDPS xmm1, xmm2/m128\r\nV/V SSE Add packed single-precision floating-point values from \r\nxmm2/mem to xmm1 and store result in xmm1.\r\nVEX.NDS.128.0F 58 /r\r\nVADDPS xmm1,xmm2, xmm3/m128\r\nV/V AVX Add packed single-precision floating-point values from \r\nxmm3/mem to xmm2 and store result in xmm1.\r\nVEX.NDS.256.0F 58 /r\r\nVADDPS ymm1, ymm2, ymm3/m256\r\nV/V AVX Add packed single-precision floating-point values from \r\nymm3/mem to ymm2 and store result in ymm1.\r\nVEX.L1.0F.W0 41 /r \r\nKANDW k1, k2, k3\r\nV/V AVX512F Bitwise AND word masks k2 and k3 and place result in k1.\r\nEVEX.NDS.128.0F.W0 58 /r\r\nVADDPS xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m32bcst \r\nV/V AVX512VL\r\nAVX512F\r\nAdd packed single-precision floating-point values from \r\nxmm3/m128/m32bcst to xmm2 and store result in xmm1 \r\nwith writemask k1.\r\nEVEX.NDS.256.0F.W0 58 /r\r\nVADDPS ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m32bcst \r\nV/V AVX512VL\r\nAVX512F\r\nAdd packed single-precision floating-point values from \r\nymm3/m256/m32bcst to ymm2 and store result in ymm1 \r\nwith writemask k1.\r\nEVEX.NDS.512.0F.W0 58 /r\r\nVADDPS zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m32bcst {er} \r\nV/V AVX512F Add packed single-precision floating-point values from \r\nzmm3/m512/m32bcst with zmm2 and store result in zmm1 \r\nwith writemask k1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/cb32143a-0e04-4cd6-b3e3-986a8e0f24c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b103f536376c58980aa71b5eaec66f39ef348b60c0d761d212835b51cd19b988",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 405
      },
      {
        "segments": [
          {
            "segment_id": "97442e58-fd65-4c1d-8aa8-c4419f33be37",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "5-2 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• VEX: indicates the presence of the VEX prefix is required. The VEX prefix can be encoded using the three-byte \r\nform (the first byte is C4H), or using the two-byte form (the first byte is C5H). The two-byte form of VEX only \r\napplies to those instructions that do not require the following fields to be encoded: VEX.mmmmm, VEX.W, \r\nVEX.X, VEX.B.\r\nThe encoding of various sub-fields of the VEX prefix is described using the following notations:\r\n— NDS, NDD, DDS: implies that VEX.vvvv field is valid for the encoding of an operand. It may specify either \r\nthe source register (NDS) or the destination register (NDD). The VEX.vvvv field can be encoded using either \r\nthe 2-byte or 3-byte form of the VEX prefix. DDS expresses a syntax where vvvv encodes the second \r\nsource register in a three-operand instruction syntax where the content of first source register will be \r\noverwritten by the result. If NDS, NDD and DDS are absent (i.e. VEX.vvvv does not encode an operand), \r\nVEX.vvvv must be 1111b.\r\n— 128,256,L0,L1: VEX.L fields can be 0 (denoted by VEX.128 or VEX.L0 for mask instructions) or 1 (denoted \r\nby VEX.256 or VEX.L1 for mask instructions). The VEX.L field can be encoded using either the 2-byte or 3-\r\nbyte form of the VEX prefix. The presence of the notation VEX.256 or VEX.128 in the opcode column should \r\nbe interpreted as follows:\r\n• If VEX.256 is present in the opcode column: The semantics of the instruction must be encoded with \r\nVEX.L = 1. An attempt to encode this instruction with VEX.L= 0 can result in one of two situations: (a) \r\nif VEX.128 version is defined, the processor will behave according to the defined VEX.128 behavior; (b) \r\nan #UD occurs if there is no VEX.128 version defined.\r\n• If VEX.128 is present in the opcode column but there is no VEX.256 version defined for the same opcode \r\nbyte: Three situations apply: (a) For VEX-encoded, 128-bit SIMD integer instructions, software must \r\nencode the instruction with VEX.L = 0. The processor will treat the opcode byte encoded with VEX.L= 1 \r\nby causing an #UD exception; (b) For VEX-encoded, 128-bit packed floating-point instructions, \r\nsoftware must encode the instruction with VEX.L = 0. The processor will treat the opcode byte encoded \r\nwith VEX.L= 1 by causing an #UD exception (e.g. VMOVLPS); (c) For VEX-encoded, scalar, SIMD \r\nfloating-point instructions, software should encode the instruction with VEX.L = 0 to ensure software \r\ncompatibility with future processor generations. Scalar SIMD floating-point instruction can be distin\u0002guished from the mnemonic of the instruction. Generally, the last two letters of the instruction \r\nmnemonic would be either “SS”, “SD”, or “SI” for SIMD floating-point conversion instructions, except \r\nVBROADCASTSx are unique cases.\r\n• VEX.L0 and VEX.L1 notations are used in the case of masking instructions such as KANDW since the \r\nVEX.L bit is not used to distinguish between the 128-bit and 256-bit forms for these instructions. \r\nInstead, this bit is used to distinguish between the two operand form (VEX.L0) and the three operand \r\nform (VEX.L1) of the same mask instruction.\r\n• If VEX.L0 is present in the opcode column: The semantics of the instruction must be encoded with VEX.L \r\n= 0. An attempt to encode this instruction with VEX.L= 1 can result in one of two situations: (a) if \r\nVEX.L1 version is defined, the processor will behave according to the defined VEX.L1 behavior; (b) an \r\n#UD occurs if there is no VEX.L1 version defined.\r\n• If VEX.L1 is present in the opcode column: The semantics of the instruction must be encoded with VEX.L \r\n= 1. An attempt to encode this instruction with VEX.L= 0 can result in one of two situations: (a) if \r\nVEX.L0 version is defined, the processor will behave according to the defined VEX.L1 behavior; (b) an \r\n#UD occurs if there is no VEX.L0 version defined.\r\n• LIG: VEX.L bit ignored\r\n— 66,F2,F3: The presence or absence of these value maps to the VEX.pp field encodings. If absent, this \r\ncorresponds to VEX.pp=00B. If present, the corresponding VEX.pp value affects the “opcode” byte in the \r\nsame way as if a SIMD prefix (66H, F2H or F3H) does to the ensuing opcode byte. Thus a non-zero encoding \r\nof VEX.pp may be considered as an implied 66H/F2H/F3H prefix. The VEX.pp field may be encoded using \r\neither the 2-byte or 3-byte form of the VEX prefix.\r\n— 0F,0F3A,0F38: The presence maps to a valid encoding of the VEX.mmmmm field. Only three encoded \r\nvalues of VEX.mmmmm are defined as valid, corresponding to the escape byte sequence of 0FH, 0F3AH \r\nand 0F38H. The effect of a valid VEX.mmmmm encoding on the ensuing opcode byte is the same as if the \r\ncorresponding escape byte sequence on the ensuing opcode byte for non-VEX encoded instructions. Thus a \r\nvalid encoding of VEX.mmmmm may be considered as an implied escape byte sequence of either 0FH, \r\n0F3AH or 0F38H. The VEX.mmmmm field must be encoded using the 3-byte form of VEX prefix. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/97442e58-fd65-4c1d-8aa8-c4419f33be37.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f5db411a60a09645b8681aba5d1da9fd3270de1f5ae5c04e3ff01206d0c5be6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 824
      },
      {
        "segments": [
          {
            "segment_id": "97442e58-fd65-4c1d-8aa8-c4419f33be37",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "5-2 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• VEX: indicates the presence of the VEX prefix is required. The VEX prefix can be encoded using the three-byte \r\nform (the first byte is C4H), or using the two-byte form (the first byte is C5H). The two-byte form of VEX only \r\napplies to those instructions that do not require the following fields to be encoded: VEX.mmmmm, VEX.W, \r\nVEX.X, VEX.B.\r\nThe encoding of various sub-fields of the VEX prefix is described using the following notations:\r\n— NDS, NDD, DDS: implies that VEX.vvvv field is valid for the encoding of an operand. It may specify either \r\nthe source register (NDS) or the destination register (NDD). The VEX.vvvv field can be encoded using either \r\nthe 2-byte or 3-byte form of the VEX prefix. DDS expresses a syntax where vvvv encodes the second \r\nsource register in a three-operand instruction syntax where the content of first source register will be \r\noverwritten by the result. If NDS, NDD and DDS are absent (i.e. VEX.vvvv does not encode an operand), \r\nVEX.vvvv must be 1111b.\r\n— 128,256,L0,L1: VEX.L fields can be 0 (denoted by VEX.128 or VEX.L0 for mask instructions) or 1 (denoted \r\nby VEX.256 or VEX.L1 for mask instructions). The VEX.L field can be encoded using either the 2-byte or 3-\r\nbyte form of the VEX prefix. The presence of the notation VEX.256 or VEX.128 in the opcode column should \r\nbe interpreted as follows:\r\n• If VEX.256 is present in the opcode column: The semantics of the instruction must be encoded with \r\nVEX.L = 1. An attempt to encode this instruction with VEX.L= 0 can result in one of two situations: (a) \r\nif VEX.128 version is defined, the processor will behave according to the defined VEX.128 behavior; (b) \r\nan #UD occurs if there is no VEX.128 version defined.\r\n• If VEX.128 is present in the opcode column but there is no VEX.256 version defined for the same opcode \r\nbyte: Three situations apply: (a) For VEX-encoded, 128-bit SIMD integer instructions, software must \r\nencode the instruction with VEX.L = 0. The processor will treat the opcode byte encoded with VEX.L= 1 \r\nby causing an #UD exception; (b) For VEX-encoded, 128-bit packed floating-point instructions, \r\nsoftware must encode the instruction with VEX.L = 0. The processor will treat the opcode byte encoded \r\nwith VEX.L= 1 by causing an #UD exception (e.g. VMOVLPS); (c) For VEX-encoded, scalar, SIMD \r\nfloating-point instructions, software should encode the instruction with VEX.L = 0 to ensure software \r\ncompatibility with future processor generations. Scalar SIMD floating-point instruction can be distin\u0002guished from the mnemonic of the instruction. Generally, the last two letters of the instruction \r\nmnemonic would be either “SS”, “SD”, or “SI” for SIMD floating-point conversion instructions, except \r\nVBROADCASTSx are unique cases.\r\n• VEX.L0 and VEX.L1 notations are used in the case of masking instructions such as KANDW since the \r\nVEX.L bit is not used to distinguish between the 128-bit and 256-bit forms for these instructions. \r\nInstead, this bit is used to distinguish between the two operand form (VEX.L0) and the three operand \r\nform (VEX.L1) of the same mask instruction.\r\n• If VEX.L0 is present in the opcode column: The semantics of the instruction must be encoded with VEX.L \r\n= 0. An attempt to encode this instruction with VEX.L= 1 can result in one of two situations: (a) if \r\nVEX.L1 version is defined, the processor will behave according to the defined VEX.L1 behavior; (b) an \r\n#UD occurs if there is no VEX.L1 version defined.\r\n• If VEX.L1 is present in the opcode column: The semantics of the instruction must be encoded with VEX.L \r\n= 1. An attempt to encode this instruction with VEX.L= 0 can result in one of two situations: (a) if \r\nVEX.L0 version is defined, the processor will behave according to the defined VEX.L1 behavior; (b) an \r\n#UD occurs if there is no VEX.L0 version defined.\r\n• LIG: VEX.L bit ignored\r\n— 66,F2,F3: The presence or absence of these value maps to the VEX.pp field encodings. If absent, this \r\ncorresponds to VEX.pp=00B. If present, the corresponding VEX.pp value affects the “opcode” byte in the \r\nsame way as if a SIMD prefix (66H, F2H or F3H) does to the ensuing opcode byte. Thus a non-zero encoding \r\nof VEX.pp may be considered as an implied 66H/F2H/F3H prefix. The VEX.pp field may be encoded using \r\neither the 2-byte or 3-byte form of the VEX prefix.\r\n— 0F,0F3A,0F38: The presence maps to a valid encoding of the VEX.mmmmm field. Only three encoded \r\nvalues of VEX.mmmmm are defined as valid, corresponding to the escape byte sequence of 0FH, 0F3AH \r\nand 0F38H. The effect of a valid VEX.mmmmm encoding on the ensuing opcode byte is the same as if the \r\ncorresponding escape byte sequence on the ensuing opcode byte for non-VEX encoded instructions. Thus a \r\nvalid encoding of VEX.mmmmm may be considered as an implied escape byte sequence of either 0FH, \r\n0F3AH or 0F38H. The VEX.mmmmm field must be encoded using the 3-byte form of VEX prefix. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/97442e58-fd65-4c1d-8aa8-c4419f33be37.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f5db411a60a09645b8681aba5d1da9fd3270de1f5ae5c04e3ff01206d0c5be6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 824
      },
      {
        "segments": [
          {
            "segment_id": "1a3bff54-8179-42bd-a137-0b71eb6fc37c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-3\r\nINSTRUCTION SET REFERENCE, A-Z\r\n— 0F,0F3A,0F38 and 2-byte/3-byte VEX. The presence of 0F3A and 0F38 in the opcode column implies \r\nthat opcode can only be encoded by the three-byte form of VEX. The presence of 0F in the opcode column \r\ndoes not preclude the opcode to be encoded by the two-byte of VEX if the semantics of the opcode does not \r\nrequire any subfield of VEX not present in the two-byte form of the VEX prefix.\r\n— W0: VEX.W=0. \r\n— W1: VEX.W=1.\r\n— WIG: VEX.W bit ignored\r\n— The presence of W0/W1 in the opcode column applies to two situations: (a) it is treated as an extended \r\nopcode bit, (b) the instruction semantics support an operand size promotion to 64-bit of a general-purpose \r\nregister operand or a 32-bit memory operand. The presence of W1 in the opcode column implies the opcode \r\nmust be encoded using the 3-byte form of the VEX prefix. The presence of W0 in the opcode column does \r\nnot preclude the opcode to be encoded using the C5H form of the VEX prefix, if the semantics of the opcode \r\ndoes not require other VEX subfields not present in the two-byte form of the VEX prefix. If neither W0 or \r\nW1 is present, the instruction may be encoded using either the two-byte form (if the opcode semantic does \r\nnot require VEX subfields not present in the two-byte form of VEX) or the three-byte form of VEX. Encoding \r\nan instruction using the two-byte form of VEX is equivalent to W0.\r\n• opcode: Instruction opcode.\r\n• ib: An 8-bit immediate byte is present and used as one of the instructions operands.\r\n• /is4: An 8-bit immediate byte is present containing a source register specifier in imm[7:4] and instruction\u0002specific payload in imm[3:0].\r\n• imz2: Part of the is4 immediate byte provides control functions that apply to two-source permute instructions\r\nIn general, the encoding o f VEX.R, VEX.X, VEX.B field are not shown explicitly in the opcode column. \r\nEVEX.[NDS/NDD/DDS].[128,256,512,LIG].[66,F2,F3].0F/0F3A/0F38.[W0,W1,WIG] opcode [/r] \r\n[ib,/is4]\r\n• EVEX: The EVEX prefix is encoded using the four-byte form (the first byte is 62H). Refer to Section 4.2 for \r\nmore detail on the EVEX prefix.\r\nThe encoding of various sub-fields of the EVEX prefix is described using the following notations.\r\n— NDS, NDD, DDS: implies that EVEX.vvvv (and EVEX.v’) field is valid for the encoding of an operand. It may \r\nspecify either the source register (NDS) or the destination register (NDD). DDS expresses a syntax where \r\nvvvv encodes the second source register in a three-operand instruction syntax where the content of first \r\nsource register will be overwritten by the result. If both NDS and NDD absent (i.e. EVEX.vvvv does not \r\nencode an operand), EVEX.vvvv must be 1111b (and EVEX.v’ must be 1b). \r\n— 128, 256, 512, LIG: This corresponds to the vector length; three values are allowed by EVEX: 512-bit, \r\n256-bit and 128-bit. Alternatively, vector length is ignored (LIG) for certain instructions; this typically \r\napplies to scalar instructions operating on one data element of a vector register.\r\n— 66,F2,F3: The presence of these value maps to the EVEX.pp field encodings. The corresponding VEX.pp \r\nvalue affects the “opcode” byte in the same way as if a SIMD prefix (66H, F2H or F3H) does to the ensuing \r\nopcode byte. Thus a non-zero encoding of VEX.pp may be considered as an implied 66H/F2H/F3H prefix. \r\n— 0F,0F3A,0F38: The presence maps to a valid encoding of the EVEX.mmm field. Only three encoded values \r\nof EVEX.mmm are defined as valid, corresponding to the escape byte sequence of 0FH, 0F3AH and 0F38H. \r\nThe effect of a valid EVEX.mmm encoding on the ensuing opcode byte is the same as if the corresponding \r\nescape byte sequence on the ensuing opcode byte for non-EVEX encoded instructions. Thus a valid \r\nencoding of EVEX.mmm may be considered as an implied escape byte sequence of either 0FH, 0F3AH or \r\n0F38H. \r\n— W0: EVEX.W=0. \r\n— W1: EVEX.W=1.\r\n— WIG: EVEX.W bit ignored\r\n• opcode: Instruction opcode.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1a3bff54-8179-42bd-a137-0b71eb6fc37c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dbd4e69860302bd9e2f6cf86735c8f046aeebb5878239216bf62ae6ee2a30a52",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 658
      },
      {
        "segments": [
          {
            "segment_id": "1a3bff54-8179-42bd-a137-0b71eb6fc37c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-3\r\nINSTRUCTION SET REFERENCE, A-Z\r\n— 0F,0F3A,0F38 and 2-byte/3-byte VEX. The presence of 0F3A and 0F38 in the opcode column implies \r\nthat opcode can only be encoded by the three-byte form of VEX. The presence of 0F in the opcode column \r\ndoes not preclude the opcode to be encoded by the two-byte of VEX if the semantics of the opcode does not \r\nrequire any subfield of VEX not present in the two-byte form of the VEX prefix.\r\n— W0: VEX.W=0. \r\n— W1: VEX.W=1.\r\n— WIG: VEX.W bit ignored\r\n— The presence of W0/W1 in the opcode column applies to two situations: (a) it is treated as an extended \r\nopcode bit, (b) the instruction semantics support an operand size promotion to 64-bit of a general-purpose \r\nregister operand or a 32-bit memory operand. The presence of W1 in the opcode column implies the opcode \r\nmust be encoded using the 3-byte form of the VEX prefix. The presence of W0 in the opcode column does \r\nnot preclude the opcode to be encoded using the C5H form of the VEX prefix, if the semantics of the opcode \r\ndoes not require other VEX subfields not present in the two-byte form of the VEX prefix. If neither W0 or \r\nW1 is present, the instruction may be encoded using either the two-byte form (if the opcode semantic does \r\nnot require VEX subfields not present in the two-byte form of VEX) or the three-byte form of VEX. Encoding \r\nan instruction using the two-byte form of VEX is equivalent to W0.\r\n• opcode: Instruction opcode.\r\n• ib: An 8-bit immediate byte is present and used as one of the instructions operands.\r\n• /is4: An 8-bit immediate byte is present containing a source register specifier in imm[7:4] and instruction\u0002specific payload in imm[3:0].\r\n• imz2: Part of the is4 immediate byte provides control functions that apply to two-source permute instructions\r\nIn general, the encoding o f VEX.R, VEX.X, VEX.B field are not shown explicitly in the opcode column. \r\nEVEX.[NDS/NDD/DDS].[128,256,512,LIG].[66,F2,F3].0F/0F3A/0F38.[W0,W1,WIG] opcode [/r] \r\n[ib,/is4]\r\n• EVEX: The EVEX prefix is encoded using the four-byte form (the first byte is 62H). Refer to Section 4.2 for \r\nmore detail on the EVEX prefix.\r\nThe encoding of various sub-fields of the EVEX prefix is described using the following notations.\r\n— NDS, NDD, DDS: implies that EVEX.vvvv (and EVEX.v’) field is valid for the encoding of an operand. It may \r\nspecify either the source register (NDS) or the destination register (NDD). DDS expresses a syntax where \r\nvvvv encodes the second source register in a three-operand instruction syntax where the content of first \r\nsource register will be overwritten by the result. If both NDS and NDD absent (i.e. EVEX.vvvv does not \r\nencode an operand), EVEX.vvvv must be 1111b (and EVEX.v’ must be 1b). \r\n— 128, 256, 512, LIG: This corresponds to the vector length; three values are allowed by EVEX: 512-bit, \r\n256-bit and 128-bit. Alternatively, vector length is ignored (LIG) for certain instructions; this typically \r\napplies to scalar instructions operating on one data element of a vector register.\r\n— 66,F2,F3: The presence of these value maps to the EVEX.pp field encodings. The corresponding VEX.pp \r\nvalue affects the “opcode” byte in the same way as if a SIMD prefix (66H, F2H or F3H) does to the ensuing \r\nopcode byte. Thus a non-zero encoding of VEX.pp may be considered as an implied 66H/F2H/F3H prefix. \r\n— 0F,0F3A,0F38: The presence maps to a valid encoding of the EVEX.mmm field. Only three encoded values \r\nof EVEX.mmm are defined as valid, corresponding to the escape byte sequence of 0FH, 0F3AH and 0F38H. \r\nThe effect of a valid EVEX.mmm encoding on the ensuing opcode byte is the same as if the corresponding \r\nescape byte sequence on the ensuing opcode byte for non-EVEX encoded instructions. Thus a valid \r\nencoding of EVEX.mmm may be considered as an implied escape byte sequence of either 0FH, 0F3AH or \r\n0F38H. \r\n— W0: EVEX.W=0. \r\n— W1: EVEX.W=1.\r\n— WIG: EVEX.W bit ignored\r\n• opcode: Instruction opcode.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/1a3bff54-8179-42bd-a137-0b71eb6fc37c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dbd4e69860302bd9e2f6cf86735c8f046aeebb5878239216bf62ae6ee2a30a52",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 658
      },
      {
        "segments": [
          {
            "segment_id": "0c897063-3f78-4a7a-a306-dd39bef382fe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "5-4 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• /is4: An 8-bit immediate byte is present containing a source register specifier in imm[7:4] and instruction\u0002specific payload in imm[3:0].\r\n• imz2: Part of the is4 immediate byte provides control functions that apply to two-source permute instructions\r\n• In general, the encoding of EVEX.R and R’, EVEX.X and X’, and EVEX.B and B’ fields are not shown explicitly in \r\nthe opcode column. \r\n5.1.3 Instruction Column in the Instruction Summary Table\r\n• xmm — an XMM register. The XMM registers are: XMM0 through XMM7; XMM8 through XMM15 are available in \r\n64-bit mode. XMM16 through XMM31 are available in 64-bit mode via EVEX prefix.\r\n• ymm — a YMM register. The 256-bit YMM registers are: YMM0 through YMM7; YMM8 through YMM15 are \r\navailable in 64-bit mode. YMM16 through YMM31 are available in 64-bit mode via EVEX prefix.\r\n• m256 — A 32-byte operand in memory. \r\n• ymm/m256 - a YMM register or 256-bit memory operand. \r\n• <YMM0>: indicates use of the YMM0 register as an implicit argument.\r\n• zmm — a ZMM register. The 512-bit ZMM registers require EVEX prefix and are: ZMM0 through ZMM7; ZMM8 \r\nthrough ZMM31 are available in 64-bit mode.\r\n• m512 — A 64-byte operand in memory. \r\n• zmm/m512 — a ZMM register or 512-bit memory operand. \r\n• {k1}{z} — a mask register used as instruction writemask. The 64-bit k registers are: k1 through k7. \r\nWritemask specification is available exclusively via EVEX prefix. The masking can either be done as a merging\u0002masking, where the old values are preserved for masked out elements or as a zeroing masking. The type of \r\nmasking is determined by using the EVEX.z bit.\r\n• {k1} — without {z}: a mask register used as instruction writemask for instructions that do not allow zeroing\u0002masking but support merging-masking. This corresponds to instructions that require the value of the aaa field \r\nto be different than 0 (e.g., gather) and store-type instructions which allow only merging-masking. \r\n• k1 — a mask register used as a regular operand (either destination or source). The 64-bit k registers are: k0 \r\nthrough k7.\r\n• mV — a vector memory operand; the operand size is dependent on the instruction.\r\n• vm32{x,y, z} — A vector array of memory operands specified using VSIB memory addressing. The array of \r\nmemory addresses are specified using a common base register, a constant scale factor, and a vector index \r\nregister with individual elements of 32-bit index value in an XMM register (vm32x), a YMM register (vm32y) or \r\na ZMM register (vm32z).\r\n• vm64{x,y, z} — A vector array of memory operands specified using VSIB memory addressing. The array of \r\nmemory addresses are specified using a common base register, a constant scale factor, and a vector index \r\nregister with individual elements of 64-bit index value in an XMM register (vm64x), a YMM register (vm64y) or \r\na ZMM register (vm64z).\r\n• zmm/m512/m32bcst — an operand that can be a ZMM register, a 512-bit memory location or a 512-bit \r\nvector loaded from a 32-bit memory location. \r\n• zmm/m512/m64bcst — an operand that can be a ZMM register, a 512-bit memory location or a 512-bit \r\nvector loaded from a 64-bit memory location.\r\n• <ZMM0> — indicates use of the ZMM0 register as an implicit argument.\r\n• {er} indicates support for embedded rounding control, which is only applicable to the register-register form of \r\nthe instruction. This also implies support for SAE (Suppress All Exceptions).\r\n• {sae} indicates support for SAE (Suppress All Exceptions). This is used for instructions that support SAE, but \r\ndo not support embedded rounding control.\r\n• SRC1 — Denotes the first source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having two or more source operands.\r\n• SRC2 — Denotes the second source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having two or more source operands.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/0c897063-3f78-4a7a-a306-dd39bef382fe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f231d3420a6d473512c545abcf7f730bf0c328fef8343a310334134195ace252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 647
      },
      {
        "segments": [
          {
            "segment_id": "0c897063-3f78-4a7a-a306-dd39bef382fe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "5-4 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• /is4: An 8-bit immediate byte is present containing a source register specifier in imm[7:4] and instruction\u0002specific payload in imm[3:0].\r\n• imz2: Part of the is4 immediate byte provides control functions that apply to two-source permute instructions\r\n• In general, the encoding of EVEX.R and R’, EVEX.X and X’, and EVEX.B and B’ fields are not shown explicitly in \r\nthe opcode column. \r\n5.1.3 Instruction Column in the Instruction Summary Table\r\n• xmm — an XMM register. The XMM registers are: XMM0 through XMM7; XMM8 through XMM15 are available in \r\n64-bit mode. XMM16 through XMM31 are available in 64-bit mode via EVEX prefix.\r\n• ymm — a YMM register. The 256-bit YMM registers are: YMM0 through YMM7; YMM8 through YMM15 are \r\navailable in 64-bit mode. YMM16 through YMM31 are available in 64-bit mode via EVEX prefix.\r\n• m256 — A 32-byte operand in memory. \r\n• ymm/m256 - a YMM register or 256-bit memory operand. \r\n• <YMM0>: indicates use of the YMM0 register as an implicit argument.\r\n• zmm — a ZMM register. The 512-bit ZMM registers require EVEX prefix and are: ZMM0 through ZMM7; ZMM8 \r\nthrough ZMM31 are available in 64-bit mode.\r\n• m512 — A 64-byte operand in memory. \r\n• zmm/m512 — a ZMM register or 512-bit memory operand. \r\n• {k1}{z} — a mask register used as instruction writemask. The 64-bit k registers are: k1 through k7. \r\nWritemask specification is available exclusively via EVEX prefix. The masking can either be done as a merging\u0002masking, where the old values are preserved for masked out elements or as a zeroing masking. The type of \r\nmasking is determined by using the EVEX.z bit.\r\n• {k1} — without {z}: a mask register used as instruction writemask for instructions that do not allow zeroing\u0002masking but support merging-masking. This corresponds to instructions that require the value of the aaa field \r\nto be different than 0 (e.g., gather) and store-type instructions which allow only merging-masking. \r\n• k1 — a mask register used as a regular operand (either destination or source). The 64-bit k registers are: k0 \r\nthrough k7.\r\n• mV — a vector memory operand; the operand size is dependent on the instruction.\r\n• vm32{x,y, z} — A vector array of memory operands specified using VSIB memory addressing. The array of \r\nmemory addresses are specified using a common base register, a constant scale factor, and a vector index \r\nregister with individual elements of 32-bit index value in an XMM register (vm32x), a YMM register (vm32y) or \r\na ZMM register (vm32z).\r\n• vm64{x,y, z} — A vector array of memory operands specified using VSIB memory addressing. The array of \r\nmemory addresses are specified using a common base register, a constant scale factor, and a vector index \r\nregister with individual elements of 64-bit index value in an XMM register (vm64x), a YMM register (vm64y) or \r\na ZMM register (vm64z).\r\n• zmm/m512/m32bcst — an operand that can be a ZMM register, a 512-bit memory location or a 512-bit \r\nvector loaded from a 32-bit memory location. \r\n• zmm/m512/m64bcst — an operand that can be a ZMM register, a 512-bit memory location or a 512-bit \r\nvector loaded from a 64-bit memory location.\r\n• <ZMM0> — indicates use of the ZMM0 register as an implicit argument.\r\n• {er} indicates support for embedded rounding control, which is only applicable to the register-register form of \r\nthe instruction. This also implies support for SAE (Suppress All Exceptions).\r\n• {sae} indicates support for SAE (Suppress All Exceptions). This is used for instructions that support SAE, but \r\ndo not support embedded rounding control.\r\n• SRC1 — Denotes the first source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having two or more source operands.\r\n• SRC2 — Denotes the second source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having two or more source operands.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/0c897063-3f78-4a7a-a306-dd39bef382fe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f231d3420a6d473512c545abcf7f730bf0c328fef8343a310334134195ace252",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 647
      },
      {
        "segments": [
          {
            "segment_id": "f8b25dd2-5583-4afb-b622-e503eb501c60",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-5\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• SRC3 — Denotes the third source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having three source operands.\r\n• SRC — The source in a single-source instruction.\r\n• DST — the destination in an instruction. This field is encoded by reg_field.\r\n5.1.4 64/32 bit Mode Support column in the Instruction Summary Table\r\nThe “64/32 bit Mode Support” column in the Instruction Summary table indicates whether an opcode sequence is \r\nsupported in 64-bit or the Compatibility/other IA32 modes.\r\nThe 64-bit mode support is to the left of the ‘slash’ and has the following notation.\r\n• V — Supported.\r\n• I — Not supported.\r\n• N.E. — Indicates an instruction syntax is not encodable in 64-bit mode (it may represent part of a sequence\r\nof valid instructions in other modes).\r\n• N.P. — Indicates the REX prefix does not affect the legacy instruction in 64-bit mode.\r\n• N.I. — Indicates the opcode is treated as a new instruction in 64-bit mode.\r\n• N.S. — Indicates an instruction syntax that requires an address override prefix in 64-bit mode and is not sup\u0002ported. Using an address override prefix in 64-bit mode may result in model-specific execution behavior.\r\nThe compatibility/Legacy mode support is to the right of the ‘slash’ and has the following notation.\r\n• V — Supported.\r\n• I — Not supported.\r\n• N.E. — Indicates an Intel 64 instruction mnemonics/syntax that is not encodable; the opcode sequence is not\r\napplicable as an individual instruction in compatibility mode or IA-32 mode. The opcode may represent a valid\r\nsequence of legacy IA-32 instructions.\r\n5.1.5 CPUID Support column in the Instruction Summary Table\r\nThe fourth column holds abbreviated CPUID feature flags (e.g. appropriate bits in CPUID.1:ECX, CPUID.1:EDX for \r\nSSE/SSE2/SSE3/SSSE3/SSE4.1/SSE4.2/AVX/F16C support; bits in CPUID.(EAX=07H,ECX=0):BCX for \r\nAVX2/AVX512F etc) that indicate processor support for the instruction. If the corresponding flag is ‘0’, the instruc\u0002tion will #UD.\r\nFor entries that reference to CPUID feature flags listed in Table 2-1, software should follow the detection procedure \r\ndescribed in Section 2.1 and Section 2.2.\r\nFor entries that reference to CPUID feature flags listed in Table 2-1 and AVX512VL, software should follow the \r\ndetection procedure described in Section 2.3.\r\n5.1.5.1 Operand Encoding Column in the Instruction Summary Table\r\nThe “operand encoding” column is abbreviated as Op/En in the Instruction Summary table heading. Instruction \r\noperand encoding information is provided for each assembly instruction syntax using a letter to cross reference to \r\na row entry in the operand encoding definition table that follows the instruction summary table. The operand \r\nencoding table in each instruction reference page lists each instruction operand (according to each instruction \r\nsyntax and operand ordering shown in the instruction column) relative to the ModRM byte, VEX.vvvv field or addi\u0002tional operand encoding placement. \r\nEVEX encoded instructions employ compressed disp8*N encoding of the displacement bytes, where N is defined in \r\nTable 4-5 and Table 4-6, according to tupletypes. The Op/En column of an EVEX encoded instruction uses an abbre\u0002viation that corresponds to the tupletype abbreviation (and may include an additional abbreviation related to \r\nModR/M and vvvv encoding). Most EVEX encoded instructions with VEX encoded equivalent have the ModR/M and \r\nvvvv encoding order. In such cases, the Tuple abbreviation is shown and the ModR/M, vvvv encoding abbreviation \r\nmay be omitted. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f8b25dd2-5583-4afb-b622-e503eb501c60.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=70ebd9edc81af3563392e2b690f30ed3f502e458eb20d409b7347a5bc36327af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 550
      },
      {
        "segments": [
          {
            "segment_id": "f8b25dd2-5583-4afb-b622-e503eb501c60",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-5\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• SRC3 — Denotes the third source operand in the instruction syntax of an instruction encoded with the EVEX \r\nprefix and having three source operands.\r\n• SRC — The source in a single-source instruction.\r\n• DST — the destination in an instruction. This field is encoded by reg_field.\r\n5.1.4 64/32 bit Mode Support column in the Instruction Summary Table\r\nThe “64/32 bit Mode Support” column in the Instruction Summary table indicates whether an opcode sequence is \r\nsupported in 64-bit or the Compatibility/other IA32 modes.\r\nThe 64-bit mode support is to the left of the ‘slash’ and has the following notation.\r\n• V — Supported.\r\n• I — Not supported.\r\n• N.E. — Indicates an instruction syntax is not encodable in 64-bit mode (it may represent part of a sequence\r\nof valid instructions in other modes).\r\n• N.P. — Indicates the REX prefix does not affect the legacy instruction in 64-bit mode.\r\n• N.I. — Indicates the opcode is treated as a new instruction in 64-bit mode.\r\n• N.S. — Indicates an instruction syntax that requires an address override prefix in 64-bit mode and is not sup\u0002ported. Using an address override prefix in 64-bit mode may result in model-specific execution behavior.\r\nThe compatibility/Legacy mode support is to the right of the ‘slash’ and has the following notation.\r\n• V — Supported.\r\n• I — Not supported.\r\n• N.E. — Indicates an Intel 64 instruction mnemonics/syntax that is not encodable; the opcode sequence is not\r\napplicable as an individual instruction in compatibility mode or IA-32 mode. The opcode may represent a valid\r\nsequence of legacy IA-32 instructions.\r\n5.1.5 CPUID Support column in the Instruction Summary Table\r\nThe fourth column holds abbreviated CPUID feature flags (e.g. appropriate bits in CPUID.1:ECX, CPUID.1:EDX for \r\nSSE/SSE2/SSE3/SSSE3/SSE4.1/SSE4.2/AVX/F16C support; bits in CPUID.(EAX=07H,ECX=0):BCX for \r\nAVX2/AVX512F etc) that indicate processor support for the instruction. If the corresponding flag is ‘0’, the instruc\u0002tion will #UD.\r\nFor entries that reference to CPUID feature flags listed in Table 2-1, software should follow the detection procedure \r\ndescribed in Section 2.1 and Section 2.2.\r\nFor entries that reference to CPUID feature flags listed in Table 2-1 and AVX512VL, software should follow the \r\ndetection procedure described in Section 2.3.\r\n5.1.5.1 Operand Encoding Column in the Instruction Summary Table\r\nThe “operand encoding” column is abbreviated as Op/En in the Instruction Summary table heading. Instruction \r\noperand encoding information is provided for each assembly instruction syntax using a letter to cross reference to \r\na row entry in the operand encoding definition table that follows the instruction summary table. The operand \r\nencoding table in each instruction reference page lists each instruction operand (according to each instruction \r\nsyntax and operand ordering shown in the instruction column) relative to the ModRM byte, VEX.vvvv field or addi\u0002tional operand encoding placement. \r\nEVEX encoded instructions employ compressed disp8*N encoding of the displacement bytes, where N is defined in \r\nTable 4-5 and Table 4-6, according to tupletypes. The Op/En column of an EVEX encoded instruction uses an abbre\u0002viation that corresponds to the tupletype abbreviation (and may include an additional abbreviation related to \r\nModR/M and vvvv encoding). Most EVEX encoded instructions with VEX encoded equivalent have the ModR/M and \r\nvvvv encoding order. In such cases, the Tuple abbreviation is shown and the ModR/M, vvvv encoding abbreviation \r\nmay be omitted. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f8b25dd2-5583-4afb-b622-e503eb501c60.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=70ebd9edc81af3563392e2b690f30ed3f502e458eb20d409b7347a5bc36327af",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 550
      },
      {
        "segments": [
          {
            "segment_id": "ed53874f-3c46-4ebf-bad4-c925c1fd3e6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "5-6 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nNOTES\r\nThe letters in the Op/En column of an instruction apply ONLY to the encoding definition table \r\nimmediately following the instruction summary table.\r\nIn the encoding definition table, the letter ‘r’ within a pair of parentheses denotes the content of the operand will \r\nbe read by the processor. The letter ‘w’ within a pair of parenthesis denotes the content of the operand will be \r\nupdated by the processor.\r\n5.2 SUMMARY OF TERMS\r\n• “Legacy SSE” — Refers to SSE, SSE2, SSE3, SSSE3, SSE4, and any future instruction sets referencing XMM \r\nregisters and encoded without a VEX or EVEX prefix.\r\n• XGETBV, XSETBV, XSAVE, XRSTOR are defined in Intel 64 and IA-32 Architectures Software Developer’s \r\nManual, Volumes 3A and Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2C.\r\n• VEX — Refers to a two-byte or three-byte prefix. AVX and FMA instructions are encoded using a VEX prefix.\r\n• EVEX — Refers to a four-byte prefix. AVX512F instructions are encoded using an EVEX prefix.\r\n• VEX.vvvv — The VEX bit field specifying a source or destination register (in 1’s complement form).\r\n• rm_field — Shorthand for the ModR/M r/m field and any REX.B\r\n• reg_field — Shorthand for the ModR/M reg field and any REX.R\r\n5.3 TERNARY BIT VECTOR LOGIC TABLE \r\nVPTERNLOGD/VPTERNLOGQ instructions operate on dword/qword elements and take three bit vectors of the \r\nrespective input data elements to form a set of 32/64 indices, where each 3-bit value provides an index into an 8-\r\nbit lookup table represented by the imm8 byte of the instruction. The 256 possible values of the imm8 byte is \r\nconstructed as a 16x16 boolean logic table. The 16 rows of the table uses the lower 4 bits of imm8 as row index. \r\nThe 16 columns are referenced by imm8[7:4]. The 16 columns of the table are present in two halves, with 8 \r\ncolumns shown in Table 5-1 for the column index value between 0:7, followed by Table 5-2 showing the 8 columns \r\ncorresponding to column index 8:15. This section presents the two-halves of the 256-entry table using a short\u0002hand notation representing simple or compound boolean logic expressions with three input bit source data. \r\nThe three input bit source data will be denoted with the capital letters: A, B, C; where A represents a bit from the \r\nfirst source operand (also the destination operand), B and C represent a bit from the 2nd and 3rd source operands. \r\nEach map entry takes the form of a logic expression consisting of one of more component expressions. Each \r\ncomponent expression consists of either a unary or binary boolean operator and associated operands. Each binary \r\nboolean operator is expressed in lowercase letters, and operands concatenated after the logic operator. The unary \r\noperator ‘not’ is expressed using ‘!’. Additionally, the conditional expression “A?B:C” expresses a result returning B \r\nif A is set, returning C otherwise.\r\nA binary boolean operator is followed by two operands, e.g. andAB. For a compound binary expression that contain \r\ncommutative components and comprising the same logic operator, the 2nd logic operator is omitted and three \r\noperands can be concatenated in sequence, e.g. andABC. When the 2nd operand of the first binary boolean expres\u0002sion comes from the result of another boolean expression, the 2nd boolean expression is concatenated after the \r\nuppercase operand of the first logic expression, e.g. norBnandAC. When the result is independent of an operand, \r\nthat operand is omitted in the logic expression, e.g. zeros or norCB.\r\nThe 3-input expression “majorABC” returns 0 if two or more input bits are 0, returns 1 if two or more input bits are \r\n1. The 3-input expression “minorABC” returns 1 if two or more input bits are 0, returns 0 if two or more input bits \r\nare 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ed53874f-3c46-4ebf-bad4-c925c1fd3e6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d98dc2ad57ec9173f881ab0e22c7ac4c1547585785f8a56e50483225a6ccf77",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 628
      },
      {
        "segments": [
          {
            "segment_id": "ed53874f-3c46-4ebf-bad4-c925c1fd3e6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "5-6 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nNOTES\r\nThe letters in the Op/En column of an instruction apply ONLY to the encoding definition table \r\nimmediately following the instruction summary table.\r\nIn the encoding definition table, the letter ‘r’ within a pair of parentheses denotes the content of the operand will \r\nbe read by the processor. The letter ‘w’ within a pair of parenthesis denotes the content of the operand will be \r\nupdated by the processor.\r\n5.2 SUMMARY OF TERMS\r\n• “Legacy SSE” — Refers to SSE, SSE2, SSE3, SSSE3, SSE4, and any future instruction sets referencing XMM \r\nregisters and encoded without a VEX or EVEX prefix.\r\n• XGETBV, XSETBV, XSAVE, XRSTOR are defined in Intel 64 and IA-32 Architectures Software Developer’s \r\nManual, Volumes 3A and Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2C.\r\n• VEX — Refers to a two-byte or three-byte prefix. AVX and FMA instructions are encoded using a VEX prefix.\r\n• EVEX — Refers to a four-byte prefix. AVX512F instructions are encoded using an EVEX prefix.\r\n• VEX.vvvv — The VEX bit field specifying a source or destination register (in 1’s complement form).\r\n• rm_field — Shorthand for the ModR/M r/m field and any REX.B\r\n• reg_field — Shorthand for the ModR/M reg field and any REX.R\r\n5.3 TERNARY BIT VECTOR LOGIC TABLE \r\nVPTERNLOGD/VPTERNLOGQ instructions operate on dword/qword elements and take three bit vectors of the \r\nrespective input data elements to form a set of 32/64 indices, where each 3-bit value provides an index into an 8-\r\nbit lookup table represented by the imm8 byte of the instruction. The 256 possible values of the imm8 byte is \r\nconstructed as a 16x16 boolean logic table. The 16 rows of the table uses the lower 4 bits of imm8 as row index. \r\nThe 16 columns are referenced by imm8[7:4]. The 16 columns of the table are present in two halves, with 8 \r\ncolumns shown in Table 5-1 for the column index value between 0:7, followed by Table 5-2 showing the 8 columns \r\ncorresponding to column index 8:15. This section presents the two-halves of the 256-entry table using a short\u0002hand notation representing simple or compound boolean logic expressions with three input bit source data. \r\nThe three input bit source data will be denoted with the capital letters: A, B, C; where A represents a bit from the \r\nfirst source operand (also the destination operand), B and C represent a bit from the 2nd and 3rd source operands. \r\nEach map entry takes the form of a logic expression consisting of one of more component expressions. Each \r\ncomponent expression consists of either a unary or binary boolean operator and associated operands. Each binary \r\nboolean operator is expressed in lowercase letters, and operands concatenated after the logic operator. The unary \r\noperator ‘not’ is expressed using ‘!’. Additionally, the conditional expression “A?B:C” expresses a result returning B \r\nif A is set, returning C otherwise.\r\nA binary boolean operator is followed by two operands, e.g. andAB. For a compound binary expression that contain \r\ncommutative components and comprising the same logic operator, the 2nd logic operator is omitted and three \r\noperands can be concatenated in sequence, e.g. andABC. When the 2nd operand of the first binary boolean expres\u0002sion comes from the result of another boolean expression, the 2nd boolean expression is concatenated after the \r\nuppercase operand of the first logic expression, e.g. norBnandAC. When the result is independent of an operand, \r\nthat operand is omitted in the logic expression, e.g. zeros or norCB.\r\nThe 3-input expression “majorABC” returns 0 if two or more input bits are 0, returns 1 if two or more input bits are \r\n1. The 3-input expression “minorABC” returns 1 if two or more input bits are 0, returns 0 if two or more input bits \r\nare 1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ed53874f-3c46-4ebf-bad4-c925c1fd3e6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d98dc2ad57ec9173f881ab0e22c7ac4c1547585785f8a56e50483225a6ccf77",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 628
      },
      {
        "segments": [
          {
            "segment_id": "c7d087a0-f6be-4291-ad94-f9d6469e999e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 109,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-7\r\nINSTRUCTION SET REFERENCE, A-Z\r\nThe building-block bit logic functions used in Table 5-1 and Table 5-2 include:\r\n• Constants: TRUE (1), FALSE (0)\r\n• Unary function: Not (!)\r\n• Binary functions: and, nand, or, nor, xor, xnor\r\n• Conditional function: Select (?:)\r\n• Tertiary functions: major, minor\r\n:\r\nTable 5-2 shows the half of 256-entry map corresponding to column index values 8:15.\r\nTable 5-1. Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations\r\nImm [7:4]\r\n[3:0] 0H 1H 2H 3H 4H 5H 6H 7H\r\n00H FALSE andAnorBC norBnandAC andA!B norCnandBA andA!C andAxorBC andAnandBC\r\n01H norABC norCB norBxorAC A?!B:norBC norCxorBA A?!C:norBC A?xorBC:norB\r\nC\r\nA?nandBC:no\r\nrBC\r\n02H andCnorBA norBxnorAC andC!B norBnorAC C?norBA:and\r\nBA\r\nC?norBA:A C?!B:andBA C?!B:A\r\n03H norBA norBandAC C?!B:norBA !B C?norBA:xnor\r\nBA\r\nA?!C:!B A?xorBC:!B A?nandBC:!B\r\n04H andBnorAC norCxnorBA B?norAC:and\r\nAC\r\nB?norAC:A andB!C norCnorBA B?!C:andAC B?!C:A\r\n05H norCA norCandBA B?norAC:xnor\r\nAC\r\nA?!B:!C B?!C:norAC !C A?xorBC:!C A?nandBC:!C\r\n06H norAxnorBC A?norBC:xorB\r\nC\r\nB?norAC:C xorBorAC C?norBA:B xorCorBA xorCB B?!C:orAC\r\n07H norAandBC minorABC C?!B:!A nandBorAC B?!C:!A nandCorBA A?xorBC:nan\r\ndBC\r\nnandCB\r\n08H norAnandBC A?norBC:and\r\nBC\r\nandCxorBA A?!B:andBC andBxorAC A?!C:andBC A?xorBC:and\r\nBC\r\nxorAandBC\r\n09H norAxorBC A?norBC:xnor\r\nBC\r\nC?xorBA:norB\r\nA\r\nA?!B:xnorBC B?xorAC:norA\r\nC\r\nA?!C:xnorBC xnorABC A?nandBC:xn\r\norBC\r\n0AH andC!A A?norBC:C andCnandBA A?!B:C C?!A:andBA xorCA xorCandBA A?nandBC:C\r\n0BH C?!A:norBA C?!A:!B C?nandBA:no\r\nrBA\r\nC?nandBA:!B B?xorAC:!A B?xorAC:nan\r\ndAC\r\nC?nandBA:xn\r\norBA\r\nnandBxnorAC\r\n0CH andB!A A?norBC:B B?!A:andAC xorBA andBnandAC A?!C:B xorBandAC A?nandBC:B\r\n0DH B?!A:norAC B?!A:!C B?!A:xnorAC C?xorBA:nan\r\ndBA\r\nB?nandAC:no\r\nrAC\r\nB?nandAC:!C B?nandAC:xn\r\norAC\r\nnandCxnorBA\r\n0EH norAnorBC xorAorBC B?!A:C A?!B:orBC C?!A:B A?!C:orBC B?nandAC:C A?nandBC:or\r\nBC\r\n0FH !A nandAorBC C?nandBA:!A nandBA B?nandAC:!A nandCA nandAxnorBC nandABC",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/c7d087a0-f6be-4291-ad94-f9d6469e999e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=75e6adf0a3b3c7257c45a84207189fa2d3d3c39367961b55a51e4c17e60d8cee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 256
      },
      {
        "segments": [
          {
            "segment_id": "ee0445ec-3a62-46f5-9335-b5d5e9c0de6e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 110,
            "page_width": 612,
            "page_height": 792,
            "content": "5-8 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\n:\r\nTable 5-1 and Table 5-2 translate each of the possible value of the imm8 byte to a Boolean expression. These tables \r\ncan also be used by software to translate Boolean expressions to numerical constants to form the imm8 value \r\nneeded to construct the VPTERNLOG syntax. There is a unique set of three byte constants (F0H, CCH, AAH) that \r\ncan be used for this purpose as input operands in conjunction with the Boolean expressions defined in those tables. \r\nThe reverse mapping can be expressed as:\r\nResult_imm8 = Table_Lookup_Entry( 0F0H, 0CCH, 0AAH).\r\nTable_Lookup_Entry is the Boolean expression defined in Table 5-1 and Table 5-2.\r\n5.4 INSTRUCTION SET REFERENCE\r\nTable 5-2. Low 8 columns of the 16x16 Map of VPTERNLOG Boolean Logic Operations\r\nImm [7:4]\r\n[3:0] 08H 09H 0AH 0BH 0CH 0DH 0EH 0FH\r\n00H andABC andAxnorBC andCA B?andAC:A andBA C?andBA:A andAorBC A\r\n01H A?andBC:nor\r\nBC\r\nB?andAC:!C A?C:norBC C?A:!B A?B:norBC B?A:!C xnorAorBC orAnorBC\r\n02H andCxnorBA B?andAC:xor\r\nAC\r\nB?andAC:C B?andAC:orA\r\nC\r\nC?xnorBA:an\r\ndBA\r\nB?A:xorAC B?A:C B?A:orAC\r\n03H A?andBC:!B xnorBandAC A?C:!B nandBnandA\r\nC\r\nxnorBA B?A:nandAC A?orBC:!B orA!B\r\n04H andBxnorAC C?andBA:xor\r\nBA\r\nB?xnorAC:an\r\ndAC\r\nB?xnorAC:A C?andBA:B C?andBA:orB\r\nA\r\nC?A:B C?A:orBA\r\n05H A?andBC:!C xnorCandBA xnorCA C?A:nandBA A?B:!C nandCnandB\r\nA\r\nA?orBC:!C orA!C\r\n06H A?andBC:xor\r\nBC\r\nxorABC A?C:xorBC B?xnorAC:orA\r\nC\r\nA?B:xorBC C?xnorBA:orB\r\nA\r\nA?orBC:xorBC orAxorBC\r\n07H xnorAandBC A?xnorBC:na\r\nndBC\r\nA?C:nandBC nandBxorAC A?B:nandBC nandCxorBA A?orBCnandB\r\nC\r\norAnandBC\r\n08H andCB A?xnorBC:an\r\ndBC\r\nandCorAB B?C:A andBorAC C?B:A majorABC orAandBC\r\n09H B?C:norAC xnorCB xnorCorBA C?orBA:!B xnorBorAC B?orAC:!C A?orBC:xnorB\r\nC\r\norAxnorBC\r\n0AH A?andBC:C A?xnorBC:C C B?C:orAC A?B:C B?orAC:xorAC orCandBA orCA\r\n0BH B?C:!A B?C:nandAC orCnorBA orC!B B?orAC:!A B?orAC:nand\r\nAC\r\norCxnorBA nandBnorAC\r\n0CH A?andBC:B A?xnorBC:B A?C:B C?orBA:xorBA B C?B:orBA orBandAC orBA\r\n0DH C?B!A C?B:nandBA C?orBA:!A C?orBA:nand\r\nBA\r\norBnorAC orB!C orBxnorAC nandCnorBA\r\n0EH A?andBC:orB\r\nC\r\nA?xnorBC:orB\r\nC\r\nA?C:orBC orCxorBA A?B:orBC orBxorAC orCB orABC\r\n0FH nandAnandB\r\nC\r\nnandAxorBC orC!A orCnandBA orB!A orBnandAC nandAnorBC TRUE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/ee0445ec-3a62-46f5-9335-b5d5e9c0de6e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=92a74e46ff10448eaf703409c3b148a1c05183642088701502492c6f7f9ef1b3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "b0998756-7bea-46bd-ab67-91c66396be5d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 111,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-9\r\nINSTRUCTION SET REFERENCE, A-Z\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add \r\n(4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with \r\na sequentially selected memory operand in each of the four steps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest \r\nsignificant mask bits is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type T1_4X implies that 4 32-bit elements (16 bytes) are referenced by the memory operation portion of \r\nthis instruction.\r\nRounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. \r\nPre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational excep\u0002tions of the second FMA, etc.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 9A /r\r\nV4FMADDPS zmm1{k1}{z}, zmm2+3, \r\nm128\r\nA V/V AVX512_4FMAPS Multiply packed single-precision floating-point \r\nvalues from source register block indicated by \r\nzmm2 by values from m128 and accumulate the \r\nresult in zmm1.\r\nEVEX.DDS.512.F2.0F38.W0 AA /r\r\nV4FNMADDPS zmm1{k1}{z}, \r\nzmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply and negate packed single-precision \r\nfloating-point values from source register block \r\nindicated by zmm2 by values from m128 and \r\naccumulate the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA T1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/b0998756-7bea-46bd-ab67-91c66396be5d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e7f8b676780d82f9b77e9490359c3c18addd35f14c2b55194d3ea365e768e154",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "59725739-3510-4238-89d8-4d4b5c026f52",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "5-10 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\ndefine NFMA_PS(kl, vl, dest, k1, msrc, regs_loaded, src_base, posneg):\r\ntmpdest ← dest\r\n// reg[] is an array representing the SIMD register file.\r\nfor j ← 0 to regs_loaded-1:\r\nfor i ← 0 to kl-1:\r\nif k1[i] or *no writemask*:\r\nif posneg = 0:\r\ntmpdest.single[i] ← RoundFPControl_MXCSR(tmpdest.single[i] - reg[src_base + j ].single[i] * msrc.single[j])\r\nelse:\r\ntmpdest.single[i] ← RoundFPControl_MXCSR(tmpdest.single[i] + reg[src_base + j ].single[i] * msrc.single[j])\r\nelse if *zeroing*:\r\ntmpdest.single[i] ← 0\r\ndest ← tmpdst\r\ndest[MAX_VL-1:VL] ← 0\r\nV4FMADDPS and V4FNMADDPS dest{k1}, src1, msrc (AVX512)\r\nkl,vl = (16,512)\r\nregs_loaded ← 4\r\nsrc_base ← src_reg_id & ~3 // for src1 operand\r\nposneg ← 0 if negative form, 1 otherwise\r\nNFMA_PS(kl, vl, dest, k1, msrc, regs_loaded, src_base, posneg)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nV4FMADDPS __m512 _mm512_4fmadd_ps( __m512, __m512x4, __m128 *);\r\nV4FMADDPS __m512 _mm512_mask_4fmadd_ps(__m512, __mmask16, __m512x4, __m128 *);\r\nV4FMADDPS __m512 _mm512_maskz_4fmadd_ps(__mmask16, __m512, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_4fnmadd_ps(__m512, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_mask_4fnmadd_ps(__m512, __mmask16, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_maskz_4fnmadd_ps(__mmask16, __m512, __m512x4, __m128 *);\r\nSIMD Floating-Point Exceptions\r\nOverflow, Underflow, Invalid, Precision, Denormal.\r\nOther Exceptions\r\nSee Type E2; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/59725739-3510-4238-89d8-4d4b5c026f52.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a092207b2dd1e256368e050abc7e26ec83381ae4f57b74e076523c2093409ba9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 488
      },
      {
        "segments": [
          {
            "segment_id": "fb43ee73-af35-4ec2-820e-995d6cbf7396",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-11\r\nINSTRUCTION SET REFERENCE, A-Z\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add \r\n(4-iterations) \r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a \r\nsequentially selected memory operand in each of the four steps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that \r\noperand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if the least significant \r\nmask bit is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type T1_4X implies that 4 32-bit elements (16 bytes) are referenced by the memory operation portion of \r\nthis instruction.\r\nRounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computa\u0002tional exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, \r\netc.\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\ndefine NFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg):\r\ntmpdest ← dest\r\n// reg[] is an array representing the SIMD register file.\r\nif k1[0] or *no writemask*:\r\nfor j ← 0 to regs_loaded - 1:\r\nif posneg = 0:\r\ntmpdest.single[0] ← RoundFPControl_MXCSR(tmpdest.single[0] - reg[src_base + j ].single[0] * msrc.single[j])\r\nelse:\r\ntmpdest.single[0] ← RoundFPControl_MXCSR(tmpdest.single[0] + reg[src_base + j ].single[0] * msrc.single[j])\r\nelse if *zeroing*:\r\ntmpdest.single[0] ← 0\r\ndest ← tmpdst\r\ndest[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.LLIG.F2.0F38.W0 9B /r\r\nV4FMADDSS xmm1{k1}{z}, \r\nxmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply scalar single-precision floating-point \r\nvalues from source register block indicated by \r\nxmm2 by values from m128 and accumulate the \r\nresult in xmm1.\r\nEVEX.DDS.LLIG.F2.0F38.W0 AB /r\r\nV4FNMADDSS xmm1{k1}{z}, \r\nxmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply and negate scalar single-precision \r\nfloating-point values from source register block \r\nindicated by xmm2 by values from m128 and \r\naccumulate the result in xmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA T1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/fb43ee73-af35-4ec2-820e-995d6cbf7396.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=44c5f8527e93fc9ece576f19c336eaa6c6f1c4f14da9c5d5bd1b791f89825480",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a006f655-7eda-466f-b1c6-844474f52b5c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 114,
            "page_width": 612,
            "page_height": 792,
            "content": "5-12 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nV4FMADDSS and V4FNMADDSS dest{k1}, src1, msrc (AVX512)\r\nvl = 128\r\nregs_loaded ← 4\r\nsrc_base ← src_reg_id & ~3 // for src1 operand\r\nposneg ← 0 if negative form, 1 otherwise\r\nNFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nV4FMADDSS __m128 _mm_4fmadd_ss(__m128, __m128x4, __m128 *);\r\nV4FMADDSS __m128 _mm_mask_4fmadd_ss(__m128, __mmask8, __m128x4, __m128 *);\r\nV4FMADDSS __m128 _mm_maskz_4fmadd_ss(__mmask8, __m128, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_4fnmadd_ss(__m128, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_mask_4fnmadd_ss(__m128, __mmask8, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_maskz_4fnmadd_ss(__mmask8, __m128, __m128x4, __m128 *);\r\nSIMD Floating-Point Exceptions\r\nOverflow, Underflow, Invalid, Precision, Denormal.\r\nOther Exceptions\r\nSee Type E2; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a006f655-7eda-466f-b1c6-844474f52b5c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=948ff052bc7467b0389a2c449371a1e519d53082a1d5b09f00df87e93083f81c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 472
      },
      {
        "segments": [
          {
            "segment_id": "891b9b81-fee1-4ce0-8b60-dd5f8c113f22",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 115,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-13\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with \r\ndoubleword accumulation; see Figure 5-1 below. The memory operand is sequentially selected in each of the four \r\nsteps.\r\nIn the above box, the notation of “+3”' is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest \r\n16-bits of the mask is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type T1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion \r\nof this instruction.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 52 /r\r\nVP4DPWSSD zmm1{k1}{z}, zmm2+3, \r\nm128\r\nA V/V AVX512_4VNNIW Multiply signed words from source register block \r\nindicated by zmm2 by signed words from m128 \r\nand accumulate resulting signed dwords in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA T1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nFigure 5-1. Register Source-Block Dot Product of Two Signed Word Operands with Doubleword Accumulation1\r\nNOTES:\r\n1. For illustration purposes, one source-block dot product instance is shown out of\r\nthe four.\r\nb1 b0 b1 b0\r\nc1 c0\r\nc1=c1+a2*b0+a3*b1 c0=c0+a0*b0+a1*b1\r\na3 a2 a1 a0\r\n16b 16b 16b 16b\r\n32b 32b\r\n32b 32b",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/891b9b81-fee1-4ce0-8b60-dd5f8c113f22.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c01425b76cf928e191ce1cc67c24537afd8905ef6aa4397d74ae21365e9933e9",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e338a30c-9158-4a52-858b-8dbd067c49b7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "5-14 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\nVP4DPWSSD dest, src1, src2\r\n(KL,VL) = (16,512)\r\nN ← 4\r\nORIGDEST ← DEST\r\nsrc_base ← src_reg_id & ~ (N-1) // for src1 operand\r\nFOR i ← 0 to KL-1:\r\nIF k1[i] or *no writemask*:\r\nFOR m ← 0 to N-1:\r\nt ← SRC2.dword[m]\r\np1dword ← reg[src_base+m].word[2*i] * t.word[0]\r\np2dword ← reg[src_base+m].word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← DEST.dword[i] + p1dword + p2dword\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVP4DPWSSD __m512i _mm512_4dpwssd_epi32(__m512i, __m512ix4, __m128i *);\r\nVP4DPWSSD __m512i _mm512_mask_4dpwssd_epi32(__m512i, __mmask16, __m512ix4, __m128i *);\r\nVP4DPWSSD __m512i _mm512_maskz_4dpwssd_epi32(__mmask16, __m512i, __m512ix4, __m128i *);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/e338a30c-9158-4a52-858b-8dbd067c49b7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e0688cab64e541990fe0e30e9595b3199ec0ef4baee403aba420e76b7a10a4cb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 414
      },
      {
        "segments": [
          {
            "segment_id": "24709493-c415-4ac0-9389-4cadb3555fbf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-15\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation \r\n(4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with \r\ndoubleword accumulation and signed saturation. The memory operand is sequentially selected in each of the four \r\nsteps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest \r\n16-bits of the mask is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type T1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion \r\nof this instruction.\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\nVP4DPWSSDS dest, src1, src2\r\n(KL,VL) = (16,512)\r\nN ← 4\r\nORIGDEST ← DEST\r\nsrc_base ← src_reg_id & ~ (N-1) // for src1 operand\r\nFOR i ← 0 to KL-1:\r\nIF k1[i] or *no writemask*:\r\nFOR m ← 0 to N-1:\r\nt ← SRC2.dword[m]\r\np1dword ← reg[src_base+m].word[2*i] * t.word[0]\r\np2dword ← reg[src_base+m].word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(DEST.dword[i] + p1dword + p2dword)\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 53 /r\r\nVP4DPWSSDS zmm1{k1}{z}, \r\nzmm2+3, m128\r\nA V/V AVX512_4VNNIW Multiply signed words from source register block \r\nindicated by zmm2 by signed words from m128 \r\nand accumulate the resulting dword results with \r\nsigned saturation in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA T1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/24709493-c415-4ac0-9389-4cadb3555fbf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0c3696abc1c634be69e98899496584c1c73d655a1aee5656e3ecf29d1db6a479",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "2972d476-5c7f-4bcb-bf5b-27f6766fd846",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "5-16 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVP4DPWSSDS __m512i _mm512_4dpwssds_epi32(__m512i, __m512ix4, __m128i *);\r\nVP4DPWSSDS __m512i _mm512_mask_4dpwssds_epi32(__m512i, __mmask16, __m512ix4, __m128i *);\r\nVP4DPWSSDS __m512i _mm512_maskz_4dpwssds_epi32(__mmask16, __m512i, __m512ix4, __m128i *);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/2972d476-5c7f-4bcb-bf5b-27f6766fd846.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d2b9a4f51b8c8d85790b30bd6a6ae2e206232cb55f6a5a3c9e1db2d4a2035e0a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 369
      },
      {
        "segments": [
          {
            "segment_id": "79cb0540-0a0b-413f-ab23-053fb111f638",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-17\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMB—Permute Packed Bytes Elements \r\nInstruction Operand Encoding\r\nDescription\r\nCopies bytes from the second source operand (the third operand) to the destination operand (the first operand) \r\naccording to the byte indices in the first source operand (the second operand). Note that this instruction permits a \r\nbyte in the source operand to be copied to more than one location in the destination operand. \r\nOnly the low 6(EVEX.512)/5(EVEX.256)/4(EVEX.128) bits of each byte index is used to select the location of the \r\nsource byte from the second source operand.\r\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM reg\u0002ister, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated at byte \r\ngranularity by the writemask k1.\r\nOperation\r\nVPERMB (EVEX encoded versions)\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nIF VL = 128:\r\nn ← 3;\r\nELSE IF VL = 256:\r\nn ← 4;\r\nELSE IF VL = 512:\r\nn ← 5;\r\nFI;\r\nFOR j ← 0 TO KL-1:\r\nid ← SRC1[j*8 + n : j*8] ; // location of the source byte\r\nIF k1[j] OR *no writemask* THEN\r\nDEST[j*8 + 7: j*8] ← SRC2[id*8 +7: id*8];\r\nELSE IF zeroing-masking THEN\r\nDEST[j*8 + 7: j*8] ← 0;\r\n*ELSE \r\nDEST[j*8 + 7: j*8] remains unchanged*\r\nFI\r\nENDFOR\r\nDEST[MAX_VL-1:VL] ← 0;\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID \r\nFeature Flag\r\nDescription\r\nEVEX.NDS.128.66.0F38.W0 8D /r A V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in xmm3/m128 using byte indexes in \r\nxmm2 and store the result in xmm1 using writemask \r\nk1.\r\nVPERMB xmm1 {k1}{z}, xmm2, \r\nxmm3/m128\r\nEVEX.NDS.256.66.0F38.W0 8D /r A V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in ymm3/m256 using byte indexes in \r\nymm2 and store the result in ymm1 using writemask \r\nk1.\r\nVPERMB ymm1 {k1}{z}, ymm2, \r\nymm3/m256\r\nEVEX.NDS.512.66.0F38.W0 8D /r A V/V AVX512VBMI Permute bytes in zmm3/m512 using byte indexes in \r\nzmm2 and store the result in zmm1 using writemask \r\nk1.\r\nVPERMB zmm1 {k1}{z}, zmm2, \r\nzmm3/m512\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULLMEM ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/79cb0540-0a0b-413f-ab23-053fb111f638.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d725f99705ebd81acbc2ed5ba991f88e1e86a0a7ece16ce030e2e629c4034950",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "50968741-fd2d-40d1-af98-4ad54bdb9002",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "5-18 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPERMB __m512i _mm512_permutexvar_epi8( __m512i idx, __m512i a);\r\nVPERMB __m512i _mm512_mask_permutexvar_epi8(__m512i s, __mmask64 k, __m512i idx, __m512i a);\r\nVPERMB __m512i _mm512_maskz_permutexvar_epi8( __mmask64 k, __m512i idx, __m512i a);\r\nVPERMB __m256i _mm256_permutexvar_epi8( __m256i idx, __m256i a);\r\nVPERMB __m256i _mm256_mask_permutexvar_epi8(__m256i s, __mmask32 k, __m256i idx, __m256i a);\r\nVPERMB __m256i _mm256_maskz_permutexvar_epi8( __mmask32 k, __m256i idx, __m256i a);\r\nVPERMB __m128i _mm_permutexvar_epi8( __m128i idx, __m128i a);\r\nVPERMB __m128i _mm_mask_permutexvar_epi8(__m128i s, __mmask16 k, __m128i idx, __m128i a);\r\nVPERMB __m128i _mm_maskz_permutexvar_epi8( __mmask16 k, __m128i idx, __m128i a);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.nb.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/50968741-fd2d-40d1-af98-4ad54bdb9002.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aa8b023134a381e8174c2f4e8280263b64a219e87177634bceb36c9048c2c88f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 444
      },
      {
        "segments": [
          {
            "segment_id": "a8575b83-e479-414b-bdc3-71943946192a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-19\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMI2B—Full Permute of Bytes from Two Tables Overwriting the Index\r\nInstruction Operand Encoding\r\nDescription\r\nPermutes byte values in the second operand (the first source operand) and the third operand (the second source \r\noperand) using the byte indices in the first operand (the destination operand) to select byte elements from the \r\nsecond or third source operands. The selected byte elements are written to the destination at byte granularity \r\nunder the writemask k1. \r\nThe first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select \r\nelements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the \r\nresult. The third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In each index \r\nbyte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each input table.\r\nNote that these instructions permit a byte value in the source operands to be copied to more than one location in \r\nthe destination operand. Also, the same tables can be reused in subsequent iterations, but the index elements are \r\noverwritten.\r\nBits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 75 /r\r\nVPERMI2B xmm1 {k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in xmm3/m128 and xmm2 using \r\nbyte indexes in xmm1 and store the byte results \r\nin xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 75 /r\r\nVPERMI2B ymm1 {k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in ymm3/m256 and ymm2 using \r\nbyte indexes in ymm1 and store the byte results \r\nin ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 75 /r\r\nVPERMI2B zmm1 {k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512VBMI Permute bytes in zmm3/m512 and zmm2 using \r\nbyte indexes in zmm1 and store the byte results \r\nin zmm1 using writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULLMEM ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a8575b83-e479-414b-bdc3-71943946192a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2b73b2199eccdc9f7b06efe102abe34457003ffbcc66a197219e7f206cf8cfbc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 331
      },
      {
        "segments": [
          {
            "segment_id": "4819028f-448f-42fe-b00a-dcca3f2dfb11",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 122,
            "page_width": 612,
            "page_height": 792,
            "content": "5-20 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPERMI2B (EVEX encoded versions)\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nIF VL = 128:\r\nid ← 3;\r\nELSE IF VL = 256:\r\nid ← 4;\r\nELSE IF VL = 512:\r\nid ← 5;\r\nFI;\r\nTMP_DEST[VL-1:0] ← DEST[VL-1:0];\r\nFOR j ← 0 TO KL-1\r\noff ← 8*SRC1[j*8 + id: j*8] ;\r\nIF k1[j] OR *no writemask*:\r\nDEST[j*8 + 7: j*8] ← TMP_DEST[j*8+id+1]? SRC2[off+7:off] : SRC1[off+7:off];\r\nELSE IF *zeroing-masking*\r\nDEST[j*8 + 7: j*8] ← 0;\r\n*ELSE \r\nDEST[j*8 + 7: j*8] remains unchanged*\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL] ← 0;\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPERMI2B __m512i _mm512_permutex2var_epi8(__m512i a, __m512i idx, __m512i b);\r\nVPERMI2B __m512i _mm512_mask2_permutex2var_epi8(__m512i a, __m512i idx, __mmask64 k, __m512i b);\r\nVPERMI2B __m512i _mm512_maskz_permutex2var_epi8(__mmask64 k, __m512i a, __m512i idx, __m512i b);\r\nVPERMI2B __m256i _mm256_permutex2var_epi8(__m256i a, __m256i idx, __m256i b);\r\nVPERMI2B __m256i _mm256_mask2_permutex2var_epi8(__m256i a, __m256i idx, __mmask32 k, __m256i b);\r\nVPERMI2B __m256i _mm256_maskz_permutex2var_epi8(__mmask32 k, __m256i a, __m256i idx, __m256i b);\r\nVPERMI2B __m128i _mm_permutex2var_epi8(__m128i a, __m128i idx, __m128i b);\r\nVPERMI2B __m128i _mm_mask2_permutex2var_epi8(__m128i a, __m128i idx, __mmask16 k, __m128i b);\r\nVPERMI2B __m128i _mm_maskz_permutex2var_epi8(__mmask16 k, __m128i a, __m128i idx, __m128i b);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.nb.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/4819028f-448f-42fe-b00a-dcca3f2dfb11.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d230ab32f2344e5bf13aa49f51fe98f0708ecb0b234077c1bf4438c59123ad50",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 196
      },
      {
        "segments": [
          {
            "segment_id": "501186b9-07a7-4aa4-880b-a502c04cfb36",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 123,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-21\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMT2B—Full Permute of Bytes from Two Tables Overwriting a Table\r\nInstruction Operand Encoding\r\nDescription\r\nPermutes byte values from two tables, comprising of the first operand (also the destination operand) and the third \r\noperand (the second source operand). The second operand (the first source operand) provides byte indices to \r\nselect byte results from the two tables. The selected byte elements are written to the destination at byte granu\u0002larity under the writemask k1. \r\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select \r\nelements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the \r\nresult. The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In \r\neach index byte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each \r\ninput table.\r\nNote that these instructions permit a byte value in the source operands to be copied to more than one location in \r\nthe destination operand. Also, the second table and the indices can be reused in subsequent iterations, but the first \r\ntable is overwritten.\r\nBits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.\r\nOpcode/\r\nInstruction\r\nOp\r\n/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 7D /r\r\nVPERMT2B xmm1 {k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in xmm3/m128 and xmm1 using byte \r\nindexes in xmm2 and store the byte results in xmm1 \r\nusing writemask k1.\r\nEVEX.NDS.256.66.0F38.W0 7D /r\r\nVPERMT2B ymm1 {k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512VL\r\nAVX512VBMI\r\nPermute bytes in ymm3/m256 and ymm1 using byte \r\nindexes in ymm2 and store the byte results in ymm1 \r\nusing writemask k1.\r\nEVEX.NDS.512.66.0F38.W0 7D /r\r\nVPERMT2B zmm1 {k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512VBMI Permute bytes in zmm3/m512 and zmm1 using byte \r\nindexes in zmm2 and store the byte results in zmm1 \r\nusing writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULLMEM ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/501186b9-07a7-4aa4-880b-a502c04cfb36.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=37454c0f06a6b6d875e3a3ce54a6097d66b72f62fb6edecad9ca15642019fb59",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 336
      },
      {
        "segments": [
          {
            "segment_id": "4abb68f3-7b30-4739-91ab-c76955f20604",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 124,
            "page_width": 612,
            "page_height": 792,
            "content": "5-22 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPERMT2B (EVEX encoded versions)\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nIF VL = 128:\r\nid ← 3;\r\nELSE IF VL = 256:\r\nid ← 4;\r\nELSE IF VL = 512:\r\nid ← 5;\r\nFI;\r\nTMP_DEST[VL-1:0] ← DEST[VL-1:0];\r\nFOR j ← 0 TO KL-1\r\noff ← 8*SRC1[j*8 + id: j*8] ;\r\nIF k1[j] OR *no writemask*:\r\nDEST[j*8 + 7: j*8] ← SRC1[j*8+id+1]? SRC2[off+7:off] : TMP_DEST[off+7:off];\r\nELSE IF *zeroing-masking*\r\nDEST[j*8 + 7: j*8] ← 0;\r\n*ELSE \r\nDEST[j*8 + 7: j*8] remains unchanged*\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL] ← 0;\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPERMT2B __m512i _mm512_permutex2var_epi8(__m512i a, __m512i idx, __m512i b);\r\nVPERMT2B __m512i _mm512_mask_permutex2var_epi8(__m512i a, __mmask64 k, __m512i idx, __m512i b);\r\nVPERMT2B __m512i _mm512_maskz_permutex2var_epi8(__mmask64 k, __m512i a, __m512i idx, __m512i b);\r\nVPERMT2B __m256i _mm256_permutex2var_epi8(__m256i a, __m256i idx, __m256i b);\r\nVPERMT2B __m256i _mm256_mask_permutex2var_epi8(__m256i a, __mmask32 k, __m256i idx, __m256i b);\r\nVPERMT2B __m256i _mm256_maskz_permutex2var_epi8(__mmask32 k, __m256i a, __m256i idx, __m256i b);\r\nVPERMT2B __m128i _mm_permutex2var_epi8(__m128i a, __m128i idx, __m128i b);\r\nVPERMT2B __m128i _mm_mask_permutex2var_epi8(__m128i a, __mmask16 k, __m128i idx, __m128i b);\r\nVPERMT2B __m128i _mm_maskz_permutex2var_epi8(__mmask16 k, __m128i a, __m128i idx, __m128i b);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.nb.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/4abb68f3-7b30-4739-91ab-c76955f20604.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ecee153a33b47ed612d4f8d679888a0c663737710a1ca198f0adf626a256675c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 196
      },
      {
        "segments": [
          {
            "segment_id": "d76d2f2d-1494-4ede-aee2-daa5e4bd416d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 125,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-23\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMT2W/D/Q/PS/PD—Full Permute from Two Tables Overwriting one Table\r\nOpcode/\r\nInstruction\r\nOp / \r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID \r\nFeature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W1 7D /r\r\nVPERMT2W xmm1 {k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512VL\r\nAVX512BW\r\nPermute word integers from two tables in xmm3/m128 \r\nand xmm1 using indexes in xmm2 and store the result in \r\nxmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7D /r\r\nVPERMT2W ymm1 {k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512VL\r\nAVX512BW\r\nPermute word integers from two tables in ymm3/m256 \r\nand ymm1 using indexes in ymm2 and store the result in \r\nymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7D /r\r\nVPERMT2W zmm1 {k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512BW Permute word integers from two tables in zmm3/m512 \r\nand zmm1 using indexes in zmm2 and store the result in \r\nzmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W0 7E /r\r\nVPERMT2D xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-words from two tables in \r\nxmm3/m128/m32bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 7E /r\r\nVPERMT2D ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-words from two tables in \r\nymm3/m256/m32bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 7E /r\r\nVPERMT2D zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512F Permute double-words from two tables in \r\nzmm3/m512/m32bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W1 7E /r\r\nVPERMT2Q xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute quad-words from two tables in \r\nxmm3/m128/m64bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7E /r\r\nVPERMT2Q ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute quad-words from two tables in \r\nymm3/m256/m64bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7E /r\r\nVPERMT2Q zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512F Permute quad-words from two tables in \r\nzmm3/m512/m64bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W0 7F /r\r\nVPERMT2PS xmm1 {k1}{z}, \r\nxmm2, xmm3/m128/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute single-precision FP values from two tables in \r\nxmm3/m128/m32bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 7F /r\r\nVPERMT2PS ymm1 {k1}{z}, \r\nymm2, ymm3/m256/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute single-precision FP values from two tables in \r\nymm3/m256/m32bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 7F /r\r\nVPERMT2PS zmm1 {k1}{z}, \r\nzmm2, zmm3/m512/m32bcst\r\nB V/V AVX512F Permute single-precision FP values from two tables in \r\nzmm3/m512/m32bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W1 7F /r\r\nVPERMT2PD xmm1 {k1}{z}, \r\nxmm2, xmm3/m128/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-precision FP values from two tables in \r\nxmm3/m128/m64bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7F /r\r\nVPERMT2PD ymm1 {k1}{z}, \r\nymm2, ymm3/m256/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-precision FP values from two tables in \r\nymm3/m256/m64bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7F /r\r\nVPERMT2PD zmm1 {k1}{z}, \r\nzmm2, zmm3/m512/m64bcst\r\nB V/V AVX512F Permute double-precision FP values from two tables in \r\nzmm3/m512/m64bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/d76d2f2d-1494-4ede-aee2-daa5e4bd416d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b05720144181d0ad801dd379341efc9932aef61e5b0c2058a94312808c69e57f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 549
      },
      {
        "segments": [
          {
            "segment_id": "d76d2f2d-1494-4ede-aee2-daa5e4bd416d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 125,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-23\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMT2W/D/Q/PS/PD—Full Permute from Two Tables Overwriting one Table\r\nOpcode/\r\nInstruction\r\nOp / \r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID \r\nFeature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W1 7D /r\r\nVPERMT2W xmm1 {k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512VL\r\nAVX512BW\r\nPermute word integers from two tables in xmm3/m128 \r\nand xmm1 using indexes in xmm2 and store the result in \r\nxmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7D /r\r\nVPERMT2W ymm1 {k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512VL\r\nAVX512BW\r\nPermute word integers from two tables in ymm3/m256 \r\nand ymm1 using indexes in ymm2 and store the result in \r\nymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7D /r\r\nVPERMT2W zmm1 {k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512BW Permute word integers from two tables in zmm3/m512 \r\nand zmm1 using indexes in zmm2 and store the result in \r\nzmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W0 7E /r\r\nVPERMT2D xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-words from two tables in \r\nxmm3/m128/m32bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 7E /r\r\nVPERMT2D ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-words from two tables in \r\nymm3/m256/m32bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 7E /r\r\nVPERMT2D zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512F Permute double-words from two tables in \r\nzmm3/m512/m32bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W1 7E /r\r\nVPERMT2Q xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute quad-words from two tables in \r\nxmm3/m128/m64bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7E /r\r\nVPERMT2Q ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute quad-words from two tables in \r\nymm3/m256/m64bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7E /r\r\nVPERMT2Q zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512F Permute quad-words from two tables in \r\nzmm3/m512/m64bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W0 7F /r\r\nVPERMT2PS xmm1 {k1}{z}, \r\nxmm2, xmm3/m128/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute single-precision FP values from two tables in \r\nxmm3/m128/m32bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 7F /r\r\nVPERMT2PS ymm1 {k1}{z}, \r\nymm2, ymm3/m256/m32bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute single-precision FP values from two tables in \r\nymm3/m256/m32bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 7F /r\r\nVPERMT2PS zmm1 {k1}{z}, \r\nzmm2, zmm3/m512/m32bcst\r\nB V/V AVX512F Permute single-precision FP values from two tables in \r\nzmm3/m512/m32bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.\r\nEVEX.DDS.128.66.0F38.W1 7F /r\r\nVPERMT2PD xmm1 {k1}{z}, \r\nxmm2, xmm3/m128/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-precision FP values from two tables in \r\nxmm3/m128/m64bcst and xmm1 using indexes in xmm2 \r\nand store the result in xmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 7F /r\r\nVPERMT2PD ymm1 {k1}{z}, \r\nymm2, ymm3/m256/m64bcst\r\nB V/V AVX512VL\r\nAVX512F\r\nPermute double-precision FP values from two tables in \r\nymm3/m256/m64bcst and ymm1 using indexes in ymm2 \r\nand store the result in ymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 7F /r\r\nVPERMT2PD zmm1 {k1}{z}, \r\nzmm2, zmm3/m512/m64bcst\r\nB V/V AVX512F Permute double-precision FP values from two tables in \r\nzmm3/m512/m64bcst and zmm1 using indices in zmm2 \r\nand store the result in zmm1 using writemask k1.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/d76d2f2d-1494-4ede-aee2-daa5e4bd416d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b05720144181d0ad801dd379341efc9932aef61e5b0c2058a94312808c69e57f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 549
      },
      {
        "segments": [
          {
            "segment_id": "555b6a8e-63f0-47ff-ae90-14823e1ac96c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 126,
            "page_width": 612,
            "page_height": 792,
            "content": "5-24 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nInstruction Operand Encoding\r\nDescription\r\nPermutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using \r\nindices in the second operand (the first source operand) to select elements from the first and third operands. The \r\nselected elements are written to the destination operand (the first operand) according to the writemask k1. \r\nThe first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select \r\nelements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the \r\nresult. \r\nD/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit \r\nmemory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the \r\nlow 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).\r\nDword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits \r\n[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If \r\nthe id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.\r\nQword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each \r\ninput table.\r\nWord element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit \r\nmemory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each \r\ninput table. \r\nNote that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than \r\none location in the destination operand. Note also that in this case, the same index can be reused for example for \r\na second iteration, while the table elements being permuted are overwritten.\r\nBits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128. \r\nOperation\r\nVPERMT2W (EVEX encoded versions)\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nIF VL = 128\r\nid  2\r\nFI;\r\nIF VL = 256\r\nid  3\r\nFI;\r\nIF VL = 512\r\nid  4\r\nFI;\r\nTMP_DEST DEST\r\nFOR j  0 TO KL-1\r\ni  j * 16\r\noff  16*SRC1[i+id:i]\r\nIF k1[j] OR *no writemask*\r\nTHEN \r\nDEST[i+15:i]=SRC1[i+id+1] ? SRC2[off+15:off] \r\n : TMP_DEST[off+15:off]\r\nELSE \r\nIF *merging-masking* ; merging-masking\r\nTHEN *DEST[i+15:i] remains unchanged*\r\nELSE ; zeroing-masking\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULLMEM ModRM:reg (r,w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB FULL ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/555b6a8e-63f0-47ff-ae90-14823e1ac96c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=54f4532286f5bba9d01e701a53078a0daac8e80a528981c1c6a423042f8f52c8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 424
      },
      {
        "segments": [
          {
            "segment_id": "a5d97f8f-eff9-4e6f-b8f7-77b5e3e11f3b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 127,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-25\r\nINSTRUCTION SET REFERENCE, A-Z\r\nDEST[i+15:i]  0\r\nFI\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL]  0\r\nVPERMT2D/VPERMT2PS (EVEX encoded versions)\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nIF VL = 128\r\nid  1\r\nFI;\r\nIF VL = 256\r\nid  2\r\nFI;\r\nIF VL = 512\r\nid  3\r\nFI;\r\nTMP_DEST DEST\r\nFOR j  0 TO KL-1\r\ni  j * 32\r\noff  32*SRC1[i+id:i]\r\nIF k1[j] OR *no writemask*\r\nTHEN \r\nIF (EVEX.b = 1) AND (SRC2 *is memory*)\r\nTHEN \r\nDEST[i+31:i]  SRC1[i+id+1] ? SRC2[31:0] \r\n : TMP_DEST[off+31:off]\r\nELSE \r\nDEST[i+31:i]  SRC1[i+id+1] ? SRC2[off+31:off] \r\n : TMP_DEST[off+31:off]\r\nFI\r\nELSE \r\nIF *merging-masking* ; merging-masking\r\nTHEN *DEST[i+31:i] remains unchanged*\r\nELSE ; zeroing-masking\r\nDEST[i+31:i]  0\r\nFI\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL]  0\r\nVPERMT2Q/VPERMT2PD (EVEX encoded versions)\r\n(KL, VL) = (2, 128), (4, 256), (8 512)\r\nIF VL = 128\r\nid  0\r\nFI;\r\nIF VL = 256\r\nid  1\r\nFI;\r\nIF VL = 512\r\nid  2\r\nFI;\r\nTMP_DEST DEST\r\nFOR j  0 TO KL-1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/a5d97f8f-eff9-4e6f-b8f7-77b5e3e11f3b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=18af3d1d7be436dbacbbb9166d874bad08407eae73a68f9019bef9667acccf1a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "00eca8de-f3fc-4721-b23f-2869a94b24f5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 128,
            "page_width": 612,
            "page_height": 792,
            "content": "5-26 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\ni  j * 64\r\noff  64*SRC1[i+id:i]\r\nIF k1[j] OR *no writemask*\r\nTHEN \r\nIF (EVEX.b = 1) AND (SRC2 *is memory*)\r\nTHEN \r\nDEST[i+63:i]  SRC1[i+id+1] ? SRC2[63:0] \r\n : TMP_DEST[off+63:off]\r\nELSE \r\nDEST[i+63:i]  SRC1[i+id+1] ? SRC2[off+63:off] \r\n : TMP_DEST[off+63:off]\r\nFI\r\nELSE \r\nIF *merging-masking* ; merging-masking\r\nTHEN *DEST[i+63:i] remains unchanged*\r\nELSE ; zeroing-masking\r\nDEST[i+63:i]  0\r\nFI\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL]  0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPERMT2D __m512i _mm512_permutex2var_epi32(__m512i a, __m512i idx, __m512i b);\r\nVPERMT2D __m512i _mm512_mask_permutex2var_epi32(__m512i a, __mmask16 k, __m512i idx, __m512i b);\r\nVPERMT2D __m512i _mm512_mask2_permutex2var_epi32(__m512i a, __m512i idx, __mmask16 k, __m512i b);\r\nVPERMT2D __m512i _mm512_maskz_permutex2var_epi32(__mmask16 k, __m512i a, __m512i idx, __m512i b);\r\nVPERMT2D __m256i _mm256_permutex2var_epi32(__m256i a, __m256i idx, __m256i b);\r\nVPERMT2D __m256i _mm256_mask_permutex2var_epi32(__m256i a, __mmask8 k, __m256i idx, __m256i b);\r\nVPERMT2D __m256i _mm256_mask2_permutex2var_epi32(__m256i a, __m256i idx, __mmask8 k, __m256i b);\r\nVPERMT2D __m256i _mm256_maskz_permutex2var_epi32(__mmask8 k, __m256i a, __m256i idx, __m256i b);\r\nVPERMT2D __m128i _mm_permutex2var_epi32(__m128i a, __m128i idx, __m128i b);\r\nVPERMT2D __m128i _mm_mask_permutex2var_epi32(__m128i a, __mmask8 k, __m128i idx, __m128i b);\r\nVPERMT2D __m128i _mm_mask2_permutex2var_epi32(__m128i a, __m128i idx, __mmask8 k, __m128i b);\r\nVPERMT2D __m128i _mm_maskz_permutex2var_epi32(__mmask8 k, __m128i a, __m128i idx, __m128i b);\r\nVPERMT2PD __m512d _mm512_permutex2var_pd(__m512d a, __m512i idx, __m512d b);\r\nVPERMT2PD __m512d _mm512_mask_permutex2var_pd(__m512d a, __mmask8 k, __m512i idx, __m512d b);\r\nVPERMT2PD __m512d _mm512_mask2_permutex2var_pd(__m512d a, __m512i idx, __mmask8 k, __m512d b);\r\nVPERMT2PD __m512d _mm512_maskz_permutex2var_pd(__mmask8 k, __m512d a, __m512i idx, __m512d b);\r\nVPERMT2PD __m256d _mm256_permutex2var_pd(__m256d a, __m256i idx, __m256d b);\r\nVPERMT2PD __m256d _mm256_mask_permutex2var_pd(__m256d a, __mmask8 k, __m256i idx, __m256d b);\r\nVPERMT2PD __m256d _mm256_mask2_permutex2var_pd(__m256d a, __m256i idx, __mmask8 k, __m256d b);\r\nVPERMT2PD __m256d _mm256_maskz_permutex2var_pd(__mmask8 k, __m256d a, __m256i idx, __m256d b);\r\nVPERMT2PD __m128d _mm_permutex2var_pd(__m128d a, __m128i idx, __m128d b);\r\nVPERMT2PD __m128d _mm_mask_permutex2var_pd(__m128d a, __mmask8 k, __m128i idx, __m128d b);\r\nVPERMT2PD __m128d _mm_mask2_permutex2var_pd(__m128d a, __m128i idx, __mmask8 k, __m128d b);\r\nVPERMT2PD __m128d _mm_maskz_permutex2var_pd(__mmask8 k, __m128d a, __m128i idx, __m128d b);\r\nVPERMT2PS __m512 _mm512_permutex2var_ps(__m512 a, __m512i idx, __m512 b);\r\nVPERMT2PS __m512 _mm512_mask_permutex2var_ps(__m512 a, __mmask16 k, __m512i idx, __m512 b);\r\nVPERMT2PS __m512 _mm512_mask2_permutex2var_ps(__m512 a, __m512i idx, __mmask16 k, __m512 b);\r\nVPERMT2PS __m512 _mm512_maskz_permutex2var_ps(__mmask16 k, __m512 a, __m512i idx, __m512 b);",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/00eca8de-f3fc-4721-b23f-2869a94b24f5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=befadac6f00608ac07acd1f60fd604ea0a8f43a26f32a70d0dd5519bd60fe94f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 506
      },
      {
        "segments": [
          {
            "segment_id": "02be2013-c794-4d53-889e-8b7c4a958e87",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 129,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-27\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPERMT2PS __m256 _mm256_permutex2var_ps(__m256 a, __m256i idx, __m256 b);\r\nVPERMT2PS __m256 _mm256_mask_permutex2var_ps(__m256 a, __mmask8 k, __m256i idx, __m256 b);\r\nVPERMT2PS __m256 _mm256_mask2_permutex2var_ps(__m256 a, __m256i idx, __mmask8 k, __m256 b);\r\nVPERMT2PS __m256 _mm256_maskz_permutex2var_ps(__mmask8 k, __m256 a, __m256i idx, __m256 b);\r\nVPERMT2PS __m128 _mm_permutex2var_ps(__m128 a, __m128i idx, __m128 b);\r\nVPERMT2PS __m128 _mm_mask_permutex2var_ps(__m128 a, __mmask8 k, __m128i idx, __m128 b);\r\nVPERMT2PS __m128 _mm_mask2_permutex2var_ps(__m128 a, __m128i idx, __mmask8 k, __m128 b);\r\nVPERMT2PS __m128 _mm_maskz_permutex2var_ps(__mmask8 k, __m128 a, __m128i idx, __m128 b);\r\nVPERMT2Q __m512i _mm512_permutex2var_epi64(__m512i a, __m512i idx, __m512i b);\r\nVPERMT2Q __m512i _mm512_mask_permutex2var_epi64(__m512i a, __mmask8 k, __m512i idx, __m512i b);\r\nVPERMT2Q __m512i _mm512_mask2_permutex2var_epi64(__m512i a, __m512i idx, __mmask8 k, __m512i b);\r\nVPERMT2Q __m512i _mm512_maskz_permutex2var_epi64(__mmask8 k, __m512i a, __m512i idx, __m512i b);\r\nVPERMT2Q __m256i _mm256_permutex2var_epi64(__m256i a, __m256i idx, __m256i b);\r\nVPERMT2Q __m256i _mm256_mask_permutex2var_epi64(__m256i a, __mmask8 k, __m256i idx, __m256i b);\r\nVPERMT2Q __m256i _mm256_mask2_permutex2var_epi64(__m256i a, __m256i idx, __mmask8 k, __m256i b);\r\nVPERMT2Q __m256i _mm256_maskz_permutex2var_epi64(__mmask8 k, __m256i a, __m256i idx, __m256i b);\r\nVPERMT2Q __m128i _mm_permutex2var_epi64(__m128i a, __m128i idx, __m128i b);\r\nVPERMT2Q __m128i _mm_mask_permutex2var_epi64(__m128i a, __mmask8 k, __m128i idx, __m128i b);\r\nVPERMT2Q __m128i _mm_mask2_permutex2var_epi64(__m128i a, __m128i idx, __mmask8 k, __m128i b);\r\nVPERMT2Q __m128i _mm_maskz_permutex2var_epi64(__mmask8 k, __m128i a, __m128i idx, __m128i b);\r\nVPERMT2W __m512i _mm512_permutex2var_epi16(__m512i a, __m512i idx, __m512i b);\r\nVPERMT2W __m512i _mm512_mask_permutex2var_epi16(__m512i a, __mmask32 k, __m512i idx, __m512i b);\r\nVPERMT2W __m512i _mm512_mask2_permutex2var_epi16(__m512i a, __m512i idx, __mmask32 k, __m512i b);\r\nVPERMT2W __m512i _mm512_maskz_permutex2var_epi16(__mmask32 k, __m512i a, __m512i idx, __m512i b);\r\nVPERMT2W __m256i _mm256_permutex2var_epi16(__m256i a, __m256i idx, __m256i b);\r\nVPERMT2W __m256i _mm256_mask_permutex2var_epi16(__m256i a, __mmask16 k, __m256i idx, __m256i b);\r\nVPERMT2W __m256i _mm256_mask2_permutex2var_epi16(__m256i a, __m256i idx, __mmask16 k, __m256i b);\r\nVPERMT2W __m256i _mm256_maskz_permutex2var_epi16(__mmask16 k, __m256i a, __m256i idx, __m256i b);\r\nVPERMT2W __m128i _mm_permutex2var_epi16(__m128i a, __m128i idx, __m128i b);\r\nVPERMT2W __m128i _mm_mask_permutex2var_epi16(__m128i a, __mmask8 k, __m128i idx, __m128i b);\r\nVPERMT2W __m128i _mm_mask2_permutex2var_epi16(__m128i a, __m128i idx, __mmask8 k, __m128i b);\r\nVPERMT2W __m128i _mm_maskz_permutex2var_epi16(__mmask8 k, __m128i a, __m128i idx, __m128i b);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVPERMT2D/Q/PS/PD: See Exceptions Type E4NF.\r\nVPERMT2W: See Exceptions Type E4NF.nb.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/02be2013-c794-4d53-889e-8b7c4a958e87.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e302b2355cc9779ca3f80c165c46acc477962aa85eae26a562f069dd4b665d38",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 328
      },
      {
        "segments": [
          {
            "segment_id": "f8a7d53e-3553-4df2-be44-58bf37a74b51",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 130,
            "page_width": 612,
            "page_height": 792,
            "content": "5-28 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPMADD52LUQ—Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products \r\nto Qword Accumulators\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second oper\u0002and) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the \r\nthird operand) to form packed 104-bit intermediate results. The low 52-bit, unsigned integer of each 104-bit \r\nproduct is added to the corresponding qword unsigned integer of the destination operand (the first operand) \r\nunder the writemask k1.\r\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM reg\u0002ister, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory loca\u0002tion. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit \r\ngranularity.\r\nOpcode/\r\nInstruction\r\nOp/En 32/64 \r\nbit Mode \r\nSupport\r\nCPUID Description\r\nEVEX.DDS.128.66.0F38.W1 B4 /r\r\nVPMADD52LUQ xmm1 {k1}{z}, \r\nxmm2,xmm3/m128/m64bcst\r\nA V/V AVX512IFMA\r\nAVX512VL\r\nMultiply unsigned 52-bit integers in xmm2 and \r\nxmm3/m128 and add the low 52 bits of the 104-bit \r\nproduct to the qword unsigned integers in xmm1 \r\nusing writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 B4 /r\r\nVPMADD52LUQ ymm1 {k1}{z}, \r\nymm2, ymm3/m256/m64bcst\r\nA V/V AVX512IFMA\r\nAVX512VL\r\nMultiply unsigned 52-bit integers in ymm2 and \r\nymm3/m128 and add the low 52 bits of the 104-bit \r\nproduct to the qword unsigned integers in ymm1 \r\nusing writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 B4 /r\r\nVPMADD52LUQ zmm1 {k1}{z}, \r\nzmm2,zmm3/m512/m64bcst\r\nA V/V AVX512IFMA Multiply unsigned 52-bit integers in zmm2 and \r\nzmm3/m128 and add the low 52 bits of the 104-bit \r\nproduct to the qword unsigned integers in zmm1 \r\nusing writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULL ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m(r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/f8a7d53e-3553-4df2-be44-58bf37a74b51.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1f62ce6e7ead595bed2be566e60b6ca66daccb99f543f00c0453075898048b59",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6994ac07-af62-4f2d-b724-7d9735a773b0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 131,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-29\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPMADD52LUQ (EVEX encoded)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1\r\ni  j * 64;\r\nIF k1[j] OR *no writemask* THEN\r\nIF src2 is Memory AND EVEX.b=1 THEN\r\ntsrc2[63:0] ← ZeroExtend64(src2[51:0]);\r\nELSE\r\ntsrc2[63:0] ← ZeroExtend64(src2[i+51:i];\r\nFI;\r\nTemp128[127:0] ← ZeroExtend64(src1[i+51:i]) * tsrc2[63:0];\r\nTemp2[63:0] ← DEST[i+63:i] + ZeroExtend64(temp128[51:0]) ;\r\nDEST[i+63:i] ← Temp2[63:0];\r\nELSE \r\nIF *zeroing-masking* THEN\r\nDEST[i+63:i] ← 0;\r\nELSE *merge-masking*\r\nDEST[i+63:i] is unchanged;\r\nFI;\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL] ← 0;\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPMADD52LUQ __m512i _mm512_madd52lo_epu64( __m512i a, __m512i b, __m512i c);\r\nVPMADD52LUQ __m512i _mm512_mask_madd52lo_epu64(__m512i s, __mmask8 k, __m512i a, __m512i b, __m512i c);\r\nVPMADD52LUQ __m512i _mm512_maskz_madd52lo_epu64( __mmask8 k, __m512i a, __m512i b, __m512i c);\r\nVPMADD52LUQ __m256i _mm256_madd52lo_epu64( __m256i a, __m256i b, __m256i c);\r\nVPMADD52LUQ __m256i _mm256_mask_madd52lo_epu64(__m256i s, __mmask8 k, __m256i a, __m256i b, __m256i c);\r\nVPMADD52LUQ __m256i _mm256_maskz_madd52lo_epu64( __mmask8 k, __m256i a, __m256i b, __m256i c);\r\nVPMADD52LUQ __m128i _mm_madd52lo_epu64( __m128i a, __m128i b, __m128i c);\r\nVPMADD52LUQ __m128i _mm_mask_madd52lo_epu64(__m128i s, __mmask8 k, __m128i a, __m128i b, __m128i c);\r\nVPMADD52LUQ __m128i _mm_maskz_madd52lo_epu64( __mmask8 k, __m128i a, __m128i b, __m128i c);\r\nFlags Affected\r\nNone.\r\nSIMD Floating-Point Exceptions\r\nNone\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/6994ac07-af62-4f2d-b724-7d9735a773b0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2361fd47587a2fb59d9153d1d8fff8bddf7939b4c96578409e1d274a0024f3a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 486
      },
      {
        "segments": [
          {
            "segment_id": "7fc6b9bc-f068-43c3-8a56-2632b6525f41",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 132,
            "page_width": 612,
            "page_height": 792,
            "content": "5-30 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPMADD52HUQ—Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit \r\nProducts to 64-bit Accumulators\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second oper\u0002and) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the \r\nthird operand) to form packed 104-bit intermediate results. The high 52-bit, unsigned integer of each 104-bit \r\nproduct is added to the corresponding qword unsigned integer of the destination operand (the first operand) \r\nunder the writemask k1.\r\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM reg\u0002ister, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory loca\u0002tion. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit \r\ngranularity.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n32/64 \r\nbit Mode \r\nSupport\r\nCPUID Description\r\nEVEX.DDS.128.66.0F38.W1 B5 /r\r\nVPMADD52HUQ xmm1 {k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nA V/V AVX512IFMA\r\nAVX512VL\r\nMultiply unsigned 52-bit integers in xmm2 and \r\nxmm3/m128 and add the high 52 bits of the 104-\r\nbit product to the qword unsigned integers in \r\nxmm1 using writemask k1.\r\nEVEX.DDS.256.66.0F38.W1 B5 /r\r\nVPMADD52HUQ ymm1 {k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nA V/V AVX512IFMA\r\nAVX512VL\r\nMultiply unsigned 52-bit integers in ymm2 and \r\nymm3/m128 and add the high 52 bits of the 104-\r\nbit product to the qword unsigned integers in \r\nymm1 using writemask k1.\r\nEVEX.DDS.512.66.0F38.W1 B5 /r\r\nVPMADD52HUQ zmm1 {k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nA V/V AVX512IFMA Multiply unsigned 52-bit integers in zmm2 and \r\nzmm3/m128 and add the high 52 bits of the 104-\r\nbit product to the qword unsigned integers in \r\nzmm1 using writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nFV FULL ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m(r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/7fc6b9bc-f068-43c3-8a56-2632b6525f41.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0e6406a3e7937341370f613a88461dd909442d9dd23a28e82246440fa0ce7e66",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "5c5c8d83-4a29-4dfb-beda-d70da1d09fb7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 133,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-31\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPMADD52HUQ (EVEX encoded)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1\r\ni  j * 64;\r\nIF k1[j] OR *no writemask* THEN\r\nIF src2 is Memory AND EVEX.b=1 THEN\r\ntsrc2[63:0] ← ZeroExtend64(src2[51:0]);\r\nELSE\r\ntsrc2[63:0] ← ZeroExtend64(src2[i+51:i];\r\nFI;\r\nTemp128[127:0] ← ZeroExtend64(src1[i+51:i]) * tsrc2[63:0];\r\nTemp2[63:0] ← DEST[i+63:i] + ZeroExtend64(temp128[103:52]) ;\r\nDEST[i+63:i] ← Temp2[63:0];\r\nELSE \r\nIF *zeroing-masking* THEN\r\nDEST[i+63:i] ← 0;\r\nELSE *merge-masking*\r\nDEST[i+63:i] is unchanged;\r\nFI;\r\nFI;\r\nENDFOR\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPMADD52HUQ __m512i _mm512_madd52hi_epu64( __m512i a, __m512i b, __m512i c);\r\nVPMADD52HUQ __m512i _mm512_mask_madd52hi_epu64(__m512i s, __mmask8 k, __m512i a, __m512i b, __m512i c);\r\nVPMADD52HUQ __m512i _mm512_maskz_madd52hi_epu64( __mmask8 k, __m512i a, __m512i b, __m512i c);\r\nVPMADD52HUQ __m256i _mm256_madd52hi_epu64( __m256i a, __m256i b, __m256i c);\r\nVPMADD52HUQ __m256i _mm256_mask_madd52hi_epu64(__m256i s, __mmask8 k, __m256i a, __m256i b, __m256i c);\r\nVPMADD52HUQ __m256i _mm256_maskz_madd52hi_epu64( __mmask8 k, __m256i a, __m256i b, __m256i c);\r\nVPMADD52HUQ __m128i _mm_madd52hi_epu64( __m128i a, __m128i b, __m128i c);\r\nVPMADD52HUQ __m128i _mm_mask_madd52hi_epu64(__m128i s, __mmask8 k, __m128i a, __m128i b, __m128i c);\r\nVPMADD52HUQ __m128i _mm_maskz_madd52hi_epu64( __mmask8 k, __m128i a, __m128i b, __m128i c);\r\nFlags Affected\r\nNone.\r\nSIMD Floating-Point Exceptions\r\nNone\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/5c5c8d83-4a29-4dfb-beda-d70da1d09fb7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b6565c0bb7819aa3988b0d0509988c56306a179289b829746f427f4aa2308843",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 492
      },
      {
        "segments": [
          {
            "segment_id": "403fb04d-f7a1-4e0d-89e4-a34f3d45e059",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 134,
            "page_width": 612,
            "page_height": 792,
            "content": "5-32 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPMULTISHIFTQB – Select Packed Unaligned Bytes from Quadword Sources\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction selects eight unaligned bytes from each input qword element of the second source operand (the \r\nthird operand) and writes eight assembled bytes for each qword element in the destination operand (the first \r\noperand). Each byte result is selected using a byte-granular shift control within the corresponding qword element \r\nof the first source operand (the second operand). Each byte result in the destination operand is updated under the \r\nwritemask k1.\r\nOnly the low 6 bits of each control byte are used to select an 8-bit slot to extract the output byte from the qword \r\ndata in the second source operand. The starting bit of the 8-bit slot can be unaligned relative to any byte boundary \r\nand is left-shifted from the beginning of the input qword source by the amount specified in the low 6-bit of the \r\ncontrol byte. If the 8-bit slot would exceed the qword boundary, the out-of-bound portion of the 8-bit slot is \r\nwrapped back to start from bit 0 of the input qword element.\r\nThe first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM reg\u0002ister, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory loca\u0002tion. The destination operand is a ZMM/YMM/XMM register.\r\nOpcode / \r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID \r\nFeature Flag\r\nDescription\r\nEVEX.NDS.128.66.0F38.W1 83 /r\r\nVPMULTISHIFTQB xmm1 {k1}{z}, \r\nxmm2,xmm3/m128/m64bcst\r\nA V/V AVX512VBMI\r\nAVX512VL\r\nSelect unaligned bytes from qwords in \r\nxmm3/m128/m64bcst using control bytes in \r\nxmm2, write byte results to xmm1 under k1.\r\nEVEX.NDS.256.66.0F38.W1 83 /r\r\nVPMULTISHIFTQB ymm1 {k1}{z}, \r\nymm2,ymm3/m256/m64bcst\r\nA V/V AVX512VBMI\r\nAVX512VL\r\nSelect unaligned bytes from qwords in \r\nymm3/m256/m64bcst using control bytes in \r\nymm2, write byte results to ymm1 under k1.\r\nEVEX.NDS.512.66.0F38.W1 83 /r\r\nVPMULTISHIFTQB zmm1 {k1}{z}, \r\nzmm2,zmm3/m512/m64bcst\r\nA V/V AVX512VBMI Select unaligned bytes from qwords in \r\nzmm3/m512/m64bcst using control bytes in \r\nzmm2, write byte results to zmm1 under k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULL ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/403fb04d-f7a1-4e0d-89e4-a34f3d45e059.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=910a463986e905740f4492752deb3beaa1aebc7ee64ca9218fbdeed0137990be",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 348
      },
      {
        "segments": [
          {
            "segment_id": "516976b1-0959-45a3-a4f5-57dfb27cbc13",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 135,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-33\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPMULTISHIFTQB DEST, SRC1, SRC2 (EVEX encoded version)\r\n(KL, VL) = (2, 128),(4, 256), (8, 512)\r\nFOR i ← 0 TO KL-1\r\nIF EVEX.b=1 AND src2 is memory THEN\r\ntcur ← src2.qword[0]; //broadcasting\r\nELSE\r\ntcur ← src2.qword[i];\r\nFI;\r\nFOR j ← 0 to 7 \r\nctrl ← src1.qword[i].byte[j] & 63;\r\nFOR k ← 0 to 7 \r\nres.bit[k] ← tcur.bit[ (ctrl+k) mod 64 ];\r\nENDFOR\r\nIF k1[i*8+j] or no writemask THEN\r\ndst.qword[i].byte[j] ← res;\r\nELSE IF zeroing-masking THEN\r\ndst.qword[i].byte[j] ← 0;\r\nENDFOR\r\nENDFOR\r\nDEST.qword[MAX_VL-1:VL] ← 0;\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPMULTISHIFTQB __m512i _mm512_multishift_epi64_epi8( __m512i a, __m512i b);\r\nVPMULTISHIFTQB __m512i _mm512_mask_multishift_epi64_epi8(__m512i s, __mmask64 k, __m512i a, __m512i b);\r\nVPMULTISHIFTQB __m512i _mm512_maskz_multishift_epi64_epi8( __mmask64 k, __m512i a, __m512i b);\r\nVPMULTISHIFTQB __m256i _mm256_multishift_epi64_epi8( __m256i a, __m256i b);\r\nVPMULTISHIFTQB __m256i _mm256_mask_multishift_epi64_epi8(__m256i s, __mmask32 k, __m256i a, __m256i b);\r\nVPMULTISHIFTQB __m256i _mm256_maskz_multishift_epi64_epi8( __mmask32 k, __m256i a, __m256i b);\r\nVPMULTISHIFTQB __m128i _mm_multishift_epi64_epi8( __m128i a, __m128i b);\r\nVPMULTISHIFTQB __m128i _mm_mask_multishift_epi64_epi8(__m128i s, __mmask8 k, __m128i a, __m128i b);\r\nVPMULTISHIFTQB __m128i _mm_maskz_multishift_epi64_epi8( __mmask8 k, __m128i a, __m128i b);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/516976b1-0959-45a3-a4f5-57dfb27cbc13.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2269ef578cb804e10146121ddc30c3204e377c5c3f04b408804e6f7bf29bade4",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "cf508bf4-d83b-4629-9338-06465e2a1304",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 136,
            "page_width": 612,
            "page_height": 792,
            "content": "5-34 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPOPCNTD/VPOPCNTQ — Return the Count of Number of Bits Set to 1 in DWORD/QWORD\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction counts the number of bits set to one in each dword or qword element of its source (e.g., zmm2 or \r\nmemory) and places the results in the destination register (zmm1). The EVEX encoded form of this instruction \r\nsupports memory fault suppression.\r\nOperation\r\nVPOPCNTD\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1\r\nIF MaskBit(j) OR *no writemask*\r\nDEST.dword[j] ← POPCNT(SRC.dword[j])\r\nELSE IF *merging-masking*\r\n*DEST.dword[j] remains unchanged*\r\nELSE \r\nDEST.dword[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPOPCNTQ\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1\r\nIF MaskBit(j) OR *no writemask*\r\nDEST.qword[j] ← POPCNT(SRC.qword[j])\r\nELSE IF *merging-masking*\r\n*DEST.qword[j] remains unchanged*\r\nELSE \r\nDEST.qword[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPOPCNTD __m512i _mm512_popcnt_epi32(__m512i);\r\nVPOPCNTD __m512i _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);\r\nVPOPCNTD __m512i _mm512_maskz_popcnt_epi32(__mmask16, __m512i);\r\nVPOPCNTQ __m512i _mm512_popcnt_epi64(__m512i);\r\nVPOPCNTQ __m512i _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);\r\nVPOPCNTQ __m512i _mm512_maskz_popcnt_epi64(__mmask8, __m512i);\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.512.66.0F38.W0 55 /r\r\nVPOPCNTD zmm1{k1}{z}, \r\nzmm2/m512/m32bcst\r\nA V/V AVX512_VPOPCN\r\nTDQ\r\nCounts the number of bits set to one in \r\nzmm2/m512/m32bcst and puts the result in \r\nzmm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 55 /r\r\nVPOPCNTQ zmm1{k1}{z}, \r\nzmm2/m512/m64bcst\r\nA V/V AVX512_VPOPCN\r\nTDQ\r\nCounts the number of bits set to one in \r\nzmm2/m512/m64bcst and puts the result in \r\nzmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA FULL ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/cf508bf4-d83b-4629-9338-06465e2a1304.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6b7b3b22f3d443f9ff1123d2d3605832aae7ee954fdc87cbb694f14556059d16",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3df999f6-f0d2-4c6d-8c79-4449550d0456",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 137,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 5-35\r\nINSTRUCTION SET REFERENCE, A-Z\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/3df999f6-f0d2-4c6d-8c79-4449550d0456.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=53cfeb2d0cd9451ddaeaf7b7c71c425a902c5681db8533ce44b10cdfaa785fb2",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "97c90517-e55a-48a5-bec4-2ba4f7226df0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 138,
            "page_width": 612,
            "page_height": 792,
            "content": "5-36 Ref. # 319433-029\r\nINSTRUCTION SET REFERENCE, A-Z",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/97c90517-e55a-48a5-bec4-2ba4f7226df0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=97924cbd60d4f641faa585c5eb815d6726dfd975937f2d29eb88d270d78d2e57",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 471
      },
      {
        "segments": [
          {
            "segment_id": "77bb40f3-2f67-495a-b7bd-c6893020bf05",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 139,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 I\r\nINDEX\r\nB\r\nBrand information 2-38\r\nprocessor brand index 2-40\r\nprocessor brand string 2-38\r\nC\r\nCache and TLB information 2-33\r\nCache Inclusiveness 2-14\r\nCLFLUSH instruction\r\nCPUID flag 2-32\r\nCMOVcc flag 2-32\r\nCMOVcc instructions\r\nCPUID flag 2-32\r\nCMPXCHG16B instruction\r\nCPUID bit 2-30\r\nCMPXCHG8B instruction\r\nCPUID flag 2-32\r\nCPUID instruction 2-12, 2-32\r\n36-bit page size extension 2-32\r\nAPIC on-chip 2-32\r\nbasic CPUID information 2-13\r\ncache and TLB characteristics 2-13, 2-33\r\nCLFLUSH flag 2-32\r\nCLFLUSH instruction cache line size 2-28\r\nCMPXCHG16B flag 2-30\r\nCMPXCHG8B flag 2-32\r\nCPL qualified debug store 2-29\r\ndebug extensions, CR4.DE 2-31\r\ndebug store supported 2-32\r\ndeterministic cache parameters leaf 2-13, 2-15, 2-17, 2-18, 2-19, 2-20, 2-21\r\nextended function information 2-24\r\nfeature information 2-31\r\nFPU on-chip 2-31\r\nFSAVE flag 2-32\r\nFXRSTOR flag 2-32\r\nIA-32e mode available 2-24\r\ninput limits for EAX 2-26\r\nL1 Context ID 2-30\r\nlocal APIC physical ID 2-28\r\nmachine check architecture 2-32\r\nmachine check exception 2-32\r\nmemory type range registers 2-32\r\nMONITOR feature information 2-36\r\nMONITOR/MWAIT flag 2-29\r\nMONITOR/MWAIT leaf 2-14, 2-15, 2-16, 2-17, 2-22\r\nMWAIT feature information 2-36\r\npage attribute table 2-32\r\npage size extension 2-31\r\nperformance monitoring features 2-36\r\nphysical address bits 2-25\r\nphysical address extension 2-32\r\npower management 2-36, 2-37, 2-38\r\nprocessor brand index 2-28, 2-38\r\nprocessor brand string 2-25, 2-38\r\nprocessor serial number 2-32\r\nprocessor type field 2-27\r\nRDMSR flag 2-31\r\nreturned in EBX 2-28\r\nreturned in ECX & EDX 2-28\r\nself snoop 2-33\r\nSpeedStep technology 2-29\r\nSS2 extensions flag 2-33",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/77bb40f3-2f67-495a-b7bd-c6893020bf05.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e8f208188856f241db0a2a427793b21f7d5d52d28f533b50274d0431aba881f5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "badf7634-81e7-4aa0-b045-68f2af786e81",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 140,
            "page_width": 612,
            "page_height": 792,
            "content": "II Ref. # 319433-029\r\nSSE extensions flag 2-33\r\nSSE3 extensions flag 2-29\r\nSSSE3 extensions flag 2-29\r\nSYSENTER flag 2-32\r\nSYSEXIT flag 2-32\r\nthermal management 2-36, 2-37, 2-38\r\nthermal monitor 2-29, 2-32, 2-33\r\ntime stamp counter 2-31\r\nusing CPUID 2-12\r\nvendor ID string 2-26\r\nversion information 2-13, 2-35\r\nvirtual 8086 Mode flag 2-31\r\nvirtual address bits 2-25\r\nWRMSR flag 2-31\r\nE\r\nEVEX.R 5-4\r\nF\r\nFeature information, processor 2-12\r\nFXRSTOR instruction\r\nCPUID flag 2-32\r\nFXSAVE instruction\r\nCPUID flag 2-32\r\nI\r\nIA-32e mode\r\nCPUID flag 2-24\r\nL\r\nL1 Context ID 2-30\r\nM\r\nMachine check architecture\r\nCPUID flag 2-32\r\ndescription 2-32\r\nMAXSD- Return Maximum Scalar Double-Precision Floating-Point Value 1-3\r\nMMX instructions\r\nCPUID flag for technology 2-32\r\nModel & family information 2-35\r\nMONITOR instruction\r\nCPUID flag 2-29\r\nfeature data 2-36\r\nMWAIT instruction\r\nCPUID flag 2-29\r\nfeature data 2-36\r\nP\r\nPending break enable 2-33\r\nPerformance-monitoring counters\r\nCPUID inquiry for 2-36\r\nR\r\nRDMSR instruction\r\nCPUID flag 2-31\r\nS\r\nSelf Snoop 2-33\r\nSpeedStep technology 2-29\r\nSSE extensions\r\nCPUID flag 2-33\r\nSSE2 extensions",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/badf7634-81e7-4aa0-b045-68f2af786e81.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=48305741e52cf4355b4b1d4b1006c0b25bda4eab6149fff465a99b8197850269",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 405
      },
      {
        "segments": [
          {
            "segment_id": "05b0fd2e-3aeb-4815-927e-d346ab67cc50",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 141,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-029 III\r\nCPUID flag 2-33\r\nSSE3\r\nCPUID flag 2-29\r\nSSE3 extensions\r\nCPUID flag 2-29\r\nSSSE3 extensions\r\nCPUID flag 2-29\r\nStepping information 2-35\r\nSYSENTER instruction\r\nCPUID flag 2-32\r\nSYSEXIT instruction\r\nCPUID flag 2-32\r\nT\r\nThermal Monitor\r\nCPUID flag 2-33\r\nThermal Monitor 2 2-29\r\nCPUID flag 2-29\r\nTime Stamp Counter 2-31\r\nV\r\nVersion information, processor 2-12\r\nVEX 5-1\r\nVEX.B 5-2\r\nVEX.L 5-2, 5-3\r\nVEX.mmmmm 5-2\r\nVEX.pp 5-2, 5-3\r\nVEX.R 5-3\r\nVEX.vvvv 5-2\r\nVEX.W 5-2\r\nVEX.X 5-2\r\nVPERMI2B - Full Permute of Bytes from Two Tables Overwriting the Index 5-11\r\nVPERMT2B- Full Permute of Bytes from Two Tables Overwriting a Table 5-21\r\nVPERMT2W/D/Q/PS/PD—Full Permute from Two Tables Overwriting one Table 5-23\r\nVPMADD52HUQ—Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit Accumulators 5-\r\n30\r\nVPMADD52LUQ—Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword Accumulators 5-28\r\nW\r\nWBINVD/INVD bit 2-14\r\nWRMSR instruction\r\nCPUID flag 2-31\r\nX\r\nXFEATURE_ENALBED_MASK 2-1\r\nXRSTOR 1-1, 2-1, 2-37, 5-6\r\nXSAVE 1-1, 2-1, 2-4, 2-30, 2-37, 5-6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/6b7e14a7-c9c1-498f-86e7-70adb20bfd65/images/05b0fd2e-3aeb-4815-927e-d346ab67cc50.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041452Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9c651035eb606fdaa8b6bc009ea11a81059ad4057776f47facc83efd15f196f3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 167
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": null}\n```"
        }
      ]
    }
  }
}