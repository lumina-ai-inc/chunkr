{
  "file_name": "Intel Advanced Encryption Standard (AES) New Instructions Set.pdf",
  "task_id": "d4e9162c-c35b-4fba-acfa-6035c80162c2",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "a0665ecb-8b72-47a1-8dc8-830767cc934b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "White Paper \r\nShay Gueron \r\nMobility Group, Israel \r\nDevelopment Center \r\nIntel Corporation \r\nIntel® Advanced \r\nEncryption Standard \r\n(AES) New Instructions \r\nSet \r\nIntel® AES New Instructions are a set of instructions available \r\nbeginning with the 2010 Intel® Core™ processor family based on the \r\n32nm Intel® microarchitecture codename Westmere. These instructions \r\nenable fast and secure data encryption and decryption, using the \r\nAdvanced Encryption Standard (AES) which is defined by FIPS \r\nPublication number 197. Since AES is currently the dominant block \r\ncipher, and it is used in various protocols, the new instructions are \r\nvaluable for a wide range of applications. \r\nThe architecture consists of six instructions that offer full hardware \r\nsupport for AES. Four instructions support the AES encryption and \r\ndecryption, and other two instructions support the AES key expansion. \r\nThe AES instructions have the flexibility to support all usages of AES, \r\nincluding all standard key lengths, standard modes of operation, and \r\neven some nonstandard or future variants. They offer a significant \r\nincrease in performance compared to the current pure-software \r\nimplementations. \r\nBeyond improving performance, the AES instructions provide important \r\nsecurity benefits. By running in data-independent time and not using \r\ntables, they help in eliminating the major timing and cache-based \r\nattacks that threaten table-based software implementations of AES. In \r\naddition, they make AES simple to implement, with reduced code size, \r\nwhich helps reducing the risk of inadvertent introduction of security \r\nflaws, such as difficult-to-detect side channel leaks. \r\nThis paper gives an overview of the AES algorithm and the Intel AES \r\nNew Instructions. It provides guidelines and demonstrations for using \r\nthese instructions to write secure and high performance AES \r\nimplementations. This version of the paper also provides a high \r\nperformance library for implementing AES in the ECB/CBC/CTR modes, \r\nand discloses for the first time, the measured performance numbers. \r\n323641-001 \r\nRevision 3.0 \r\nMay 2010 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/a0665ecb-8b72-47a1-8dc8-830767cc934b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c11a280c415f6d5ac3f8507fa451137a0bcac8b0c97d84afddc1a3c86b752c1a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 296
      },
      {
        "segments": [
          {
            "segment_id": "0181dbb0-b97a-4529-a553-e8d6f2b2c2e2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n2 323641-001 \r\nContents \r\nIntroduction.......................................................................................................................... 4\r\nPreliminaries: AES and Intel® Architecture ........................................................................... 4\r\nThe AES Algorithm ................................................................................................................ 7\r\nIntel® AES New Instructions Architecture ........................................................................... 16\r\nSoftware Side Channels and the AES Instructions .............................................................. 21\r\nBasic C Code Examples........................................................................................................ 23\r\nSoftware Flexibility and Miscellaneous Usage Models ......................................................... 31\r\nPerformance and Performance Optimization Guidelines ..................................................... 39\r\nAn AES Library .................................................................................................................... 42\r\nPerformance Results ........................................................................................................... 76\r\nConclusion .......................................................................................................................... 79\r\nAcknowledgements ............................................................................................................. 80\r\nAbout the Author ................................................................................................................ 80\r\nFigures \r\nFigure 1. State Bit, Byte, and Doubleword Positions in an xmm Register .................. 6\r\nFigure 2. S-Box and InvS-Box Lookup Tables ....................................................... 9\r\nFigure 3. MixColumns Transformation Equations ..................................................11\r\nFigure 4. InvMixColumns Transformation Equations .............................................12\r\nFigure 5. AES Key Expansion Pseudo Code (as Described in FIPS197) .....................13\r\nFigure 6. Preparing the Decryption Round Keys ...................................................15\r\nFigure 7. The AES Encryption Flow.....................................................................15\r\nFigure 8. The AES Decryption Flow (Using the Equivalent Inverse Cipher)................15\r\nFigure 9. The AESENC and AESENCLAST Instructions ...........................................16\r\nFigure 10. The AESDEC and AESDECLAST Instructions .........................................16\r\nFigure 11. AESENC Example .............................................................................16\r\nFigure 12. AESENCLAST Example ......................................................................17\r\nFigure 13. AESDEC Example .............................................................................17\r\nFigure 14. AESDECLAST Example ......................................................................17\r\nFigure 15. AES-128 Encryption Outlined Code Sequence .......................................17\r\nFigure 16. AES-192 Decryption: Outlined Code Sequence .....................................18\r\nFigure 17. The AESKEYGENASSIST Instruction ....................................................18\r\nFigure 18. AESKEYGENASSIST Example .............................................................19\r\nFigure 19. AES-128 Key Expansion: Outlined Code Example ..................................19\r\nFigure 20. The AESIMC Instruction ....................................................................20\r\nFigure 21. AESIMC Example..............................................................................20\r\nFigure 22. Using AESIMC for AES-128: Outlined Code Example..............................20\r\nFigure 23. Checking the CPU Support for the AES Instructions ...............................24\r\nFigure 24. AES-128 Key Expansion (C code) .......................................................24\r\nFigure 25. AES-192 Key Expansion (C code) .......................................................26",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/0181dbb0-b97a-4529-a553-e8d6f2b2c2e2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ca20a80e1603754696001e99dc24d1ca94babed1894676c77302b3641af283a4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 272
      },
      {
        "segments": [
          {
            "segment_id": "3117ab61-7dcb-4e72-a668-9ba1ebe20c0b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 3 \r\nFigure 26. AES-256 Key Expansion (C code) .......................................................27\r\nFigure 27. AES-128, AES-192 and AES-256 Encryption and Decryption in ECB Mode (C \r\ncode) .................................................................................................28\r\nFigure 28. AES-128, AES-192 and AES-256 Encryption and Decryption in CBC Mode (C \r\ncode) .................................................................................................29\r\nFigure 29. AES-128, AES-192 and AES-256 in CTR Mode (C code)..........................30\r\nFigure 30. Using the AES instructions to compute a 256-bit block size RINJDAEL round32\r\nFigure 31. Isolating the AES Transformations with Combinations of AES Instructions 34\r\nFigure 32. Isolating the AES Transformations (C Code) .........................................34\r\nFigure 33. Isolating the AES Transformations – Code Results.................................36\r\nFigure 34. AES128-ECB Encryption with On-the-Fly Key Expansion.........................36\r\nFigure 35. AES128-ECB Decryption with On-the-Fly Key Expansion ........................38\r\nFigure 36. Parallelizing CBC Decrypt Function 4 Blocks at a Time ...........................40\r\nFigure 37.CBC Encrypt Four Buffers in Parallel – C function ..................................41\r\nFigure 38. Unrolled Key Expansion Decrypt using InvMixColumns...........................43\r\nFigure 39. AES-128 Key Expansion: Assembly Code .............................................44\r\nFigure 40. AES-192 Key Expansion: Assembly Code .............................................45\r\nFigure 41. AES-256 Key Expansion: Assembly Code .............................................46\r\nFigure 42. A Universal Key Expansion(C code).....................................................47\r\nFigure 43. The AES Encryption Parallelizing 4 Blocks (AT&T Assembly Function) .......49\r\nFigure 44. The AES Decryption Parallelizing 4 Blocks (AT&T Assembly Function) .......52\r\nFigure 45. CBC Encryption of 1 Block at a Time (AT&T Assembly Function) ..............54\r\nFigure 46. CBC Decryption Parallelizing 4 Blocks (AT&T Assembly Function).............55\r\nFigure 47. CTR Encryption Parallelizing 4 Blocks (AT&T Assembly Function) .............58\r\nFigure 48. The ECB Main Function......................................................................62\r\nFigure 49. CBC Main Function ...........................................................................66\r\nFigure 50. CTR Main Function............................................................................69\r\nFigure 51. ECB Output Example ........................................................................74\r\nFigure 52. CBC Output Example ........................................................................74\r\nFigure 53. CTR Output Example ........................................................................75\r\nFigure 54. The Measurement Macro ...................................................................76\r\nFigure 55. The Performance of AES-128 Encryption in ECB Mode, as a Function of the \r\nBuffer Size (Processor based on Intel microarchitecture codename Westmere)78\r\nFigure 56. The Performance of AES-128 Decryption in CBC Mode, as a Function of the \r\nBuffer Size (Processor based on Intel microarchitecture codename Westmere)79\r\nFigure 57. The Performance of AES-128 Encryption in CTR Mode, as a Function of the \r\nBuffer Size (Processor based on Intel microarchitecture codename Westmere)79\r\n Tables \r\nTable 1. The Performance of the AES Key Expansion (Processor based on Intel \r\nmicroarchitecture codename Westmere) ..................................................77\r\nTable 2. The Performance of AES Encryption and Decryption of a 1K Bytes Buffer, in \r\nVarious Modes of Operation (Processor based on Intel microarchitecture \r\ncodename Westmere) ...........................................................................77\r\nTable 3. Additional Performance Numbers (Processor based on Intel microarchitecture \r\ncodename Westmere) ...........................................................................77",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/3117ab61-7dcb-4e72-a668-9ba1ebe20c0b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=79bf28ad95ac722e11177441cd49c3dfb0df401bd69c99662545c302dbbc66b9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 412
      },
      {
        "segments": [
          {
            "segment_id": "73c1a4d7-79f0-48fa-a52c-67f708c59f3f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n4 323641-001 \r\nIntroduction \r\nThe Advanced Encryption Standard (AES) is the Federal Information Processing \r\nStandard for symmetric encryption, and it is defined by FIPS Publication #197 (2001). \r\nFrom the cryptographic perspective, AES is widely believed to be secure and efficient, \r\nand is therefore broadly accepted as the standard for both government and industry \r\napplications. In fact, almost any new protocol requiring symmetric encryption supports \r\nAES, and many existing systems that were originally designed with other symmetric \r\nencryption algorithms are being converted to AES. Given the popularity of AES and its \r\nexpected long term importance, improving AES performance and security has significant \r\nbenefits for the PC client and server platforms. \r\nIntel is introducing a new set of instructions beginning with the all new 2010 Intel®\r\nCore™ processor family based on the 32nm Intel® microarchitecture codename \r\nWestmere. \r\nThe new architecture has six instructions: four instructions (AESENC, AESENCLAST, \r\nAESDEC, and AESDELAST) facilitate high performance AES encryption and decryption, \r\nand the other two (AESIMC and AESKEYGENASSIST) support the AES key expansion. \r\nTogether, these instructions provide full hardware support for AES, offering high \r\nperformance, enhanced security, and a great deal of software usage flexibility \r\nThe Intel AES New Instructions can support AES encryption and decryption with each \r\none of the standard key lengths (128, 192, and 256 bits), using the standard block size \r\nof 128 bits (and potentially also other block sizes for generalized variants such as the \r\nRIJNDAEL algorithms). They are well suited to all common uses of AES, including bulk \r\nencryption/decryption using cipher modes such as ECB, CBC and CTR, data \r\nauthentication using CBC-MACs (e.g., CMAC), random number generation using \r\nalgorithms such as CTR-DRBG, and authenticated encryption using modes such as GCM. \r\nIt is believed that these instructions will be useful for a wide range of cryptographic \r\napplications. \r\nThis paper provides an overview of the AES algorithm and guidelines for utilizing the \r\nIntel AES New Instructions to achieve high performance and secure AES processing. \r\nSome special usage models of this architecture are also described. This version of the \r\npaper also provides a high performance library for implementing AES in the \r\nECB/CBC/CTR modes of operation, and discloses, for the first time, the performance \r\nnumbers for the provided code. \r\nPreliminaries: AES and Intel® Architecture \r\nAES Definition and Brief Description \r\nThe Advanced Encryption Standard (AES) is the United States Government’s Federal \r\nInformation Processing Standard for symmetric encryption, defined by FIPS Publication \r\n#197 (FIPS197 hereafter). \r\nAES is a block cipher that encrypts a 128-bit block (plaintext) to a 128-bit block \r\n(ciphertext), or decrypts a 128-bit block (ciphertext) to a 128-bit block (plaintext). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/73c1a4d7-79f0-48fa-a52c-67f708c59f3f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=762af07ba9e209b337a9904c14f11d5138a381f09525f61005928abbaf2841f5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 432
      },
      {
        "segments": [
          {
            "segment_id": "bb534d95-d839-41cc-b9f9-ff8da23915c8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 5 \r\nAES uses a key (cipher key) whose length can be 128, 192, or 256 bits. Hereafter \r\nencryption/decryption with a cipher key of 128, 192, or 256 bits is denoted AES\u0002128, AES192, AES-256, respectively. \r\nAES-128, AES-192, and AES-256 process the data block in, respectively, 10, 12, \r\nor 14 iterations of pre-defined sequences of transformations, which are also called \r\nAES rounds (“rounds” for short). The rounds are identical except for the last one, \r\nwhich slightly differs from the others (by skipping one of the transformations). \r\nThe rounds operate on two 128-bit inputs: “State” and “Round key”. Each round from 1 \r\nto 10/12/14 uses a different round key. The 10/12/14 round keys are derived from the \r\ncipher key by the “Key Expansion” algorithm. This algorithm is independent of the \r\nprocessed data, and can be therefore carried out independently of the \r\nencryption/decryption phase (typically, the key is expanded once and is thereafter used \r\nfor many data blocks using some cipher mode of operation). \r\nThe data block is processed serially as follows: initially, the input data block is XOR-ed \r\nwith the first 128 bits of the cipher key to generate the “State” (an intermediate cipher \r\nresult). Subsequently, the State passes, serially, 10/12/14 rounds, each round \r\nconsisting of a sequence of transformations operating on the State and using a different \r\nround key. The result of the last round is the encrypted (decrypted) block. \r\nAES Text Convention in Intel® Architecture Terminology \r\nFIPS197 defines AES in terms of bytes. However, the algorithm is described using a text \r\nconvention where hexadecimal strings are written with the low-memory byte on the left, \r\nand the high-memory byte on the right (this convention is analogous to writing integers \r\nin a “Big Endian“ convention). This text convention determines the way in which the test \r\nvectors are written, and the description of some of the algorithm’s transformations. On \r\nthe other hand, Intel® Architecture (IA) convention is the opposite: hexadecimal strings \r\nare written with the low-memory byte on the right and the high-memory byte on the \r\nleft (this is analogous to writing integers in a “Little Endian” convention). \r\nIn either case, the low-memory byte is byte 0, the next is byte 1, and so forth. In the \r\nFIPS197 notation, when a 128-bit vector (string) is read from left to right, the bytes are \r\nread as [Byte0, Byte1, …, Byte14, Byte15], i.e., byte 0 (denoted “Byte0”) is the \r\nleftmost one. In an IA notation, when a 128-bit vector is read from left to right, the \r\nbytes are read as [Byte15, Byte14, …, Byte1, Byte0], i.e., byte 0 is the rightmost one. \r\nFor encoding the bytes, each byte value can be viewed as an integer between 0 and \r\n255, written in binary notation. Under this view, both the FIPS197 and Intel conventions \r\nuse a Little Endian notation: the leftmost bit of the byte is the most significant bit (e.g., \r\nthe byte 11000010 corresponds to the integer 194). The byte values are represented as \r\n2-digit (two characters) numbers in hexadecimal notation. For example, the byte \r\n11000010 (which corresponds to 194 in decimal notation) is represented as c2. \r\nWe point out that the store/load processor operations are consistent with the way that \r\nthe AES instructions operate. In other words, the textual convention does not require \r\nprogrammers using the AES architecture to perform any byte reversal in their code, \r\nHereafter, we use Intel’s IA convention to represent the AES State: 128-bit vectors \r\n([127-0]) are split to bytes as [127-120, … 31-24, 23-16, 15-8, 7-0] and the bytes are \r\nwritten in a hexadecimal notation (as two characters). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bb534d95-d839-41cc-b9f9-ff8da23915c8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c56e9fb082ad66f8ef0ab35b4a2147b0135aff98e71c1e4fd3740c3420d0d62b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 596
      },
      {
        "segments": [
          {
            "segment_id": "bb534d95-d839-41cc-b9f9-ff8da23915c8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 5 \r\nAES uses a key (cipher key) whose length can be 128, 192, or 256 bits. Hereafter \r\nencryption/decryption with a cipher key of 128, 192, or 256 bits is denoted AES\u0002128, AES192, AES-256, respectively. \r\nAES-128, AES-192, and AES-256 process the data block in, respectively, 10, 12, \r\nor 14 iterations of pre-defined sequences of transformations, which are also called \r\nAES rounds (“rounds” for short). The rounds are identical except for the last one, \r\nwhich slightly differs from the others (by skipping one of the transformations). \r\nThe rounds operate on two 128-bit inputs: “State” and “Round key”. Each round from 1 \r\nto 10/12/14 uses a different round key. The 10/12/14 round keys are derived from the \r\ncipher key by the “Key Expansion” algorithm. This algorithm is independent of the \r\nprocessed data, and can be therefore carried out independently of the \r\nencryption/decryption phase (typically, the key is expanded once and is thereafter used \r\nfor many data blocks using some cipher mode of operation). \r\nThe data block is processed serially as follows: initially, the input data block is XOR-ed \r\nwith the first 128 bits of the cipher key to generate the “State” (an intermediate cipher \r\nresult). Subsequently, the State passes, serially, 10/12/14 rounds, each round \r\nconsisting of a sequence of transformations operating on the State and using a different \r\nround key. The result of the last round is the encrypted (decrypted) block. \r\nAES Text Convention in Intel® Architecture Terminology \r\nFIPS197 defines AES in terms of bytes. However, the algorithm is described using a text \r\nconvention where hexadecimal strings are written with the low-memory byte on the left, \r\nand the high-memory byte on the right (this convention is analogous to writing integers \r\nin a “Big Endian“ convention). This text convention determines the way in which the test \r\nvectors are written, and the description of some of the algorithm’s transformations. On \r\nthe other hand, Intel® Architecture (IA) convention is the opposite: hexadecimal strings \r\nare written with the low-memory byte on the right and the high-memory byte on the \r\nleft (this is analogous to writing integers in a “Little Endian” convention). \r\nIn either case, the low-memory byte is byte 0, the next is byte 1, and so forth. In the \r\nFIPS197 notation, when a 128-bit vector (string) is read from left to right, the bytes are \r\nread as [Byte0, Byte1, …, Byte14, Byte15], i.e., byte 0 (denoted “Byte0”) is the \r\nleftmost one. In an IA notation, when a 128-bit vector is read from left to right, the \r\nbytes are read as [Byte15, Byte14, …, Byte1, Byte0], i.e., byte 0 is the rightmost one. \r\nFor encoding the bytes, each byte value can be viewed as an integer between 0 and \r\n255, written in binary notation. Under this view, both the FIPS197 and Intel conventions \r\nuse a Little Endian notation: the leftmost bit of the byte is the most significant bit (e.g., \r\nthe byte 11000010 corresponds to the integer 194). The byte values are represented as \r\n2-digit (two characters) numbers in hexadecimal notation. For example, the byte \r\n11000010 (which corresponds to 194 in decimal notation) is represented as c2. \r\nWe point out that the store/load processor operations are consistent with the way that \r\nthe AES instructions operate. In other words, the textual convention does not require \r\nprogrammers using the AES architecture to perform any byte reversal in their code, \r\nHereafter, we use Intel’s IA convention to represent the AES State: 128-bit vectors \r\n([127-0]) are split to bytes as [127-120, … 31-24, 23-16, 15-8, 7-0] and the bytes are \r\nwritten in a hexadecimal notation (as two characters). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bb534d95-d839-41cc-b9f9-ff8da23915c8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c56e9fb082ad66f8ef0ab35b4a2147b0135aff98e71c1e4fd3740c3420d0d62b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 596
      },
      {
        "segments": [
          {
            "segment_id": "c120c733-2781-4b73-91d8-a792abb0e38a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n6 323641-001 \r\nExample \r\nConsider the vector (State) d4bf5d30e0b452aeb84111f11e2798e5, written in the \r\nFIPS197 notation. It consists of 16 bytes, each one represented as 2-digit hexadecimal \r\nnumbers, as follows: “d4 bf 5d 30 e0 b4 52 ae b8 41 11 f1 1e 27 98 e5”. Here, d4 is \r\nbyte 0. \r\nThe equivalent IA-compatible notation is e598271ef11141b8ae52b4e0305dbfd4 (also \r\ndenoted in hexadecimal notation by 0xe598271ef11141b8ae52b4e0305dbfd4). This \r\ncorresponds to the 16 bytes (2-digit hexadecimal numbers) “e5 98 27 1e f1 11 41 b8 ae \r\n52 b4 e0 30 5d bf d4” (again, byte 0 is d4). The corresponding 128-bit encoding is: \r\n1110010110011000001001110001111011110001000100010100000110111000 \r\n1010111001010010101101001110000000110000010111011011111111010100 \r\n(Where bit 127 equals 1 and bit 0 equals 0). \r\nThe AES State in Terms of IA Data Structure \r\nIntel’s AES instructions operate on one or two 128-bit inputs, and the typical instruction \r\nformat is “instruction xmm1 xmm2/m128” (details are provided in the following text). \r\nHere, xmm1 and xmm2 are aliases to any two xmm registers, and the result is written \r\ninto xmm1. The /m128 indicates a register-memory instruction. \r\nWhen referring to the contents of an xmm register, one may refer to the bits (127-0), \r\nto the bytes (15-0), or to the 32-bit double words (3-0). Hereafter, 32-bit data chunks \r\nare referred to as “doublewords” to be consistent with the IA terminology (note however \r\nthat the FIPS197 document calls 32-bits chunks “words”). The bytes are also referred to \r\nby the letters P-A and the doublewords are also referred to by X3-X0. Figure 1 \r\nillustrates the bit/byte/doublewords positions of the State in an xmm register. \r\nFigure 1. State Bit, Byte, and Doubleword Positions in an xmm Register \r\n127-\r\n120 \r\n119-\r\n112 \r\n111-\r\n104 \r\n103-\r\n96 \r\n95-\r\n88 \r\n87-\r\n80 \r\n79-\r\n72 \r\n71-\r\n64 \r\n63-\r\n56 \r\n55-\r\n48 \r\n47-\r\n40 \r\n39-\r\n32 \r\n31-\r\n24 \r\n23-\r\n16 \r\n15-\r\n8 \r\n7-\r\n0 \r\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 \r\n3 \r\n(127-96) \r\n2 \r\n(95-64) \r\n1 \r\n(63-32) \r\n0 \r\n(31-0) \r\nX3 X2 X1 X0 \r\nP O N M L K J I H G F E D C B A \r\n4x4 Matrix Notation of \r\nan xmm Register \r\nA E I M \r\nB F J N \r\nC G K O \r\nD H L P ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/c120c733-2781-4b73-91d8-a792abb0e38a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=28f94a4ead8ac1e844d56906e7b9f8c0e1700050bfe65996c6c277c3c5bc933e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "e7e4fb62-18cd-44d8-b0c5-1629fb473951",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 7 \r\nExample \r\nThe vector e598271ef11141b8ae52b4e0305dbfd4 is split to bytes as follows: \r\nByte # 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 \r\nLetter P O N M L K J I H G F E D C B A \r\nValue e5 98 27 1e f1 11 41 b8 ae 52 b4 e0 30 5d bf d4 \r\nand its corresponding 4x4 matrix representation is: \r\n4x4 Matrix Format of an xmm \r\nRegister \r\nThe Vector Arranged in the \r\n4x4 Format \r\nA E I M d4 e0 b8 1e \r\nB F J N bf b4 41 27 \r\nC G K O 5d 52 11 98 \r\nD H L P 30 ae f1 e5 \r\nThe AES Algorithm\r\nThis chapter describes the functions and the transformations used by the AES algorithm. \r\nCipher Key \r\nAES is a symmetric key encryption algorithm. It uses a cipher key whose length is 128 \r\nbits, 192 bits or 256 bits. The AES algorithm with a cipher key of length 128, 192, 256 \r\nbits is denoted AES-128, AES-192, AES-256, respectively. \r\nState \r\nThe process of encryption (decryption) of plaintext (ciphertext) to ciphertext (plaintext) \r\ngenerates intermediate 128-bit results. These intermediate results are referred to as the \r\nState. \r\nData Blocks \r\nAES operates on an input data block of 128 bits and its output is also a data block of \r\n128 bits. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/e7e4fb62-18cd-44d8-b0c5-1629fb473951.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d1b0db8789b14cbd675b4c50a8bad053c6bb80a77438d02f9f654885db33a1a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 232
      },
      {
        "segments": [
          {
            "segment_id": "57a790ad-3058-49b0-a3f6-468c327f54d5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n8 323641-001 \r\nRound Keys \r\nAES-128, AES192, and AES-256 algorithms expand the cipher key to 10, 12, and 14 \r\nround keys, respectively. The length of each round key is 128 bits. The algorithm for \r\nderiving the round keys from the cipher key is the called the AES Key Expansion. \r\nAddRoundKey \r\nAddRoundKey is a (128-bit, 128-bit) Æ 128-bit transformation, which is defined as the \r\nbit-wise xor of its two arguments. In the AES flow, these arguments are the State and \r\nthe round key. AddRoundKey is its own inverse. \r\nCounting the Rounds and the Round Keys \r\nThe AES algorithm starts with a whitening step, implemented by XOR-ing the input data \r\nblock with the first 128 bits of the cipher key. These 128 bits are the whitening key. The \r\nalgorithm continues with 10/12/14 rounds, each one using another round key. When \r\ncounting this way, the rounds and the round keys are counted from 1 to 10/12/14, \r\naccordingly. However, sometimes the whitening step is also referred to as “Round 0”, \r\nand the corresponding 128 bits of the whitening key are referred to as Round Key 0. In \r\nthat case, the count of the AES rounds and the round keys starts from 0 to 10/12/14. \r\nWe use these conventions interchangeably. \r\nS-Box and InvS-Sbox \r\nS-Box (Substitution Box) is an 8-bit Æ 8-bit transformation defined as the affine \r\nfunction x Æ A x-1 + b where A is an 8x8 binary matrix and b is an 8-bit binary vector, \r\nas follows: \r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n+\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n→\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n1\r\n1\r\n0\r\n0\r\n0\r\n1\r\n1\r\n0\r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7\r\n \r\n11110 0 01\r\n1110 0 011\r\n110 0 0111\r\n10 0 01111\r\n0 0 011111\r\n0 0111110\r\n0111110 0\r\n111110 0 0\r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7 -1\r\nHere, the notations for “addition” and “multiplication” represent, respectively, bitwise \r\nXOR and bitwise AND. Also, ( )-1 denotes inversion in the Galois Field (Finite Field) \r\nGF(28\r\n) defined by the reduction polynomial x8+x4+x3+x+1 (0x11b for short). Hereafter, \r\nthis field is referred to as AES-GF256-Field. \r\nInvS-Box is the inverse of S-Box transformation, defined as y Æ (A-1 y + A-1 b)-1. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/57a790ad-3058-49b0-a3f6-468c327f54d5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0131e4018fe3ff49eda8db0f54d212fb5493d3e15d7eb55a847dc7e8871cd5b1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 464
      },
      {
        "segments": [
          {
            "segment_id": "d727f776-1d53-4c2b-bc90-ccee9f6b11b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 9 \r\n1\r\n1\r\n0\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7\r\n \r\n1010 010 0\r\n010 010 01\r\n10 010 010\r\n0 010 0101\r\n010 01010\r\n10 01010 0\r\n0 01010 01\r\n01010 010 \r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7 −\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n+\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n→\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\nS-Box and InvS-Box Lookup Tables \r\nThe S-Box and InvS-Box transformations can also be defined by lookup table as follows. \r\nThe input to the lookup tables is a byte B [7-0] where x and y denote its low and high \r\nnibbles: x [3-0] = B [7-4], y [3-0] = B [3-0].The output byte is encoded in the table as \r\na two digit number in hexadecimal notation. For example, S-Box lookup for the input 85 \r\n(x=8; y=5 in hexadecimal notation) yields 97 in hexadecimal notation. InvS-Box lookup \r\nfor the input 97 yields 85. \r\nFigure 2. S-Box and InvS-Box Lookup Tables\r\nS-Box lookup table \r\n ------------------ y ----------------------> \r\n 0 1 2 3 4 5 6 7 8 9 a b c d e f \r\n ^ 0 63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76 \r\n | 1 ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0 \r\n | 2 b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15 \r\n | 3 04 c7 23 c3 18 96 05 9a 07 12 80 e2 eb 27 b2 75 \r\n | 4 09 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84 \r\n | 5 53 d1 00 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf \r\n 6 d0 ef aa fb 43 4d 33 85 45 f9 02 7f 50 3c 9f a8 \r\n x 7 51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2 \r\n 8 cd 0c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73 \r\n | 9 60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e 0b db \r\n | a e0 32 3a 0a 49 06 24 5c c2 d3 ac 62 91 95 e4 79 \r\n | b e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae 08 \r\n | c ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a \r\n | d 70 3e b5 66 48 03 f6 0e 61 35 57 b9 86 c1 1d 9e \r\n | e e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df \r\n V f 8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16 \r\nInvS-Box lookup table \r\n ------------------ y ----------------------> \r\n 0 1 2 3 4 5 6 7 8 9 a b c d e f \r\n ^ 0 52 09 6a d5 30 36 a5 38 bf 40 a3 9e 81 f3 d7 fb \r\n | 1 7c e3 39 82 9b 2f ff 87 34 8e 43 44 c4 de e9 cb \r\n | 2 54 7b 94 32 a6 c2 23 3d ee 4c 95 0b 42 fa c3 4e \r\n | 3 08 2e a1 66 28 d9 24 b2 76 5b a2 49 6d 8b d1 25 \r\n | 4 72 f8 f6 64 86 68 98 16 d4 a4 5c cc 5d 65 b6 92 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/d727f776-1d53-4c2b-bc90-ccee9f6b11b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5260c46e48b5c6a5941b65d0e42be6334f9ec1ff898a88490ed79440af44e933",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 710
      },
      {
        "segments": [
          {
            "segment_id": "d727f776-1d53-4c2b-bc90-ccee9f6b11b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 9 \r\n1\r\n1\r\n0\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7\r\n \r\n1010 010 0\r\n010 010 01\r\n10 010 010\r\n0 010 0101\r\n010 01010\r\n10 01010 0\r\n0 01010 01\r\n01010 010 \r\nx0\r\nx1\r\nx2\r\nx3\r\nx4\r\nx5\r\nx6\r\nx7 −\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n+\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\n→\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎟\r\n⎠\r\n⎞\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎜\r\n⎝\r\n⎛\r\nS-Box and InvS-Box Lookup Tables \r\nThe S-Box and InvS-Box transformations can also be defined by lookup table as follows. \r\nThe input to the lookup tables is a byte B [7-0] where x and y denote its low and high \r\nnibbles: x [3-0] = B [7-4], y [3-0] = B [3-0].The output byte is encoded in the table as \r\na two digit number in hexadecimal notation. For example, S-Box lookup for the input 85 \r\n(x=8; y=5 in hexadecimal notation) yields 97 in hexadecimal notation. InvS-Box lookup \r\nfor the input 97 yields 85. \r\nFigure 2. S-Box and InvS-Box Lookup Tables\r\nS-Box lookup table \r\n ------------------ y ----------------------> \r\n 0 1 2 3 4 5 6 7 8 9 a b c d e f \r\n ^ 0 63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76 \r\n | 1 ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0 \r\n | 2 b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15 \r\n | 3 04 c7 23 c3 18 96 05 9a 07 12 80 e2 eb 27 b2 75 \r\n | 4 09 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84 \r\n | 5 53 d1 00 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf \r\n 6 d0 ef aa fb 43 4d 33 85 45 f9 02 7f 50 3c 9f a8 \r\n x 7 51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2 \r\n 8 cd 0c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73 \r\n | 9 60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e 0b db \r\n | a e0 32 3a 0a 49 06 24 5c c2 d3 ac 62 91 95 e4 79 \r\n | b e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae 08 \r\n | c ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a \r\n | d 70 3e b5 66 48 03 f6 0e 61 35 57 b9 86 c1 1d 9e \r\n | e e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df \r\n V f 8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16 \r\nInvS-Box lookup table \r\n ------------------ y ----------------------> \r\n 0 1 2 3 4 5 6 7 8 9 a b c d e f \r\n ^ 0 52 09 6a d5 30 36 a5 38 bf 40 a3 9e 81 f3 d7 fb \r\n | 1 7c e3 39 82 9b 2f ff 87 34 8e 43 44 c4 de e9 cb \r\n | 2 54 7b 94 32 a6 c2 23 3d ee 4c 95 0b 42 fa c3 4e \r\n | 3 08 2e a1 66 28 d9 24 b2 76 5b a2 49 6d 8b d1 25 \r\n | 4 72 f8 f6 64 86 68 98 16 d4 a4 5c cc 5d 65 b6 92 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/d727f776-1d53-4c2b-bc90-ccee9f6b11b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5260c46e48b5c6a5941b65d0e42be6334f9ec1ff898a88490ed79440af44e933",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 710
      },
      {
        "segments": [
          {
            "segment_id": "5b3b9b29-27c8-4a4f-abc4-77c615102674",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n10 323641-001 \r\n | 5 6c 70 48 50 fd ed b9 da 5e 15 46 57 a7 8d 9d 84 \r\n 6 90 d8 ab 00 8c bc d3 0a f7 e4 58 05 b8 b3 45 06 \r\n x 7 d0 2c 1e 8f ca 3f 0f 02 c1 af bd 03 01 13 8a 6b \r\n 8 3a 91 11 41 4f 67 dc ea 97 f2 cf ce f0 b4 e6 73 \r\n | 9 96 ac 74 22 e7 ad 35 85 e2 f9 37 e8 1c 75 df 6e \r\n | a 47 f1 1a 71 1d 29 c5 89 6f b7 62 0e aa 18 be 1b \r\n | b fc 56 3e 4b c6 d2 79 20 9a db c0 fe 78 cd 5a f4 \r\n | c 1f dd a8 33 88 07 c7 31 b1 12 10 59 27 80 ec 5f \r\n | d 60 51 7f a9 19 b5 4a 0d 2d e5 7a 9f 93 c9 9c ef \r\n | e a0 e0 3b 4d ae 2a f5 b0 c8 eb bb 3c 83 53 99 61 \r\n V f 17 2b 04 7e ba 77 d6 26 e1 69 14 63 55 21 0c 7d \r\nSubBytes Transformation \r\nSubBytes is the 16-byte Æ 16-byte transformation defined by applying the S-Box \r\ntransformation to each one of the 16 bytes of the input, namely: \r\n[P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A] Æ [S-Box (P), S-Box (O), S-Box (N), S-Box \r\n(M), S-Box (L), S-Box (K), S-Box (J), S-Box (I), S-Box (H), S-Box (G), S-Box (F), \r\nS-Box (E), S-Box (D), S-Box (C), S-Box (B), S-Box (A)]. \r\nSubBytes Example \r\nSubBytes (73744765635354655d5b56727b746f5d) = \r\n8f92a04dfbed204d4c39b1402192a84c \r\nInvSubBytes Transformation \r\nInvSubBytes is a 16-byte Æ 16-byte transformation defined by applying the InvS-Box \r\nfunction to each byte of the input, namely: \r\n[P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A] Æ [InvS-Box (P), InvS-Box (O), InvS-Box (N), \r\nInvS-Box (M), InvS-Box (L), InvS-Box (K), InvS-Box (J), InvS-Box (I), InvS-Box \r\n(H), InvS-Box (G), InvS-Box (F), InvS-Box (E), InvS-Box (D), InvS-Box (C), \r\nInvS-Box (B), InvS-Box (A)]. \r\nInvSubBytes Example \r\nInvSubBytes (5d7456657b536f65735b47726374545d) = \r\n8dcab9bc035006bc8f57161e00cafd8d \r\nShiftRows Transformation \r\nShiftRows is the following byte-wise permutation: (15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, \r\n4, 3, 2, 1, 0) Æ (11, 6, 1, 12, 7, 2, 13, 8, 3, 14, 9, 4, 15, 10, 5, 0). In the P-A notation \r\nis reads [P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A] Æ [L,G,B,M,H,C,N,I,D,O,J,E,P,K,F,A]. Its \r\nname comes from viewing the transformation as an operation on the 4x4 matrix \r\nrepresentation of the State. Under this view, the first row is unchanged, the second row \r\nis left rotated by one byte position, the third row is left rotated by two byte positions, \r\nand the fourth row is left rotated by three byte positions. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/5b3b9b29-27c8-4a4f-abc4-77c615102674.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=10f119dfaa9468735e9fa8710818972b0e0d3c60173cdfe9d912456337ef7959",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 441
      },
      {
        "segments": [
          {
            "segment_id": "1cf5f120-47f5-44ba-a798-2e48600004b7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 11 \r\nShiftRows Example \r\nShiftRows (7b5b54657374566563746f725d53475d) = \r\n73744765635354655d5b56727b746f5d \r\nInvShiftRows Transformation \r\nInvShiftRows is the inverse of ShiftRows. It is the following byte-wise permutation: (15, \r\n14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0) Æ (3, 6, 9, 12, 15, 2, 5, 8, 11, 14, 1, 4, \r\n7, 10, 13, 0). In the P-A notation is reads [P,O,N,M,L,K,J,I,H,G,F,E,D,C,B,A] Æ\r\n[D,G,J,M,P,C,F,I,L,O,B,E,H,K,N,A] \r\nInvShiftRows Example \r\nInvShiftRows (7b5b54657374566563746f725d53475d) = \r\n5d7456657b536f65735b47726374545d \r\nMixColumns Transformation \r\nMixColumns is a 16-byte Æ 16-byte transformation operating on the columns of the 4x4 \r\nmatrix representation of the input. The transformation treats each column as a third \r\ndegree polynomial with coefficients in AES-GF256-Field. Each column of the 4x4 matrix \r\nrepresentation of the State is multiplied by polynomial a(x) = {03}x3\r\n + {01}x2 + {01}x \r\n+ {02} and reduced modulo x4\r\n + 1. Here, { } denotes an element in AES-GF256-Field. \r\nThe equations that define MixColumns are detailed in Figure 3. The transformation is [P \r\n– A] Æ [P’ – A’]; the symbol • denotes multiplication in AES-GF256-Field (i.e., • is a \r\ncarry-less multiplication followed by reduction modulo 0x11b); the symbol + denotes \r\nXOR. \r\nFigure 3. MixColumns Transformation Equations\r\nA' = ({02} • A) + ({03} • B) + C + D \r\nB' = A + ({02} • B) + ({03} • C) + D \r\nC' = A + B + ({02} • C) + ({03} • D) \r\nD' = ({03} • A) + B + C + ({02} • D) \r\nE' = ({02} • E) + ({03} • F) + G + H \r\nF' = E + ({02} • F) + ({03} • G) + H \r\nG' = E + F + ({02} • G) + ({03} • H) \r\nH' = ({03} • E) + F + G + ({02} • H) \r\nI' = ({02} • I) + ({03} • J) + K + L \r\nJ' = I + ({02} • J) + ({03} • K) + L \r\nK' = I + J + ({02} • K) + ({03} • L) \r\nL' = ({03} • I) + J + K + ({02} • L) \r\nM' = ({02} • M) + ({03} • N) + O + P \r\nN' = M + ({02} • N) + ({03} • O) + P \r\nO' = M + N + ({02} • O) + ({03} • P) \r\nP' = ({03} • M) + N + O + ({02} • P) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/1cf5f120-47f5-44ba-a798-2e48600004b7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3aa663caf8848559e295ad83d045627cee0bf8521cadb87957f3235e9ed1b3be",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 406
      },
      {
        "segments": [
          {
            "segment_id": "6b2ef6af-3980-45a1-91ed-dfda311b15ec",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n12 323641-001 \r\nMixColumns Example \r\nMixColums (627a6f6644b109c82b18330a81c3b3e5) = \r\n7b5b54657374566563746f725d53475d \r\nInvMixColumns Transformation \r\nInvMixColumns is a 16-byte Æ 16-byte transformation operating on the columns of the \r\n4x4 matrix representation of the input. It is the inverse of MixColumns. The \r\ntransformation treats each column as a third degree polynomial with coefficients in AES\u0002GF256-Field. Each column of the 4x4 matrix representation of the state is multiplied by \r\npolynomial a-1(x) = {0b}x3\r\n + {0d}x2 + {09}x + {0e} and reduced modulo x4 + 1. The equations \r\nthat define InvMixColumns are detailed in Figure 4. The transformation is [P – A] Æ [P’ \r\n– A’]; the symbol • denotes multiplication in AES-GF256-Field (i.e., • is a carry-less \r\nmultiplication followed by reduction mod 0x11b); the symbol + denotes XOR. \r\nFigure 4. InvMixColumns Transformation Equations\r\nA' = ({0e} • A) + ({0b} • B) + ({0d} • C) + ({09} • D) \r\nB' = ({09} • A) + ({0e} • B) + ({0b} • C) + ({0d} • D) \r\nC' = ({0d} • A) + ({09} • B) + ({0e} • C) + ({0b} • D) \r\nD' = ({0b} • A) + ({0d} • B) + ({09} • C) + ({0e} • D) \r\nE' = ({0e} • E) + ({0b} • F) + ({0d} • G) + ({09} • H) \r\nF' = ({09} • E) + ({0e} • F) + ({0b} • G) + ({0d} • H) \r\nG' = ({0d} • E) + ({09} • F) + ({0e} • G) + ({0b} • H) \r\nH' = ({0b} • E) + ({0d} • F) + ({09} • G) + ({0e} • H) \r\nI' = ({0e} • I) + ({0b} • J) + ({0d} • K) + ({09} • L) \r\nJ' = ({09} • I) + ({0e} • J) + ({0b} • K) + ({0d} • L) \r\nK' = ({0d} • I) + ({09} • J) + ({0e} • K) + ({0b} • L) \r\nL' = ({0b} • I) + ({0d} • J) + ({09} • K) + ({0e} • L) \r\nM' = ({0e} • M) + ({0b} • N) + ({0d} • O) + ({09} • P) \r\nN' = ({09} • M) + ({0e} • N) + ({0b} • O) + ({0d} • P) \r\nO' = ({0d} • M) + ({09} • N) + ({0e} • O) + ({0b} • P) \r\nP' = ({0b} • M) + ({0d} • N) + ({09} • O) + ({0e} • P) \r\nInvMixColumns Example \r\nInvMixColumns (8dcab9dc035006bc8f57161e00cafd8d) = \r\nd635a667928b5eaeeec9cc3bc55f5777 \r\nSubWord Transformation \r\nSubWord is the doubleword Æ doubleword transformation defined by applying the S\u0002Box transformation to each one of the 4 bytes of the input, namely: \r\nSubWord (X) = [S-Box(X[31-24]), S-Box(X[23-16]), S-Box(X[15-8]), S-Box(X[7-0])] ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/6b2ef6af-3980-45a1-91ed-dfda311b15ec.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=000a9047fdcb2035bd63e99679a25d8903ef69546c8f52da15a3050e55d0990d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 445
      },
      {
        "segments": [
          {
            "segment_id": "f35f60f5-b1df-48fd-83f9-fdbc949533b2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 13 \r\nSubWord Example \r\nSubWord (73744765) = 8f92a04d \r\nRotWord Transformation \r\nRotWord is the doubleword Æ doubleword transformation defined by: \r\nRotWord (X [31-0]) = [X[7-0], X [31-24], X [23-16], X [15-8]] \r\n(in C language notation, RotWord(X) = (X >> 8) | (X << 24)) \r\nRotWord Example \r\nRotWord (3c4fcf09) = 093c4fcf \r\nRound Constant (RCON) \r\nThe AES key expansion procedure uses ten constants called Round Constants \r\n(RCON hereafter). The ten RCON values are RCON [i] = {02}i-1 for i=1, 2, …, 10, \r\nwhere the operations are in AES-GF256-Field. \r\nEach RCON value is an element of AES-GF256-Field, and is encoded here as a byte. The \r\nten RCON values are (in hexadecimal notation): \r\nRCON [1] = 0x01, RCON [2] = 0x02, RCON [3] = 0x04, RCON [4] = 0x08, RCON [5] = 0x10, \r\nRCON [6] = 0x20, RCON [7] = 0x40, RCON [8] = 0x80, RCON [9] = 0x1B, RCON [10] = 0x36. \r\nRemark: in the following RCON values are also viewed, interchangedly, as doublewords \r\nwhere their 24 leftmost bits equal 0. For example, RCON [7] = 0x00000040 (in \r\nhexadecimal notation). \r\nKey Expansion \r\nAES uses a cipher key whose length is 128, 192 or 256 bits. This cipher key is \r\nexpanded into 10, 12, or 14 round keys, respectively, using the “Key Expansion” \r\nalgorithm, where the length of each round key is 128 bits. This Key Expansion \r\nalgorithm depends only on the cipher key. Since it is independent of the processed data, \r\nit can be (and typically is) executed prior to the encryption/decryption phase. At the \r\nheart of the Key Expansion algorithm is the combination of the transformations \r\nSubWord(RotWord(tmp)) and SubWord(tmp) and the use of the RCON values. Figure 5 \r\nshows the pseudo code for the AES Key Expansion algorithm (as described in FIPS197). \r\nFigure 5. AES Key Expansion Pseudo Code (as Described in FIPS197)\r\nParameters \r\nNb = 4 (data blocks are of 128 bits) \r\nNk = number of doublewords in the cipher key \r\n (4, 6, 8 for AES-128, AES-192, AES-256, resp.) \r\nNr = number of rounds in the cipher \r\n (Nr=10, 12, 14 for AES-128, AES-192, AES-256, respectively). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/f35f60f5-b1df-48fd-83f9-fdbc949533b2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6eef4ebc4633ecc655c7a943d5136071feb5e55da4b5e91f0cd99308f259a2ff",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 351
      },
      {
        "segments": [
          {
            "segment_id": "b42cdcad-c3a3-4bcb-bd14-ccfa38a8b4b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n14 323641-001 \r\nThe Key Expansion routine \r\nKeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk) \r\nbegin \r\nword tmp \r\ni = 0 \r\nwhile (i < Nk) \r\n w[i] = word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]) \r\n i = i+1 \r\nend while \r\ni = Nk \r\nwhile (i < Nb * (Nr+1)) \r\n tmp = w[i-1] \r\n if (i mod Nk = 0) \r\n tmp = SubWord(RotWord(tmp)) xor RCON[i/Nk] \r\n else \r\n if (Nk = 8) \r\n tmp = SubWord(tmp) \r\n end if \r\n w[i] = w[i-Nk] xor tmp \r\n i = i + 1 \r\nend while \r\nAES Encryption and Decryption Flows \r\nThe Order of Transformations \r\nSubBytes transformation operates separately on each byte of the State, while the \r\nShiftRows transformation operates on the columns of the State. Therefore, ShiftRows \r\nand SubBytes commute with each other. Similarly, InvShiftRows and InvSubBytes \r\ncommute. \r\nIn the following, we use the notation where ShiftRows is applied before SubBytes and \r\nInvShiftRows is applied before InvSubBytes (unlike the order that appears in FIPS197). \r\nDecryption with the Equivalent Inverse Cipher \r\nThere are two equivalent ways to perform AES decryption, one is called the “Inverse \r\nCipher” and the other is called the “Equivalent Inverse Cipher”. They differ in the \r\ninternal order of the sequence of the (inverse) transformations, and also in the way that \r\nthe decryption round keys are defined. \r\nIntel architecture uses the Equivalent Inverse Cipher for decryption. \r\nTo use the “Equivalent Inverse Cipher”, the round keys for the decryption must be \r\nproperly prepared, as follows. Denote the round key which is used in round number j \r\nduring the encryption flow, by Round_Key_Encrypt [j], j=0, 1, 2, ..., Nr. Here, Nr = \r\n10/12/14 for AES-128, AES-192, AES-256, respectively. Denote the decryption round \r\nkey, which is used during round j of the decryption flow, by Round_Key_Decrypt [j]. \r\nThe following figure shows how the decryption round keys can be derived from the \r\nencryption round keys. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/b42cdcad-c3a3-4bcb-bd14-ccfa38a8b4b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c8e3e7b84a4a817442054135cd92b366b52acca40dd21874c9186ac866d6fa10",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "c0510967-30e7-416e-8552-80eea075adbf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 15 \r\nFigure 6. Preparing the Decryption Round Keys \r\nRound_Key_Decrypt [0] = Round_Key_Encrypt [Nr] \r\nfor round = 1, 2, to Nr-1 \r\n Round_Key_Decrypt [round] = InvMixColumns (Round_Key_Encrypt [Nr- round]) \r\nRound_Key_Decrypt [Nr] = Round_Key_Encrypt [0] \r\nEncryption and Decryption Flows \r\nAES encryption and decryption flows consist of a back-to-back sequence of AES \r\ntransformations, operating on a 128-bit State (data) and a round key. The flows depend \r\non the cipher key length, where \r\nAES-128 encryption/decryption consists of 40 steps (transformations) \r\nAES-192 encryption/decryption consists of 48 steps \r\nAES-256 encryption/decryption consists of 56 steps \r\nThe color code is used in Figure 7 and Figure 8 for describing the respective different \r\nflows. In the following pseudo code, it is assumed that the 10, 12, or 14 round keys \r\nare already derived (expanded) from the cipher key and stored, in the proper order, in \r\nan array (Round_Key_Encrypt and Round_Key_Decrypt). Here, it is assumed that \r\nRound_Key_Encrypt [0] stores the first 128 bits of the cipher key, which is used for the \r\nfirst XOR operation (aka round 0). \r\nFigure 7. The AES Encryption Flow \r\n; Data is a 128-bit block to be encrypted. \r\n; The round keys are stored in the array Round_Key_Encrypt \r\n Tmp = AddRoundKey (Data, Round_Key_Encrypt [0]) \r\n For round = 1-9 or 1-11 or 1-13: \r\n Tmp = ShiftRows (Tmp) \r\n Tmp = SubBytes (Tmp)\r\n Tmp = MixColumns (Tmp) \r\n Tmp = AddRoundKey (Tmp, Round_Key_Encrypt [round]) \r\n end loop \r\n Tmp = ShiftRows (Tmp) \r\n Tmp = SubBytes (Tmp) \r\n Tmp = AddRoundKey (Tmp, Round_Key_Encrypt [10 or 12 or 14]) \r\n Result = Tmp \r\nFigure 8. The AES Decryption Flow (Using the Equivalent Inverse Cipher) \r\n; Data is a 128-bit block to be decrypted. \r\n; The decryption round keys are stored in the array Round_Key_Decrypt \r\n; (it is assumed here that decryption round keys have been properly prepared \r\n; to be used by the Equivalent Inverse Cipher) \r\n Tmp = AddRoundKey (Data, Round_Key_Decrypt [0]) \r\n For round = 1-9 or 1-11 or 1-13: \r\n Tmp = InvShiftRows (Tmp) \r\n Tmp = InvSubBytes (Tmp)\r\n Tmp = InvMixColumns (Tmp) \r\n Tmp = AddRoundKey (Tmp, Round_Key_Decrypt [round]) \r\n end loop ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/c0510967-30e7-416e-8552-80eea075adbf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3f40e980e302936b26e0ec1048fd472c2c492a5cedcf3585a8281b3c0a88ffa0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 343
      },
      {
        "segments": [
          {
            "segment_id": "9814c173-b8fb-4e12-a5da-1f8569762f6e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n16 323641-001 \r\n Tmp = InvShiftRows (Tmp) \r\n Tmp = InvSubBytes (Tmp) \r\n Tmp = AddRoundKey (Tmp, Round_Key_Decrypt [10 or 12 or 14]) \r\n Result = Tmp\r\nIntel® AES New Instructions Architecture\r\nThe Intel AES New Instructions consists of six instructions. \r\nFour instructions, namely AESENC, AESENCLAST, AESDEC, AESDECLAST, are provided \r\nfor data encryption and decryption (the names are short for AES Encrypt Round, AES \r\nEncrypt Last Round, AES Decrypt Round AES Decrypt Last Round). These instructions \r\nhave both register-register and register-memory variants. \r\nTwo other instructions, namely AESIMC and AESKEYGENASSIST are provided in order to \r\nassist with AES Key Expansion (the names are short for AES Inverse Mix Columns, and \r\nAES Key Generation Assist). \r\nThe Four AES Round Instructions \r\nAESENC, AESENCLAST, AESDEC, AESDECLAST are defined by the pseudo code in the \r\nfollowing figures (“xmm1” and “xmm2” are aliases to any two xmm registers). These \r\ninstructions perform a grouped sequence of transformations of the AES \r\nencryption/decryption flows (in fact, they perform the longest sequence possible, \r\nwithout introducing a branch in an instruction). \r\nFigure 9. The AESENC and AESENCLAST Instructions \r\nAESENC xmm1, xmm2/m128 \r\nTmp := xmm1 \r\nRound Key := xmm2/m128 \r\nTmp := ShiftRows (Tmp) \r\nTmp := SubBytes (Tmp) \r\nTmp := MixColumns (Tmp) \r\nxmm1 := Tmp xor Round Key \r\nAESENCLAST xmm1, xmm2/m128 \r\nTmp := xmm1 \r\nRound Key := xmm2/m128 \r\nTmp := Shift Rows (Tmp) \r\nTmp := SubBytes (Tmp) \r\nxmm1 := Tmp xor Round Key \r\nFigure 10. The AESDEC and AESDECLAST Instructions \r\nAESDEC xmm1, xmm2/m128 \r\nTmp := xmm1 \r\nRound Key := xmm2/m128 \r\nTmp := InvShift Rows (Tmp) \r\nTmp := InvSubBytes (Tmp) \r\nTmp := InvMixColumns (Tmp) \r\nxmm1 := Tmp xor Round Key \r\nAESDECLAST xmm1, xmm2/m128 \r\nState := xmm1 \r\nRound Key := xmm2/m128 \r\nTmp := InvShift Rows (State) \r\nTmp := InvSubBytes (Tmp) \r\nxmm1:= Tmp xor Round Key \r\nAESENC Example \r\nFigure 11. AESENC Example \r\n; xmm1 and xmm2 hold two 128-bit inputs (xmm1 = State; xmm2 = Round key). \r\n; The result is delivered in xmm1. \r\nxmm1 = 7b5b54657374566563746f725d53475d xmm2 = 48692853686179295b477565726f6e5d ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/9814c173-b8fb-4e12-a5da-1f8569762f6e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b939aba18604e20db2a4330731d8174a0251219fb55c464c79cc035ca3e5d35e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 328
      },
      {
        "segments": [
          {
            "segment_id": "9690c82d-5e1a-4d97-b5f1-446d8c28ce2c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 17 \r\nAESENC result (in xmm1): a8311c2f9fdba3c58b104b58ded7e595 \r\nAESENCLAST Example \r\nFigure 12. AESENCLAST Example \r\n; xmm1 and xmm2 hold two 128-bit inputs (xmm1 = State; xmm2 = Round key) \r\n; The result delivered in xmm1 \r\nxmm1 = 7b5b54657374566563746f725d53475d xmm2 = 48692853686179295b477565726f6e5d \r\nAESENCLAST result (in xmm1): c7fb881e938c5964177ec42553fdc611 \r\nAESEDEC Example \r\nFigure 13. AESDEC Example \r\n; xmm1 and xmm2 hold two 128-bit inputs (xmm1 = State; xmm2 = Round key). \r\n; The result delivered in xmm1. \r\nxmm1 = 7b5b54657374566563746f725d53475d xmm2 = 48692853686179295b477565726f6e5d \r\nAESDEC result (in xmm1): 138ac342faea2787b58eb95eb730392a \r\nAESDECLAST Example \r\nFigure 14. AESDECLAST Example \r\n; xmm1 and xmm2 hold two 128-bit inputs (xmm1 = State; xmm2 = Round key). \r\n; The result delivered in xmm1. \r\nxmm1 = 7b5b54657374566563746f725d53475d xmm2 = 48692853686179295b477565726f6e5d \r\nAESDECLAST result (in xmm1): c5a391ef6b317f95d410637b72a593d0 \r\nAES Encryption and Decryption Flows Using the AES Round \r\nInstructions \r\nFrom Figures 7 and 8, and the definition of AESENC/AESENCLAST, \r\nAESDEC/AESDECLAST instructions (see Figures 9, 10) it is easy to understand how the \r\ninstructions could be used for AES encryption and decryption. We provide here two \r\noutlined code examples, one showing an AES-128 encryption code sequence, and the \r\nother showing an AES-192 decryption code sequence. \r\nFigure 15. AES-128 Encryption Outlined Code Sequence \r\n; AES-128 encryption sequence. \r\n; The data block is in xmm15. \r\n; Registers xmm0–xmm10 hold the round keys(from 0 to 10 in this order). \r\n; In the end, xmm15 holds the encryption result. \r\n pxor xmm15, xmm0 ; Whitening step (Round 0) \r\n aesenc xmm15, xmm1 ; Round 1 \r\n aesenc xmm15, xmm2 ; Round 2 \r\n aesenc xmm15, xmm3 ; Round 3 \r\n aesenc xmm15, xmm4 ; Round 4 \r\n aesenc xmm15, xmm5 ; Round 5 \r\n aesenc xmm15, xmm6 ; Round 6 \r\n aesenc xmm15, xmm7 ; Round 7 \r\n aesenc xmm15, xmm8 ; Round 8 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/9690c82d-5e1a-4d97-b5f1-446d8c28ce2c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5112d23f51fed9cfa6e54403d800628595f4a4b654b20e0ebbb6418a08f20df4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 290
      },
      {
        "segments": [
          {
            "segment_id": "5a8c4a33-ae11-4168-a7f7-7213fa11a844",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n18 323641-001 \r\n aesenc xmm15, xmm9 ; Round 9 \r\n aesenclast xmm15, xmm10 ; Round 10 \r\nFigure 16. AES-192 Decryption: Outlined Code Sequence\r\n ; AES-192 decryption sequence. \r\n ; The data is in xmm15. \r\n ; Registers xmm12 – xmm0 hold the decryption round keys. \r\n ; (the decryption round keys are derived from the encryption round keys by \r\n ; passing them (except for the first and the last) through the \r\n ; InvMixColumns transformation.) \r\n ; In the end - xmm15 holds the decryption result \r\n pxor xmm15, xmm12 ; First xor \r\n aesdec xmm15, xmm11 ; Round 1 (consuming round keys in reverse order) \r\n aesdec xmm15, xmm10 ; Round 2 \r\n aesdec xmm15, xmm9 ; Round 3 \r\n aesdec xmm15, xmm8 ; Round 4 \r\n aesdec xmm15, xmm7 ; Round 5 \r\n aesdec xmm15, xmm6 ; Round 6 \r\n aesdec xmm15, xmm5 ; Round 7 \r\n aesdec xmm15, xmm4 ; Round 8 \r\n aesdec xmm15, xmm3 ; Round 9 \r\n aesdec xmm15, xmm2 ; Round 10 \r\n aesdec xmm15, xmm1 ; Round 11 \r\n aesdeclast xmm15, xmm0 ; Round 12 \r\nThe Two Instructions for Supporting AES Key Expansion \r\nAES Key Expansion is supported by two instructions. AESKEYGENASSIST is used for \r\ngenerating the round keys used for encryption. AESIMC is used for converting the \r\nencryption round keys to a form usable for decryption using the Equivalent Inverse \r\nCipher. \r\nThe AESKEYGENASSIST Instruction \r\nFigure 17. The AESKEYGENASSIST Instruction \r\nAESKEYGENASSIST xmm1, xmm2/m128, imm8 \r\nTmp := xmm2/LOAD(m128) \r\nX3[31-0] := Tmp[127-96]; \r\nX2[31-0] := Tmp[95-64]; \r\nX1[31-0] := Tmp[63-32]; \r\nX0[31-0] := Tmp[31-0]; \r\nRCON[7-0] := imm8; \r\nRCON [31-8] := 0; \r\nxmm1 := [RotWord (SubWord (X3)) XOR RCON, SubWord (X3), \r\n RotWord (SubWord (X1)) XOR RCON, SubWord (X1)] ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/5a8c4a33-ae11-4168-a7f7-7213fa11a844.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6ca34923c608f03594de5b7e73509dd03ab5065a95eff446ec93e8b87b4a966",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "5d068144-604a-4b62-8a29-2d3cd58e8e55",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 19 \r\nAESKEYGENASSIST Example \r\nFigure 18. AESKEYGENASSIST Example \r\n; xmm2 holds a 128-bit input; imm8 holds the RCON value \r\n; result delivered in xmm1 \r\nxmm2 = 3c4fcf098815f7aba6d2ae2816157e2b imm8 = 1 \r\nAESKEYGENASSIST result (in xmm1): 01eb848beb848a013424b5e524b5e434 \r\nKey Expansion Using AESKEYGENASSIST \r\nFigure 5 show the AES Key Expansion flow, for the different key sizes (128/192/256 \r\nbits). From this software flow, it is clear that the AESKEYGENASSIST instruction is \r\ndesigned to be used for two operations in the expansion sequence, namely \r\ntmp = SubWord(RotWord(tmp)) xor RCON[i/Nk]\r\nand \r\n tmp = SubWord(tmp) \r\nwhere the latter is relevant only for the 256-bits key expansion. \r\nThere are several possible ways to expand the key using AESKEYGENASSIST, and full \r\ncode demonstrations are listed below. We give here the example for AES-128. \r\nFigure 19. AES-128 Key Expansion: Outlined Code Example \r\n; Cipher key is stored in “Key”. For example, \r\n; Key 0x0f0e0d0c0b0a09080706050403020100 \r\n; The key scheduled to be stored in the array Key_Schedule. \r\n movdqu xmm1, XMMWORD PTR Key \r\n movdqu XMMWORD PTR Key_Schedule, xmm1 \r\n mov rcx, OFFSET Key_Schedule+16 \r\n aeskeygenassist xmm2, xmm1, 0x1 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x2 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x4 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x8 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x10 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x20 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x40 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x80 \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x1b \r\n call key_expansion_128 \r\n aeskeygenassist xmm2, xmm1, 0x36 \r\n call key_expansion_128 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/5d068144-604a-4b62-8a29-2d3cd58e8e55.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f29cdb834aa09e3de33b360e63e9c94ef98ee8a8d8a6d53f4466dc10377f8378",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 504
      },
      {
        "segments": [
          {
            "segment_id": "3c24d09f-c217-4d9b-a9f1-fc9de88d95e3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n20 323641-001 \r\n jmp END; \r\nkey_expansion_128: \r\n pshufd xmm2, xmm2, 0xff \r\n vpslldq xmm3, xmm1, 0x4 \r\n pxor xmm1, xmm3 \r\n vpslldq xmm3, xmm1, 0x4 \r\n pxor xmm1, xmm3 \r\n vpslldq xmm3, xmm1, 0x4 \r\n pxor xmm1, xmm3 \r\n pxor xmm1, xmm2 \r\n movdqu XMMWORD PTR [rcx], xmm1 \r\n add rcx, 0x10 \r\n ret \r\nEND: \r\nPreparing the Decryption Round Keys Using AESIMC \r\nBy their definition, AESDEC and AESDECLAST should be used for decryption with the \r\nEquivalent Inverse Cipher. To this end, the encryption round keys 1-9/11/13 (for AES\u0002128/AES-192/AES-256, respectively) need to be first passed through the \r\nInvMixColumns transformation. This can be easily done by using the AESIMC \r\ninstruction, which is defined by the following pseudo code. \r\nFigure 20. The AESIMC Instruction \r\nAESIMC xmm1, xmm2/m128 \r\nRoundKey := xmm2/m128; \r\nxmm1 := InvMixColumns (RoundKey) \r\nAESIMC Example \r\nFigure 21. AESIMC Example \r\n; xmm2 hold one 128-bit inputs (xmm2 = Round key) \r\n; result delivered in xmm1 \r\nxmm2 = 48692853686179295b477565726f6e5d \r\nAESIMC result (in xmm1): 627a6f6644b109c82b18330a81c3b3e5 \r\nGenerating AES Decryption Round Keys \r\nThe following Assembly code snippet shows an example for generating an AES-128 key \r\nschedule for decryption. \r\nFigure 22. Using AESIMC for AES-128: Outlined Code Example \r\n; The array Key_Schedule holds the expanded round keys (round keys 0-10). \r\n; The decryption round keys are to be stored in the array Key_Schedule_Decrypt. \r\n; Transforming the encryption round keys to decryption keys is done by passing round \r\n; keys 1-9 through InMixColumns transformation (using aesimc instruction), to be \r\n; ready to use with the Equivalent Inverse Cipher. \r\nmov rdx, OFFSET Key_Schedule \r\nmov rax, OFFSET Key_Schedule_Decrypt ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/3c24d09f-c217-4d9b-a9f1-fc9de88d95e3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3c9ddc0e64d66d9b323da93c009efa201c1c879be072266ff3df7d9389df7c2a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ddc1957d-322c-4d78-ba48-5e5059a96640",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 21 \r\nmovdqu xmm1, XMMWORD PTR [rdx] \r\nmovdqu XMMWORD PTR [rax], xmm1 \r\nadd rdx, 0x10 \r\nadd rax, 0x10 \r\nmov ecx, 9 ; 9 for AES-128, 11 for AES-192, 13 for AES-256 \r\nrepeat_Nr_minus_one_times: \r\n movdqu xmm1, XMMWORD PTR [rdx] \r\n aesimc xmm1, xmm1 \r\n movdqu XMMWORD PTR [rax], xmm1 \r\n add rdx, 0x10 \r\n add rax, 0x10 \r\nloop repeat_Nr_minus_one_times \r\nmovdqu xmm1, XMMWORD PTR [rdx] \r\nmovdqu XMMWORD PTR [rax], xmm1 \r\nApplication Programming Model \r\nThe AES extensions follow the same programming model as Intel® SSE, Intel® SSE2, \r\nIntel® SSE3, Intel SSSE3, and Intel® SSE4 (see Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 1). Operating systems that support handling Intel \r\nSSE state will also support applications that use the AES instructions. This is the same \r\nrequirement for Legacy Intel SSE (i.e., Intel SSE2, Intel SSE3, Intel SSSE3, and Intel \r\nSSE4). \r\nDetecting AES Instructions \r\nBefore an application attempts to use the AES instructions, it should verify that the \r\nprocessor indeed supports these instructions. This is done by checking that \r\nCPUID.01H:ECX.AES[bit 25] = 1. \r\nSoftware Side Channels and the AES \r\nInstructions\r\nThis chapter provides a brief description of software side channel attacks and explains \r\nwhy memory access patterns can be used against software implementations of AES that \r\nuse table lookups. \r\nWhat are Software Side Channel Attacks? \r\nSoftware side channels are a set of vulnerabilities targeting modern computing \r\nenvironments. They can be potentially used for attacking cryptographic applications that \r\nrun on a multi-tasking platform. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/ddc1957d-322c-4d78-ba48-5e5059a96640.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e5e3dc2507cddf299b12929794fc27d3f08505531d3100be747a1ef9ff84ed8a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 495
      },
      {
        "segments": [
          {
            "segment_id": "37485175-f15a-43ad-9983-06cad68ff172",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n22 323641-001 \r\nThese attacks use the fact that practically all current commercial computer platforms \r\nrun multiple tasks on a single set of hardware resources. Some recent publications \r\nshowed that multi-tasking operating systems combined with processor’s resource \r\nsharing can lead to side channel information leaks, where an unprivileged spy process \r\n(“spy” hereafter) running in parallel to some cryptosystem (“crypto” hereafter), at the \r\nsame privilege level (“Ring 3”) can obtain information on crypto's memory access \r\npatterns, or on its execution flow. In some cases (depending on the way that the crypto \r\nprogram is written), this information can be used for compromising secret information \r\n(e.g., keys). \r\nThe focus of this chapter is software side channels, and how the currently known timing \r\nand cache attacks on AES can be mitigated by using the AES instructions. \r\nThe CPU Cache and the Basics of Cache Attacks \r\nCache is a widely used performance optimization technique, employed by virtually all \r\nmodern processors. The cache is a special (and expensive) type of memory that can be \r\naccessed much faster than the main memory. It is used by the CPU for storing the \r\nrecently read areas of memory. In each memory access, the CPU first checks if the \r\nrequired data is already in the cache. In that case (called cache hit), the memory access \r\nis very fast. If the required data is not in the cache (cache miss), it is read from the \r\nmemory (more slowly) and also stored in the cache for future reads. Obviously, storing \r\nnew data in the cache requires that the CPU evicts some previously loaded data - \r\ntypically the least recently used data. The cache helps reducing the average memory \r\naccess time by a significant amount. However, there is a side effect: the time for \r\nreading a particular piece of data depends on whether or not this data is already in the \r\ncache. This depends on the specific contents of the cache in the relevant moment, which \r\nis the overall result of all the processes that run on the platform. Malicious code could \r\npotentially exploit this cache behavior and attack cryptographic applications which \r\ninvolve data-dependent memory access in sensitive steps. \r\nLookup Tables and the Implied Vulnerability \r\nCurrently, many efficient and commonly used AES software implementations on the PC \r\nplatform use lookup tables (see e.g., Gladman’s implementation \r\nhttp://fp.gladman.plus.com/ or the OpenSSL code http://www.openssl.org). These \r\ntables are large, and therefore span across several cache lines. As a result, different \r\ncache lines may be accesses when different parts of the table are read. Unfortunately, \r\nin some critical steps of the AES algorithm, the accessed parts of the tables depend \r\n(implicitly) on the secret key, and this fact introduces vulnerabilities. \r\nA potential attack has a spy process executing on the same system as the “victim” \r\ncrypto process. The spy repeatedly performs data reads, and this way it causes the \r\ncache to be filled with its own data. It measures (using the RDTSC instruction) the \r\nlatency of its own reads, and can therefore identify those cache lines which have been \r\nmeanwhile evicted by the operation of the crypto (AES) process that runs in parallel. \r\nThis can be used to deduce which parts of the tables were accessed by the AES \r\noperation. Analysis of this information can lead to revealing the secret key (typically, \r\nthe information on the first and the last AES rounds leak the most sensitive \r\ninformation). We give here two (among many existing) references that provide more \r\ndetails on side channel attacks on software implementation of AES: D. A. Osvik, A. \r\nShamir, and E. Tromer, “Cache Attacks and Countermeasures: The Case of AES”, \r\nLecture Notes in Computer Science series, Springer-Verlag, 3860: 1-20, (2006) and also ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/37485175-f15a-43ad-9983-06cad68ff172.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2ce66361a0b26451d5cae0b5ecd05e2eb5143835660bca9f94bd49ff23cb8ccb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 615
      },
      {
        "segments": [
          {
            "segment_id": "37485175-f15a-43ad-9983-06cad68ff172",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n22 323641-001 \r\nThese attacks use the fact that practically all current commercial computer platforms \r\nrun multiple tasks on a single set of hardware resources. Some recent publications \r\nshowed that multi-tasking operating systems combined with processor’s resource \r\nsharing can lead to side channel information leaks, where an unprivileged spy process \r\n(“spy” hereafter) running in parallel to some cryptosystem (“crypto” hereafter), at the \r\nsame privilege level (“Ring 3”) can obtain information on crypto's memory access \r\npatterns, or on its execution flow. In some cases (depending on the way that the crypto \r\nprogram is written), this information can be used for compromising secret information \r\n(e.g., keys). \r\nThe focus of this chapter is software side channels, and how the currently known timing \r\nand cache attacks on AES can be mitigated by using the AES instructions. \r\nThe CPU Cache and the Basics of Cache Attacks \r\nCache is a widely used performance optimization technique, employed by virtually all \r\nmodern processors. The cache is a special (and expensive) type of memory that can be \r\naccessed much faster than the main memory. It is used by the CPU for storing the \r\nrecently read areas of memory. In each memory access, the CPU first checks if the \r\nrequired data is already in the cache. In that case (called cache hit), the memory access \r\nis very fast. If the required data is not in the cache (cache miss), it is read from the \r\nmemory (more slowly) and also stored in the cache for future reads. Obviously, storing \r\nnew data in the cache requires that the CPU evicts some previously loaded data - \r\ntypically the least recently used data. The cache helps reducing the average memory \r\naccess time by a significant amount. However, there is a side effect: the time for \r\nreading a particular piece of data depends on whether or not this data is already in the \r\ncache. This depends on the specific contents of the cache in the relevant moment, which \r\nis the overall result of all the processes that run on the platform. Malicious code could \r\npotentially exploit this cache behavior and attack cryptographic applications which \r\ninvolve data-dependent memory access in sensitive steps. \r\nLookup Tables and the Implied Vulnerability \r\nCurrently, many efficient and commonly used AES software implementations on the PC \r\nplatform use lookup tables (see e.g., Gladman’s implementation \r\nhttp://fp.gladman.plus.com/ or the OpenSSL code http://www.openssl.org). These \r\ntables are large, and therefore span across several cache lines. As a result, different \r\ncache lines may be accesses when different parts of the table are read. Unfortunately, \r\nin some critical steps of the AES algorithm, the accessed parts of the tables depend \r\n(implicitly) on the secret key, and this fact introduces vulnerabilities. \r\nA potential attack has a spy process executing on the same system as the “victim” \r\ncrypto process. The spy repeatedly performs data reads, and this way it causes the \r\ncache to be filled with its own data. It measures (using the RDTSC instruction) the \r\nlatency of its own reads, and can therefore identify those cache lines which have been \r\nmeanwhile evicted by the operation of the crypto (AES) process that runs in parallel. \r\nThis can be used to deduce which parts of the tables were accessed by the AES \r\noperation. Analysis of this information can lead to revealing the secret key (typically, \r\nthe information on the first and the last AES rounds leak the most sensitive \r\ninformation). We give here two (among many existing) references that provide more \r\ndetails on side channel attacks on software implementation of AES: D. A. Osvik, A. \r\nShamir, and E. Tromer, “Cache Attacks and Countermeasures: The Case of AES”, \r\nLecture Notes in Computer Science series, Springer-Verlag, 3860: 1-20, (2006) and also ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/37485175-f15a-43ad-9983-06cad68ff172.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2ce66361a0b26451d5cae0b5ecd05e2eb5143835660bca9f94bd49ff23cb8ccb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 615
      },
      {
        "segments": [
          {
            "segment_id": "16d07a4b-fbf7-42fd-b7e3-560cc0f84ebe",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 23 \r\nD. J. Bernstein, \"Cache-timing attacks on AES\", \r\nhttp://people.csail.mit.edu/tromer/papers/cache.pdf (2005). \r\nSoftware Mitigation for AES Carries a Performance Penalty \r\nThere are ways to write AES software in a way that avoids the key-dependent memory \r\naccess. One example is to permute the lookup tables in order to obscure the undesired \r\ndata dependency. Details can be found in the paper: E. Brickell, E., G. Graunke, M. \r\nNeve, J. P. Seifert, “Software mitigations to hedge AES against cache based software \r\nside channel vulnerabilities” http://eprint.iacr.org/2006/052.pdf. However, these \r\nmitigation techniques carry significant performance penalty. Another way (called Bit \r\nSlicing) is to write the AES software without lookup tables at all, for example, as shown \r\nin: M. Matsui and S. Fukuda. “How to Maximize Software Performance of Symmetric \r\nPrimitives on Pentium III and 4 Processors”. LNCS, Springer Verlag, 3557: 398–412 \r\n(2005). This approach also involves performance penalty. In general, software \r\nimplementations of AES, that included techniques for avoiding key-dependent memory \r\naccesses are slower than the optimized (but vulnerable) implementations based on \r\nlookup tables. \r\nRecent results by Bernstein and Schwabe, “New AES Software Speed Records”, \r\nProceedings of INDOCRYPT 2008, Lecture Notes in Computer Science 5365:322-336 \r\n(2008) show very fast implementations of AES-128 in CTR mode, using bit slicing \r\n(without lookup tables). This paper also includes a comprehensive survey of \r\nperformance results of software implementations of AES. \r\nThe AES Instructions Help Protecting Against Side \r\nChannels Attacks \r\nThe AES instructions are designed to mitigate all of the known timing and cache side \r\nchannel leakage of sensitive data (from Ring 3 spy processes). Their latency is data\u0002independent, and since all the computations are performed internally by the hardware, \r\nno lookup tables are required. Therefore, if the AES instructions are used properly (e.g., \r\nas in the following code examples) the AES encryption/decryption, as well as the Key \r\nExpansion, would have data-independent timing and would involve only data\u0002independent memory access. Consequently, the AES instructions allow for writing high \r\nperformance AES software which is, at the same time, protected against the currently \r\nknown software side channel attacks. \r\nBasic C Code Examples \r\nThis chapter provides C code examples illustrating the basic usage of the AES \r\ninstructions. The examples are provided as function written in C, using compiler \r\nintrinsics, and they include functions for AES128/192/256 key expansion, encryption \r\nand decryption in ECB, CBC, CTR modes of operation. \r\nThe interface of these functions is similar to the interface of OpenSSL, with some slight \r\nmodifications: \r\nCBC mode: the CBC function behaves exactly as the analogous function of OpenSSL. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/16d07a4b-fbf7-42fd-b7e3-560cc0f84ebe.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0fe6b9c37c385633adf531846e943389c129779fa2d5a1a826d1856f59767706",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 419
      },
      {
        "segments": [
          {
            "segment_id": "bf28c2ba-8b82-47f2-aa01-91a4bac6359d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n24 323641-001 \r\nECB mode: OpenSSL does not have ECB mode for encrypting a buffer, but rather \r\nprovides a function for encrypting a single block. The ECB function provided here, has \r\nthe same interface, but also receives the buffer length as a parameter (and operates \r\non that buffer). \r\nCTR mode: the OpenSSL function receives a pre-computed counter block as input. Our \r\nfunction receives the IV and the nonce, and builds the counter block. \r\nThe functions can be compiled and linked with the test functions that are provided in the \r\n“Test Functions” Section (see below), in order to generate a running executable. \r\nThe intention is to provide the basic examples, in order to help software writers develop \r\ntheir applications. The emphasis was given here to code clarity, simplicity, and \r\nportability (the code samples can be run on Linux/Windows and can be compiled with \r\nicc, gcc and the Microsoft compiler). However, it should be noted that these code \r\nexamples are not necessarily optimized for performance. An optimized library (written in \r\nassembly) is provided in a separate chapter. \r\nUsing the Code Examples with ICC/gcc and the Software \r\nDevelopment Emulator \r\nThe code examples presented here were compiled and run on a Linux environment, \r\nusing both the Intel® C Compiler (icc) and with gcc. The ICC and gcc compilers support \r\nthe AES instructions from version ICC 11.1 and gcc 4.4, respectively. \r\nThe code can be run even without a processor based on Intel microarchitecture \r\ncodename Westmere, using an Intel emulator (Intel® Software Development Emulator; \r\nIntel® SDE), which can be downloaded from http://www.intel.com/software/sde. \r\nDetecting AES Instructions \r\nBefore an application attempts to use the AES instructions, it should verify that the \r\nprocessor supports these instructions. This should be done by checking that \r\nCPUID.01H:ECX.AES[bit 25] = 1. The following (assembly) code demonstrates this \r\ncheck. \r\nFigure 23. Checking the CPU Support for the AES Instructions \r\n#define cpuid(func,ax,bx,cx,dx)\\ \r\n __asm__ __volatile__ (\"cpuid\":\\ \r\n \"=a\" (ax), \"=b\" (bx), \"=c\" (cx), \"=d\" (dx) : \"a\" (func)); \r\nint Check_CPU_support_AES() \r\n { \r\n unsigned int a,b,c,d; \r\n cpuid(1, a,b,c,d); \r\n return (c & 0x2000000); \r\n } \r\nAES-128, AES-192, and AES-256 Key Expansion (C code) \r\nFigure 24. AES-128 Key Expansion (C code) \r\n#include <wmmintrin.h> ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bf28c2ba-8b82-47f2-aa01-91a4bac6359d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2c6e8b93ff44039aea8418d2f22ea7a0219955bf27d06a96774dbddce757ba42",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 359
      },
      {
        "segments": [
          {
            "segment_id": "56c7ef13-7014-4e0c-a892-1ef02a08d5e4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 25 \r\ninline __m128i AES_128_ASSIST (__m128i temp1, __m128i temp2) \r\n { \r\n __m128i temp3; \r\n temp2 = _mm_shuffle_epi32 (temp2 ,0xff); \r\n temp3 = _mm_slli_si128 (temp1, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp1 = _mm_xor_si128 (temp1, temp2); \r\n return temp1; \r\n } \r\nvoid AES_128_Key_Expansion (const unsigned char *userkey, \r\n unsigned char *key) \r\n { \r\n __m128i temp1, temp2; \r\n __m128i *Key_Schedule = (__m128i*)key; \r\n \r\n temp1 = _mm_loadu_si128((__m128i*)userkey); \r\n Key_Schedule[0] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1 ,0x1); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[1] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x2); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[2] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x4); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[3] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x8); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[4] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x10); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[5] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x20); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[6] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x40); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[7] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x80); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[8] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x1b); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[9] = temp1; \r\n temp2 = _mm_aeskeygenassist_si128 (temp1,0x36); \r\n temp1 = AES_128_ASSIST(temp1, temp2); \r\n Key_Schedule[10] = temp1; \r\n } ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/56c7ef13-7014-4e0c-a892-1ef02a08d5e4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ceaab4c921b40ed6b97e79f2777c68cad687060134d150ca22fdd1cffc620461",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a3f4a0f5-c9f7-442a-8685-4675b0258c9b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n26 323641-001 \r\nFigure 25. AES-192 Key Expansion (C code) \r\n#include <wmmintrin.h> \r\ninline void KEY_192_ASSIST(__m128i* temp1, __m128i * temp2, __m128i * temp3) \r\n { \r\n __m128i temp4; \r\n *temp2 = _mm_shuffle_epi32 (*temp2, 0x55); \r\n temp4 = _mm_slli_si128 (*temp1, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n *temp1 = _mm_xor_si128 (*temp1, *temp2); \r\n *temp2 = _mm_shuffle_epi32(*temp1, 0xff); \r\n temp4 = _mm_slli_si128 (*temp3, 0x4); \r\n *temp3 = _mm_xor_si128 (*temp3, temp4); \r\n *temp3 = _mm_xor_si128 (*temp3, *temp2); \r\n } \r\nvoid AES_192_Key_Expansion (const unsigned char *userkey, \r\n unsigned char *key) \r\n { \r\n __m128i temp1, temp2, temp3, temp4; \r\n __m128i *Key_Schedule = (__m128i*)key; \r\n temp1 = _mm_loadu_si128((__m128i*)userkey); \r\n temp3 = _mm_loadu_si128((__m128i*)(userkey+16)); \r\n Key_Schedule[0]=temp1; \r\n Key_Schedule[1]=temp3; \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x1); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[1] = (__m128i)_mm_shuffle_pd((__m128d)Key_Schedule[1], \r\n (__m128d)temp1,0); \r\n Key_Schedule[2] = (__m128i)_mm_shuffle_pd((__m128d)temp1,(__m128d)temp3,1); \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x2); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[3]=temp1; \r\n Key_Schedule[4]=temp3; \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x4); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[4] = (__m128i)_mm_shuffle_pd((__m128d)Key_Schedule[4], \r\n (__m128d)temp1,0); \r\n Key_Schedule[5] = (__m128i)_mm_shuffle_pd((__m128d)temp1,(__m128d)temp3,1); \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x8); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[6]=temp1; \r\n Key_Schedule[7]=temp3; \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x10); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[7] = (__m128i)_mm_shuffle_pd((__m128d)Key_Schedule[7], \r\n (__m128d)temp1,0); \r\n Key_Schedule[8] = (__m128i)_mm_shuffle_pd((__m128d)temp1,(__m128d)temp3,1); ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/a3f4a0f5-c9f7-442a-8685-4675b0258c9b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=132ad1b3e368e97983e9b18366cfca9888d70a304fa755187f22189d35efaaa9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 367
      },
      {
        "segments": [
          {
            "segment_id": "733cb3f1-9479-4add-a55e-aae886d08327",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 27 \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x20); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[9]=temp1; \r\n Key_Schedule[10]=temp3; \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x40); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[10] = (__m128i)_mm_shuffle_pd((__m128d)Key_Schedule[10], \r\n (__m128d)temp1,0); \r\n Key_Schedule[11] = (__m128i)_mm_shuffle_pd((__m128d)temp1,(__m128d)temp3,1); \r\n temp2=_mm_aeskeygenassist_si128 (temp3,0x80); \r\n KEY_192_ASSIST(&temp1, &temp2, &temp3); \r\n Key_Schedule[12]=temp1; } \r\nFigure 26. AES-256 Key Expansion (C code) \r\n#include <wmmintrin.h> \r\ninline void KEY_256_ASSIST_1(__m128i* temp1, __m128i * temp2) \r\n { \r\n __m128i temp4; \r\n *temp2 = _mm_shuffle_epi32(*temp2, 0xff); \r\n temp4 = _mm_slli_si128 (*temp1, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp1 = _mm_xor_si128 (*temp1, temp4); \r\n *temp1 = _mm_xor_si128 (*temp1, *temp2); \r\n } \r\ninline void KEY_256_ASSIST_2(__m128i* temp1, __m128i * temp3) \r\n { \r\n __m128i temp2,temp4; \r\n temp4 = _mm_aeskeygenassist_si128 (*temp1, 0x0); \r\n temp2 = _mm_shuffle_epi32(temp4, 0xaa); \r\n temp4 = _mm_slli_si128 (*temp3, 0x4); \r\n *temp3 = _mm_xor_si128 (*temp3, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp3 = _mm_xor_si128 (*temp3, temp4); \r\n temp4 = _mm_slli_si128 (temp4, 0x4); \r\n *temp3 = _mm_xor_si128 (*temp3, temp4); \r\n *temp3 = _mm_xor_si128 (*temp3, temp2); \r\n } \r\nvoid AES_256_Key_Expansion (const unsigned char *userkey, \r\n unsigned char *key) \r\n { \r\n __m128i temp1, temp2, temp3; \r\n __m128i *Key_Schedule = (__m128i*)key; \r\n temp1 = _mm_loadu_si128((__m128i*)userkey); \r\n temp3 = _mm_loadu_si128((__m128i*)(userkey+16)); \r\n Key_Schedule[0] = temp1; \r\n Key_Schedule[1] = temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x01); \r\n KEY_256_ASSIST_1(&temp1, &temp2); ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/733cb3f1-9479-4add-a55e-aae886d08327.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8429344fecb141c6426db31fb061ad96ff3e5415bfed924a1b1282a6fc210a34",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b44f6806-c0a9-4c26-a6dd-96b071583455",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n28 323641-001 \r\n Key_Schedule[2]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[3]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x02); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[4]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[5]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x04); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[6]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[7]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x08); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[8]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[9]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x10); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[10]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[11]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x20); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[12]=temp1; \r\n KEY_256_ASSIST_2(&temp1, &temp3); \r\n Key_Schedule[13]=temp3; \r\n temp2 = _mm_aeskeygenassist_si128 (temp3,0x40); \r\n KEY_256_ASSIST_1(&temp1, &temp2); \r\n Key_Schedule[14]=temp1; \r\n } \r\nAES Encryption and Decryption in ECB Mode \r\nFigure 27. AES-128, AES-192 and AES-256 Encryption and Decryption in ECB Mode (C code) \r\n#include <wmmintrin.h> \r\n/* Note – the length of the output buffer is assumed to be a multiple of 16 bytes */ \r\nvoid AES_ECB_encrypt(const unsigned char *in, //pointer to the PLAINTEXT \r\n unsigned char *out, //pointer to the CIPHERTEXT buffer \r\n unsigned long length, //text length in bytes \r\n const char *key, //pointer to the expanded key schedule \r\n int number_of_rounds) //number of AES rounds 10,12 or 14 \r\n { \r\n __m128i tmp; \r\n int i,j; \r\n if(length%16) \r\n length = length/16+1; \r\n else \r\n length = length/16; \r\n for(i=0; i < length; i++){ ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/b44f6806-c0a9-4c26-a6dd-96b071583455.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=94bc945267e13da52de12cdf24b3c2ff5c0e27982739dec7c998cdef6800f70a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 360
      },
      {
        "segments": [
          {
            "segment_id": "bcbc6cae-a78c-4701-8b9a-464362996961",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 29 \r\n tmp = _mm_loadu_si128 (&((__m128i*)in)[i]); \r\n tmp = _mm_xor_si128 (tmp,((__m128i*)key)[0]); \r\n for(j=1; j <number_of_rounds; j++){ \r\n tmp = _mm_aesenc_si128 (tmp,((__m128i*)key)[j]); \r\n } \r\n tmp = _mm_aesenclast_si128 (tmp,((__m128i*)key)[j]); \r\n _mm_storeu_si128 (&((__m128i*)out)[i],tmp); \r\n } \r\n } \r\nvoid AES_ECB_decrypt(const unsigned char *in, //pointer to the CIPHERTEXT \r\n unsigned char *out, //pointer to the DECRYPTED TEXT buffer \r\n unsigned long length, //text length in bytes \r\n const char *key, //pointer to the expanded key schedule \r\n int number_of_rounds) //number of AES rounds 10,12 or 14 \r\n { \r\n __m128i tmp; \r\n int i,j; \r\n if(length%16) \r\n length = length/16+1; \r\n else \r\n length = length/16; \r\n for(i=0; i < length; i++){ \r\n tmp = _mm_loadu_si128 (&((__m128i*)in)[i]); \r\n tmp = _mm_xor_si128 (tmp,((__m128i*)key)[0]); \r\n for(j=1; j <number_of_rounds; j++){ \r\n tmp = _mm_aesdec_si128 (tmp,((__m128i*)key)[j]); \r\n } \r\n tmp = _mm_aesdeclast_si128 (tmp,((__m128i*)key)[j]); \r\n _mm_storeu_si128 (&((__m128i*)out)[i],tmp); \r\n } \r\n } \r\nAES Encryption and Decryption in CBC Mode \r\nFigure 28. AES-128, AES-192 and AES-256 Encryption and Decryption in CBC Mode (C code) \r\n#include <wmmintrin.h> \r\nvoid AES_CBC_encrypt(const unsigned char *in, \r\n unsigned char *out, \r\n unsigned char ivec[16], \r\n unsigned long length, \r\n unsigned char *key, \r\n int number_of_rounds) \r\n { \r\n __m128i feedback,data; \r\n int i,j; \r\n if (length%16) \r\n length = length/16+1; \r\n else length /=16; \r\n feedback=_mm_loadu_si128 ((__m128i*)ivec); \r\n for(i=0; i < length; i++){ ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bcbc6cae-a78c-4701-8b9a-464362996961.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d88bcede294b6f3940d0fb7873b6542d1a95e2426af77ae6bc8cb59e5f1b9e9a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "902fb22a-9c5a-4c13-82c2-6c179280dfab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n30 323641-001 \r\n data = _mm_loadu_si128 (&((__m128i*)in)[i]); \r\n feedback = _mm_xor_si128 (data,feedback); \r\n feedback = _mm_xor_si128 (feedback,((__m128i*)key)[0]); \r\n for(j=1; j <number_of_rounds; j++) \r\n feedback = _mm_aesenc_si128 (feedback,((__m128i*)key)[j]); \r\n feedback = _mm_aesenclast_si128 (feedback,((__m128i*)key)[j]); \r\n _mm_storeu_si128 (&((__m128i*)out)[i],feedback); \r\n } \r\n } \r\nvoid AES_CBC_decrypt(const unsigned char *in, \r\n unsigned char *out, \r\n unsigned char ivec[16], \r\n unsigned long length, \r\n unsigned char *key, \r\n int number_of_rounds) \r\n { \r\n __m128i data,feedback,last_in; \r\n int i,j; \r\n if (length%16) \r\n length = length/16+1; \r\n else length /=16; \r\n feedback=_mm_loadu_si128 ((__m128i*)ivec); \r\n for(i=0; i < length; i++){ \r\n last_in=_mm_loadu_si128 (&((__m128i*)in)[i]); \r\n data = _mm_xor_si128 (last_in,((__m128i*)key)[0]); \r\n for(j=1; j <number_of_rounds; j++){ \r\n data = _mm_aesdec_si128 (data,((__m128i*)key)[j]); \r\n } \r\n data = _mm_aesdeclast_si128 (data,((__m128i*)key)[j]); \r\n data = _mm_xor_si128 (data,feedback); \r\n _mm_storeu_si128 (&((__m128i*)out)[i],data); \r\n feedback=last_in; \r\n } \r\n } \r\nAES in CTR Mode \r\nFigure 29. AES-128, AES-192 and AES-256 in CTR Mode (C code) \r\n#include <wmmintrin.h> \r\n#include <emmintrin.h> \r\n#include <smmintrin.h> \r\nvoid AES_CTR_encrypt (const unsigned char *in, \r\n unsigned char *out, \r\n const unsigned char ivec[8], \r\n const unsigned char nonce[4], \r\n unsigned long length, \r\n const unsigned char *key, \r\n int number_of_rounds) \r\n { \r\n __m128i ctr_block, tmp, ONE, BSWAP_EPI64; \r\n int i,j; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/902fb22a-9c5a-4c13-82c2-6c179280dfab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=099aa51321c96eeb373fb10d129c1b4e1433c03a90398e249c8900e4e3289674",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 343
      },
      {
        "segments": [
          {
            "segment_id": "41e6851c-b5a4-4acf-adc7-dab49891824d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 31 \r\n if (length%16) \r\n length = length/16 + 1; \r\n else length/=16; \r\n ONE = _mm_set_epi32(0,1,0,0); \r\n BSWAP_EPI64 = _mm_setr_epi8(7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8); \r\n ctr_block = _mm_insert_epi64(ctr_block, *(long long*)ivec, 1); \r\n ctr_block = _mm_insert_epi32(ctr_block, *(long*)nonce, 1); \r\n ctr_block = _mm_srli_si128(ctr_block, 4); \r\n ctr_block = _mm_shuffle_epi8(ctr_block, BSWAP_EPI64); \r\n ctr_block = _mm_add_epi64(ctr_block, ONE); \r\n for(i=0; i < length; i++){ \r\n tmp = _mm_shuffle_epi8(ctr_block, BSWAP_EPI64); \r\n ctr_block = _mm_add_epi64(ctr_block, ONE); \r\n tmp = _mm_xor_si128(tmp, ((__m128i*)key)[0]); \r\n for(j=1; j <number_of_rounds; j++) { \r\n tmp = _mm_aesenc_si128 (tmp, ((__m128i*)key)[j]); \r\n }; \r\n tmp = _mm_aesenclast_si128 (tmp, ((__m128i*)key)[j]); \r\n tmp = _mm_xor_si128(tmp,_mm_loadu_si128(&((__m128i*)in)[i])); \r\n _mm_storeu_si128 (&((__m128i*)out)[i],tmp); \r\n } \r\n } \r\nSoftware Flexibility and Miscellaneous Usage \r\nModels \r\nThe AES instructions are useful for many common cryptographic applications. They \r\nsupport all of the AES variants defined by FIPS197, including encryption and decryption \r\nwith the three standard key lengths, using the standard block size of 128 bits. The AES \r\ninstructions can also be used for all common uses of AES, including bulk encryption and \r\ndecryption using cipher modes such as CBC or CTR, data authentication using CBC\u0002MACs such as CMAC, random number generation using algorithms such as CTR-DRBG, \r\nand authenticated encryption using modes such as GCM. \r\nSoftware has the flexibility to pre-expand the keys and re-use them (which is the typical \r\nusage model for the PC platform) or to expand them on-the-fly. Such an example is \r\ngiven in a subsequenct section, below. We also provide examples for using the AES \r\ninstructions for other (non-AES) Rijndael variants, and to isolating the individual AES \r\ntransformations from the AES instructions. \r\nRijndael and other AES variants \r\nWe illustrate here the flexibility for software writers to use the AES instructions in some \r\nless common usage scenarios, such as Rijndael and related variants, and constructs that \r\nuse isolated AES components. \r\nWe note that modifying standard cryptographic algorithms is likely to introduce severe \r\nsecurity problems, and should be avoided. Therefore, the variants described here should ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/41e6851c-b5a4-4acf-adc7-dab49891824d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2a82530ccc88db1ce9c58c4e07acb7ac1e8428711606ba1e0c69b50a6306f3b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "c173bfff-11ce-4161-8f69-9743d6a4f45c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n32 323641-001 \r\nbe used only if they are standardized (or at least widely agreed to be useful and \r\nsecure). \r\nAccording to FIPS197 “This standard explicitly defines the allowed values for the key \r\nlength (Nk), block size (Nb), and number of rounds (Nr) [5]. However, future \r\nreaffirmations of this standard could include changes or additions to the allowed values \r\nfor those parameters. Therefore, implementers may choose to design their AES \r\nimplementations with future flexibility in mind.” \r\nHere, we consider the applicability of the AES instructions to such variants of AES. \r\nHereafter, we refer to the original Rijndael cipher, on which AES is based, as \r\n“RIJNDAEL”. \r\nChanging the number of rounds \r\nRIJNDAEL supports any number of rounds between 10 and 14, with the number of \r\nrounds chosen as a function of the key length and block size. Intel’s AES architecture is \r\ncompletely flexible to support these or any other number of rounds, simply by executing \r\nmore or fewer AESENC / AESDEC instructions and key scheduling instructions. \r\nChanging the key length or key schedule \r\nRIJNDAEL supports any key length which is a multiple of 32 bits ranging between 128 \r\nand 256 bits. The AES instructions can readily support such key lengths (and any \r\nothers) by simply executing more or fewer key scheduling steps. The \r\nAESKEYGENASSIST instruction can take any RCON value as the input’s immediate byte. \r\nFurthermore, since the instruction set decouples the round keys (and their generation) \r\nfrom their use in the AESENC, AESENCLAST, AESDEC, AESDECLAST instructions, it \r\nwould be easy to modify or replace the RIJNDAEL key schedule with a different \r\nvariation, while keeping the benefits of the round instructions. \r\nChanging the block size (e.g., RIJNDAEL-256) \r\nRIJNDAEL supports any block size which is a multiple of 32 bits, from 128 to 256 bits. \r\nWe explain here how the AES instructions can be used for supporting such block sizes. \r\nTo support RIJNDAEL with a block size larger than 128 bits, the RIJNDAEL state needs \r\nto be stored in two registers (if the block size is smaller than 256 bits, only part of the \r\nsecond register holds relevant data). For each round, bytes should be swapped between \r\nthe registers and then shuffled in order to to account for the the appropriate ShiftRows \r\ntransformation (which is different from the ShiftRows for AES). Following this, the AES \r\nround instructions can be applied, independently, to the registers that hold the parts of \r\nthe state. Due to the high parallelism of this sequence, the result should be efficient. \r\nFor example, consider a 256 bits block. Here, the RIJNDAEL state occupies two full xmm \r\nregisters, and the two halves of the round key need to be stored in two other xmm \r\nresgisters. The new AVX instruction VPBLENDVB can be used to swap 8 bytes between \r\nthese registers (and store the results in two new registers). Then, additional shuffling is \r\nrequired to account for the difference in ShiftRows between the 256 and 128-bit \r\nversions of RIJNDAEL. After this is done, the RIJNDAEL round can be computed by \r\napplying two AES round instruction, using the appropriate registers that hold the halves \r\nof the round key. \r\nFigure 30. Using the AES instructions to compute a 256-bit block size RINJDAEL round \r\n#include <wmmintrin.h> ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/c173bfff-11ce-4161-8f69-9743d6a4f45c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a0422363454a7153b880df7b764d0176e5a32f9331f356d3c52eefa7a130734f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 539
      },
      {
        "segments": [
          {
            "segment_id": "c173bfff-11ce-4161-8f69-9743d6a4f45c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n32 323641-001 \r\nbe used only if they are standardized (or at least widely agreed to be useful and \r\nsecure). \r\nAccording to FIPS197 “This standard explicitly defines the allowed values for the key \r\nlength (Nk), block size (Nb), and number of rounds (Nr) [5]. However, future \r\nreaffirmations of this standard could include changes or additions to the allowed values \r\nfor those parameters. Therefore, implementers may choose to design their AES \r\nimplementations with future flexibility in mind.” \r\nHere, we consider the applicability of the AES instructions to such variants of AES. \r\nHereafter, we refer to the original Rijndael cipher, on which AES is based, as \r\n“RIJNDAEL”. \r\nChanging the number of rounds \r\nRIJNDAEL supports any number of rounds between 10 and 14, with the number of \r\nrounds chosen as a function of the key length and block size. Intel’s AES architecture is \r\ncompletely flexible to support these or any other number of rounds, simply by executing \r\nmore or fewer AESENC / AESDEC instructions and key scheduling instructions. \r\nChanging the key length or key schedule \r\nRIJNDAEL supports any key length which is a multiple of 32 bits ranging between 128 \r\nand 256 bits. The AES instructions can readily support such key lengths (and any \r\nothers) by simply executing more or fewer key scheduling steps. The \r\nAESKEYGENASSIST instruction can take any RCON value as the input’s immediate byte. \r\nFurthermore, since the instruction set decouples the round keys (and their generation) \r\nfrom their use in the AESENC, AESENCLAST, AESDEC, AESDECLAST instructions, it \r\nwould be easy to modify or replace the RIJNDAEL key schedule with a different \r\nvariation, while keeping the benefits of the round instructions. \r\nChanging the block size (e.g., RIJNDAEL-256) \r\nRIJNDAEL supports any block size which is a multiple of 32 bits, from 128 to 256 bits. \r\nWe explain here how the AES instructions can be used for supporting such block sizes. \r\nTo support RIJNDAEL with a block size larger than 128 bits, the RIJNDAEL state needs \r\nto be stored in two registers (if the block size is smaller than 256 bits, only part of the \r\nsecond register holds relevant data). For each round, bytes should be swapped between \r\nthe registers and then shuffled in order to to account for the the appropriate ShiftRows \r\ntransformation (which is different from the ShiftRows for AES). Following this, the AES \r\nround instructions can be applied, independently, to the registers that hold the parts of \r\nthe state. Due to the high parallelism of this sequence, the result should be efficient. \r\nFor example, consider a 256 bits block. Here, the RIJNDAEL state occupies two full xmm \r\nregisters, and the two halves of the round key need to be stored in two other xmm \r\nresgisters. The new AVX instruction VPBLENDVB can be used to swap 8 bytes between \r\nthese registers (and store the results in two new registers). Then, additional shuffling is \r\nrequired to account for the difference in ShiftRows between the 256 and 128-bit \r\nversions of RIJNDAEL. After this is done, the RIJNDAEL round can be computed by \r\napplying two AES round instruction, using the appropriate registers that hold the halves \r\nof the round key. \r\nFigure 30. Using the AES instructions to compute a 256-bit block size RINJDAEL round \r\n#include <wmmintrin.h> ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/c173bfff-11ce-4161-8f69-9743d6a4f45c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a0422363454a7153b880df7b764d0176e5a32f9331f356d3c52eefa7a130734f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 539
      },
      {
        "segments": [
          {
            "segment_id": "21bd7613-69f1-4bb1-83ff-ba371b3e77b5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 33 \r\n#include <emmintrin.h> \r\n#include <smmintrin.h> \r\nvoid Rijndael256_encrypt (unsigned char *in, \r\n unsigned char *out, \r\n unsigned char *Key_Schedule, \r\n unsigned long long length, \r\n int number_of_rounds) \r\n { \r\n __m128i tmp1, tmp2, data1 ,data2; \r\n __m128i RIJNDAEL256_MASK = \r\n _mm_set_epi32(0x03020d0c, 0x0f0e0908, 0x0b0a0504, 0x07060100); \r\n __m128i BLEND_MASK= \r\n _mm_set_epi32(0x80000000, 0x80800000, 0x80800000, 0x80808000); \r\n __m128i *KS = (__m128i*)Key_Schedule; \r\n int i,j; \r\n for(i=0; i < length/32; i++) { /* loop over the data blocks */ \r\n data1 = _mm_loadu_si128(&((__m128i*)in)[i*2+0]); /* load data block */ \r\n data2 = _mm_loadu_si128(&((__m128i*)in)[i*2+1]); \r\n data1 = _mm_xor_si128(data1, KS[0]); /* round 0 (initial xor) */ \r\n data2 = _mm_xor_si128(data2, KS[1]); \r\n /* Do number_of_rounds-1 AES rounds */ \r\n for(j=1; j < number_of_rounds; j++) { \r\n /*Blend to compensate for the shift rows shifts bytes between two \r\n 128 bit blocks*/ \r\n tmp1 = _mm_blendv_epi8(data1, data2, BLEND_MASK); \r\n tmp2 = _mm_blendv_epi8(data2, data1, BLEND_MASK); \r\n /*Shuffle that compensates for the additional shift in rows 3 and 4 \r\n as opposed to rijndael128 (AES)*/ \r\n tmp1 = _mm_shuffle_epi8(tmp1, RIJNDAEL256_MASK); \r\n tmp2 = _mm_shuffle_epi8(tmp2, RIJNDAEL256_MASK); \r\n /*This is the encryption step that includes sub bytes, shift rows, \r\n mix columns, xor with round key*/ \r\n data1 = _mm_aesenc_si128(tmp1, KS[j*2]); \r\n data2 = _mm_aesenc_si128(tmp2, KS[j*2+1]); \r\n } \r\n tmp1 = _mm_blendv_epi8(data1, data2, BLEND_MASK); \r\n tmp2 = _mm_blendv_epi8(data2, data1, BLEND_MASK); \r\n tmp1 = _mm_shuffle_epi8(tmp1, RIJNDAEL256_MASK); \r\n tmp2 = _mm_shuffle_epi8(tmp2, RIJNDAEL256_MASK); \r\n tmp1 = _mm_aesenclast_si128(tmp1, KS[j*2+0]); /*last AES round */ \r\n tmp2 = _mm_aesenclast_si128(tmp2, KS[j*2+1]); \r\n _mm_storeu_si128(&((__m128i*)out)[i*2+0],tmp1); \r\n _mm_storeu_si128(&((__m128i*)out)[i*2+1],tmp2); \r\n } \r\n}\r\nIsolating the AES Transformations \r\nCipher designers may wish to build new cryptographic algorithms using components of \r\nAES. Such algorithms could benefit from the performance and side channel benefits of \r\nthe AES instructions if they are designed to use the AES transformations. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/21bd7613-69f1-4bb1-83ff-ba371b3e77b5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b7d090a1423771839c06851ef23d77b8afd0f3242a9d8c42e576df138a618ee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 256
      },
      {
        "segments": [
          {
            "segment_id": "98f81c9c-e119-494d-8b26-31f9e56c40ff",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n34 323641-001 \r\nIn particular, the AES transformations can be useful building blocks for hash functions. \r\nFor example, the use the MixColumns transformation provides rapid diffusion and the \r\nAES S-box is a good nonlinear mixer. Operating on large block sizes could be useful in \r\nconstructing hash functions with a long digest size. \r\nThis concept is already being used for constructing some of the new Secure Hash \r\nFunction algorithms that have been recently submitted to the NIST cryptographic hash \r\nAlgorithm Competition. Two candidate algorithms (namely, SHAvite-3, and ECHO) that \r\nuse the AES instrcution for achieving high performance survived in Round 2 of the \r\ncompetition. For details on the impact of the AES instructions on such hash algorithms, \r\nsee “The Intel AES Instructions Set and the SHA-3 Candidates” (by R. Benadjila, O. \r\nBillet, S. Gueron. M. Robshaw) in Lecture Notes in Computer Science - Proceedings of \r\nAsiacrypt 2009, 5665:51-66 (2009). \r\nWe show here how combinations of the AES instructions can isolate the AES \r\ntransformations. \r\nFigure 31. Isolating the AES Transformations with Combinations of AES Instructions \r\nIsolating ShiftRows \r\n PSHUFB xmm0, 0x0b06010c07020d08030e09040f0a0500 \r\nIsolating InvShiftRows \r\n PSHUFB xmm0, 0x0306090c0f0205080b0e0104070a0d00 \r\nIsolating MixColumns \r\n AESDECLAST xmm0, 0x00000000000000000000000000000000 \r\n AESENC xmm0, 0x00000000000000000000000000000000 \r\nIsolating InvMixColumns \r\n AESENCLAST xmm0, 0x00000000000000000000000000000000 \r\n AESDEC xmm0, 0x00000000000000000000000000000000 \r\nIsolating SubBytes \r\n PSHUFB xmm0, 0x0306090c0f0205080b0e0104070a0d00 \r\n AESENCLAST xmm0, 0x00000000000000000000000000000000 \r\nIsolating InvSubBytes \r\n PSHUFB xmm0, 0x0b06010c07020d08030e09040f0a0500 \r\n AESDECLAST xmm0, 0x00000000000000000000000000000000 \r\nThe following code demonstrates show how the AES transformations can be isolated. \r\nFigure 32. Isolating the AES Transformations (C Code) \r\n#include <stdio.h> \r\n#include <wmmintrin.h> \r\n#include <smmintrin.h> \r\nvoid print_m128i_with_string(char* string,__m128i data) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<16; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\n/*****************************************************************************/ \r\nint main () \r\n { \r\n __m128i ZERO = _mm_setzero_si128(); \r\n __m128i ISOLATE_SROWS_MASK = ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/98f81c9c-e119-494d-8b26-31f9e56c40ff.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be960f4ee1e9591c3db5578c5c2d8928275668b3808ba9ea64106c965ad3a5f7",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "60756f83-c1ed-46ab-9671-87f8fe79691b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 35 \r\n _mm_set_epi32(0x0B06010C, 0x07020D08, 0x030E0904, 0x0F0A0500); \r\n __m128i ISOLATE_SBOX_MASK = \r\n _mm_set_epi32(0x0306090C, 0x0F020508, 0x0B0E0104, 0x070A0D00); \r\n __m128i Round_Key_0 = \r\n _mm_set_epi32(0x0f0e0d0c, 0x0b0a0908, 0x07060504, 0x03020100); \r\n __m128i Round_Key_1 = \r\n _mm_set_epi32(0xfe76abd6, 0xf178a6da, 0xfa72afd2, 0xfd74aad6); \r\n __m128i DATA = \r\n _mm_set_epi32(0xffeeddcc, 0xbbaa9988, 0x77665544, 0x33221100); \r\n __m128i temp1,temp2; \r\n printf (\"Demonstrating the exposed transformations: \\n\"); \r\n print_m128i_with_string(\"DATA:\", DATA); \r\n print_m128i_with_string(\"Round Key 0:\", Round_Key_0); \r\n temp1 = _mm_xor_si128(DATA, Round_Key_0); /* Round 0*/ \r\n print_m128i_with_string(\"After Round 0:\", temp1); \r\n print_m128i_with_string(\"Round Key 1:\", Round_Key_1); \r\n/* A \"decomposed\" encryption round, built from the individual transformations*/ \r\n temp2 = _mm_shuffle_epi8(temp1, ISOLATE_SROWS_MASK);/* isolate ShiftRows */ \r\n print_m128i_with_string(\"After ShiftRows:\", temp2); \r\n temp2 = _mm_shuffle_epi8(temp2, ISOLATE_SBOX_MASK); /* isolate SubBytes */ \r\n temp2 = _mm_aesenclast_si128(temp2, ZERO); \r\n print_m128i_with_string(\"After SubBytes:\", temp2); \r\n temp2 = _mm_aesdeclast_si128(temp2, ZERO); /* isolate MixColumns */ \r\n temp2 = _mm_aesenc_si128(temp2, ZERO); \r\n print_m128i_with_string(\"After MixColumns:\", temp2); \r\n temp2 = _mm_xor_si128(temp2, Round_Key_1); /* isolate AddRoundKey */ \r\n print_m128i_with_string(\"After AddRoundKey:\", temp2); \r\n temp1 = _mm_aesenc_si128(temp1, Round_Key_1);/* round 1 using instruction*/ \r\n \r\n printf(\"\\n\"); \r\n print_m128i_with_string(\"AES Round using exposed transformations:\", temp2); \r\n print_m128i_with_string(\"AES round using AESENC instruction:\", temp1); \r\n printf(\"\\n\"); \r\n printf (\"Going backwards using exposed inverse transformations: \\n\"); \r\n temp2 = _mm_xor_si128(temp2, Round_Key_1); /* Going Bakwards */ \r\n print_m128i_with_string(\"After InvAddRoundKey:\", temp2); \r\n temp2 = _mm_aesenclast_si128(temp2, ZERO); \r\n temp2 = _mm_aesdec_si128(temp2, ZERO); \r\n print_m128i_with_string(\"After InvMixColumns:\", temp2); \r\n temp2 = _mm_shuffle_epi8(temp2, ISOLATE_SROWS_MASK); ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/60756f83-c1ed-46ab-9671-87f8fe79691b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6864b488b679c8b76c991dc7c5c3a1054381c8894fc71369ef34f0990bca59fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 469
      },
      {
        "segments": [
          {
            "segment_id": "7595a363-63a8-4b42-a971-3723f28a3cc0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n36 323641-001 \r\n temp2 = _mm_aesdeclast_si128(temp2, ZERO); \r\n print_m128i_with_string(\"After InvSubBytes:\", temp2); \r\n temp2 = _mm_shuffle_epi8(temp2, ISOLATE_SBOX_MASK); \r\n print_m128i_with_string(\"After InvShiftRows:\", temp2); \r\n temp2 = _mm_xor_si128(temp2, Round_Key_0); \r\n print_m128i_with_string(\"Final:\", temp2); \r\n printf (\"Returned to initial state. \\n\"); \r\n } \r\nFigure 33. Isolating the AES Transformations – Code Results \r\nDemonstrating the exposed transformations: \r\nDATA: [0x00112233445566778899aabbccddeeff] \r\nRound Key 0: [0x000102030405060708090a0b0c0d0e0f] \r\nAfter Round 0: [0x00102030405060708090a0b0c0d0e0f0] \r\nRound Key 1: [0xd6aa74fdd2af72fadaa678f1d6ab76fe] \r\nAfter ShiftRows: [0x0050a0f04090e03080d02070c01060b0] \r\nAfter SubBytes: [0x6353e08c0960e104cd70b751bacad0e7] \r\nAfter MixColumns: [0x5f72641557f5bc92f7be3b291db9f91a] \r\nAfter AddRoundKey: [0x89d810e8855ace682d1843d8cb128fe4] \r\nAES Round using exposed transformations:[0x89d810e8855ace682d1843d8cb128fe4] \r\nAES round using AESENC instruction: [0x89d810e8855ace682d1843d8cb128fe4] \r\nGoing backwards using exposed inverse transformations: \r\nAfter InvAddRoundKey: [0x5f72641557f5bc92f7be3b291db9f91a] \r\nAfter InvMixColumns: [0x6353e08c0960e104cd70b751bacad0e7] \r\nAfter InvSubBytes: [0x0050a0f04090e03080d02070c01060b0] \r\nAfter InvShiftRows: [0x00102030405060708090a0b0c0d0e0f0] \r\nFinal: [0x00112233445566778899aabbccddeeff] \r\nReturned to initial state. \r\nOn-the-Fly Key Expansion \r\nThe following two examples illustrate AES-128 encryption and decryption with on-the-fly \r\nkey expansion. The input key for the encryption is the cipher key. For the decryption, \r\nthe input key is the last round key (number 10 in this example). This example also \r\ndemonstrates the use of a combination of instrcutions to isolate AES transofrmations. \r\nHere, the AES SBox is isolated and the key expansion is carried out without using the \r\nAESKEYGENASSIST instruction. \r\nFigure 34. AES128-ECB Encryption with On-the-Fly Key Expansion \r\n#include <wmmintrin.h> \r\n#include <smmintrin.h> \r\n//unsigned char *userkey points to the cipher key \r\n//unsigned char *data points to 16 bytes of data to be encrypted \r\nvoid AES_128_ENCRYPT_on_the_fly (const unsigned char *userkey, \r\n const unsigned char *data) \r\n { ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/7595a363-63a8-4b42-a971-3723f28a3cc0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2e6db3235fc1b934b798d8b2ef212320f771adbf4e253f399f700237e21b4c44",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8daa1c59-85cb-4125-9faf-d9b424c056c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 37 \r\n __m128i temp1, temp2, temp3; \r\n __m128i block; \r\n __m128i shuffle_mask = \r\n _mm_set_epi32(0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d); \r\n __m128i rcon; \r\n int i; \r\n block = _mm_loadu_si128((__m128i*)&data[0]); \r\n temp1 = _mm_loadu_si128((__m128i*)userkey); \r\n rcon = _mm_set_epi32(1,1,1,1); \r\n block = _mm_xor_si128(block, temp1); \r\n for (i=1; i<=8; i++){ \r\n temp2 = _mm_shuffle_epi8(temp1, shuffle_mask); \r\n temp2 = _mm_aesenclast_si128 (temp2,rcon); \r\n rcon = _mm_slli_epi32(rcon,1); \r\n temp3 = _mm_slli_si128 (temp1, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp1 = _mm_xor_si128 (temp1, temp2); \r\n block = _mm_aesenc_si128 (block, temp1); \r\n } \r\n rcon = _mm_set_epi32(0x1b,0x1b,0x1b,0x1b); \r\n temp2 = _mm_shuffle_epi8(temp1, shuffle_mask); \r\n temp2 = _mm_aesenclast_si128 (temp2,rcon); \r\n rcon = _mm_slli_epi32(rcon,1); \r\n temp3 = _mm_slli_si128 (temp1, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp1 = _mm_xor_si128 (temp1, temp2); \r\n block = _mm_aesenc_si128 (block, temp1); \r\n temp2 = _mm_shuffle_epi8(temp1, shuffle_mask); \r\n temp2 = _mm_aesenclast_si128 (temp2,rcon); \r\n temp3 = _mm_slli_si128 (temp1, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp3 = _mm_slli_si128 (temp3, 0x4); \r\n temp1 = _mm_xor_si128 (temp1, temp3); \r\n temp1 = _mm_xor_si128 (temp1, temp2); \r\n block = _mm_aesenclast_si128 (block, temp1); \r\n _mm_storeu_si128((__m128i*)&data[0] ,block); \r\n } ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/8daa1c59-85cb-4125-9faf-d9b424c056c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=00f7421da0b5da0981ec1d7086ed75acb67f91ab7349bc5966447b48532615df",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 427
      },
      {
        "segments": [
          {
            "segment_id": "a8851b94-80a1-41a3-beaf-385245ec8d6a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n38 323641-001 \r\nFigure 35. AES128-ECB Decryption with On-the-Fly Key Expansion \r\n#include <wmmintrin.h> \r\n#include <smmintrin.h> \r\n//unsigned char *userkey points to the last key of the encrypt key schedule \r\n//unsigned char *data points to 16 bytes of data to be encrypted \r\nvoid AES_128_DECRYPT_on_the_fly (const unsigned char *userkey, \r\n const unsigned char *data) \r\n { \r\n __m128i temp1, temp2, temp3, temp4; \r\n int mask = 0x0c0f0e0d; \r\n int con1 = 0x80, con2 = 0x36; \r\n __m128i shuffle_mask = \r\n _mm_set_epi32(0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d); \r\n __m128i rcon; \r\n __m128i block; \r\n int i; \r\n rcon = _mm_set_epi32(0x1b,0x1b,0x1b,0x1b); \r\n temp1 = _mm_loadu_si128((__m128i*)userkey); \r\n block = _mm_loadu_si128((__m128i*)&data[0]); \r\n block = _mm_xor_si128(block, temp1); \r\n for (i=1; i<=2; i++){ \r\n temp2 = _mm_slli_si128(temp1 , 4); \r\n temp2 = _mm_xor_si128(temp1, temp2); \r\n temp3 = _mm_shuffle_epi8(temp2, shuffle_mask); \r\n temp3 = _mm_aesenclast_si128 (temp3,rcon); \r\n temp1 = _mm_xor_si128(temp1,temp3); \r\n temp1 = (__m128i)_mm_blend_ps((__m128)temp1, (__m128)temp2, 14); \r\n temp2 = _mm_aesimc_si128(temp1); \r\n rcon = _mm_srli_epi32(rcon,1); \r\n block = _mm_aesdec_si128 (block, temp2); \r\n } \r\n rcon = _mm_set_epi32(1,1,1,1); \r\n for (i=3; i<10; i++){ \r\n temp2 = _mm_slli_si128(temp1 , 4); \r\n temp2 = _mm_xor_si128(temp1, temp2); \r\n temp3 = _mm_shuffle_epi8(temp2, shuffle_mask); \r\n temp3 = _mm_aesenclast_si128 (temp3,rcon); \r\n temp1 = _mm_xor_si128(temp1,temp3); \r\n temp1 = (__m128i)_mm_blend_ps((__m128)temp1, (__m128)temp2, 14); \r\n temp2 = _mm_aesimc_si128(temp1); \r\n rcon = _mm_srli_epi32(rcon,1); \r\n block = _mm_aesdec_si128 (block, temp2); \r\n } \r\n temp2 = _mm_slli_si128(temp1 , 4); \r\n temp2 = _mm_xor_si128(temp1, temp2); \r\n temp3 = _mm_shuffle_epi8(temp2, shuffle_mask); \r\n temp3 = _mm_aesenclast_si128 (temp3,rcon); \r\n temp1 = _mm_xor_si128(temp1,temp3); \r\n temp1 = (__m128i)_mm_blend_ps((__m128)temp1, (__m128)temp2, 14); \r\n block = _mm_aesdeclast_si128 (block, temp1); \r\n _mm_storeu_si128((__m128i*)&data[0] ,block); ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/a8851b94-80a1-41a3-beaf-385245ec8d6a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=08cf95e2ac6f5bed75e621d2d04e2e69d6e7b080f44d63500a97e89f16412814",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 214
      },
      {
        "segments": [
          {
            "segment_id": "ede1a410-f9d5-45af-a007-c51623def187",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 39 \r\n } \r\nPerformance and Performance Optimization \r\nGuidelines \r\nExpected Performance for Encryption and Decryption \r\nThe AES instructions provide a substantial performance speedup to bulk data \r\nencryption and decryption. When using parallelizable modes of operation, such as CBC \r\ndecryption, CTR, and CTR-derived modes (GCM), XTS. The performance speedup could \r\nexceed an order of magnitude over software-only, lookup tables based AES \r\nimplementations. In scenarios where pipelined operation is impossible, for example in \r\nCBC encryption, the performance speedup would still be significant, around 2 to 3 times \r\nover (unprotected) software implementation. \r\nThe Relative Cost of the Key Expansion \r\nThe AES architecture is optimized for security and performance in applications where \r\nmany block encryptions are performed with the same key (e.g., disk or network \r\nencryption). For example, Microsoft’s Bitlocker disk encryption application uses a single \r\nkey for the whole volume. In these applications, the cost of the key expansion is \r\namortized over many blocks, making the overhead of the key expansion marginal from \r\nthe performance perspective. \r\nSome less frequent applications require frequent key scheduling. For example, some \r\nrandom number generators may rekey frequently to achieve forward secrecy. One \r\nextreme example is a Davies-Meyer hashing construction, which uses a block cipher \r\nprimitive as a compression function, and the cipher is re-keyed for each processed data \r\nblock. \r\nAlthough these are not the mainstream usage models of the AES instructions, we point \r\nout that the AESKEYGENASSIST and AESIMC instructions facilitate Key Expansion \r\nprocedure which is lookup tables free, and faster than software only key expansion. In \r\naddition, we point out that unrolling of the key expansion code, which is provided in the \r\nprevious sections, improves the key expansion performance. The AES256 case can also \r\nutilize the instruction AESENCLAST, for the sbox transformation, that is faster than \r\nusing AESKEYGENASSIST. \r\nOptimizing AES Software for Enhanced Performance in \r\nParallel Modes of Operation \r\nPerhaps the most significant performance optimization for encryptio/decryption using \r\nthe AES instructions can be achieved by re-ordering the computations. This helps take \r\nbetter advantage of parallelism in parallel modes of operation such as ECB, CTR, and \r\nCBC-Decrypt (with the CBC-Encrypt serial mode being an exception). This section \r\nexplains how it can be done. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/ede1a410-f9d5-45af-a007-c51623def187.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=366a464024fa9d7cf6de4b3b2b1e66eb87c238971d7c8a0503f35d5d294ebb2a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 363
      },
      {
        "segments": [
          {
            "segment_id": "ed0890e5-5e02-4f6f-9a59-4aa1e7f114bf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n40 323641-001 \r\nThe hardware that supports the four AES round instructions is pipelined. This allows \r\nindependent AES instructions to be dispatched theoretically every 1-2 CPU clock cycle \r\n(depending on the micro architectural implementation), if data can be provided \r\nsufficiently fast. As a result, the AES throughput can be significantly enhanced for \r\nparallel modes of operation, if the “order of the loop” is reversed: instead of completing \r\nthe encryption of one data block and then continuing to the subsequent block, it is \r\npreferable to write software sequences that compute one AES round on multiple blocks, \r\nusing one Round Key, and only then continue to computing the subsequent round on for \r\nmultiple blocks (using another round key). For such software optimization, one needs to \r\nchoose the number of blocks that will be processed in parallel. This optimal \r\nparallelization parameter value depends on the scenario, for example on how many \r\nregisters are available, and how many data blocks are to be (typically) processed. \r\nExcessive pipelining does not provide performance benefit, and it also consumes \r\nregisters that can be used for other purposes. Therefore, the tradeoff should be \r\nassessed by the developers depending on the application and the optimization targets. \r\nIn general, we recommend processing 4 or 8 blocks in parallel, to for optimized \r\nthroughput. The speedup that can be gained is significant. For cases where the size, in \r\nblocks, of the processed buffer is not divisible by 4 (or by 8), the remainder blocks need \r\nto be handled separately. \r\nIn the following, we offer two examples. The first one is a function (C code snippet) that \r\nillustrates CBC decryption of 4 data blocks (the complete code was provided in the \r\nprevious examples, and can be run with the proper choice of the #define PARALLEL). The \r\nsecond example is a C code function that encrypts 8 blocks in parallel, using ECB mode \r\n(the complete code was provided in the previous examples, and can be run with the \r\nproper choice of #define EIGHT_BLOCKS). \r\nFigure 36. Parallelizing CBC Decrypt Function 4 Blocks at a Time \r\n#include <wmmintrin.h> \r\nvoid AES_CBC_decrypt_parallelize_4_blocks(const unsigned char *in, \r\n unsigned char *out, \r\n unsigned char ivec[16], \r\n unsigned long length, \r\n unsigned char *key_schedule, \r\n unsigned int nr) \r\n { \r\n __m128i data1,data2,data3,data4; \r\n __m128i feedback1,feedback2,feedback3,feedback4,last_in; \r\n int i,j; \r\n if (length%16) \r\n length = length/16 + 1; \r\n else length/=16; \r\n feedback1=_mm_loadu_si128 ((__m128i*)ivec); \r\n for(i=0; i < length/4; i++){ \r\n data1=_mm_loadu_si128 (&((__m128i*)in)[i*4+0]); \r\n data2=_mm_loadu_si128 (&((__m128i*)in)[i*4+1]); \r\n data3=_mm_loadu_si128 (&((__m128i*)in)[i*4+2]); \r\n data4=_mm_loadu_si128 (&((__m128i*)in)[i*4+3]); \r\n feedback2=data1; \r\n feedback3=data2; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/ed0890e5-5e02-4f6f-9a59-4aa1e7f114bf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c0c1de8ee164c50c0854382da7496a9641027f82c1506feacc5e1b613e78187b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 402
      },
      {
        "segments": [
          {
            "segment_id": "aeeadc87-8672-4ed5-966b-93bef2098770",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 41 \r\n feedback4=data3; \r\n last_in=data4; \r\n data1 = _mm_xor_si128 (data1,((__m128i*)key_schedule)[0]); \r\n data2 = _mm_xor_si128 (data2,((__m128i*)key_schedule)[0]); \r\n data3 = _mm_xor_si128 (data3,((__m128i*)key_schedule)[0]); \r\n data4 = _mm_xor_si128 (data4,((__m128i*)key_schedule)[0]); \r\n \r\n for(j=1; j < nr; j++){ \r\n data1 = _mm_aesdec_si128 (data1,((__m128i*)key_schedule)[j]); \r\n data2 = _mm_aesdec_si128 (data2,((__m128i*)key_schedule)[j]); \r\n data3 = _mm_aesdec_si128 (data3,((__m128i*)key_schedule)[j]); \r\n data4 = _mm_aesdec_si128 (data4,((__m128i*)key_schedule)[j]); \r\n } \r\n data1 = _mm_aesdeclast_si128 (data1,((__m128i*)key_schedule)[j]); \r\n data2 = _mm_aesdeclast_si128 (data2,((__m128i*)key_schedule)[j]); \r\n data3 = _mm_aesdeclast_si128 (data3,((__m128i*)key_schedule)[j]); \r\n data4 = _mm_aesdeclast_si128 (data4,((__m128i*)key_schedule)[j]); \r\n data1 = _mm_xor_si128 (data1,feedback1); \r\n data2 = _mm_xor_si128 (data2,feedback2); \r\n data3 = _mm_xor_si128 (data3,feedback3); \r\n data4 = _mm_xor_si128 (data4,feedback4); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+0],data1); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+1],data2); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+2],data3); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+3],data4); \r\n feedback1=last_in; \r\n } \r\n for(j=i*4; j < length; j++){ \r\n data1=_mm_loadu_si128 (&((__m128i*)in)[j]); \r\n last_in=data1; \r\n data1 = _mm_xor_si128 (data1,((__m128i*)key_schedule)[0]); \r\n for(i=1; i < nr; i++){ \r\n data1 = _mm_aesdec_si128 (data1,((__m128i*)key_schedule)[i]); \r\n } \r\n data1 = _mm_aesdeclast_si128 (data1,((__m128i*)key_schedule)[i]); \r\n data1 = _mm_xor_si128 (data1,feedback1); \r\n _mm_storeu_si128 (&((__m128i*)out)[j],data1); \r\n feedback1=last_in; \r\n } \r\n } \r\nFigure 37.CBC Encrypt Four Buffers in Parallel – C function \r\n#include <wmmintrin.h> \r\nvoid AES_CBC_encrypt_parallelize_4_blocks(const unsigned char *in, \r\n unsigned char *out, \r\n unsigned char ivec1[16], \r\n unsigned char ivec2[16], \r\n unsigned char ivec3[16], \r\n unsigned char ivec4[16], \r\n unsigned long length, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/aeeadc87-8672-4ed5-966b-93bef2098770.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c8322c9c7f4b78e156a410780343af8c7a71ef93cfe74200a3507695800bfbcd",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "989d9bc9-6fc7-4f54-aeee-73baba6125bd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n42 323641-001 \r\n const unsigned char *key, \r\n int nr) \r\n { \r\n __m128i feedback1,feedback2,feedback3,feedback4; \r\n __m128i data1,data2,data3,data4; \r\n int i,j; \r\n feedback1=_mm_loadu_si128 ((__m128i*)ivec1); \r\n feedback2=_mm_loadu_si128 ((__m128i*)ivec2); \r\n feedback3=_mm_loadu_si128 ((__m128i*)ivec3); \r\n feedback4=_mm_loadu_si128 ((__m128i*)ivec4); \r\n for(i=0; i < length/16/4; i++){ \r\n data1 = _mm_loadu_si128 (&((__m128i*)in)[i*4+0]); \r\n data2 = _mm_loadu_si128 (&((__m128i*)in)[i*4+1]); \r\n data3 = _mm_loadu_si128 (&((__m128i*)in)[i*4+2]); \r\n data4 = _mm_loadu_si128 (&((__m128i*)in)[i*4+3]); \r\n feedback1 = _mm_xor_si128 (data1,feedback1); \r\n feedback2 = _mm_xor_si128 (data2,feedback2); \r\n feedback3 = _mm_xor_si128 (data3,feedback3); \r\n feedback4 = _mm_xor_si128 (data4,feedback4); \r\n feedback1 = _mm_xor_si128 (feedback1,((__m128i*)key)[0]); \r\n feedback2 = _mm_xor_si128 (feedback2,((__m128i*)key)[0]); \r\n feedback3 = _mm_xor_si128 (feedback3,((__m128i*)key)[0]); \r\n feedback4 = _mm_xor_si128 (feedback4,((__m128i*)key)[0]); \r\n \r\n for(j=1; j <nr; j++){ \r\n feedback1 = _mm_aesenc_si128 (feedback1,((__m128i*)key)[j]); \r\n feedback2 = _mm_aesenc_si128 (feedback2,((__m128i*)key)[j]); \r\n feedback3 = _mm_aesenc_si128 (feedback3,((__m128i*)key)[j]); \r\n feedback4 = _mm_aesenc_si128 (feedback4,((__m128i*)key)[j]); \r\n } \r\n feedback1 = _mm_aesenclast_si128 (feedback1,((__m128i*)key)[j]); \r\n feedback2 = _mm_aesenclast_si128 (feedback2,((__m128i*)key)[j]); \r\n feedback3 = _mm_aesenclast_si128 (feedback3,((__m128i*)key)[j]); \r\n feedback4 = _mm_aesenclast_si128 (feedback4,((__m128i*)key)[j]); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+0],feedback1); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+1],feedback2); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+2],feedback3); \r\n _mm_storeu_si128 (&((__m128i*)out)[i*4+3],feedback4); \r\n } \r\n } \r\nAn AES Library \r\nThis chapter provides high performance functions, written in assembly (AT&T syntax), \r\nimplementing AES-128, AES-192, AES-256 in ECB, CBC, and CTR modes. A separate \r\nsection provides test functions that can be used for generating executables that can be \r\nrun and measured for performance. The outputs of the test runs are also provided \r\nbelow. These functions have a very similar or identical interface to that of OpenSSL (as \r\nexplained above). ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/989d9bc9-6fc7-4f54-aeee-73baba6125bd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a629d643175f6b784eb45eef5827c51868b216af92f0d9796e95d05774fc13a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 364
      },
      {
        "segments": [
          {
            "segment_id": "75553727-e593-4fba-8604-9097ebd1df7a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 43 \r\nKey Expansion \r\nFigure 38. Unrolled Key Expansion Decrypt using InvMixColumns \r\n//void AES_Key_Expansion_Decrypt(const unsigned char *encrypt_schedule, \r\n// unsigned char *decrypt_schedule, \r\n// int number_of_rounds) \r\n.align 16,0x90 \r\n.globl AES_Key_Expansion_Decrypt \r\nAES_Key_Expansion_Decrypt: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %edx \r\n movslq %edx, %rdx \r\n movq %rdx, %rax \r\n shlq $4, %rax \r\n cmpq $10, %rdx \r\n movdqa (%rax,%rdi), %xmm0 \r\n movdqa %xmm0, (%rsi) \r\n \r\n aesimc -16(%rax,%rdi), %xmm1 \r\n aesimc -32(%rax,%rdi), %xmm2 \r\n aesimc -48(%rax,%rdi), %xmm3 \r\n aesimc -64(%rax,%rdi), %xmm4 \r\n movdqa %xmm1, 16(%rsi) \r\n movdqa %xmm2, 32(%rsi) \r\n movdqa %xmm3, 48(%rsi) \r\n movdqa %xmm4, 64(%rsi) \r\n \r\n aesimc -80(%rax,%rdi), %xmm5 \r\n aesimc -96(%rax,%rdi), %xmm6 \r\n aesimc -112(%rax,%rdi), %xmm7 \r\n aesimc -128(%rax,%rdi), %xmm8 \r\n movdqa %xmm5, 80(%rsi) \r\n movdqa %xmm6, 96(%rsi) \r\n movdqa %xmm7, 112(%rsi) \r\n movdqa %xmm8, 128(%rsi) \r\n \r\n aesimc -144(%rax,%rdi), %xmm9 \r\n movdqa %xmm9, 144(%rsi) \r\n \r\n jle END_DEC \r\n cmpq $12, %rdx \r\n \r\n aesimc -160(%rax,%rdi), %xmm0 \r\n aesimc -176(%rax,%rdi), %xmm1 \r\n movdqa %xmm0, 160(%rsi) \r\n movdqa %xmm1, 176(%rsi) \r\n jle END_DEC \r\n aesimc -192(%rax,%rdi), %xmm0 \r\n aesimc -208(%rax,%rdi), %xmm1 \r\n movdqa %xmm0, 192(%rsi) \r\n movdqa %xmm1, 208(%rsi) \r\n \r\nEND_DEC: \r\n movdqa (%rdi), %xmm0 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/75553727-e593-4fba-8604-9097ebd1df7a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec10f445a41122315e0c70dc68638e3cca36cd80e999a29ec43fbdc09dd9986a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7f26ee0a-6f26-49d8-986b-ba78733c1bb4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n44 323641-001 \r\n movdqa %xmm0, (%rax,%rsi) \r\n ret \r\nFigure 39. AES-128 Key Expansion: Assembly Code \r\n//void AES_128_Key_Expansion(const unsigned char* userkey, \r\n// unsigned char* key_schedule); \r\n.align 16,0x90 \r\n.globl AES_128_Key_Expansion \r\nAES_128_Key_Expansion: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n movl $10, 240(%rsi) \r\n movdqu (%rdi), %xmm1 \r\n movdqa %xmm1, (%rsi) \r\n \r\nASSISTS: \r\n aeskeygenassist $1, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 16(%rsi) \r\n aeskeygenassist $2, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 32(%rsi) \r\n aeskeygenassist $4, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 48(%rsi) \r\n aeskeygenassist $8, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 64(%rsi) \r\n aeskeygenassist $16, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 80(%rsi) \r\n aeskeygenassist $32, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 96(%rsi) \r\n aeskeygenassist $64, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 112(%rsi) \r\n aeskeygenassist $0x80, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 128(%rsi) \r\n aeskeygenassist $0x1b, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 144(%rsi) \r\n aeskeygenassist $0x36, %xmm1, %xmm2 \r\n call PREPARE_ROUNDKEY_128 \r\n movdqa %xmm1, 160(%rsi) \r\n ret \r\n \r\nPREPARE_ROUNDKEY_128: \r\n pshufd $255, %xmm2, %xmm2 \r\n movdqa %xmm1, %xmm3 \r\n pslldq $4, %xmm3 \r\n pxor %xmm3, %xmm1 \r\n pslldq $4, %xmm3 \r\n pxor %xmm3, %xmm1 \r\n pslldq $4, %xmm3 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/7f26ee0a-6f26-49d8-986b-ba78733c1bb4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8a63bb3aa23f5ef39c64c673022e79ec17f84812d0e20050bcd1ec768e70efbc",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "97949974-e4d7-45df-9a02-e3d2e3e83c86",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 45 \r\n pxor %xmm3, %xmm1 \r\n pxor %xmm2, %xmm1 \r\n ret \r\nFigure 40. AES-192 Key Expansion: Assembly Code \r\n//void AES_192_Key_Expansion (const unsigned char *userkey, \r\n// unsigned char *key) \r\n.globl AES_192_Key_Expansion \r\nAES_192_Key_Expansion: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n movdqu (%rdi), %xmm1 \r\n movdqu 16(%rdi), %xmm3 \r\n movdqa %xmm1, (%rsi) \r\n movdqa %xmm3, %xmm5 \r\n \r\n aeskeygenassist $0x1, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n shufpd $0, %xmm1, %xmm5 \r\n movdqa %xmm5, 16(%rsi) \r\n movdqa %xmm1, %xmm6 \r\n shufpd $1, %xmm3, %xmm6 \r\n movdqa %xmm6, 32(%rsi) \r\n \r\n aeskeygenassist $0x2, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n movdqa %xmm1, 48(%rsi) \r\n movdqa %xmm3, %xmm5 \r\n \r\n aeskeygenassist $0x4, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n shufpd $0, %xmm1, %xmm5 \r\n movdqa %xmm5, 64(%rsi) \r\n movdqa %xmm1, %xmm6 \r\n shufpd $1, %xmm3, %xmm6 \r\n movdqa %xmm6, 80(%rsi) \r\n \r\n aeskeygenassist $0x8, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n movdqa %xmm1, 96(%rsi) \r\n movdqa %xmm3, %xmm5 \r\n \r\n aeskeygenassist $0x10, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n shufpd $0, %xmm1, %xmm5 \r\n movdqa %xmm5, 112(%rsi) \r\n movdqa %xmm1, %xmm6 \r\n shufpd $1, %xmm3, %xmm6 \r\n movdqa %xmm6, 128(%rsi) \r\n \r\n aeskeygenassist $0x20, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n movdqa %xmm1, 144(%rsi) \r\n movdqa %xmm3, %xmm5 \r\n \r\n aeskeygenassist $0x40, %xmm3, %xmm2 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/97949974-e4d7-45df-9a02-e3d2e3e83c86.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=638925893c8fb99b56203a472e7205c94ac3499e02538ad2f4a39dfecd357a86",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 489
      },
      {
        "segments": [
          {
            "segment_id": "577b4b44-8d56-4ab4-9288-53639fcfa2b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n46 323641-001 \r\n call PREPARE_ROUNDKEY_192 \r\n shufpd $0, %xmm1, %xmm5 \r\n movdqa %xmm5, 160(%rsi) \r\n movdqa %xmm1, %xmm6 \r\n shufpd $1, %xmm3, %xmm6 \r\n movdqa %xmm6, 176(%rsi) \r\n \r\n aeskeygenassist $0x80, %xmm3, %xmm2 \r\n call PREPARE_ROUNDKEY_192 \r\n movdqa %xmm1, 192(%rsi) \r\n ret \r\n \r\nPREPARE_ROUNDKEY_192: \r\n pshufd $0x55, %xmm2, %xmm2 \r\n movdqu %xmm1, %xmm4 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pxor %xmm2, %xmm1 \r\n pshufd $0xff, %xmm1, %xmm2 \r\n movdqu %xmm3, %xmm4 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm3 \r\n pxor %xmm2, %xmm3 \r\n ret \r\nFigure 41. AES-256 Key Expansion: Assembly Code \r\n//void AES_256_Key_Expansion (const unsigned char *userkey, \r\n// unsigned char *key) \r\n.globl AES_256_Key_Expansion \r\nAES_256_Key_Expansion: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n movdqu (%rdi), %xmm1 \r\n movdqu 16(%rdi), %xmm3 \r\n movdqa %xmm1, (%rsi) \r\n movdqa %xmm3, 16(%rsi) \r\n \r\n aeskeygenassist $0x1, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 32(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 48(%rsi) \r\n aeskeygenassist $0x2, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 64(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 80(%rsi) \r\n aeskeygenassist $0x4, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 96(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/577b4b44-8d56-4ab4-9288-53639fcfa2b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1441a7b9fbbe71d37f55da53be10c7a2ef47d00c58eac5eeb3d41621e6358dd0",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "600cd88e-cf72-4c45-ab8e-5dd186cab332",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 47 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 112(%rsi) \r\n aeskeygenassist $0x8, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 128(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 144(%rsi) \r\n aeskeygenassist $0x10, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 160(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 176(%rsi) \r\n aeskeygenassist $0x20, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 192(%rsi) \r\n aeskeygenassist $0x0, %xmm1, %xmm2 \r\n call MAKE_RK256_b \r\n movdqa %xmm3, 208(%rsi) \r\n aeskeygenassist $0x40, %xmm3, %xmm2 \r\n call MAKE_RK256_a \r\n movdqa %xmm1, 224(%rsi) \r\n \r\n ret \r\n \r\nMAKE_RK256_a: \r\n pshufd $0xff, %xmm2, %xmm2 \r\n movdqa %xmm1, %xmm4 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm1 \r\n pxor %xmm2, %xmm1 \r\n ret \r\n \r\nMAKE_RK256_b: \r\n pshufd $0xaa, %xmm2, %xmm2 \r\n movdqa %xmm3, %xmm4 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm3 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm3 \r\n pslldq $4, %xmm4 \r\n pxor %xmm4, %xmm3 \r\n pxor %xmm2, %xmm3 \r\n ret \r\nFigure 42. A Universal Key Expansion(C code) \r\n/* \r\nA function with OpenSSL interface (using AES_KEY struct), to call the other key\u0002length specific key expansion functions \r\n*/ \r\n#include <wmmintrin.h> \r\n#if !defined (ALIGN16) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/600cd88e-cf72-4c45-ab8e-5dd186cab332.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aebcbf45fe8b9ee63ad5c0d4cdc3428365521c4c4b5324329f5e562224b56c85",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d77da00f-e610-494d-8cae-ac08492891b1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n48 323641-001 \r\n# if defined (__GNUC__) \r\n# define ALIGN16 __attribute__ ( (aligned (16))) \r\n# else \r\n# define ALIGN16 __declspec (align (16)) \r\n# endif \r\n#endif \r\ntypedef struct KEY_SCHEDULE{ \r\n ALIGN16 unsigned char KEY[16*15]; \r\n unsigned int nr; \r\n }AES_KEY; \r\nint AES_set_encrypt_key (const unsigned char *userKey, \r\n const int bits, \r\n AES_KEY *key) \r\n { \r\n if (!userKey || !key) \r\n return -1; \r\n if (bits == 128) \r\n { \r\n AES_128_Key_Expansion (userKey,key); \r\n key->nr = 10; \r\n return 0; \r\n } \r\n else if (bits == 192) \r\n { \r\n AES_192_Key_Expansion (userKey,key); \r\n key->nr = 12; \r\n return 0; \r\n } \r\n else if (bits == 256) \r\n { \r\n AES_256_Key_Expansion (userKey,key); \r\n key->nr = 14; \r\n return 0; \r\n } \r\n return -2; \r\n } \r\nint AES_set_decrypt_key (const unsigned char *userKey, \r\n const int bits, \r\n AES_KEY *key) \r\n { \r\n int i,nr;; \r\n AES_KEY temp_key; \r\n __m128i *Key_Schedule = (__m128i*)key->KEY; \r\n __m128i *Temp_Key_Schedule = (__m128i*)temp_key.KEY; \r\n if (!userKey || !key) \r\n return -1; \r\n if (AES_set_encrypt_key(userKey,bits,&temp_key) == -2) \r\n return -2; \r\n nr = temp_key.nr; \r\n key->nr = nr; \r\n Key_Schedule[nr] = Temp_Key_Schedule[0]; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/d77da00f-e610-494d-8cae-ac08492891b1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a6693a7cfdeb7ee41815e7025f32af074b25398dedf152d1a018298ab8548d65",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 494
      },
      {
        "segments": [
          {
            "segment_id": "eb1ab61b-d138-4aeb-9e9e-d121b7f8d179",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 49 \r\n Key_Schedule[nr-1] = _mm_aesimc_si128(Temp_Key_Schedule[1]); \r\n Key_Schedule[nr-2] = _mm_aesimc_si128(Temp_Key_Schedule[2]); \r\n Key_Schedule[nr-3] = _mm_aesimc_si128(Temp_Key_Schedule[3]); \r\n Key_Schedule[nr-4] = _mm_aesimc_si128(Temp_Key_Schedule[4]); \r\n Key_Schedule[nr-5] = _mm_aesimc_si128(Temp_Key_Schedule[5]); \r\n Key_Schedule[nr-6] = _mm_aesimc_si128(Temp_Key_Schedule[6]); \r\n Key_Schedule[nr-7] = _mm_aesimc_si128(Temp_Key_Schedule[7]); \r\n Key_Schedule[nr-8] = _mm_aesimc_si128(Temp_Key_Schedule[8]); \r\n Key_Schedule[nr-9] = _mm_aesimc_si128(Temp_Key_Schedule[9]); \r\n if(nr>10){ \r\n Key_Schedule[nr-10] = _mm_aesimc_si128(Temp_Key_Schedule[10]); \r\n Key_Schedule[nr-11] = _mm_aesimc_si128(Temp_Key_Schedule[11]); \r\n } \r\n if(nr>12){ \r\n Key_Schedule[nr-12] = _mm_aesimc_si128(Temp_Key_Schedule[12]); \r\n Key_Schedule[nr-13] = _mm_aesimc_si128(Temp_Key_Schedule[13]); \r\n } \r\n Key_Schedule[0] = Temp_Key_Schedule[nr]; \r\n return 0; \r\n } \r\nECB MODE \r\nFigure 43. The AES Encryption Parallelizing 4 Blocks (AT&T Assembly Function) \r\n//void AES_ECB_encrypt (const unsigned char *in, \r\n// unsigned char *out, \r\n// unsigned long length, \r\n// const unsigned char *KS, \r\n// int nr) \r\n.globl AES_ECB_encrypt \r\nAES_ECB_encrypt: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %rdx \r\n# parameter 4: %rcx \r\n# parameter 5: %r8d \r\n movq %rdx, %r10 \r\n shrq $4, %rdx \r\n shlq $60, %r10 \r\n je NO_PARTS_4 \r\n addq $1, %rdx \r\nNO_PARTS_4: \r\n movq %rdx, %r10 \r\n shlq $62, %r10 \r\n shrq $62, %r10 \r\n shrq $2, %rdx \r\n je REMAINDER_4 \r\n subq $64, %rsi \r\nLOOP_4: \r\n movdqu (%rdi), %xmm1 \r\n movdqu 16(%rdi), %xmm2 \r\n movdqu 32(%rdi), %xmm3 \r\n movdqu 48(%rdi), %xmm4 \r\n movdqa (%rcx), %xmm9 \r\n movdqa 16(%rcx), %xmm10 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/eb1ab61b-d138-4aeb-9e9e-d121b7f8d179.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dfa4b57f18b5d819f170ba21e86d95c77d1f62698672b047be8029ec45720324",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "60e4eb56-6382-49ec-b3c4-fb91d7b87903",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n50 323641-001 \r\n movdqa 32(%rcx), %xmm11 \r\n movdqa 48(%rcx), %xmm12 \r\n pxor %xmm9, %xmm1 \r\n pxor %xmm9, %xmm2 \r\n pxor %xmm9, %xmm3 \r\n pxor %xmm9, %xmm4 \r\n aesenc %xmm10, %xmm1 \r\n aesenc %xmm10, %xmm2 \r\n aesenc %xmm10, %xmm3 \r\n aesenc %xmm10, %xmm4 \r\n aesenc %xmm11, %xmm1 \r\n aesenc %xmm11, %xmm2 \r\n aesenc %xmm11, %xmm3 \r\n aesenc %xmm11, %xmm4 \r\n aesenc %xmm12, %xmm1 \r\n aesenc %xmm12, %xmm2 \r\n aesenc %xmm12, %xmm3 \r\n aesenc %xmm12, %xmm4 \r\n movdqa 64(%rcx), %xmm9 \r\n movdqa 80(%rcx), %xmm10 \r\n movdqa 96(%rcx), %xmm11 \r\n movdqa 112(%rcx), %xmm12 \r\n aesenc %xmm9, %xmm1 \r\n aesenc %xmm9, %xmm2 \r\n aesenc %xmm9, %xmm3 \r\n aesenc %xmm9, %xmm4 \r\n aesenc %xmm10, %xmm1 \r\n aesenc %xmm10, %xmm2 \r\n aesenc %xmm10, %xmm3 \r\n aesenc %xmm10, %xmm4 \r\n aesenc %xmm11, %xmm1 \r\n aesenc %xmm11, %xmm2 \r\n aesenc %xmm11, %xmm3 \r\n aesenc %xmm11, %xmm4 \r\n aesenc %xmm12, %xmm1 \r\n aesenc %xmm12, %xmm2 \r\n aesenc %xmm12, %xmm3 \r\n aesenc %xmm12, %xmm4 \r\n movdqa 128(%rcx), %xmm9 \r\n movdqa 144(%rcx), %xmm10 \r\n movdqa 160(%rcx), %xmm11 \r\n cmpl $12, %r8d \r\n aesenc %xmm9, %xmm1 \r\n aesenc %xmm9, %xmm2 \r\n aesenc %xmm9, %xmm3 \r\n aesenc %xmm9, %xmm4 \r\n aesenc %xmm10, %xmm1 \r\n aesenc %xmm10, %xmm2 \r\n aesenc %xmm10, %xmm3 \r\n aesenc %xmm10, %xmm4 \r\n jb LAST_4 \r\n movdqa 160(%rcx), %xmm9 \r\n movdqa 176(%rcx), %xmm10 \r\n movdqa 192(%rcx), %xmm11 \r\n cmpl $14, %r8d \r\n aesenc %xmm9, %xmm1 \r\n aesenc %xmm9, %xmm2 \r\n aesenc %xmm9, %xmm3 \r\n aesenc %xmm9, %xmm4 \r\n aesenc %xmm10, %xmm1 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/60e4eb56-6382-49ec-b3c4-fb91d7b87903.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b31645fff8b16698fdae562020dc35f0a35353c0d1e36748e67fa780034b5b0f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 357
      },
      {
        "segments": [
          {
            "segment_id": "39fffad8-453b-44cc-968a-fa9a74fbc123",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 51 \r\n aesenc %xmm10, %xmm2 \r\n aesenc %xmm10, %xmm3 \r\n aesenc %xmm10, %xmm4 \r\n jb LAST_4 \r\n movdqa 192(%rcx), %xmm9 \r\n movdqa 208(%rcx), %xmm10 \r\n movdqa 224(%rcx), %xmm11 \r\n aesenc %xmm9, %xmm1 \r\n aesenc %xmm9, %xmm2 \r\n aesenc %xmm9, %xmm3 \r\n aesenc %xmm9, %xmm4 \r\n aesenc %xmm10, %xmm1 \r\n aesenc %xmm10, %xmm2 \r\n aesenc %xmm10, %xmm3 \r\n aesenc %xmm10, %xmm4 \r\nLAST_4: \r\n addq $64, %rdi \r\n addq $64, %rsi \r\n decq %rdx \r\n aesenclast %xmm11, %xmm1 \r\n aesenclast %xmm11, %xmm2 \r\n aesenclast %xmm11, %xmm3 \r\n aesenclast %xmm11, %xmm4 \r\n movdqu %xmm1, (%rsi) \r\n movdqu %xmm2, 16(%rsi) \r\n movdqu %xmm3, 32(%rsi) \r\n movdqu %xmm4, 48(%rsi) \r\n jne LOOP_4 \r\n addq $64, %rsi \r\nREMAINDER_4: \r\n cmpq $0, %r10 \r\n je END_4 \r\nLOOP_4_2: \r\n movdqu (%rdi), %xmm1 \r\n addq $16, %rdi \r\n pxor (%rcx), %xmm1 \r\n movdqu 160(%rcx), %xmm2 \r\n aesenc 16(%rcx), %xmm1 \r\n aesenc 32(%rcx), %xmm1 \r\n aesenc 48(%rcx), %xmm1 \r\n aesenc 64(%rcx), %xmm1 \r\n aesenc 80(%rcx), %xmm1 \r\n aesenc 96(%rcx), %xmm1 \r\n aesenc 112(%rcx), %xmm1 \r\n aesenc 128(%rcx), %xmm1 \r\n aesenc 144(%rcx), %xmm1 \r\n cmpl $12, %r8d \r\n jb LAST_4_2 \r\n movdqu 192(%rcx), %xmm2 \r\n aesenc 160(%rcx), %xmm1 \r\n aesenc 176(%rcx), %xmm1 \r\n cmpl $14, %r8d \r\n jb LAST_4_2 \r\n movdqu 224(%rcx), %xmm2 \r\n aesenc 192(%rcx), %xmm1 \r\n aesenc 208(%rcx), %xmm1 \r\nLAST_4_2: \r\n aesenclast %xmm2, %xmm1 \r\n movdqu %xmm1, (%rsi) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/39fffad8-453b-44cc-968a-fa9a74fbc123.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2ded2b61b8640aad8f7a556bad2f3aac4b0ca47aeaa8c67910e96c7fb344d042",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e83fc119-b066-41fe-aa96-ec2058154d83",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n52 323641-001 \r\n addq $16, %rsi \r\n decq %r10 \r\n jne LOOP_4_2 \r\nEND_4: \r\n ret \r\nFigure 44. The AES Decryption Parallelizing 4 Blocks (AT&T Assembly Function) \r\n//void AES_ECB_decrypt (const unsigned char *in, \r\n// unsigned char *out, \r\n// unsigned long length, \r\n// const unsigned char *KS, \r\n// int nr) \r\n.globl AES_ECB_decrypt \r\nAES_ECB_decrypt: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %rdx \r\n# parameter 4: %rcx \r\n# parameter 5: %r8d \r\n movq %rdx, %r10 \r\n shrq $4, %rdx \r\n shlq $60, %r10 \r\n je DNO_PARTS_4 \r\n addq $1, %rdx \r\nDNO_PARTS_4: \r\n movq %rdx, %r10 \r\n shlq $62, %r10 \r\n shrq $62, %r10 \r\n shrq $2, %rdx \r\n je DREMAINDER_4 \r\n subq $64, %rsi \r\nDLOOP_4: \r\n movdqu (%rdi), %xmm1 \r\n movdqu 16(%rdi), %xmm2 \r\n movdqu 32(%rdi), %xmm3 \r\n movdqu 48(%rdi), %xmm4 \r\n movdqa (%rcx), %xmm9 \r\n movdqa 16(%rcx), %xmm10 \r\n movdqa 32(%rcx), %xmm11 \r\n movdqa 48(%rcx), %xmm12 \r\n pxor %xmm9, %xmm1 \r\n pxor %xmm9, %xmm2 \r\n pxor %xmm9, %xmm3 \r\n pxor %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n aesdec %xmm11, %xmm1 \r\n aesdec %xmm11, %xmm2 \r\n aesdec %xmm11, %xmm3 \r\n aesdec %xmm11, %xmm4 \r\n aesdec %xmm12, %xmm1 \r\n aesdec %xmm12, %xmm2 \r\n aesdec %xmm12, %xmm3 \r\n aesdec %xmm12, %xmm4 \r\n movdqa 64(%rcx), %xmm9 \r\n movdqa 80(%rcx), %xmm10 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/e83fc119-b066-41fe-aa96-ec2058154d83.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7d42d2fa2d23c5a0adebdb212e9b2cacec3eaa03560483d93d1ccbe577e7154a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 359
      },
      {
        "segments": [
          {
            "segment_id": "15510ff7-1f73-481a-a96e-02f0495c89d0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 53 \r\n movdqa 96(%rcx), %xmm11 \r\n movdqa 112(%rcx), %xmm12 \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n aesdec %xmm11, %xmm1 \r\n aesdec %xmm11, %xmm2 \r\n aesdec %xmm11, %xmm3 \r\n aesdec %xmm11, %xmm4 \r\n aesdec %xmm12, %xmm1 \r\n aesdec %xmm12, %xmm2 \r\n aesdec %xmm12, %xmm3 \r\n aesdec %xmm12, %xmm4 \r\n movdqa 128(%rcx), %xmm9 \r\n movdqa 144(%rcx), %xmm10 \r\n movdqa 160(%rcx), %xmm11 \r\n cmpl $12, %r8d \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n jb DLAST_4 \r\n movdqa 160(%rcx), %xmm9 \r\n movdqa 176(%rcx), %xmm10 \r\n movdqa 192(%rcx), %xmm11 \r\n cmpl $14, %r8d \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n jb DLAST_4 \r\n movdqa 192(%rcx), %xmm9 \r\n movdqa 208(%rcx), %xmm10 \r\n movdqa 224(%rcx), %xmm11 \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\nDLAST_4: \r\n addq $64, %rdi \r\n addq $64, %rsi \r\n decq %rdx \r\n aesdeclast %xmm11, %xmm1 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/15510ff7-1f73-481a-a96e-02f0495c89d0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=720fac88fb53f30960052ac1e9376d6860a3f06f310219f68007ed90b6fae5a1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7233a140-761a-48bd-b303-f282c6064f7b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n54 323641-001 \r\n aesdeclast %xmm11, %xmm2 \r\n aesdeclast %xmm11, %xmm3 \r\n aesdeclast %xmm11, %xmm4 \r\n movdqu %xmm1, (%rsi) \r\n movdqu %xmm2, 16(%rsi) \r\n movdqu %xmm3, 32(%rsi) \r\n movdqu %xmm4, 48(%rsi) \r\n jne DLOOP_4 \r\n addq $64, %rsi \r\nDREMAINDER_4: \r\n cmpq $0, %r10 \r\n je DEND_4 \r\nDLOOP_4_2: \r\n movdqu (%rdi), %xmm1 \r\n addq $16, %rdi \r\n pxor (%rcx), %xmm1 \r\n movdqu 160(%rcx), %xmm2 \r\n cmpl $12, %r8d \r\n aesdec 16(%rcx), %xmm1 \r\n aesdec 32(%rcx), %xmm1 \r\n aesdec 48(%rcx), %xmm1 \r\n aesdec 64(%rcx), %xmm1 \r\n aesdec 80(%rcx), %xmm1 \r\n aesdec 96(%rcx), %xmm1 \r\n aesdec 112(%rcx), %xmm1 \r\n aesdec 128(%rcx), %xmm1 \r\n aesdec 144(%rcx), %xmm1 \r\n jb DLAST_4_2 \r\n cmpl $14, %r8d \r\n movdqu 192(%rcx), %xmm2 \r\n aesdec 160(%rcx), %xmm1 \r\n aesdec 176(%rcx), %xmm1 \r\n jb DLAST_4_2 \r\n movdqu 224(%rcx), %xmm2 \r\n aesdec 192(%rcx), %xmm1 \r\n aesdec 208(%rcx), %xmm1 \r\nDLAST_4_2: \r\n aesdeclast %xmm2, %xmm1 \r\n movdqu %xmm1, (%rsi) \r\n addq $16, %rsi \r\n decq %r10 \r\n jne DLOOP_4_2 \r\nDEND_4: \r\n ret \r\nCBC MODE \r\nFigure 45. CBC Encryption of 1 Block at a Time (AT&T Assembly Function) \r\n//AES_CBC_encrypt (const unsigned char *in, \r\n// unsigned char *out, \r\n// unsigned char ivec[16], \r\n// unsigned long length, \r\n// const unsigned char *KS, \r\n// int nr) \r\n.globl AES_CBC_encrypt \r\nAES_CBC_encrypt: ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/7233a140-761a-48bd-b303-f282c6064f7b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7098f45181308fbe018910fd49e9884cd6f1f78ab324cecf2237407e040f565c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "bef0a53b-620a-417d-a28f-0f2f4729c653",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 55 \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %rdx \r\n# parameter 4: %rcx \r\n# parameter 5: %r8 \r\n# parameter 6: %r9d \r\n movq %rcx, %r10 \r\n shrq $4, %rcx \r\n shlq $60, %r10 \r\n je NO_PARTS \r\n addq $1, %rcx \r\nNO_PARTS: \r\n subq $16, %rsi \r\n movdqa (%rdx), %xmm1 \r\nLOOP: \r\n pxor (%rdi), %xmm1 \r\n pxor (%r8), %xmm1 \r\n addq $16,%rsi \r\n addq $16,%rdi \r\n cmpl $12, %r9d \r\n aesenc 16(%r8),%xmm1 \r\n aesenc 32(%r8),%xmm1 \r\n aesenc 48(%r8),%xmm1 \r\n aesenc 64(%r8),%xmm1 \r\n aesenc 80(%r8),%xmm1 \r\n aesenc 96(%r8),%xmm1 \r\n aesenc 112(%r8),%xmm1 \r\n aesenc 128(%r8),%xmm1 \r\n aesenc 144(%r8),%xmm1 \r\n movdqa 160(%r8),%xmm2 \r\n jb LAST \r\n cmpl $14, %r9d \r\n aesenc 160(%r8),%xmm1 \r\n aesenc 176(%r8),%xmm1 \r\n movdqa 192(%r8),%xmm2 \r\n jb LAST \r\n aesenc 192(%r8),%xmm1 \r\n aesenc 208(%r8),%xmm1 \r\n movdqa 224(%r8),%xmm2 \r\nLAST: \r\n decq %rcx \r\n aesenclast %xmm2,%xmm1 \r\n movdqu %xmm1,(%rsi) \r\n \r\n jne LOOP \r\n ret \r\nFigure 46. CBC Decryption Parallelizing 4 Blocks (AT&T Assembly Function) \r\n//AES_CBC_decrypt (const unsigned char *in, \r\n// unsigned char *out, \r\n// unsigned char ivec[16], \r\n// unsigned long length, \r\n// const unsigned char *KS, \r\n// int nr) \r\n.globl AES_CBC_decrypt \r\nAES_CBC_decrypt: ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bef0a53b-620a-417d-a28f-0f2f4729c653.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b7ebfe985098a2d19caba829b02370232bdd10c50592e5606ce4c59307491fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 510
      },
      {
        "segments": [
          {
            "segment_id": "f8ea48ba-4c6a-4a07-a0b7-e329d17c0440",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n56 323641-001 \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %rdx \r\n# parameter 4: %rcx \r\n# parameter 5: %r8 \r\n# parameter 6: %r9d \r\n movq %rcx, %r10 \r\n shrq $4, %rcx \r\n shlq $60, %r10 \r\n je DNO_PARTS_4 \r\n addq $1, %rcx \r\nDNO_PARTS_4: \r\n movq %rcx, %r10 \r\n shlq $62, %r10 \r\n shrq $62, %r10 \r\n shrq $2, %rcx \r\n movdqu (%rdx),%xmm5 \r\n je DREMAINDER_4 \r\n subq $64, %rsi \r\nDLOOP_4: \r\n movdqu (%rdi), %xmm1 \r\n movdqu 16(%rdi), %xmm2 \r\n movdqu 32(%rdi), %xmm3 \r\n movdqu 48(%rdi), %xmm4 \r\n movdqa %xmm1, %xmm6 \r\n movdqa %xmm2, %xmm7 \r\n movdqa %xmm3, %xmm8 \r\n movdqa %xmm4, %xmm15 \r\n movdqa (%r8), %xmm9 \r\n movdqa 16(%r8), %xmm10 \r\n movdqa 32(%r8), %xmm11 \r\n movdqa 48(%r8), %xmm12 \r\n pxor %xmm9, %xmm1 \r\n pxor %xmm9, %xmm2 \r\n pxor %xmm9, %xmm3 \r\n pxor %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n aesdec %xmm11, %xmm1 \r\n aesdec %xmm11, %xmm2 \r\n aesdec %xmm11, %xmm3 \r\n aesdec %xmm11, %xmm4 \r\n aesdec %xmm12, %xmm1 \r\n aesdec %xmm12, %xmm2 \r\n aesdec %xmm12, %xmm3 \r\n aesdec %xmm12, %xmm4 \r\n movdqa 64(%r8), %xmm9 \r\n movdqa 80(%r8), %xmm10 \r\n movdqa 96(%r8), %xmm11 \r\n movdqa 112(%r8), %xmm12 \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/f8ea48ba-4c6a-4a07-a0b7-e329d17c0440.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=130a97586e02d5aebc54b89d04fa4b71229c5970321fe4e4e21fbfdc347c1f7c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "60f19ca5-69c2-431b-b9f8-ff25faa4b519",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 57 \r\n aesdec %xmm10, %xmm4 \r\n aesdec %xmm11, %xmm1 \r\n aesdec %xmm11, %xmm2 \r\n aesdec %xmm11, %xmm3 \r\n aesdec %xmm11, %xmm4 \r\n aesdec %xmm12, %xmm1 \r\n aesdec %xmm12, %xmm2 \r\n aesdec %xmm12, %xmm3 \r\n aesdec %xmm12, %xmm4 \r\n movdqa 128(%r8), %xmm9 \r\n movdqa 144(%r8), %xmm10 \r\n movdqa 160(%r8), %xmm11 \r\n cmpl $12, %r9d \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n jb DLAST_4 \r\n movdqa 160(%r8), %xmm9 \r\n movdqa 176(%r8), %xmm10 \r\n movdqa 192(%r8), %xmm11 \r\n cmpl $14, %r9d \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\n jb DLAST_4 \r\n movdqa 192(%r8), %xmm9 \r\n movdqa 208(%r8), %xmm10 \r\n movdqa 224(%r8), %xmm11 \r\n aesdec %xmm9, %xmm1 \r\n aesdec %xmm9, %xmm2 \r\n aesdec %xmm9, %xmm3 \r\n aesdec %xmm9, %xmm4 \r\n aesdec %xmm10, %xmm1 \r\n aesdec %xmm10, %xmm2 \r\n aesdec %xmm10, %xmm3 \r\n aesdec %xmm10, %xmm4 \r\nDLAST_4: \r\n addq $64, %rdi \r\n addq $64, %rsi \r\n decq %rcx \r\n aesdeclast %xmm11, %xmm1 \r\n aesdeclast %xmm11, %xmm2 \r\n aesdeclast %xmm11, %xmm3 \r\n aesdeclast %xmm11, %xmm4 \r\n pxor %xmm5 ,%xmm1 \r\n pxor %xmm6 ,%xmm2 \r\n pxor %xmm7 ,%xmm3 \r\n pxor %xmm8 ,%xmm4 \r\n movdqu %xmm1, (%rsi) \r\n movdqu %xmm2, 16(%rsi) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/60f19ca5-69c2-431b-b9f8-ff25faa4b519.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=155c9db92d47cc562b17e416fabcf9c9801b7513c87020c7b657bbd05c2a0943",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "edd7ecd6-e533-4aa1-95b6-69471a29fd67",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n58 323641-001 \r\n movdqu %xmm3, 32(%rsi) \r\n movdqu %xmm4, 48(%rsi) \r\n movdqa %xmm15,%xmm5 \r\n jne DLOOP_4 \r\n addq $64, %rsi \r\nDREMAINDER_4: \r\n cmpq $0, %r10 \r\n je DEND_4 \r\nDLOOP_4_2: \r\n movdqu (%rdi), %xmm1 \r\n movdqa %xmm1 ,%xmm15 \r\n addq $16, %rdi \r\n pxor (%r8), %xmm1 \r\n movdqu 160(%r8), %xmm2 \r\n cmpl $12, %r9d \r\n aesdec 16(%r8), %xmm1 \r\n aesdec 32(%r8), %xmm1 \r\n aesdec 48(%r8), %xmm1 \r\n aesdec 64(%r8), %xmm1 \r\n aesdec 80(%r8), %xmm1 \r\n aesdec 96(%r8), %xmm1 \r\n aesdec 112(%r8), %xmm1 \r\n aesdec 128(%r8), %xmm1 \r\n aesdec 144(%r8), %xmm1 \r\n jb DLAST_4_2 \r\n movdqu 192(%r8), %xmm2 \r\n cmpl $14, %r9d \r\n aesdec 160(%r8), %xmm1 \r\n aesdec 176(%r8), %xmm1 \r\n jb DLAST_4_2 \r\n movdqu 224(%r8), %xmm2 \r\n aesdec 192(%r8), %xmm1 \r\n aesdec 208(%r8), %xmm1 \r\nDLAST_4_2: \r\n aesdeclast %xmm2, %xmm1 \r\n pxor %xmm5, %xmm1 \r\n movdqa %xmm15, %xmm5 \r\n movdqu %xmm1, (%rsi) \r\n addq $16, %rsi \r\n decq %r10 \r\n jne DLOOP_4_2 \r\nDEND_4: \r\n ret \r\nCTR MODE \r\nFigure 47. CTR Encryption Parallelizing 4 Blocks (AT&T Assembly Function) \r\n.align 16 \r\nONE: \r\n.quad 0x00000000,0x00000001 \r\n.align 16 \r\nFOUR: \r\n.quad 0x00000004,0x00000004 \r\n.align 16 \r\nEIGHT: \r\n.quad 0x00000008,0x00000008 \r\n.align 16 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/edd7ecd6-e533-4aa1-95b6-69471a29fd67.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=462aebbfb78006484824e4f244480c83ef2e2fe9b2a759697126134346e3006f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "2bd6c667-b6e0-4900-be91-fead5de6394e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 59 \r\nTWO_N_ONE: \r\n.quad 0x00000002,0x00000001 \r\n.align 16 \r\nTWO_N_TWO: \r\n.quad 0x00000002,0x00000002 \r\n.align 16 \r\nLOAD_HIGH_BROADCAST_AND_BSWAP: \r\n.byte 15,14,13,12,11,10,9,8,15,14,13,12,11,10,9,8 \r\n.align 16 \r\nBSWAP_EPI_64: \r\n.byte 7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8 \r\n//AES_CTR_encrypt (const unsigned char *in, \r\n// unsigned char *out, \r\n// const unsigned char ivec[8], \r\n// const unsigned char nonce[4], \r\n// unsigned long length, \r\n// const unsigned char *key, \r\n // int nr) \r\n.globl AES_CTR_encrypt \r\nAES_CTR_encrypt: \r\n# parameter 1: %rdi \r\n# parameter 2: %rsi \r\n# parameter 3: %rdx \r\n# parameter 4: %rcx \r\n# parameter 5: %r8 \r\n# parameter 6: %r9 \r\n# parameter 7: 8 + %rsp \r\n movq %r8, %r10 \r\n movl 8(%rsp), %r12d \r\n shrq $4, %r8 \r\n shlq $60, %r10 \r\n je NO_PARTS_4 \r\n addq $1, %r8 \r\nNO_PARTS_4: \r\n movq %r8, %r10 \r\n shlq $62, %r10 \r\n shrq $62, %r10 \r\n \r\n pinsrq $1, (%rdx), %xmm0 \r\n pinsrd $1, (%rcx), %xmm0 \r\n psrldq $4, %xmm0 \r\n movdqa %xmm0, %xmm2 \r\n pshufb (LOAD_HIGH_BROADCAST_AND_BSWAP), %xmm2 \r\n paddq (TWO_N_ONE), %xmm2 \r\n movdqa %xmm2, %xmm1 \r\n paddq (TWO_N_TWO), %xmm2 \r\n pshufb (BSWAP_EPI_64), %xmm1 \r\n pshufb (BSWAP_EPI_64), %xmm2 \r\n \r\n shrq $2, %r8 \r\n je REMAINDER_4 \r\n subq $64, %rsi \r\n subq $64, %rdi \r\nLOOP_4: ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/2bd6c667-b6e0-4900-be91-fead5de6394e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e590dbc129190977189de4645c112c76c346bd913b683a8d5e2e0160180cf9dc",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8b804d93-2ecf-4a3b-8544-97dbb084b765",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n60 323641-001 \r\n addq $64, %rsi \r\n addq $64, %rdi \r\n \r\n movdqa %xmm0, %xmm11 \r\n movdqa %xmm0, %xmm12 \r\n movdqa %xmm0, %xmm13 \r\n movdqa %xmm0, %xmm14 \r\n \r\n shufpd $2, %xmm1, %xmm11 \r\n shufpd $0, %xmm1, %xmm12 \r\n shufpd $2, %xmm2, %xmm13 \r\n shufpd $0, %xmm2, %xmm14 \r\n \r\n pshufb (BSWAP_EPI_64), %xmm1 \r\n pshufb (BSWAP_EPI_64), %xmm2 \r\n \r\n movdqa (%r9), %xmm8 \r\n movdqa 16(%r9), %xmm9 \r\n movdqa 32(%r9), %xmm10 \r\n movdqa 48(%r9), %xmm7 \r\n \r\n paddq (FOUR), %xmm1 \r\n paddq (FOUR), %xmm2 \r\n \r\n pxor %xmm8, %xmm11 \r\n pxor %xmm8, %xmm12 \r\n pxor %xmm8, %xmm13 \r\n pxor %xmm8, %xmm14 \r\n \r\n pshufb (BSWAP_EPI_64), %xmm1 \r\n pshufb (BSWAP_EPI_64), %xmm2 \r\n \r\n aesenc %xmm9, %xmm11 \r\n aesenc %xmm9, %xmm12 \r\n aesenc %xmm9, %xmm13 \r\n aesenc %xmm9, %xmm14 \r\n aesenc %xmm10, %xmm11 \r\n aesenc %xmm10, %xmm12 \r\n aesenc %xmm10, %xmm13 \r\n aesenc %xmm10, %xmm14 \r\n aesenc %xmm7, %xmm11 \r\n aesenc %xmm7, %xmm12 \r\n aesenc %xmm7, %xmm13 \r\n aesenc %xmm7, %xmm14 \r\n \r\n movdqa 64(%r9), %xmm8 \r\n movdqa 80(%r9), %xmm9 \r\n movdqa 96(%r9), %xmm10 \r\n movdqa 112(%r9), %xmm7 \r\n \r\n aesenc %xmm8, %xmm11 \r\n aesenc %xmm8, %xmm12 \r\n aesenc %xmm8, %xmm13 \r\n aesenc %xmm8, %xmm14 \r\n aesenc %xmm9, %xmm11 \r\n aesenc %xmm9, %xmm12 \r\n aesenc %xmm9, %xmm13 \r\n aesenc %xmm9, %xmm14 \r\n aesenc %xmm10, %xmm11 \r\n aesenc %xmm10, %xmm12 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/8b804d93-2ecf-4a3b-8544-97dbb084b765.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d98f466b91f4c3d9e3333c24ad875529c0c248df5659e3fed48bfd277d3a94a0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 478
      },
      {
        "segments": [
          {
            "segment_id": "6f666b10-7725-4ae9-829c-a4e656e1e4b7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 61 \r\n aesenc %xmm10, %xmm13 \r\n aesenc %xmm10, %xmm14 \r\n aesenc %xmm7, %xmm11 \r\n aesenc %xmm7, %xmm12 \r\n aesenc %xmm7, %xmm13 \r\n aesenc %xmm7, %xmm14 \r\n \r\n movdqa 128(%r9), %xmm8 \r\n movdqa 144(%r9), %xmm9 \r\n movdqa 160(%r9), %xmm10 \r\n cmp $12, %r12d \r\n \r\n aesenc %xmm8, %xmm11 \r\n aesenc %xmm8, %xmm12 \r\n aesenc %xmm8, %xmm13 \r\n aesenc %xmm8, %xmm14 \r\n aesenc %xmm9, %xmm11 \r\n aesenc %xmm9, %xmm12 \r\n aesenc %xmm9, %xmm13 \r\n aesenc %xmm9, %xmm14 \r\n jb LAST_4 \r\n movdqa 160(%r9), %xmm8 \r\n movdqa 176(%r9), %xmm9 \r\n movdqa 192(%r9), %xmm10 \r\n cmp $14, %r12d \r\n \r\n aesenc %xmm8, %xmm11 \r\n aesenc %xmm8, %xmm12 \r\n aesenc %xmm8, %xmm13 \r\n aesenc %xmm8, %xmm14 \r\n aesenc %xmm9, %xmm11 \r\n aesenc %xmm9, %xmm12 \r\n aesenc %xmm9, %xmm13 \r\n aesenc %xmm9, %xmm14 \r\n jb LAST_4 \r\n \r\n movdqa 192(%r9), %xmm8 \r\n movdqa 208(%r9), %xmm9 \r\n movdqa 224(%r9), %xmm10 \r\n \r\n aesenc %xmm8, %xmm11 \r\n aesenc %xmm8, %xmm12 \r\n aesenc %xmm8, %xmm13 \r\n aesenc %xmm8, %xmm14 \r\n aesenc %xmm9, %xmm11 \r\n aesenc %xmm9, %xmm12 \r\n aesenc %xmm9, %xmm13 \r\n aesenc %xmm9, %xmm14 \r\nLAST_4: \r\n \r\n aesenclast %xmm10, %xmm11 \r\n aesenclast %xmm10, %xmm12 \r\n aesenclast %xmm10, %xmm13 \r\n aesenclast %xmm10, %xmm14 \r\n \r\n pxor (%rdi), %xmm11 \r\n pxor 16(%rdi), %xmm12 \r\n pxor 32(%rdi), %xmm13 \r\n pxor 48(%rdi), %xmm14 \r\n ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/6f666b10-7725-4ae9-829c-a4e656e1e4b7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1a063c16d81999fc32adc043548a102cb7f773745acabd5e564a055ebb2c7b45",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "02d31190-fbdd-457f-94e7-6800cc87658c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n62 323641-001 \r\n movdqu %xmm11, (%rsi) \r\n movdqu %xmm12, 16(%rsi) \r\n movdqu %xmm13, 32(%rsi) \r\n movdqu %xmm14, 48(%rsi) \r\n dec %r8 \r\n jne LOOP_4 \r\n \r\n addq $64,%rsi \r\n addq $64,%rdi \r\n \r\nREMAINDER_4: \r\n cmp $0, %r10 \r\n je END_4 \r\n shufpd $2, %xmm1, %xmm0 \r\nIN_LOOP_4: \r\n movdqa %xmm0, %xmm11 \r\n pshufb (BSWAP_EPI_64), %xmm0 \r\n pxor (%r9), %xmm11 \r\n paddq (ONE), %xmm0 \r\n aesenc 16(%r9), %xmm11 \r\n aesenc 32(%r9), %xmm11 \r\n pshufb (BSWAP_EPI_64), %xmm0 \r\n aesenc 48(%r9), %xmm11 \r\n aesenc 64(%r9), %xmm11 \r\n aesenc 80(%r9), %xmm11 \r\n aesenc 96(%r9), %xmm11 \r\n aesenc 112(%r9), %xmm11 \r\n aesenc 128(%r9), %xmm11 \r\n aesenc 144(%r9), %xmm11 \r\n movdqa 160(%r9), %xmm2 \r\n cmp $12, %r12d \r\n jb IN_LAST_4 \r\n aesenc 160(%r9), %xmm11 \r\n aesenc 176(%r9), %xmm11 \r\n movdqa 192(%r9), %xmm2 \r\n cmp $14, %r12d \r\n jb IN_LAST_4 \r\n aesenc 192(%r9), %xmm11 \r\n aesenc 208(%r9), %xmm11 \r\n movdqa 224(%r9), %xmm2 \r\nIN_LAST_4: \r\n aesenclast %xmm2, %xmm11 \r\n pxor (%rdi) ,%xmm11 \r\n movdqu %xmm11, (%rsi) \r\n addq $16,%rdi \r\n addq $16,%rsi \r\n dec %r10 \r\n jne IN_LOOP_4 \r\nEND_4: \r\n ret \r\nTEST FUNCTIONS \r\nFigure 48. The ECB Main Function \r\n//#define AES128 \r\n//#define AES192 \r\n//#define AES256 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/02d31190-fbdd-457f-94e7-6800cc87658c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a6333e9a7c140d26fb7b613f4e97ed5921759c7b0d4eaddfc8d717cf3395d874",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8e281137-426d-4a23-a47c-be097421f81b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 63 \r\n#ifndef LENGTH \r\n#define LENGTH 64 \r\n#endif \r\n#include <stdint.h> \r\n#include <stdio.h> \r\n#include <wmmintrin.h> \r\n#if !defined (ALIGN16) \r\n# if defined (__GNUC__) \r\n# define ALIGN16 __attribute__ ( (aligned (16))) \r\n# else \r\n# define ALIGN16 __declspec (align (16)) \r\n# endif \r\n#endif \r\ntypedef struct KEY_SCHEDULE{ \r\n ALIGN16 unsigned char KEY[16*15]; \r\n unsigned int nr; \r\n }AES_KEY; \r\n/*test vectors were taken from http://csrc.nist.gov/publications/nistpubs/800-\r\n38a/sp800-38a.pdf*/ \r\nALIGN16 uint8_t AES128_TEST_KEY[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6, \r\n 0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; \r\nALIGN16 uint8_t AES192_TEST_KEY[] = {0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52, \r\n 0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5, \r\n 0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b}; \r\nALIGN16 uint8_t AES256_TEST_KEY[] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe, \r\n 0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81, \r\n 0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7, \r\n 0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}; \r\nALIGN16 uint8_t AES_TEST_VECTOR[] = {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96, \r\n 0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a, \r\n 0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c, \r\n 0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51, \r\n 0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11, \r\n 0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef, \r\n 0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17, \r\n 0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10}; \r\nALIGN16 uint8_t ECB128_EXPECTED[] = {0x3a,0xd7,0x7b,0xb4,0x0d,0x7a,0x36,0x60, \r\n 0xa8,0x9e,0xca,0xf3,0x24,0x66,0xef,0x97, \r\n 0xf5,0xd3,0xd5,0x85,0x03,0xb9,0x69,0x9d, \r\n 0xe7,0x85,0x89,0x5a,0x96,0xfd,0xba,0xaf, \r\n 0x43,0xb1,0xcd,0x7f,0x59,0x8e,0xce,0x23, \r\n 0x88,0x1b,0x00,0xe3,0xed,0x03,0x06,0x88, \r\n 0x7b,0x0c,0x78,0x5e,0x27,0xe8,0xad,0x3f, \r\n 0x82,0x23,0x20,0x71,0x04,0x72,0x5d,0xd4}; \r\nALIGN16 uint8_t ECB192_EXPECTED[] = {0xbd,0x33,0x4f,0x1d,0x6e,0x45,0xf2,0x5f, \r\n 0xf7,0x12,0xa2,0x14,0x57,0x1f,0xa5,0xcc, \r\n 0x97,0x41,0x04,0x84,0x6d,0x0a,0xd3,0xad, \r\n 0x77,0x34,0xec,0xb3,0xec,0xee,0x4e,0xef, \r\n 0xef,0x7a,0xfd,0x22,0x70,0xe2,0xe6,0x0a, \r\n 0xdc,0xe0,0xba,0x2f,0xac,0xe6,0x44,0x4e, \r\n 0x9a,0x4b,0x41,0xba,0x73,0x8d,0x6c,0x72, \r\n 0xfb,0x16,0x69,0x16,0x03,0xc1,0x8e,0x0e}; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/8e281137-426d-4a23-a47c-be097421f81b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=84d03d8e8b36fb8fa1f2cad892c9cc518a68be3457987142dfddbb2032df8581",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 432
      },
      {
        "segments": [
          {
            "segment_id": "6a94213b-13ad-4035-b853-739d69eae9af",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n64 323641-001 \r\nALIGN16 uint8_t ECB256_EXPECTED[] = {0xf3,0xee,0xd1,0xbd,0xb5,0xd2,0xa0,0x3c, \r\n 0x06,0x4b,0x5a,0x7e,0x3d,0xb1,0x81,0xf8, \r\n 0x59,0x1c,0xcb,0x10,0xd4,0x10,0xed,0x26, \r\n 0xdc,0x5b,0xa7,0x4a,0x31,0x36,0x28,0x70, \r\n 0xb6,0xed,0x21,0xb9,0x9c,0xa6,0xf4,0xf9, \r\n 0xf1,0x53,0xe7,0xb1,0xbe,0xaf,0xed,0x1d, \r\n 0x23,0x30,0x4b,0x7a,0x39,0xf9,0xf3,0xff, \r\n 0x06,0x7d,0x8d,0x8f,0x9e,0x24,0xec,0xc7}; \r\n/*****************************************************************************/ \r\nvoid print_m128i_with_string(char* string,__m128i data) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<16; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\nvoid print_m128i_with_string_short(char* string,__m128i data,int length) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<length; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\n/*****************************************************************************/ \r\nint main(){ \r\n AES_KEY key; \r\n AES_KEY decrypt_key; \r\n uint8_t *PLAINTEXT; \r\n uint8_t *CIPHERTEXT; \r\n uint8_t *DECRYPTEDTEXT; \r\n uint8_t *EXPECTED_CIPHERTEXT; \r\n uint8_t *CIPHER_KEY; \r\n int i,j; \r\n int key_length; \r\n if (!Check_CPU_support_AES()){ \r\n printf(\"Cpu does not support AES instruction set. Bailing out.\\n\"); \r\n return 1; \r\n } \r\n printf(\"CPU support AES instruction set.\\n\\n\"); \r\n#ifdef AES128 \r\n#define STR \"Performing AES128 ECB.\\n\" \r\n CIPHER_KEY = AES128_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = ECB128_EXPECTED; \r\n key_length = 128; \r\n#elif defined AES192 \r\n#define STR \"Performing AES192 ECB.\\n\" \r\n CIPHER_KEY = AES192_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = ECB192_EXPECTED; \r\n key_length = 192; \r\n#elif defined AES256 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/6a94213b-13ad-4035-b853-739d69eae9af.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=28fa8800dfd07929878e3ae760ee5199b9a7184b4e24df0bb78fa7415316b514",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "5f0dee5f-00bd-46c2-83b7-1cce214e41cf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 65 \r\n#define STR \"Performing AES256 ECB.\\n\" \r\n CIPHER_KEY = AES256_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = ECB256_EXPECTED; \r\n key_length = 256; \r\n#endif \r\n PLAINTEXT = (uint8_t*)malloc(LENGTH); \r\n CIPHERTEXT = (uint8_t*)malloc(LENGTH); \r\n DECRYPTEDTEXT = (uint8_t*)malloc(LENGTH); \r\n for(i=0 ;i<LENGTH/16/4; i++){ \r\n for(j=0; j<4; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[i*4+j], \r\n ((__m128i*)AES_TEST_VECTOR)[j]); \r\n } \r\n } \r\n for(j=i*4 ; j<LENGTH/16; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n if (LENGTH%16){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n \r\n AES_set_encrypt_key(CIPHER_KEY, key_length, &key); \r\n AES_set_decrypt_key(CIPHER_KEY, key_length, &decrypt_key); \r\n AES_ECB_encrypt(PLAINTEXT, \r\n CIPHERTEXT, \r\n LENGTH, \r\n key.KEY, \r\n key.nr); \r\n AES_ECB_decrypt(CIPHERTEXT, \r\n DECRYPTEDTEXT, \r\n LENGTH, \r\n decrypt_key.KEY, \r\n decrypt_key.nr); \r\n printf(\"%s\\n\",STR); \r\n printf(\"The Cipher Key:\\n\"); \r\n print_m128i_with_string(\"\",((__m128i*)CIPHER_KEY)[0]); \r\n if (key_length > 128) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHER_KEY)[1],(key_length/8) -16); \r\n printf(\"The Key Schedule:\\n\"); \r\n for (i=0; i< key.nr; i++) \r\n print_m128i_with_string(\"\",((__m128i*)key.KEY)[i]); \r\n \r\n printf(\"The PLAINTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) \r\n print_m128i_with_string(\"\",((__m128i*)PLAINTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)PLAINTEXT)[i],LENGTH%16); \r\n printf(\"\\n\\nThe CIPHERTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/5f0dee5f-00bd-46c2-83b7-1cce214e41cf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dfc2e0be10613d612fb55fc9ef8218d35d2c0a5519970efbf44a27d163ab00e5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "27ca549d-8c6c-45d0-94cb-004e7e9e497f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n66 323641-001 \r\n print_m128i_with_string(\"\",((__m128i*)CIPHERTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHERTEXT)[i],LENGTH%16); \r\n for(i=0; i<LENGTH; i++){ \r\n if (CIPHERTEXT[i] != EXPECTED_CIPHERTEXT[i%(16*4)]){ \r\n printf(\"The CIPHERTEXT is not equal to the EXPECTED CIHERTEXT.\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The CIPHERTEXT equals to the EXPECTED CIHERTEXT.\\n\\n\"); \r\n for(i=0; i<LENGTH; i++){ \r\n if (DECRYPTEDTEXT[i] != PLAINTEXT[i%(16*4)]){ \r\n printf(\"The DECRYPTED TEXT isn't equal to the original PLAINTEXT!\"); \r\n printf(\"\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The DECRYPTED TEXT equals to the original PLAINTEXT.\\n\\n\"); \r\n } \r\nFigure 49. CBC Main Function \r\n//#define AES128 \r\n//#define AES192 \r\n//#define AES256 \r\n#ifndef LENGTH \r\n#define LENGTH 64 \r\n#endif \r\n#include <stdint.h> \r\n#include <stdio.h> \r\n#include <wmmintrin.h> \r\n#if !defined (ALIGN16) \r\n# if defined (__GNUC__) \r\n# define ALIGN16 __attribute__ ( (aligned (16))) \r\n# else \r\n# define ALIGN16 __declspec (align (16)) \r\n# endif \r\n#endif \r\ntypedef struct KEY_SCHEDULE{ \r\n ALIGN16 unsigned char KEY[16*15]; \r\n unsigned int nr; \r\n }AES_KEY; \r\n/*test vectors were taken from http://csrc.nist.gov/publications/nistpubs/800-\r\n38a/sp800-38a.pdf*/ \r\nALIGN16 uint8_t AES128_TEST_KEY[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6, \r\n 0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}; \r\nALIGN16 uint8_t AES192_TEST_KEY[] = {0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52, \r\n 0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5, \r\n 0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b}; \r\nALIGN16 uint8_t AES256_TEST_KEY[] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe, \r\n 0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/27ca549d-8c6c-45d0-94cb-004e7e9e497f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1a5b00600a35d1498f750077b9c8cc7159b053ce39391e1ed82090a0edc599e5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      },
      {
        "segments": [
          {
            "segment_id": "92044b8f-4e7b-4779-9d41-82f9c1a27fb7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 67 \r\n 0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7, \r\n 0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}; \r\nALIGN16 uint8_t AES_TEST_VECTOR[] = {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96, \r\n 0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a, \r\n 0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c, \r\n 0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51, \r\n 0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11, \r\n 0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef, \r\n 0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17, \r\n 0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10}; \r\nALIGN16 uint8_t CBC_IV[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, \r\n 0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f}; \r\nALIGN16 uint8_t CBC128_EXPECTED[] = {0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46, \r\n 0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d, \r\n 0x50,0x86,0xcb,0x9b,0x50,0x72,0x19,0xee, \r\n 0x95,0xdb,0x11,0x3a,0x91,0x76,0x78,0xb2, \r\n 0x73,0xbe,0xd6,0xb8,0xe3,0xc1,0x74,0x3b, \r\n 0x71,0x16,0xe6,0x9e,0x22,0x22,0x95,0x16, \r\n 0x3f,0xf1,0xca,0xa1,0x68,0x1f,0xac,0x09, \r\n 0x12,0x0e,0xca,0x30,0x75,0x86,0xe1,0xa7}; \r\nALIGN16 uint8_t CBC192_EXPECTED[] = {0x4f,0x02,0x1d,0xb2,0x43,0xbc,0x63,0x3d, \r\n 0x71,0x78,0x18,0x3a,0x9f,0xa0,0x71,0xe8, \r\n 0xb4,0xd9,0xad,0xa9,0xad,0x7d,0xed,0xf4, \r\n 0xe5,0xe7,0x38,0x76,0x3f,0x69,0x14,0x5a, \r\n 0x57,0x1b,0x24,0x20,0x12,0xfb,0x7a,0xe0, \r\n 0x7f,0xa9,0xba,0xac,0x3d,0xf1,0x02,0xe0, \r\n 0x08,0xb0,0xe2,0x79,0x88,0x59,0x88,0x81, \r\n 0xd9,0x20,0xa9,0xe6,0x4f,0x56,0x15,0xcd}; \r\nALIGN16 uint8_t CBC256_EXPECTED[] = {0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba, \r\n 0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6, \r\n 0x9c,0xfc,0x4e,0x96,0x7e,0xdb,0x80,0x8d, \r\n 0x67,0x9f,0x77,0x7b,0xc6,0x70,0x2c,0x7d, \r\n 0x39,0xf2,0x33,0x69,0xa9,0xd9,0xba,0xcf, \r\n 0xa5,0x30,0xe2,0x63,0x04,0x23,0x14,0x61, \r\n 0xb2,0xeb,0x05,0xe2,0xc3,0x9b,0xe9,0xfc, \r\n 0xda,0x6c,0x19,0x07,0x8c,0x6a,0x9d,0x1b}; \r\n/*****************************************************************************/ \r\nvoid print_m128i_with_string(char* string,__m128i data) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<16; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\nvoid print_m128i_with_string_short(char* string,__m128i data,int length) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<length; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\n/*****************************************************************************/ \r\nint main(){ \r\n AES_KEY key; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/92044b8f-4e7b-4779-9d41-82f9c1a27fb7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8b16f5e5f74374ebbd300b37dfb8d76874104196fd8fe89e6b5c82400e636f23",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "cf219175-ab0d-4790-92e4-daa987a5347c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n68 323641-001 \r\n AES_KEY decrypt_key; \r\n uint8_t *PLAINTEXT; \r\n uint8_t *CIPHERTEXT; \r\n uint8_t *DECRYPTEDTEXT; \r\n uint8_t *EXPECTED_CIPHERTEXT; \r\n uint8_t *CIPHER_KEY; \r\n int i,j; \r\n int key_length; \r\n if (!Check_CPU_support_AES()){ \r\n printf(\"Cpu does not support AES instruction set. Bailing out.\\n\"); \r\n return 1; \r\n } \r\n printf(\"CPU support AES instruction set.\\n\\n\"); \r\n#ifdef AES128 \r\n#define STR \"Performing AES128 CBC.\\n\" \r\n CIPHER_KEY = AES128_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CBC128_EXPECTED; \r\n key_length = 128; \r\n#elif defined AES192 \r\n#define STR \"Performing AES192 CBC.\\n\" \r\n CIPHER_KEY = AES192_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CBC192_EXPECTED; \r\n key_length = 192; \r\n#elif defined AES256 \r\n#define STR \"Performing AES256 CBC.\\n\" \r\n CIPHER_KEY = AES256_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CBC256_EXPECTED; \r\n key_length = 256; \r\n#endif \r\n PLAINTEXT = (uint8_t*)malloc(LENGTH); \r\n CIPHERTEXT = (uint8_t*)malloc(LENGTH); \r\n DECRYPTEDTEXT = (uint8_t*)malloc(LENGTH); \r\n for(i=0 ;i<LENGTH/16/4; i++){ \r\n for(j=0; j<4; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[i*4+j], \r\n ((__m128i*)AES_TEST_VECTOR)[j]); \r\n } \r\n } \r\n for(j=i*4 ; j<LENGTH/16; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n if (LENGTH%16){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n \r\n AES_set_encrypt_key(CIPHER_KEY, key_length, &key); \r\n AES_set_decrypt_key(CIPHER_KEY, key_length, &decrypt_key); \r\n AES_CBC_encrypt(PLAINTEXT, \r\n CIPHERTEXT, \r\n CBC_IV, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/cf219175-ab0d-4790-92e4-daa987a5347c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e09ba9a94c823a9b88782d3e5fe5bda0c5a9e1e8de04deac1d20b299fd1521f7",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "212aba91-7d8a-4da7-8439-9202837d8bdf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 69 \r\n LENGTH, \r\n key.KEY, \r\n key.nr); \r\n AES_CBC_decrypt(CIPHERTEXT, \r\n DECRYPTEDTEXT, \r\n CBC_IV, \r\n LENGTH, \r\n decrypt_key.KEY, \r\n decrypt_key.nr); \r\n printf(\"%s\\n\",STR); \r\n printf(\"The Cipher Key:\\n\"); \r\n print_m128i_with_string(\"\",((__m128i*)CIPHER_KEY)[0]); \r\n if (key_length > 128) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHER_KEY)[1],(key_length/8) -16); \r\n printf(\"The Key Schedule:\\n\"); \r\n for (i=0; i< key.nr; i++) \r\n print_m128i_with_string(\"\",((__m128i*)key.KEY)[i]); \r\n printf(\"The PLAINTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) \r\n print_m128i_with_string(\"\",((__m128i*)PLAINTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)PLAINTEXT)[i],LENGTH%16); \r\n printf(\"\\n\\nThe CIPHERTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) \r\n print_m128i_with_string(\"\",((__m128i*)CIPHERTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHERTEXT)[i],LENGTH%16); \r\n for(i=0; i<((64<LENGTH)? 64 : LENGTH); i++){ \r\n if (CIPHERTEXT[i] != EXPECTED_CIPHERTEXT[i%64]){ \r\n printf(\"The ciphertext is not equal to the expected ciphertext.\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The CIPHERTEXT equals to the EXPECTED CIHERTEXT\" \r\n \" for bytes where expected text was entered.\\n\\n\"); \r\n for(i=0; i<LENGTH; i++){ \r\n if (DECRYPTEDTEXT[i] != PLAINTEXT[i%(16*4)]){ \r\n printf(\"%x\",DECRYPTEDTEXT[i]); \r\n printf(\"The DECRYPTED TEXT is not equal to the original\" \r\n \"PLAINTEXT.\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The DECRYPTED TEXT equals to the original PLAINTEXT.\\n\\n\"); \r\n } \r\nFigure 50. CTR Main Function \r\n#ifndef LENGTH \r\n#define LENGTH 64 ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/212aba91-7d8a-4da7-8439-9202837d8bdf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a43931b3d34842cfeb92ee2f6c124a4277a2ee9fc39fbe83e8c56b39ff503cf0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 391
      },
      {
        "segments": [
          {
            "segment_id": "1da67c2d-b50d-4e17-a70a-7ce7336f0f84",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n70 323641-001 \r\n#endif \r\n#include <stdint.h> \r\n#include <stdio.h> \r\n#include <wmmintrin.h> \r\n#if !defined (ALIGN16) \r\n# if defined (__GNUC__) \r\n# define ALIGN16 __attribute__ ( (aligned (16))) \r\n# else \r\n# define ALIGN16 __declspec (align (16)) \r\n# endif \r\n#endif \r\ntypedef struct KEY_SCHEDULE{ \r\n ALIGN16 unsigned char KEY[16*15]; \r\n unsigned int nr; \r\n }AES_KEY; \r\n/*test vectors were taken from http://w3.antd.nist.gov/iip_pubs/rfc3602.txt*/ \r\nALIGN16 uint8_t AES128_TEST_KEY[] = {0x7E,0x24,0x06,0x78,0x17,0xFA,0xE0,0xD7, \r\n 0x43,0xD6,0xCE,0x1F,0x32,0x53,0x91,0x63}; \r\nALIGN16 uint8_t AES192_TEST_KEY[] = {0x7C,0x5C,0xB2,0x40,0x1B,0x3D,0xC3,0x3C, \r\n 0x19,0xE7,0x34,0x08,0x19,0xE0,0xF6,0x9C, \r\n 0x67,0x8C,0x3D,0xB8,0xE6,0xF6,0xA9,0x1A}; \r\nALIGN16 uint8_t AES256_TEST_KEY[] = {0xF6,0xD6,0x6D,0x6B,0xD5,0x2D,0x59,0xBB, \r\n 0x07,0x96,0x36,0x58,0x79,0xEF,0xF8,0x86, \r\n 0xC6,0x6D,0xD5,0x1A,0x5B,0x6A,0x99,0x74, \r\n 0x4B,0x50,0x59,0x0C,0x87,0xA2,0x38,0x84}; \r\nALIGN16 uint8_t AES_TEST_VECTOR[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, \r\n 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F, \r\n 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17, \r\n 0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F}; \r\nALIGN16 uint8_t CTR128_IV[] = {0xC0,0x54,0x3B,0x59,0xDA,0x48,0xD9,0x0B}; \r\nALIGN16 uint8_t CTR192_IV[] = {0x02,0x0C,0x6E,0xAD,0xC2,0xCB,0x50,0x0D}; \r\nALIGN16 uint8_t CTR256_IV[] = {0xC1,0x58,0x5E,0xF1,0x5A,0x43,0xD8,0x75}; \r\nALIGN16 uint8_t CTR128_NONCE[] = {0x00,0x6C,0xB6,0xDB}; \r\nALIGN16 uint8_t CTR192_NONCE[] = {0x00,0x96,0xB0,0x3B}; \r\nALIGN16 uint8_t CTR256_NONCE[] = {0x00,0xFA,0xAC,0x24}; \r\nALIGN16 uint8_t CTR128_EXPECTED[] = {0x51,0x04,0xA1,0x06,0x16,0x8A,0x72,0xD9, \r\n 0x79,0x0D,0x41,0xEE,0x8E,0xDA,0xD3,0x88, \r\n 0xEB,0x2E,0x1E,0xFC,0x46,0xDA,0x57,0xC8, \r\n 0xFC,0xE6,0x30,0xDF,0x91,0x41,0xBE,0x28}; \r\nALIGN16 uint8_t CTR192_EXPECTED[] = {0x45,0x32,0x43,0xFC,0x60,0x9B,0x23,0x32, \r\n 0x7E,0xDF,0xAA,0xFA,0x71,0x31,0xCD,0x9F, \r\n 0x84,0x90,0x70,0x1C,0x5A,0xD4,0xA7,0x9C, \r\n 0xFC,0x1F,0xE0,0xFF,0x42,0xF4,0xFB,0x00}; \r\nALIGN16 uint8_t CTR256_EXPECTED[] = {0xF0,0x5E,0x23,0x1B,0x38,0x94,0x61,0x2C, \r\n 0x49,0xEE,0x00,0x0B,0x80,0x4E,0xB2,0xA9, \r\n 0xB8,0x30,0x6B,0x50,0x8F,0x83,0x9D,0x6A, ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/1da67c2d-b50d-4e17-a70a-7ce7336f0f84.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d801283769b139b70563bbdf2b858d5cc47d3e3d902e880c7ff829a01c2fc251",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "2946669e-dad9-4966-b413-84b1fbd1075c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 71 \r\n 0x55,0x30,0x83,0x1D,0x93,0x44,0xAF,0x1C}; \r\n/*****************************************************************************/ \r\nvoid print_m128i_with_string(char* string,__m128i data) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<16; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\nvoid print_m128i_with_string_short(char* string,__m128i data,int length) \r\n { \r\n unsigned char *pointer = (unsigned char*)&data; \r\n int i; \r\n printf(\"%-40s[0x\",string); \r\n for (i=0; i<length; i++) \r\n printf(\"%02x\",pointer[i]); \r\n printf(\"]\\n\"); \r\n } \r\n/*****************************************************************************/ \r\nint main(){ \r\n AES_KEY key; \r\n uint8_t *PLAINTEXT; \r\n uint8_t *CIPHERTEXT; \r\n uint8_t *DECRYPTEDTEXT; \r\n uint8_t *EXPECTED_CIPHERTEXT; \r\n uint8_t *CIPHER_KEY; \r\n uint8_t *NONCE; \r\n uint8_t *IV; \r\n int i,j; \r\n int key_length; \r\n if (!Check_CPU_support_AES()){ \r\n printf(\"Cpu does not support AES instruction set. Bailing out.\\n\"); \r\n return 1; \r\n } \r\n printf(\"CPU support AES instruction set.\\n\\n\"); \r\n#ifdef AES128 \r\n#define STR \"Performing AES128 CTR.\\n\" \r\n CIPHER_KEY = AES128_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CTR128_EXPECTED; \r\n IV = CTR128_IV; \r\n NONCE = CTR128_NONCE; \r\n key_length = 128; \r\n#elif defined AES192 \r\n#define STR \"Performing AES192 CTR.\\n\" \r\n CIPHER_KEY = AES192_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CTR192_EXPECTED; \r\n IV = CTR192_IV; \r\n NONCE = CTR192_NONCE; \r\n key_length = 192; \r\n#elif defined AES256 \r\n#define STR \"Performing AES256 CTR.\\n\" \r\n CIPHER_KEY = AES256_TEST_KEY; \r\n EXPECTED_CIPHERTEXT = CTR256_EXPECTED; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/2946669e-dad9-4966-b413-84b1fbd1075c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=04a5842ee6d8074f40ac88f1d9e8ad1c9168a873a644d3b78a6589b994b2b61a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3488ad32-a855-421f-b075-c3a9736559cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n72 323641-001 \r\n IV = CTR256_IV; \r\n NONCE = CTR256_NONCE; \r\n key_length = 256; \r\n#endif \r\n PLAINTEXT = (uint8_t*)malloc(LENGTH); \r\n CIPHERTEXT = (uint8_t*)malloc(LENGTH); \r\n DECRYPTEDTEXT = (uint8_t*)malloc(LENGTH); \r\n for(i=0 ;i<LENGTH/16/2; i++){ \r\n for(j=0; j<2; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[i*2+j], \r\n ((__m128i*)AES_TEST_VECTOR)[j]); \r\n } \r\n } \r\n for(j=i*2 ; j<LENGTH/16; j++){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n if (LENGTH%16){ \r\n _mm_storeu_si128(&((__m128i*)PLAINTEXT)[j], \r\n ((__m128i*)AES_TEST_VECTOR)[j%4]); \r\n } \r\n \r\n AES_set_encrypt_key(CIPHER_KEY, key_length, &key); \r\n AES_CTR_encrypt(PLAINTEXT, \r\n CIPHERTEXT, \r\n IV, \r\n NONCE, \r\n LENGTH, \r\n key.KEY, \r\n key.nr); \r\n AES_CTR_encrypt(CIPHERTEXT, \r\n DECRYPTEDTEXT, \r\n IV, \r\n NONCE, \r\n LENGTH, \r\n key.KEY, \r\n key.nr); \r\n printf(\"%s\\n\",STR); \r\n printf(\"The Cipher Key:\\n\"); \r\n print_m128i_with_string(\"\",((__m128i*)CIPHER_KEY)[0]); \r\n if (key_length > 128) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHER_KEY)[1],(key_length/8) -16); \r\n printf(\"The Key Schedule:\\n\"); \r\n for (i=0; i< key.nr; i++) \r\n print_m128i_with_string(\"\",((__m128i*)key.KEY)[i]); \r\n printf(\"The PLAINTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) \r\n print_m128i_with_string(\"\",((__m128i*)PLAINTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)PLAINTEXT)[i],LENGTH%16); ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/3488ad32-a855-421f-b075-c3a9736559cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aaaf4fa77dfb92e55fddaa7f16f20db6eca306a275b489e6c7917c09797d5cf3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 396
      },
      {
        "segments": [
          {
            "segment_id": "a17321df-1ac6-47c6-811b-4f40337fec3a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 73 \r\n printf(\"\\n\\nThe CIPHERTEXT:\\n\"); \r\n for (i=0; i< LENGTH/16; i++) \r\n print_m128i_with_string(\"\",((__m128i*)CIPHERTEXT)[i]); \r\n if (LENGTH%16) \r\n print_m128i_with_string_short(\"\",((__m128i*)CIPHERTEXT)[i],LENGTH%16); \r\n for(i=0; i< ((32<LENGTH)? 32 : LENGTH); i++){ \r\n if (CIPHERTEXT[i] != EXPECTED_CIPHERTEXT[i%(16*2)]){ \r\n printf(\"The ciphertext is not equal to the expected ciphertext.\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The CIPHERTEXT equals to the EXPECTED CIHERTEXT\" \r\n \" for bytes where expected text was entered.\\n\\n\"); \r\n for(i=0; i<LENGTH; i++){ \r\n if (DECRYPTEDTEXT[i] != PLAINTEXT[i]){ \r\n printf(\"The DECRYPTED TEXT is not equal to the original\" \r\n \"PLAINTEXT.\\n\\n\"); \r\n return 1; \r\n } \r\n } \r\n printf(\"The DECRYPTED TEXT equals to the original PLAINTEXT.\\n\\n\"); \r\n } \r\nHow to Use the Library \r\nThe functions provided above can be copied into files, compiled and linked into working \r\nexecutables, for example, as follows: \r\nSave the functions from Figure 39, 40, 41 into a single file (key_expansion.s) \r\nSave the code from Figure 42 (aes.c) \r\nSave the code from Figures 43, 44 (ecb.s), Figures 45,46 (cbc.s), and Figure \r\n47 (ctr.s). \r\nCompile the .s files by using \r\ngcc –maes –msse4 *.s (use gcc version 4.4.2 and above). \r\nSave the test functions from Figures 48, 49, 50 (ecb_main.c, cbc_main.c and \r\nctr_main.c). \r\nLink the required files with gcc, and generate the desired executable. \r\nCODE OUTPUTS \r\nFor ECB use: \r\nicc ecb_main.c ecb.o key_expansion.o aes.c –D[AES128/192/256] –o ecb_exe \r\n(or gcc –maes –msse4) \r\nTo define parameter length, use –DLENGTH=xxxx during compilation ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/a17321df-1ac6-47c6-811b-4f40337fec3a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fff1557bc726164b53dd81f0e4be8e7199b191625be720e4d28058d12c43af29",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4ad109d1-41be-478c-ad64-fa092959e3fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n74 323641-001 \r\nFigure 51. ECB Output Example \r\nCPU support AES instruction set. \r\nPerforming AES192 ECB. \r\nThe Cipher Key: \r\n [0x8e73b0f7da0e6452c810f32b809079e5] \r\n [0x62f8ead2522c6b7b] \r\nThe Key Schedule: \r\n [0x8e73b0f7da0e6452c810f32b809079e5] \r\n [0x62f8ead2522c6b7bfe0c91f72402f5a5] \r\n [0xec12068e6c827f6b0e7a95b95c56fec2] \r\n [0x4db7b4bd69b5411885a74796e92538fd] \r\n [0xe75fad44bb095386485af05721efb14f] \r\n [0xa448f6d94d6dce24aa326360113b30e6] \r\n [0xa25e7ed583b1cf9a27f939436a94f767] \r\n [0xc0a69407d19da4e1ec1786eb6fa64971] \r\n [0x485f703222cb8755e26d135233f0b7b3] \r\n [0x40beeb282f18a2596747d26b458c553e] \r\n [0xa7e1466c9411f1df821f750aad07d753] \r\n [0xca4005388fcc5006282d166abc3ce7b5] \r\nThe PLAINTEXT: \r\n [0x6bc1bee22e409f96e93d7e117393172a] \r\n [0xae2d8a571e03ac9c9eb76fac45af8e51] \r\n [0x30c81c46a35ce411e5fbc1191a0a52ef] \r\n [0xf69f2445df4f9b17ad2b417be66c3710] \r\nThe CIPHERTEXT: \r\n [0xbd334f1d6e45f25ff712a214571fa5cc] \r\n [0x974104846d0ad3ad7734ecb3ecee4eef] \r\n [0xef7afd2270e2e60adce0ba2face6444e] \r\n [0x9a4b41ba738d6c72fb16691603c18e0e] \r\nThe CIPHERTEXT equals to the EXPECTED CIHERTEXT. \r\nThe DECRYPTED TEXT equals to the original PLAINTEXT. \r\nFor CBC use: \r\nicc cbc_main.c cbc.o key_expansion.o aes.c –D[AES128/192/256] –o cbc_exe \r\nFigure 52. CBC Output Example \r\nCPU support AES instruction set. \r\nPerforming AES128 CBC. \r\nThe Cipher Key: \r\n [0x2b7e151628aed2a6abf7158809cf4f3c] \r\nThe Key Schedule: \r\n [0x2b7e151628aed2a6abf7158809cf4f3c] \r\n [0xa0fafe1788542cb123a339392a6c7605] \r\n [0xf2c295f27a96b9435935807a7359f67f] \r\n [0x3d80477d4716fe3e1e237e446d7a883b] \r\n [0xef44a541a8525b7fb671253bdb0bad00] \r\n [0xd4d1c6f87c839d87caf2b8bc11f915bc] \r\n [0x6d88a37a110b3efddbf98641ca0093fd] \r\n [0x4e54f70e5f5fc9f384a64fb24ea6dc4f] \r\n [0xead27321b58dbad2312bf5607f8d292f] \r\n [0xac7766f319fadc2128d12941575c006e] \r\nThe PLAINTEXT: \r\n [0x6bc1bee22e409f96e93d7e117393172a] \r\n [0xae2d8a571e03ac9c9eb76fac45af8e51] \r\n [0x30c81c46a35ce411e5fbc1191a0a52ef] ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/4ad109d1-41be-478c-ad64-fa092959e3fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=72ca2c710d27cde3c6eab4577adaaaceb2bfd0b39ff676a52b3d61633beeeef8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6b33fa69-de34-4757-8ca0-3dd13d8fe941",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 75 \r\n [0xf69f2445df4f9b17ad2b417be66c3710] \r\nThe CIPHERTEXT: \r\n [0x7649abac8119b246cee98e9b12e9197d] \r\n [0x5086cb9b507219ee95db113a917678b2] \r\n [0x73bed6b8e3c1743b7116e69e22229516] \r\n [0x3ff1caa1681fac09120eca307586e1a7] \r\nThe CIPHERTEXT equals to the EXPECTED CIHERTEXT for bytes where expected text was entered. \r\nThe DECRYPTED TEXT equals to the original PLAINTEXT. \r\nFor CTR: \r\nicc ctr_main.c ctr.o key_expansion.o aes.c –D[AES128/192/256] –o ctr_exe \r\nFigure 53. CTR Output Example \r\nCPU support AES instruction set. \r\nPerforming AES256 CTR. \r\nThe Cipher Key: \r\n [0xf6d66d6bd52d59bb0796365879eff886] \r\n [0xc66dd51a5b6a99744b50590c87a23884] \r\nThe Key Schedule: \r\n [0xf6d66d6bd52d59bb0796365879eff886] \r\n [0xc66dd51a5b6a99744b50590c87a23884] \r\n [0xcdd1327c18fc6bc71f6a5d9f6685a519] \r\n [0xf5fad3ceae904abae5c013b662622b32] \r\n [0x652011d67ddc7a1162b6278e04338297] \r\n [0x0739c046a9a98afc4c69994a2e0bb278] \r\n [0x4a17ade737cbd7f6557df078514e72ef] \r\n [0xd61680997fbf0a6533d6932f1ddd2157] \r\n [0x83eaf643b42121b5e15cd1cdb012a322] \r\n [0x31df8a0a4e60806f7db61340606b3217] \r\n [0xecc9069358e82726b9b4f6eb09a655c9] \r\n [0x30fb76d77e9bf6b8032de5f86346d7ef] \r\n [0x96c7d968ce2ffe4e779b08a57e3d5d6c] \r\n [0xc3dc3a87bd47cc3fbe6a29c7dd2cfe28] \r\nThe PLAINTEXT: \r\n [0x000102030405060708090a0b0c0d0e0f] \r\n [0x101112131415161718191a1b1c1d1e1f] \r\n [0x000102030405060708090a0b0c0d0e0f] \r\n [0x101112131415161718191a1b1c1d1e1f] \r\nThe CIPHERTEXT: \r\n [0xf05e231b3894612c49ee000b804eb2a9] \r\n [0xb8306b508f839d6a5530831d9344af1c] \r\n [0xd59e1f4edc334422d0192f2679722a1c] \r\n [0x2a771e7d6ae0d56113dcc8762b8bc18d] \r\nThe CIPHERTEXT equals to the EXPECTED CIHERTEXT for bytes where expected text was entered. \r\nThe DECRYPTED TEXT equals to the original PLAINTEXT. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/6b33fa69-de34-4757-8ca0-3dd13d8fe941.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fe1592d4e2e21377aedc8383a49a9c8ed0ccf0030ab71a22054ff49b348932b1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 448
      },
      {
        "segments": [
          {
            "segment_id": "2a3042bb-e348-498a-939c-d45b455588e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n76 323641-001 \r\nPerformance Results \r\nThis chapter provides the Intel microarchitecture codename Westmere performance \r\nresults (single thread only) obtained from running the code given in the “AES Library” \r\nchapter. The performance measurements of the given functions were carried out by \r\nusing the Time Stamp Counter (RDTSC instruction) and averaging over a large number \r\nof repetitions, after some “warmup” iterations. The following “measurement macro” was \r\nused. \r\nFigure 54. The Measurement Macro \r\n#ifndef REPEAT \r\n #define REPEAT 1000000 \r\n#endif \r\n#ifndef WARMUP \r\n #define WARMUP REPEAT/4 \r\n#endif \r\n UINT64 start_clk,end_clk; \r\n double total_clk; \r\n__inline UINT64 get_Clks(void) { \r\n UINT64 tmp; \r\n __asm__ volatile( \r\n \"rdtsc\\n\\t\\ \r\n mov %%eax,(%0)\\n\\t\\ \r\n mov %%edx,4(%0)\"::\"rm\"(&tmp):\"eax\",\"edx\"); \r\n return tmp; \r\n} \r\n#define MEASURE(x) for (i=0; i< WARMUP; i++) \\ \r\n {x;} \\ \r\n start_clk=get_Clks(); \\ \r\n for (i = 0; i < REPEAT; i++) \\ \r\n { \\ \r\n {x;} \\ \r\n } \\ \r\n end_clk=get_Clks(); \\ \r\n total_clk=(double)(end_clk-start_clk)/REPEAT; \r\nThe experiments were carried out on a processor based on Intel microarchitecture \r\ncodename Westmere running at 2.67 GHz. The system was run with Intel® Turbo Boost \r\nTechnology, Intel® Hyper-Threading Technology, and Enhanced Intel Speedstep®\r\nTechnology disabled, and no X server and no network daemon running. The operating \r\nsystem was Linux (OpenSuse 11.1 64 bits). \r\nPerformance Results ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/2a3042bb-e348-498a-939c-d45b455588e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4ab51fe448c1e05f546088357a27728e4a76818c8aeac823fe4cd8a87977aeaa",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e4262343-11ac-46b4-b9bb-f6cafb84d50f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 77 \r\nAES Key Expansion \r\nKey Size Cycles \r\nAES-128 108 \r\nAES-192 104 \r\nAES-256 136 \r\nTable 1. The Performance of the AES Key Expansion (Processor based on Intel \r\nmicroarchitecture codename Westmere) \r\n AES 128 AES 192 AES 256 \r\n Performance in CPU Cycles Per Byte for a 1KB buffer \r\nECB \r\nEncryption \r\n1.28 1.53 1.76 \r\nECB \r\nDecryption \r\n1.26 1.51 1.76 \r\nCBC \r\nEncryption \r\n4.15 4.91 5.65 \r\nCBC \r\nDecryption \r\n1.30 1.53 1.78 \r\nCTR \r\nEncryption \r\n/Decryption \r\n1.38 1.61 1.88 \r\nTable 2. The Performance of AES Encryption and Decryption of a 1K Bytes Buffer, in Various \r\nModes of Operation (Processor based on Intel microarchitecture codename Westmere) \r\nCode: CBC encryption \r\nof 4 buffers in \r\nparallel \r\nECB encrypt of \r\n1 block \r\nCTR encrypt of \r\n1 block \r\n Performance in CPU Cycles Per Byte \r\nAES-128 1.33 2.01 2.09 \r\nTable 3. Additional Performance Numbers (Processor based on Intel microarchitecture \r\ncodename Westmere) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/e4262343-11ac-46b4-b9bb-f6cafb84d50f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=89d1ff21c6e801bfe51c3f6c402a6dcf3683e4508aba8b4a50d030c21f41a6f6",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f4dd9c00-f277-44cf-a0da-1b4e12b5e8cf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n78 323641-001 \r\nCode: Key \r\nExpansion \r\nCBC encrypt ECB encrypt CTR encrypt \r\n Performance in CPU Cycles Per Byte \r\nAES-128 164.00 17.66 15.38 19.60 \r\nTable 4. AES Performance Numbers in OpenSSL (Processor based on Intel microarchitecture \r\ncodename Westmere, without AES-NI) \r\nFigure 55. The Performance of AES-128 Encryption in ECB Mode, as a Function of the Buffer \r\nSize (Processor based on Intel microarchitecture codename Westmere) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/f4dd9c00-f277-44cf-a0da-1b4e12b5e8cf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d38767e40f57dc42a0c7cfcd103cdbe1097e09294d217fcaba9ab6c923814acb",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "0ba623f3-c666-4786-bddf-6a0b7b30b760",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 79 \r\nFigure 56. The Performance of AES-128 Decryption in CBC Mode, as a Function of the Buffer \r\nSize (Processor based on Intel microarchitecture codename Westmere) \r\nFigure 57. The Performance of AES-128 Encryption in CTR Mode, as a Function of the Buffer \r\nSize (Processor based on Intel microarchitecture codename Westmere) \r\nConclusion \r\nThis paper described the Intel®’ AES New Instructions set, which, starting January 2010, \r\nare now part of the Intel IA-32 architecture. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/0ba623f3-c666-4786-bddf-6a0b7b30b760.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=04f18ff41137ab0fb7b7cb7d5acd615ce3af6d503d7f11b311ea01564e2daf97",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 491
      },
      {
        "segments": [
          {
            "segment_id": "66faac20-5943-4504-aa2e-c57c83ec7fc9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n \r\n80 323641-001 \r\nSix new AES instructions are offered, to provide important performance and security \r\nbenefits. AES is the leading standard for symmetric encryption, used in a variety of \r\napplications. For example, OS level disk encryption is a notable usage model, which can \r\nbe greatly accelerated with the proposed instructions. Consequently, a high \r\nperformance and secure solution for AES computations in commodity processors is a \r\nuseful and important technology. \r\nThe new instructions support all standard AES key lengths and modes of operation, as \r\nwell as some non-standard variants, and usage models. They can increase performance \r\nby more than an order of magnitude for parallel modes of operation (e.g., CTR and \r\nCBC-decrypt), and provide roughly 2-3 fold gains for non-parallelizable modes (such as \r\nCBC-encrypt). The AES code, using the new instructions, which is given in this paper, \r\ncan run at ~1.3 C/B in parallel modes of operation. \r\nBeyond improving performance, the new instructions help address software side channel \r\nvulnerabilities, because they run with data-independent latency and do not use lookup \r\ntables. This eliminates the major timing and cache attacks (that can be launched by \r\nRing 3 spy codes) that threaten table-based software implementations of AES. \r\nAcknowledgements \r\nMany people have contributed to the concepts, the studies, and to the implementation \r\nof the AES architecture and micro-architecture. The list of contributors includes: \r\nRoee Bar, Frank Berry, Mayank Bomb, Brent Boswell, Ernie Brickell, Yuval Bustan, \r\nMark Buxton, Srinivas Chennupaty, Tiran Cohen, Martin Dixon, Jack Doweck, Vivek \r\nEchambadi, Wajdi Feghali, Shay Fux, Vinodh Gopal, Eugene Gorkov, Amit Gradstein, \r\nMostafa Hagog, Israel Hayun, Michael Kounavis, Ram Krishnamurthy, Sanu Mathew, \r\nHenry Ou, Efi Rosenfeld, Zeev Sperber, Kirk Yap. \r\nI also thank Roee Bar, Joseph Bonneau, Mark Buxton, Mark Charney, Kevin Gotze, \r\nMichael Kounavis, Paul Kocher, Vlad Krasnov, Shihjong Kuo, Hongjiu Lu, Mark Marson, \r\nTrevor Perrin, Aaron Tersteeg, for helpful suggestions and corrections to previous \r\nversions of this paper. \r\nAbout the Author \r\nShay Gueron is an Intel Principal Engineer. He works at the CPU Architecture \r\nDepartment in the Mobility Group, at the Israel Development Center. His interests \r\ninclude applied security, cryptography, and algorithms. Shay holds a Ph.D. degree in \r\napplied mathematics from Technion—Israel Institute of Technology. He is also an \r\nAssociate Professor at the Department of Mathematics of the Faculty of Science at the \r\nUniversity of Haifa in Israel. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/66faac20-5943-4504-aa2e-c57c83ec7fc9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=140f82052b0f102d5a3ce19cd4132460e9d2029d9cfd478c71575e6a42edc8b2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 388
      },
      {
        "segments": [
          {
            "segment_id": "bb1e92c6-7ac6-4b38-9fcc-a5842c2f35fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Advanced Encryption Standard (AES) New Instructions Set \r\n323641-001 81 \r\nINFORMATION IN THIS DOCUMENT IS PROVIDED IN CONNECTION WITH INTEL® PRODUCTS. NO LICENSE, EXPRESS OR IMPLIED, \r\nBY ESTOPPEL OR OTHERWISE, TO ANY INTELLECTUAL PROPERTY RIGHTS IS GRANTED BY THIS DOCUMENT. EXCEPT AS PROVIDED \r\nIN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL \r\nDISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY \r\nOR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, \r\nCOPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life \r\nsustaining, critical control or safety systems, or in nuclear facility applications. \r\nIntel may make changes to specifications and product descriptions at any time, without notice. Designers must not rely on the \r\nabsence or characteristics of any features or instructions marked \"reserved\" or \"undefined.\" Intel reserves these for future \r\ndefinition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them. The \r\ninformation here is subject to change without notice. Do not finalize a design with this information. \r\nThis specification, as well as the software described in it, is furnished under license and may only be used or copied in accordance \r\nwith the terms of the license. The information in this document is furnished for informational use only, is subject to change without \r\nnotice, and should not be construed as a commitment by Intel Corporation. Intel Corporation assumes no responsibility or liability \r\nfor any errors or inaccuracies that may appear in this document or any software that may be provided in association with this \r\ndocument. \r\nIntel processor numbers are not a measure of performance. Processor numbers differentiate features within each processor family, \r\nnot across different processor families. See www.intel.com/products/processor_number for details. \r\nThe Intel processor/chipset families may contain design defects or errors known as errata, which may cause the product to deviate \r\nfrom published specifications. Current characterized errata are available on request. \r\nCopies of documents, which have an order number and are referenced in this document, or other Intel literature, may be obtained\r\nby calling 1-800-548-4725, or by visiting Intel's Web Site. \r\nIntel and the Intel Logo are trademarks of Intel Corporation in the U.S. and other countries. \r\n*Other names and brands may be claimed as the property of others. \r\nCopyright © 2010, Intel Corporation. All rights reserved. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/d4e9162c-c35b-4fba-acfa-6035c80162c2/images/bb1e92c6-7ac6-4b38-9fcc-a5842c2f35fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042528Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9902e587283b874dca4ec40bb954760b5feb0e8a47694d56825bc1b93f2c42df",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 400
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Intel® Advanced Encryption Standard (AES) New Instructions Set\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": null}\n```\n"
        }
      ]
    }
  }
}