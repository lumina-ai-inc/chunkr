{
  "file_name": "LMAX Disruptor - High performance alternative to bounded queues for exchanging data between concurrent threads (Disruptor-1.0).pdf",
  "task_id": "1f285ca7-fc98-418f-9289-9e77fd42df58",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "f4dae155-dcf5-4204-979c-09d9624dfe43",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 1,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 1\r\nDisruptor:\r\nHigh performance alternative to bounded queues for \r\nexchanging data between concurrent threads\r\nMartin Thompson\r\nDave Farley\r\nMichael Barker\r\nPatricia Gee\r\nAndrew Stewart\r\nMay-2011\r\nhttp://code.google.com/p/disruptor/\r\n1 Abstract\r\nLMAX was established to create a very high performance financial exchange. As part of our work to accomplish this goal \r\nwe have evaluated several approaches to the design of such a system, but as we began to measure these we ran into \r\nsome fundamental limits with conventional approaches.\r\nMany applications depend on queues to exchange data between processing stages. Our performance testing showed \r\nthat the latency costs, when using queues in this way, were in the same order of magnitude as the cost of IO operations to \r\ndisk (RAID or SSD based disk system) – dramatically slow. If there are multiple queues in an end-to-end operation, this \r\nwill add hundreds of microseconds to the overall latency. There is clearly room for optimisation.\r\nFurther investigation and a focus on the computer science made us realise that the conflation of concerns inherent in \r\nconventional approaches, (e.g. queues and processing nodes) leads to contention in multi-threaded implementations, \r\nsuggesting that there may be a better approach.\r\nThinking about how modern CPUs work, something we like to call “mechanical sympathy”, using good design practices \r\nwith a strong focus on teasing apart the concerns, we came up with a data structure and a pattern of use that we have \r\ncalled the Disruptor.\r\nTesting has shown that the mean latency using the Disruptor for a three-stage pipeline is 3 orders of magnitude lower than \r\nan equivalent queue-based approach. In addition, the Disruptor handles approximately 8 times more throughput for the \r\nsame configuration.\r\nThese performance improvements represent a step change in the thinking around concurrent programming. This new \r\npattern is an ideal foundation for any asynchronous event processing architecture where high-throughput and low-latency \r\nis required. \r\nAt LMAX we have built an order matching engine, real-time risk management, and a highly available in-memory \r\ntransaction processing system all on this pattern to great success. Each of these systems has set new performance \r\nstandards that, as far as we can tell, are unsurpassed. \r\nHowever this is not a specialist solution that is only of relevance in the Finance industry. The Disruptor is a general\u0002purpose mechanism that solves a complex problem in concurrent programming in a way that maximizes performance, and \r\nthat is simple to implement. Although some of the concepts may seem unusual it has been our experience that systems \r\nbuilt to this pattern are significantly simpler to implement than comparable mechanisms.\r\nThe Disruptor has significantly less write contention, a lower concurrency overhead and is more cache friendly than \r\ncomparable approaches, all of which results in greater throughput with less jitter at lower latency. On processors at \r\nmoderate clock rates we have seen over 25 million messages per second and latencies lower than 50 nanoseconds. This \r\nperformance is a significant improvement compared to any other implementation that we have seen. This is very close to \r\nthe theoretical limit of a modern processor to exchange data between cores.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/f4dae155-dcf5-4204-979c-09d9624dfe43.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2bb796f984723e2a5f95bc0338c51ad4bdba733995c8b8205bff49f7ff0f9ee1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 505
      },
      {
        "segments": [
          {
            "segment_id": "69de409e-67d0-4b57-a7b0-066039cfc80c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 2,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 2\r\n2 Overview\r\nThe Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early \r\ndesigns focused on architectures derived from SEDA1and Actors2using pipelines for throughput. After profiling various \r\nimplementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. \r\nWe found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new \r\nqueue implementations with better performance. However it became evident that queues as a fundamental data structure \r\nare limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is \r\nthe result of our work to build a concurrent structure that cleanly separates these concerns.\r\n3 The Complexities of Concurrency\r\nIn the context of this document, and computer science in general, concurrency means not only that two or more tasks \r\nhappen in parallel, but also that they contend on access to resources. The contended resource may be a database, file, \r\nsocket or even a location in memory.\r\nConcurrent execution of code is about two things, mutual exclusion and visibility of change. Mutual exclusion is about \r\nmanaging contended updates to some resource. Visibility of change is about controlling when such changes are made\r\nvisible to other threads. It is possible to avoid the need for mutual exclusion if you can eliminate the need for contended \r\nupdates. If your algorithm can guarantee that any given resource is modified by only one thread, then mutual exclusion is \r\nunnecessary. Read and write operations require that all changes are made visible to other threads. However only\r\ncontended write operations require the mutual exclusion of the changes. \r\nThe most costly operation in any concurrent environment is a contended write access. To have multiple threads write to \r\nthe same resource requires complex and expensive coordination. Typically this is achieved by employing a locking \r\nstrategy of some kind. \r\n3.1 The Cost of Locks\r\nLocks provide mutual exclusion and ensure that the visibility of change occurs in an ordered manner. Locks are incredibly \r\nexpensive because they require arbitration when contended. This arbitration is achieved by a context switch to the \r\noperating system kernel which will suspend threads waiting on a lock until it is released. During such a context switch, as \r\nwell as releasing control to the operating system which may decide to do other house-keeping tasks while it has control, \r\nexecution context can lose previously cached data and instructions. This can have a serious performance impact on \r\nmodern processors. Fast user mode locks can be employed but these are only of any real benefit when not contended. \r\nWe will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which \r\nincrements a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel \r\nWestmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar \r\nacross all languages with the same basic primitives.\r\nOnce a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up \r\nsignificantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results \r\nof this simple experiment are shown in the table below:\r\nMethod Time (ms)\r\nSingle thread 300\r\nSingle thread with lock 10,000\r\nTwo threads with lock 224,000\r\nSingle thread with CAS 5,700\r\nTwo threads with CAS 30,000\r\nSingle thread with volatile write 4,700\r\nTable 1 - Comparative costs of contention\r\n3.2 The Costs of “CAS”\r\nA more efficient alternative to the use of locks can be employed for updating memory when the target of the update is a \r\nsingle word. These alternatives are based upon the atomic, or interlocked, instructions implemented in modern ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/69de409e-67d0-4b57-a7b0-066039cfc80c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dc605592a50373ed23bb343fb6307b16e43a0148bcdee09a797f234077129d58",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 644
      },
      {
        "segments": [
          {
            "segment_id": "69de409e-67d0-4b57-a7b0-066039cfc80c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 2,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 2\r\n2 Overview\r\nThe Disruptor is the result of our efforts to build the world’s highest performance financial exchange at LMAX. Early \r\ndesigns focused on architectures derived from SEDA1and Actors2using pipelines for throughput. After profiling various \r\nimplementations it became evident that the queuing of events between stages in the pipeline was dominating the costs. \r\nWe found that queues also introduced latency and high levels of jitter. We expended significant effort on developing new \r\nqueue implementations with better performance. However it became evident that queues as a fundamental data structure \r\nare limited due to the conflation of design concerns for the producers, consumers, and their data storage. The Disruptor is \r\nthe result of our work to build a concurrent structure that cleanly separates these concerns.\r\n3 The Complexities of Concurrency\r\nIn the context of this document, and computer science in general, concurrency means not only that two or more tasks \r\nhappen in parallel, but also that they contend on access to resources. The contended resource may be a database, file, \r\nsocket or even a location in memory.\r\nConcurrent execution of code is about two things, mutual exclusion and visibility of change. Mutual exclusion is about \r\nmanaging contended updates to some resource. Visibility of change is about controlling when such changes are made\r\nvisible to other threads. It is possible to avoid the need for mutual exclusion if you can eliminate the need for contended \r\nupdates. If your algorithm can guarantee that any given resource is modified by only one thread, then mutual exclusion is \r\nunnecessary. Read and write operations require that all changes are made visible to other threads. However only\r\ncontended write operations require the mutual exclusion of the changes. \r\nThe most costly operation in any concurrent environment is a contended write access. To have multiple threads write to \r\nthe same resource requires complex and expensive coordination. Typically this is achieved by employing a locking \r\nstrategy of some kind. \r\n3.1 The Cost of Locks\r\nLocks provide mutual exclusion and ensure that the visibility of change occurs in an ordered manner. Locks are incredibly \r\nexpensive because they require arbitration when contended. This arbitration is achieved by a context switch to the \r\noperating system kernel which will suspend threads waiting on a lock until it is released. During such a context switch, as \r\nwell as releasing control to the operating system which may decide to do other house-keeping tasks while it has control, \r\nexecution context can lose previously cached data and instructions. This can have a serious performance impact on \r\nmodern processors. Fast user mode locks can be employed but these are only of any real benefit when not contended. \r\nWe will illustrate the cost of locks with a simple demonstration. The focus of this experiment is to call a function which \r\nincrements a 64-bit counter in a loop 500 million times. This can be executed by a single thread on a 2.4Ghz Intel \r\nWestmere EP in just 300ms if written in Java. The language is unimportant to this experiment and results will be similar \r\nacross all languages with the same basic primitives.\r\nOnce a lock is introduced to provide mutual exclusion, even when the lock is as yet un-contended, the cost goes up \r\nsignificantly. The cost increases again, by orders of magnitude, when two or more threads begin to contend. The results \r\nof this simple experiment are shown in the table below:\r\nMethod Time (ms)\r\nSingle thread 300\r\nSingle thread with lock 10,000\r\nTwo threads with lock 224,000\r\nSingle thread with CAS 5,700\r\nTwo threads with CAS 30,000\r\nSingle thread with volatile write 4,700\r\nTable 1 - Comparative costs of contention\r\n3.2 The Costs of “CAS”\r\nA more efficient alternative to the use of locks can be employed for updating memory when the target of the update is a \r\nsingle word. These alternatives are based upon the atomic, or interlocked, instructions implemented in modern ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/69de409e-67d0-4b57-a7b0-066039cfc80c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dc605592a50373ed23bb343fb6307b16e43a0148bcdee09a797f234077129d58",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 644
      },
      {
        "segments": [
          {
            "segment_id": "94f1b5a5-ec65-40d3-826c-8f0cd8e8d1e4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 3,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 3\r\nprocessors. These are commonly known as CAS (Compare And Swap) operations, e.g. “lock cmpxchg” on x86. A CAS\r\noperation is a special machine-code instruction that allows a word in memory to be conditionally set as an atomic \r\noperation. For the “increment a counter experiment” each thread can spin in a loop reading the counter then try to \r\natomically set it to its new incremented value. The old and new values are provided as parameters to this instruction. If,\r\nwhen the operation is executed, the value of the counter matches the supplied expected value, the counter is updated with \r\nthe new value. If, on the other hand, the value is not as expected, the CAS operation will fail. It is then up to the thread \r\nattempting to perform the change to retry, re-reading the counter incrementing from that value and so on until the change\r\nsucceeds. This CAS approach is significantly more efficient than locks because it does not require a context switch to the \r\nkernel for arbitration. However CAS operations are not free of cost. The processor must lock its instruction pipeline to \r\nensure atomicity and employ a memory barrier to make the changes visible to other threads. CAS operations are \r\navailable in Java by using the java.util.concurrent.Atomic* classes. \r\nIf the critical section of the program is more complex than a simple increment of a counter it may take a complex state \r\nmachine using multiple CAS operations to orchestrate the contention. Developing concurrent programs using locks is \r\ndifficult; developing lock-free algorithms using CAS operations and memory barriers is many times more complex and it is \r\nvery difficult to prove that they are correct. \r\nThe ideal algorithm would be one with only a single thread owning all writes to a single resource with other threads \r\nreading the results. To read the results in a multi-processor environment requires memory barriers to make the changes \r\nvisible to threads running on other processors.\r\n3.3 Memory Barriers\r\nModern processors perform out-of-order execution of instructions and out-of-order loads and stores of data between \r\nmemory and execution units for performance reasons. The processors need only guarantee that program logic produces \r\nthe same results regardless of execution order. This is not an issue for single-threaded programs. However, when \r\nthreads share state it is important that all memory changes appear in order, at the point required, for the data exchange to \r\nbe successful. Memory barriers are used by processors to indicate sections of code where the ordering of memory\r\nupdates is important. They are the means by which hardware ordering and visibility of change is achieved between \r\nthreads. Compilers can put in place complimentary software barriers to ensure the ordering of compiled code, such \r\nsoftware memory barriers are in addition to the hardware barriers used by the processors themselves.\r\nModern CPUs are now much faster than the current generation of memory systems. To bridge this divide CPUs use \r\ncomplex cache systems which are effectively fast hardware hash tables without chaining. These caches are kept \r\ncoherent with other processor cache systems via message passing protocols. In addition, processors have “store buffers”\r\nto offload writes to these caches, and “invalidate queues” so that the cache coherency protocols can acknowledge \r\ninvalidation messages quickly for efficiency when a write is about to happen.\r\nWhat this means for data is that the latest version of any value could, at any stage after being written, be in a register, a \r\nstore buffer, one of many layers of cache, or in main memory. If threads are to share this value, it needs to be made \r\nvisible in an ordered fashion and this is achieved through the coordinated exchange of cache coherency messages. The \r\ntimely generation of these messages can be controlled by memory barriers.\r\nA read memory barrier orders load instructions on the CPU that executes it by marking a point in the invalidate queue for \r\nchanges coming into its cache. This gives it a consistent view of the world for write operations ordered before the read \r\nbarrier.\r\nA write barrier orders store instructions on the CPU that executes it by marking a point in the store buffer, thus flushing \r\nwrites out via its cache. This barrier gives an ordered view to the world of what store operations happen before the write \r\nbarrier.\r\nA full memory barrier orders both loads and stores but only on the CPU that executes it.\r\nSome CPUs have more variants in addition to these three primitives but these three are sufficient to understand the \r\ncomplexities of what is involved. In the Java memory model the read and write of a volatile field implements the read and\r\nwrite barriers respectively. This was made explicit in the Java Memory Model3as defined with the release of Java 5.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/94f1b5a5-ec65-40d3-826c-8f0cd8e8d1e4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4fd6c0558a997b2a7652ad0489d9ab788badd8eb1c587e7429f14269cd407164",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 786
      },
      {
        "segments": [
          {
            "segment_id": "94f1b5a5-ec65-40d3-826c-8f0cd8e8d1e4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 3,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 3\r\nprocessors. These are commonly known as CAS (Compare And Swap) operations, e.g. “lock cmpxchg” on x86. A CAS\r\noperation is a special machine-code instruction that allows a word in memory to be conditionally set as an atomic \r\noperation. For the “increment a counter experiment” each thread can spin in a loop reading the counter then try to \r\natomically set it to its new incremented value. The old and new values are provided as parameters to this instruction. If,\r\nwhen the operation is executed, the value of the counter matches the supplied expected value, the counter is updated with \r\nthe new value. If, on the other hand, the value is not as expected, the CAS operation will fail. It is then up to the thread \r\nattempting to perform the change to retry, re-reading the counter incrementing from that value and so on until the change\r\nsucceeds. This CAS approach is significantly more efficient than locks because it does not require a context switch to the \r\nkernel for arbitration. However CAS operations are not free of cost. The processor must lock its instruction pipeline to \r\nensure atomicity and employ a memory barrier to make the changes visible to other threads. CAS operations are \r\navailable in Java by using the java.util.concurrent.Atomic* classes. \r\nIf the critical section of the program is more complex than a simple increment of a counter it may take a complex state \r\nmachine using multiple CAS operations to orchestrate the contention. Developing concurrent programs using locks is \r\ndifficult; developing lock-free algorithms using CAS operations and memory barriers is many times more complex and it is \r\nvery difficult to prove that they are correct. \r\nThe ideal algorithm would be one with only a single thread owning all writes to a single resource with other threads \r\nreading the results. To read the results in a multi-processor environment requires memory barriers to make the changes \r\nvisible to threads running on other processors.\r\n3.3 Memory Barriers\r\nModern processors perform out-of-order execution of instructions and out-of-order loads and stores of data between \r\nmemory and execution units for performance reasons. The processors need only guarantee that program logic produces \r\nthe same results regardless of execution order. This is not an issue for single-threaded programs. However, when \r\nthreads share state it is important that all memory changes appear in order, at the point required, for the data exchange to \r\nbe successful. Memory barriers are used by processors to indicate sections of code where the ordering of memory\r\nupdates is important. They are the means by which hardware ordering and visibility of change is achieved between \r\nthreads. Compilers can put in place complimentary software barriers to ensure the ordering of compiled code, such \r\nsoftware memory barriers are in addition to the hardware barriers used by the processors themselves.\r\nModern CPUs are now much faster than the current generation of memory systems. To bridge this divide CPUs use \r\ncomplex cache systems which are effectively fast hardware hash tables without chaining. These caches are kept \r\ncoherent with other processor cache systems via message passing protocols. In addition, processors have “store buffers”\r\nto offload writes to these caches, and “invalidate queues” so that the cache coherency protocols can acknowledge \r\ninvalidation messages quickly for efficiency when a write is about to happen.\r\nWhat this means for data is that the latest version of any value could, at any stage after being written, be in a register, a \r\nstore buffer, one of many layers of cache, or in main memory. If threads are to share this value, it needs to be made \r\nvisible in an ordered fashion and this is achieved through the coordinated exchange of cache coherency messages. The \r\ntimely generation of these messages can be controlled by memory barriers.\r\nA read memory barrier orders load instructions on the CPU that executes it by marking a point in the invalidate queue for \r\nchanges coming into its cache. This gives it a consistent view of the world for write operations ordered before the read \r\nbarrier.\r\nA write barrier orders store instructions on the CPU that executes it by marking a point in the store buffer, thus flushing \r\nwrites out via its cache. This barrier gives an ordered view to the world of what store operations happen before the write \r\nbarrier.\r\nA full memory barrier orders both loads and stores but only on the CPU that executes it.\r\nSome CPUs have more variants in addition to these three primitives but these three are sufficient to understand the \r\ncomplexities of what is involved. In the Java memory model the read and write of a volatile field implements the read and\r\nwrite barriers respectively. This was made explicit in the Java Memory Model3as defined with the release of Java 5.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/94f1b5a5-ec65-40d3-826c-8f0cd8e8d1e4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4fd6c0558a997b2a7652ad0489d9ab788badd8eb1c587e7429f14269cd407164",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 786
      },
      {
        "segments": [
          {
            "segment_id": "b92c0252-74da-42af-aac1-c42e633d0d79",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 4,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 4\r\n3.4 Cache Lines\r\nThe way in which caching is used in modern processors is of immense importance to successful high performance \r\noperation. Such processors are enormously efficient at churning through data and instructions held in cache and yet, \r\ncomparatively, are massively inefficient when a cache miss occurs.\r\nOur hardware does not move memory around in bytes or words. For efficiency, caches are organised into cache-lines that \r\nare typically 32-256 bytes in size, the most common cache-line being 64 bytes. This is the level of granularity at which \r\ncache coherency protocols operate. This means that if two variables are in the same cache line, and they are written to by \r\ndifferent threads, then they present the same problems of write contention as if they were a single variable. This is a \r\nconcept know as “false sharing”. For high performance then, it is important to ensure that independent, but concurrently \r\nwritten, variables do not share the same cache-line if contention is to be minimised.\r\nWhen accessing memory in a predictable manner CPUs are able to hide the latency cost of accessing main memory by \r\npredicting which memory is likely to be accessed next and pre-fetching it into the cache in the background. This only \r\nworks if the processors can detect a pattern of access such as walking memory with a predictable “stride”. When iterating \r\nover the contents of an array the stride is predictable and so memory will be pre-fetched in cache lines, maximizing the \r\nefficiency of the access. Strides typically have to be less than 2048 bytes in either direction to be noticed by the \r\nprocessor. However, data structures like linked lists and trees tend to have nodes that are more widely distributed in \r\nmemory with no predictable stride of access. The lack of a consistent pattern in memory constrains the ability of the \r\nsystem to pre-fetch cache-lines, resulting in main memory accesses which can be more than 2 orders of magnitude less \r\nefficient.\r\n3.5 The Problems of Queues\r\nQueues typically use either linked-lists or arrays for the underlying storage of elements. If an in-memory queue is allowed \r\nto be unbounded then for many classes of problem it can grow unchecked until it reaches the point of catastrophic failure\r\nby exhausting memory. This happens when producers outpace the consumers. Unbounded queues can be useful in \r\nsystems where the producers are guaranteed not to outpace the consumers and memory is a precious resource, but there \r\nis always a risk if this assumption doesn’t hold and queue grows without limit. To avoid this catastrophic outcome, queues \r\nare commonly constrained in size (bounded). Keeping a queue bounded requires that it is either array-backed or that the \r\nsize is actively tracked.\r\nQueue implementations tend to have write contention on the head, tail, and size variables. When in use, queues are \r\ntypically always close to full or close to empty due to the differences in pace between consumers and producers. They \r\nvery rarely operate in a balanced middle ground where the rate of production and consumption is evenly matched. This \r\npropensity to be always full or always empty results in high levels of contention and/or expensive cache coherence. The \r\nproblem is that even when the head and tail mechanisms are separated using different concurrent objects such as locks or \r\nCAS variables, they generally occupy the same cache-line.\r\nThe concerns of managing producers claiming the head of a queue, consumers claiming the tail, and the storage of nodes \r\nin between make the designs of concurrent implementations very complex to manage beyond using a single large-grain \r\nlock on the queue. Large grain locks on the whole queue for put and take operations are simple to implement but \r\nrepresent a significant bottleneck to throughput. If the concurrent concerns are teased apart within the semantics of a \r\nqueue then the implementations become very complex for anything other than a single producer – single consumer \r\nimplementation.\r\nIn Java there is a further problem with the use of queues, as they are significant sources of garbage. Firstly, objects have \r\nto be allocated and placed in the queue. Secondly, if linked-list backed, objects have to be allocated representing the\r\nnodes of the list. When no longer referenced, all these objects allocated to support the queue implementation need to be \r\nre-claimed.\r\n3.6 Pipelines and Graphs\r\nFor many classes of problem it makes sense to wire together several processing stages into pipelines. Such pipelines\r\noften have parallel paths, being organised into graph-like topologies. The links between each stage are often\r\nimplemented by queues with each stage having its own thread.\r\nThis approach is not cheap - at each stage we have to incur the cost of en-queuing and de-queuing units of work. The \r\nnumber of targets multiplies this cost when the path must fork, and incurs an inevitable cost of contention when it must re\u0002join after such a fork.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/b92c0252-74da-42af-aac1-c42e633d0d79.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=977cfd3f92d922d3fa149f7245704384f02048747e10e7fcf9790f1dcd2b4a04",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 806
      },
      {
        "segments": [
          {
            "segment_id": "b92c0252-74da-42af-aac1-c42e633d0d79",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 4,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 4\r\n3.4 Cache Lines\r\nThe way in which caching is used in modern processors is of immense importance to successful high performance \r\noperation. Such processors are enormously efficient at churning through data and instructions held in cache and yet, \r\ncomparatively, are massively inefficient when a cache miss occurs.\r\nOur hardware does not move memory around in bytes or words. For efficiency, caches are organised into cache-lines that \r\nare typically 32-256 bytes in size, the most common cache-line being 64 bytes. This is the level of granularity at which \r\ncache coherency protocols operate. This means that if two variables are in the same cache line, and they are written to by \r\ndifferent threads, then they present the same problems of write contention as if they were a single variable. This is a \r\nconcept know as “false sharing”. For high performance then, it is important to ensure that independent, but concurrently \r\nwritten, variables do not share the same cache-line if contention is to be minimised.\r\nWhen accessing memory in a predictable manner CPUs are able to hide the latency cost of accessing main memory by \r\npredicting which memory is likely to be accessed next and pre-fetching it into the cache in the background. This only \r\nworks if the processors can detect a pattern of access such as walking memory with a predictable “stride”. When iterating \r\nover the contents of an array the stride is predictable and so memory will be pre-fetched in cache lines, maximizing the \r\nefficiency of the access. Strides typically have to be less than 2048 bytes in either direction to be noticed by the \r\nprocessor. However, data structures like linked lists and trees tend to have nodes that are more widely distributed in \r\nmemory with no predictable stride of access. The lack of a consistent pattern in memory constrains the ability of the \r\nsystem to pre-fetch cache-lines, resulting in main memory accesses which can be more than 2 orders of magnitude less \r\nefficient.\r\n3.5 The Problems of Queues\r\nQueues typically use either linked-lists or arrays for the underlying storage of elements. If an in-memory queue is allowed \r\nto be unbounded then for many classes of problem it can grow unchecked until it reaches the point of catastrophic failure\r\nby exhausting memory. This happens when producers outpace the consumers. Unbounded queues can be useful in \r\nsystems where the producers are guaranteed not to outpace the consumers and memory is a precious resource, but there \r\nis always a risk if this assumption doesn’t hold and queue grows without limit. To avoid this catastrophic outcome, queues \r\nare commonly constrained in size (bounded). Keeping a queue bounded requires that it is either array-backed or that the \r\nsize is actively tracked.\r\nQueue implementations tend to have write contention on the head, tail, and size variables. When in use, queues are \r\ntypically always close to full or close to empty due to the differences in pace between consumers and producers. They \r\nvery rarely operate in a balanced middle ground where the rate of production and consumption is evenly matched. This \r\npropensity to be always full or always empty results in high levels of contention and/or expensive cache coherence. The \r\nproblem is that even when the head and tail mechanisms are separated using different concurrent objects such as locks or \r\nCAS variables, they generally occupy the same cache-line.\r\nThe concerns of managing producers claiming the head of a queue, consumers claiming the tail, and the storage of nodes \r\nin between make the designs of concurrent implementations very complex to manage beyond using a single large-grain \r\nlock on the queue. Large grain locks on the whole queue for put and take operations are simple to implement but \r\nrepresent a significant bottleneck to throughput. If the concurrent concerns are teased apart within the semantics of a \r\nqueue then the implementations become very complex for anything other than a single producer – single consumer \r\nimplementation.\r\nIn Java there is a further problem with the use of queues, as they are significant sources of garbage. Firstly, objects have \r\nto be allocated and placed in the queue. Secondly, if linked-list backed, objects have to be allocated representing the\r\nnodes of the list. When no longer referenced, all these objects allocated to support the queue implementation need to be \r\nre-claimed.\r\n3.6 Pipelines and Graphs\r\nFor many classes of problem it makes sense to wire together several processing stages into pipelines. Such pipelines\r\noften have parallel paths, being organised into graph-like topologies. The links between each stage are often\r\nimplemented by queues with each stage having its own thread.\r\nThis approach is not cheap - at each stage we have to incur the cost of en-queuing and de-queuing units of work. The \r\nnumber of targets multiplies this cost when the path must fork, and incurs an inevitable cost of contention when it must re\u0002join after such a fork.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/b92c0252-74da-42af-aac1-c42e633d0d79.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=977cfd3f92d922d3fa149f7245704384f02048747e10e7fcf9790f1dcd2b4a04",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 806
      },
      {
        "segments": [
          {
            "segment_id": "87d31341-61f9-4908-be5e-247c5fd4686d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 5,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 5\r\nIt would be ideal if the graph of dependencies could be expressed without incurring the cost of putting the queues between \r\nstages.\r\n4 The Design of the LMAX disruptor\r\nWhile trying to address the problems described above, a design emerged through a rigorous separation of the concerns \r\nthat we saw as being conflated in queues. This approach was combined with a focus on ensuring that any data should be \r\nowned by only one thread for write access, therefore eliminating write contention. That design became known as the \r\n“Disruptor”. It was so named because it had elements of similarity for dealing with graphs of dependencies to the concept \r\nof “Phasers”4in Java 7, introduced to support Fork-Join. \r\nThe LMAX disruptor is designed to address all of the issues outlined above in an attempt to maximize the efficiency of \r\nmemory allocation, and operate in a cache-friendly manner so that it will perform optimally on modern hardware.\r\nAt the heart of the disruptor mechanism sits a pre-allocated bounded data structure in the form of a ring-buffer. Data is \r\nadded to the ring buffer through one or more producers and processed by one or more consumers.\r\n4.1 Memory Allocation\r\nAll memory for the ring buffer is pre-allocated on start up. A ring-buffer can store either an array of pointers to entries or \r\nan array of structures representing the entries. The limitations of the Java language mean that entries are associated with \r\nthe ring-buffer as pointers to objects. Each of these entries is typically not the data being passed itself, but a container for \r\nit. This pre-allocation of entries eliminates issues in languages that support garbage collection, since the entries will be re\u0002used and live for the duration of the Disruptor instance. The memory for these entries is allocated at the same time and it \r\nis highly likely that it will be laid out contiguously in main memory and so support cache striding. There is a proposal by \r\nJohn Rose to introduce “value types”5to the Java language which would allow arrays of tuples, like other languages such \r\nas C, and so ensure that memory would be allocated contiguously and avoid the pointer indirection.\r\nGarbage collection can be problematic when developing low-latency systems in a managed runtime environment like \r\nJava. The more memory that is allocated the greater the burden this puts on the garbage collector. Garbage collectors \r\nwork at their best when objects are either very short-lived or effectively immortal. The pre-allocation of entries in the ring \r\nbuffer means that it is immortal as far as garbage collector is concerned and so represents little burden. \r\nUnder heavy load queue-based systems can back up, which can lead to a reduction in the rate of processing, and results\r\nin the allocated objects surviving longer than they should, thus being promoted beyond the young generation with\r\ngenerational garbage collectors. This has two implications: first, the objects have to be copied between generations which \r\ncause latency jitter; second, these objects have to be collected from the old generation which is typically a much more \r\nexpensive operation and increases the likelihood of “stop the world” pauses that result when the fragmented memory \r\nspace requires compaction. In large memory heaps this can cause pauses of seconds per GB in duration.\r\n4.2 Teasing Apart the Concerns\r\nWe saw the following concerns as being conflated in all queue implementations, to the extent that this collection of distinct \r\nbehaviours tend to define the interfaces that queues implement:\r\n1. Storage of items being exchanged\r\n2. Coordination of producers claiming the next sequence for exchange\r\n3. Coordination of consumers being notified that a new item is available\r\nWhen designing a financial exchange in a language that uses garbage collection, too much memory allocation can be \r\nproblematic. So, as we have described linked-list backed queues are a not a good approach. Garbage collection is \r\nminimized if the entire storage for the exchange of data between processing stages can be pre-allocated. Further, if this \r\nallocation can be performed in a uniform chunk, then traversal of that data will be done in a manner that is very friendly to \r\nthe caching strategies employed by modern processors. A data-structure that meets this requirement is an array with all \r\nthe slots pre-filled. On creation of the ring buffer the Disruptor utilises the abstract factory pattern to pre-allocate the \r\nentries. When an entry is claimed, a producer can copy its data into the pre-allocated structure. \r\nOn most processors there is a very high cost for the remainder calculation on the sequence number, which determines the \r\nslot in the ring. This cost can be greatly reduced by making the ring size a power of 2. A bit mask of size minus one can \r\nbe used to perform the remainder operation efficiently.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/87d31341-61f9-4908-be5e-247c5fd4686d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8a725d1e52461ad7e150f32d89613b27703c3bcd434c6f544054d5b767109e64",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 789
      },
      {
        "segments": [
          {
            "segment_id": "87d31341-61f9-4908-be5e-247c5fd4686d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 5,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 5\r\nIt would be ideal if the graph of dependencies could be expressed without incurring the cost of putting the queues between \r\nstages.\r\n4 The Design of the LMAX disruptor\r\nWhile trying to address the problems described above, a design emerged through a rigorous separation of the concerns \r\nthat we saw as being conflated in queues. This approach was combined with a focus on ensuring that any data should be \r\nowned by only one thread for write access, therefore eliminating write contention. That design became known as the \r\n“Disruptor”. It was so named because it had elements of similarity for dealing with graphs of dependencies to the concept \r\nof “Phasers”4in Java 7, introduced to support Fork-Join. \r\nThe LMAX disruptor is designed to address all of the issues outlined above in an attempt to maximize the efficiency of \r\nmemory allocation, and operate in a cache-friendly manner so that it will perform optimally on modern hardware.\r\nAt the heart of the disruptor mechanism sits a pre-allocated bounded data structure in the form of a ring-buffer. Data is \r\nadded to the ring buffer through one or more producers and processed by one or more consumers.\r\n4.1 Memory Allocation\r\nAll memory for the ring buffer is pre-allocated on start up. A ring-buffer can store either an array of pointers to entries or \r\nan array of structures representing the entries. The limitations of the Java language mean that entries are associated with \r\nthe ring-buffer as pointers to objects. Each of these entries is typically not the data being passed itself, but a container for \r\nit. This pre-allocation of entries eliminates issues in languages that support garbage collection, since the entries will be re\u0002used and live for the duration of the Disruptor instance. The memory for these entries is allocated at the same time and it \r\nis highly likely that it will be laid out contiguously in main memory and so support cache striding. There is a proposal by \r\nJohn Rose to introduce “value types”5to the Java language which would allow arrays of tuples, like other languages such \r\nas C, and so ensure that memory would be allocated contiguously and avoid the pointer indirection.\r\nGarbage collection can be problematic when developing low-latency systems in a managed runtime environment like \r\nJava. The more memory that is allocated the greater the burden this puts on the garbage collector. Garbage collectors \r\nwork at their best when objects are either very short-lived or effectively immortal. The pre-allocation of entries in the ring \r\nbuffer means that it is immortal as far as garbage collector is concerned and so represents little burden. \r\nUnder heavy load queue-based systems can back up, which can lead to a reduction in the rate of processing, and results\r\nin the allocated objects surviving longer than they should, thus being promoted beyond the young generation with\r\ngenerational garbage collectors. This has two implications: first, the objects have to be copied between generations which \r\ncause latency jitter; second, these objects have to be collected from the old generation which is typically a much more \r\nexpensive operation and increases the likelihood of “stop the world” pauses that result when the fragmented memory \r\nspace requires compaction. In large memory heaps this can cause pauses of seconds per GB in duration.\r\n4.2 Teasing Apart the Concerns\r\nWe saw the following concerns as being conflated in all queue implementations, to the extent that this collection of distinct \r\nbehaviours tend to define the interfaces that queues implement:\r\n1. Storage of items being exchanged\r\n2. Coordination of producers claiming the next sequence for exchange\r\n3. Coordination of consumers being notified that a new item is available\r\nWhen designing a financial exchange in a language that uses garbage collection, too much memory allocation can be \r\nproblematic. So, as we have described linked-list backed queues are a not a good approach. Garbage collection is \r\nminimized if the entire storage for the exchange of data between processing stages can be pre-allocated. Further, if this \r\nallocation can be performed in a uniform chunk, then traversal of that data will be done in a manner that is very friendly to \r\nthe caching strategies employed by modern processors. A data-structure that meets this requirement is an array with all \r\nthe slots pre-filled. On creation of the ring buffer the Disruptor utilises the abstract factory pattern to pre-allocate the \r\nentries. When an entry is claimed, a producer can copy its data into the pre-allocated structure. \r\nOn most processors there is a very high cost for the remainder calculation on the sequence number, which determines the \r\nslot in the ring. This cost can be greatly reduced by making the ring size a power of 2. A bit mask of size minus one can \r\nbe used to perform the remainder operation efficiently.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/87d31341-61f9-4908-be5e-247c5fd4686d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8a725d1e52461ad7e150f32d89613b27703c3bcd434c6f544054d5b767109e64",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 789
      },
      {
        "segments": [
          {
            "segment_id": "203403c1-7317-4199-8435-8d76edd0c23f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 6,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 6\r\nAs we described earlier bounded queues suffer from contention at the head and tail of the queue. The ring buffer data \r\nstructure is free from this contention and concurrency primitives because these concerns have been teased out into \r\nproducer and consumer barriers through which the ring buffer must be accessed. The logic for these barriers is described \r\nbelow.\r\nIn most common usages of the Disruptor there is usually only one producer. Typical producers are file readers or network \r\nlisteners. In cases where there is a single producer there is no contention on sequence/entry allocation. \r\nIn more unusual usages where there are multiple producers, producers will race one another to claim the next entry in the \r\nring-buffer. Contention on claiming the next available entry can be managed with a simple CAS operation on the \r\nsequence number for that slot.\r\nOnce a producer has copied the relevant data to the claimed entry it can make it public to consumers by committing the \r\nsequence. This can be done without CAS by a simple busy spin until the other producers have reached this sequence in \r\ntheir own commit. Then this producer can advance the cursor signifying the next available entry for consumption.\r\nProducers can avoid wrapping the ring by tracking the sequence of consumers as a simple read operation before they \r\nwrite to the ring buffer.\r\nConsumers wait for a sequence to become available in the ring buffer before they read the entry. Various strategies can \r\nbe employed while waiting. If CPU resource is precious they can wait on a condition variable within a lock that gets \r\nsignalled by the producers. This obviously is a point of contention and only to be used when CPU resource is more \r\nimportant than latency or throughput. The consumers can also loop checking the cursor which represents the currently \r\navailable sequence in the ring buffer. This could be done with or without a thread yield by trading CPU resource against \r\nlatency. This scales very well as we have broken the contended dependency between the producers and consumers if we \r\ndo not use a lock and condition variable. Lock free multi-producer – multi-consumer queues do exist but they require \r\nmultiple CAS operations on the head, tail, size counters. The Disruptor does not suffer this CAS contention.\r\n4.3 Sequencing\r\nSequencing is the core concept to how the concurrency is managed in the Disruptor. Each producer and consumer works \r\noff a strict sequencing concept for how it interacts with the ring buffer. Producers claim the next slot in sequence when \r\nclaiming an entry in the ring. This sequence of the next available slot can be a simple counter in the case of only one \r\nproducer or an atomic counter updated using CAS operations in the case of multiple producers. Once a sequence value \r\nis claimed, this entry in the ring buffer is now available to be written to by the claiming producer. When the producer has \r\nfinished updating the entry it can commit the changes by updating a separate counter which represents the cursor on the \r\nring buffer for the latest entry available to consumers. The ring buffer cursor can be read and written in a busy spin by the \r\nproducers using memory barrier without requiring a CAS operation as below.\r\n long expectedSequence = claimedSequence – 1;\r\n while (cursor != expectedSequence)\r\n {\r\n // busy spin\r\n }\r\n cursor = claimedSequence;\r\nConsumers wait for a given sequence to become available by using a memory barrier to read the cursor. Once the cursor \r\nhas been updated the memory barriers ensure the changes to the entries in the ring buffer are visible to the consumers \r\nwho have waited on the cursor advancing.\r\nConsumers each contain their own sequence which they update as they process entries from the ring buffer. These \r\nconsumer sequences allow the producers to track consumers to prevent the ring from wrapping. Consumer sequences \r\nalso allow consumers to coordinate work on the same entry in an ordered manner\r\nIn the case of having only one producer, and regardless of the complexity of the consumer graph, no locks or CAS \r\noperations are required. The whole concurrency coordination can be achieved with just memory barriers on the discussed \r\nsequences. \r\n4.4 Batching Effect\r\nWhen consumers are waiting on an advancing cursor sequence in the ring buffer an interesting opportunity arises that is \r\nnot possible with queues. If the consumer finds the ring buffer cursor has advanced a number of steps since it last ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/203403c1-7317-4199-8435-8d76edd0c23f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8db77803e8fd885b6de56e5ec41c7637b676d9a4b9f891789f342ba10c84737c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 739
      },
      {
        "segments": [
          {
            "segment_id": "203403c1-7317-4199-8435-8d76edd0c23f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 6,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 6\r\nAs we described earlier bounded queues suffer from contention at the head and tail of the queue. The ring buffer data \r\nstructure is free from this contention and concurrency primitives because these concerns have been teased out into \r\nproducer and consumer barriers through which the ring buffer must be accessed. The logic for these barriers is described \r\nbelow.\r\nIn most common usages of the Disruptor there is usually only one producer. Typical producers are file readers or network \r\nlisteners. In cases where there is a single producer there is no contention on sequence/entry allocation. \r\nIn more unusual usages where there are multiple producers, producers will race one another to claim the next entry in the \r\nring-buffer. Contention on claiming the next available entry can be managed with a simple CAS operation on the \r\nsequence number for that slot.\r\nOnce a producer has copied the relevant data to the claimed entry it can make it public to consumers by committing the \r\nsequence. This can be done without CAS by a simple busy spin until the other producers have reached this sequence in \r\ntheir own commit. Then this producer can advance the cursor signifying the next available entry for consumption.\r\nProducers can avoid wrapping the ring by tracking the sequence of consumers as a simple read operation before they \r\nwrite to the ring buffer.\r\nConsumers wait for a sequence to become available in the ring buffer before they read the entry. Various strategies can \r\nbe employed while waiting. If CPU resource is precious they can wait on a condition variable within a lock that gets \r\nsignalled by the producers. This obviously is a point of contention and only to be used when CPU resource is more \r\nimportant than latency or throughput. The consumers can also loop checking the cursor which represents the currently \r\navailable sequence in the ring buffer. This could be done with or without a thread yield by trading CPU resource against \r\nlatency. This scales very well as we have broken the contended dependency between the producers and consumers if we \r\ndo not use a lock and condition variable. Lock free multi-producer – multi-consumer queues do exist but they require \r\nmultiple CAS operations on the head, tail, size counters. The Disruptor does not suffer this CAS contention.\r\n4.3 Sequencing\r\nSequencing is the core concept to how the concurrency is managed in the Disruptor. Each producer and consumer works \r\noff a strict sequencing concept for how it interacts with the ring buffer. Producers claim the next slot in sequence when \r\nclaiming an entry in the ring. This sequence of the next available slot can be a simple counter in the case of only one \r\nproducer or an atomic counter updated using CAS operations in the case of multiple producers. Once a sequence value \r\nis claimed, this entry in the ring buffer is now available to be written to by the claiming producer. When the producer has \r\nfinished updating the entry it can commit the changes by updating a separate counter which represents the cursor on the \r\nring buffer for the latest entry available to consumers. The ring buffer cursor can be read and written in a busy spin by the \r\nproducers using memory barrier without requiring a CAS operation as below.\r\n long expectedSequence = claimedSequence – 1;\r\n while (cursor != expectedSequence)\r\n {\r\n // busy spin\r\n }\r\n cursor = claimedSequence;\r\nConsumers wait for a given sequence to become available by using a memory barrier to read the cursor. Once the cursor \r\nhas been updated the memory barriers ensure the changes to the entries in the ring buffer are visible to the consumers \r\nwho have waited on the cursor advancing.\r\nConsumers each contain their own sequence which they update as they process entries from the ring buffer. These \r\nconsumer sequences allow the producers to track consumers to prevent the ring from wrapping. Consumer sequences \r\nalso allow consumers to coordinate work on the same entry in an ordered manner\r\nIn the case of having only one producer, and regardless of the complexity of the consumer graph, no locks or CAS \r\noperations are required. The whole concurrency coordination can be achieved with just memory barriers on the discussed \r\nsequences. \r\n4.4 Batching Effect\r\nWhen consumers are waiting on an advancing cursor sequence in the ring buffer an interesting opportunity arises that is \r\nnot possible with queues. If the consumer finds the ring buffer cursor has advanced a number of steps since it last ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/203403c1-7317-4199-8435-8d76edd0c23f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8db77803e8fd885b6de56e5ec41c7637b676d9a4b9f891789f342ba10c84737c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 739
      },
      {
        "segments": [
          {
            "segment_id": "5cc5edfe-44d2-4476-a487-f46b5ea6dd5b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 7,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 7\r\nchecked it can process up to that sequence without getting involved in the concurrency mechanisms. This results in the\r\nlagging consumer quickly regaining pace with the producers when the producers burst ahead thus balancing the system. \r\nThis type of batching increases throughput while reducing and smoothing latency at the same time. Based on our \r\nobservations, this effect results in a close to constant time for latency regardless of load, up until the memory sub-system\r\nis saturated, and then the profile is linear following Little’s Law6. This is very different to the “J” curve effect on latency we \r\nhave observed with queues as load increases.\r\n4.5 Dependency Graphs\r\nA queue represents the simple one step pipeline dependency between producers and consumers. If the consumers form \r\na chain or graph-like structure of dependencies then queues are required between each stage of the graph. This incurs \r\nthe fixed costs of queues many times within the graph of dependent stages. When designing the LMAX financial \r\nexchange our profiling showed that taking a queue based approach resulted in queuing costs dominating the total \r\nexecution costs for processing a transaction.\r\nBecause the producer and consumer concerns are separated with the Disruptor pattern, it is possible to represent a \r\ncomplex graph of dependencies between consumers while only using a single ring buffer at the core. This results in \r\ngreatly reduced fixed costs of execution thus increasing throughput while reducing latency.\r\nA single ring buffer can be used to store entries with a complex structure representing the whole workflow in a cohesive \r\nplace. Care must be taken in the design of such a structure so that the state written by independent consumers does not \r\nresult in false sharing of cache lines. \r\n4.6 Disruptor Class Diagram\r\nThe core relationships in the Disruptor framework are depicted in the class diagram below. This diagram leaves out the \r\nconvenience classes which can be used to simplify the programming model. After the dependency graph is constructed \r\nthe programming model is simple. Producers claim entries in sequence via a ProducerBarrier, write their changes into the \r\nclaimed entry, then commit that entry back via the ProducerBarrier making them available for consumption. As a \r\nconsumer all one needs do is provide a BatchHandler implementation that receives call backs when a new entry is \r\navailable. This resulting programming model is event based having a lot of similarities to the Actor Model.\r\nSeparating the concerns normally conflated in queue implementations allows for a more flexible design. A RingBuffer\r\nexists at the core of the Disruptor pattern providing storage for data exchange without contention. The concurrency \r\nconcerns are separated out for the producers and consumers interacting with the RingBuffer. The ProducerBarrier\r\nmanages any concurrency concerns associated with claiming slots in the ring buffer, while tracking dependant consumers \r\nto prevent the ring from wrapping. The ConsumerBarrier notifies consumers when new entries are available, and \r\nConsumers can be constructed into a graph of dependencies representing multiple stages in a processing pipeline.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/5cc5edfe-44d2-4476-a487-f46b5ea6dd5b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=773b047c04c1a680cb1d2ad80d46512c899455a1fad904a763a19d0f1a3b53d8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 492
      },
      {
        "segments": [
          {
            "segment_id": "c34f0e29-43cd-4c25-8019-c45f4ecfda9c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 8,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 8\r\n«interface» ProducerBarrier\r\n«interface» ConsumerBarrier «interface» Entry 1..* 1 RingBuffer\r\n«interface» ClaimStrategy «interface» WaitStrategy 1 1 1 1\r\n* 1 1 * «interface» Consumer 0..1 1..*\r\n0..* 0..*\r\nSingleThreadedClaimStrategy MultiThreadedClaimStrategy BusySpinWaitStrategy YieldingWaitStrategy BlockingWaitStrategy\r\n«interface» EntryFactory fill claim\r\nwaitFor\r\ntrack sequence\r\ntrack sequence\r\nwaitFor\r\n4.7 Code Example\r\nThe code below is an example of a single producer and single consumer using the convenience interface BatchHandler\r\nfor implementing a consumer. The consumer runs on a separate thread receiving entries as they become available.\r\n// Callback handler which can be implemented by consumers\r\nfinal BatchHandler<ValueEntry> batchHandler = new BatchHandler<ValueEntry>()\r\n{\r\n public void onAvailable(final ValueEntry entry) throws Exception\r\n {\r\n // process a new entry as it becomes available.\r\n }\r\n public void onEndOfBatch() throws Exception\r\n {\r\n // useful for flushing results to an IO device if necessary.\r\n }\r\n public void onCompletion()\r\n {\r\n // do any necessary clean up before shutdown\r\n }\r\n};\r\nRingBuffer<ValueEntry> ringBuffer =\r\n new RingBuffer<ValueEntry>(ValueEntry.ENTRY_FACTORY, SIZE,\r\n ClaimStrategy.Option.SINGLE_THREADED,\r\nWaitStrategy.Option.YIELDING);\r\nConsumerBarrier<ValueEntry> consumerBarrier = ringBuffer.createConsumerBarrier(); \r\nBatchConsumer<ValueEntry> batchConsumer = \r\n new BatchConsumer<ValueEntry>(consumerBarrier, batchHandler);\r\nProducerBarrier<ValueEntry> producerBarrier = ringBuffer.createProducerBarrier(batchConsumer); \r\n// Each consumer can run on a separate thread\r\nEXECUTOR.submit(batchConsumer);",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/c34f0e29-43cd-4c25-8019-c45f4ecfda9c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a98132420704e6f89856bcc79d118785845dcde77ef298423b0466844acc5d31",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6eb85026-279f-4fee-9e73-80eb868135a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 9,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 9\r\n// Producers claim entries in sequence\r\nValueEntry entry = producerBarrier.nextEntry();\r\n// copy data into the entry container\r\n// make the entry available to consumers\r\nproducerBarrier.commit(entry); \r\n5 Throughput Performance Testing\r\nAs a reference we choose Doug Lea’s excellent java.util.concurrent.ArrayBlockingQueue7 which has the highest \r\nperformance of any bounded queue based on our testing. The tests are conducted in a blocking programming style to \r\nmatch that of the Disruptor. The tests cases detailed below are available in the Disruptor open source project. Note: \r\nrunning the tests requires a system capable of executing at least 4 threads in parallel.\r\nUnicast: 1P – 1C\r\nThree Step Pipeline: 1P – 3C\r\nSequencer: 3P – 1C\r\nMulticast: 1P – 3C\r\nDiamond: 1P – 3C\r\nC1\r\nP1 C3\r\nC2\r\nC1\r\nP1 C2\r\nC3\r\nP1\r\nP2 C1\r\nP3\r\nP1 C1 C2 C3\r\nP1 C1",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/6eb85026-279f-4fee-9e73-80eb868135a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bcd53eb78a4a39800fd053b6822c5ac364aa1da31637d9f98d16abd0b0ec1d7f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 317
      },
      {
        "segments": [
          {
            "segment_id": "1b773b95-3825-4f56-9da1-4774f6780da9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 10,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 10\r\nFor the above configurations an ArrayBlockingQueue was applied for each arc of data flow compared to barrier \r\nconfiguration with the Disruptor. The following table shows the performance results in operations per second using a Java \r\n1.6.0_25 64-bit Sun JVM, Windows 7, Intel Core i7 860 @ 2.8 GHz without HT and Intel Core i7-2720QM, Ubuntu 11.04,\r\nand taking the best of 3 runs when processing 500 million messages. Results can vary substantially across different JVM \r\nexecutions and the figures below are not the highest we have observed.\r\nTable 2 - Comparative throughput (in ops per sec)\r\n6 Latency Performance Testing\r\nTo measure latency we take the three stage pipeline and generate events at less than saturation. This is achieved by \r\nwaiting 1 microsecond after injecting an event before injecting the next and repeating 50 million times. To time at this level \r\nof precision it is necessary to use time stamp counters from the CPU. We chose CPUs with an invariant TSC because \r\nolder processors suffer from changing frequency due to power saving and sleep states. Intel Nehalem and later \r\nprocessors use an invariant TSC which can be accessed by the latest Oracle JVMs running on Ubuntu 11.04. No CPU \r\nbinding has been employed for this test.\r\nFor comparison we use the ArrayBlockingQueue once again. We could have used ConcurrentLinkedQueue8 which is \r\nlikely to give better results but we want to use a bounded queue implementation to ensure producers do not outpace \r\nconsumers by creating back pressure. The results below are for 2.2Ghz Core i7-2720QM running Java 1.6.0_25 64-bit on \r\nUbuntu 11.04.\r\nMean latency per hop for the Disruptor comes out at 52 nanoseconds compared to 32,757 nanoseconds for \r\nArrayBlockingQueue. Profiling shows the use of locks and signalling via a condition variable are the main cause of latency \r\nfor the ArrayBlockingQueue. \r\nTable 3 - Comparative Latency in three stage pipeline\r\nNehalem 2.8Ghz – Windows 7 SP1 64-bit Sandy Bridge 2.2Ghz – Linux 2.6.38 64-bit\r\nABQ Disruptor ABQ Disruptor\r\nUnicast: 1P – 1C 5,339,256 25,998,336 4,057,453 22,381,378\r\nPipeline: 1P – 3C 2,128,918 16,806,157 2,006,903 15,857,913\r\nSequencer: 3P – 1C 5,539,531 13,403,268 2,056,118 14,540,519\r\nMulticast: 1P – 3C 1,077,384 9,377,871 260,733 10,860,121\r\nDiamond: 1P – 3C 2,113,941 16,143,613 2,082,725 15,295,197\r\nArray Blocking Queue (ns) Disruptor (ns)\r\nMin Latency 145 29\r\nMean Latency 32,757 52\r\n99% observations less than 2,097,152 128\r\n99.99% observations less than 4,194,304 8,192\r\nMax Latency 5,069,086 175,567",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/1b773b95-3825-4f56-9da1-4774f6780da9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=17ea6c42f13e31c3d80dae22439dac0b4305d1d9bd390b7340520ca827f431ec",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 399
      },
      {
        "segments": [
          {
            "segment_id": "ddb01f6e-2d5c-42ee-b719-91034d530d1a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 595.32,
              "height": 841.92
            },
            "page_number": 11,
            "page_width": 595.32,
            "page_height": 841.92,
            "content": "v1.0 11\r\n7 Conclusion\r\nThe Disruptor is a major step forward for increasing throughput, reducing latency between concurrent execution contexts\r\nand ensuring predictable latency, an important consideration in many applications. Our testing shows that it out-performs \r\ncomparable approaches for exchanging data between threads. We believe that this is the highest performance \r\nmechanism for such data exchange. By concentrating on a clean separation of the concerns involved in cross-thread data \r\nexchange, by eliminating write contention, minimizing read contention and ensuring that the code worked well with the \r\ncaching employed by modern processors, we have created a highly efficient mechanism for exchanging data between \r\nthreads in any application.\r\nThe batching effect that allows consumers to process entries up to a given threshold, without any contention, introduces a \r\nnew characteristic in high performance systems. For most systems, as load and contention increase there is an \r\nexponential increase in latency, the characteristic “J” curve. As load increases on the Disruptor, latency remains almost \r\nflat until saturation occurs of the memory sub-system.\r\nWe believe that the Disruptor establishes a new benchmark for high-performance computing and is very well placed to \r\ncontinue to take advantage of current trends in processor and computer design.\r\n \r\n1 Staged Event Driven Architecture – http://www.eecs.harvard.edu/~mdw/proj/seda/\r\n2 Actor model – http://dspace.mit.edu/handle/1721.1/6952\r\n3\r\nJava Memory Model - http://www.ibm.com/developerworks/library/j-jtp02244/index.html\r\n4 Phasers - http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166ydocs/jsr166y/Phaser.html\r\n5 Value Types - http://blogs.oracle.com/jrose/entry/tuples_in_the_vm\r\n6\r\nLittle’s Law - http://en.wikipedia.org/wiki/Little%27s_law\r\n7 ArrayBlockingQueue - http://download.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html\r\n8 ConcurrentLinkedQueue - http://download.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html\r\n1\r\n4\r\n16\r\n64\r\n256\r\n1024\r\n4096\r\n16384\r\n65536\r\n262144\r\n1048576\r\n4194304\r\n16777216\r\n67108864\r\n248\r\n163264\r\n128256512\r\n1,0242,0484,0968,192\r\n16,38432,76865,536\r\n131,072262,144524,288\r\n1,048,5762,097,1524,194,3048,388,608\r\nFrequency\r\nLatency (ns)\r\nDisruptor ArrayBlockingQueue",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/1f285ca7-fc98-418f-9289-9e77fd42df58/images/ddb01f6e-2d5c-42ee-b719-91034d530d1a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041633Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cb1ce65332d74a492d27ce853e2ddcdfeb4d93758b7693caa1d43831eac5e560",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 263
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Disruptor: High performance alternative to bounded queues for exchanging data between concurrent threads\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "```string\nMartin Thompson\nDave Farley\nMichael Barker\nPatricia Gee\nAndrew Stewart\n```"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "Value: May-2011"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "```json\n{\"location\": null}\n```\n"
        }
      ]
    }
  }
}