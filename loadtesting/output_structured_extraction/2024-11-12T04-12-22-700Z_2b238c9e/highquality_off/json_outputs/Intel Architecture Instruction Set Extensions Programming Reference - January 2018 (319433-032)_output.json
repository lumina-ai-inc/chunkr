{
  "file_name": "Intel Architecture Instruction Set Extensions Programming Reference - January 2018 (319433-032).pdf",
  "task_id": "a906755a-32b5-4013-a032-1d5bc6502072",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "1ba290d6-0cbb-4589-bba4-b02d1a827318",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Architecture\r\nInstruction Set Extensions and Future Features\r\nProgramming Reference\r\n319433-032\r\nJANUARY 2018",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1ba290d6-0cbb-4589-bba4-b02d1a827318.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c69a692a22cdce91cdff02e7a9e7591d86a3551c78e475a44e0ec17015d86f11",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1cbf5106-9d16-42e3-af2c-b5aa4f81c430",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "ii Ref. # 319433-032\r\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\r\nmore at intel.com, or from the OEM or retailer.\r\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\r\nfrom such losses.\r\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\r\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\r\nmatter disclosed herein.\r\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\r\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica\u0002tions. Current characterized errata are available on request.\r\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\r\nwithout notice. Intel does not guarantee the availability of these interfaces in any future product. Contact your Intel representative to obtain the\r\nlatest Intel product specifications and roadmaps.\r\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\r\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\r\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\r\nand/or other countries.\r\n*Other names and brands may be claimed as the property of others.\r\nCopyright © 1997-2018, Intel Corporation. All Rights Reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1cbf5106-9d16-42e3-af2c-b5aa4f81c430.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5e828cde5e43f94d0d30b4a87965dd2d20820e9693a3201ae8a0478c9bc29666",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 288
      },
      {
        "segments": [
          {
            "segment_id": "7e3ad26f-250f-4012-85cc-c9bfd01bc18c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 iii\r\nRevision History\r\nRevision Description Date\r\n-025\r\n• Removed instructions that now reside in the Intel® 64 and \r\nIA-32 Architectures Software Developer’s Manual.\r\n• Minor updates to chapter 1.\r\n• Updates to Table 2-1, Table 2-2 and Table 2-8 (leaf 07H) to \r\nindicate support for AVX512_4VNNIW and AVX512_4FMAPS.\r\n• Minor update to Table 2-8 (leaf 15H) regarding ECX \r\ndefinition.\r\n• Minor updates to Section 4.6.2 and Section 4.6.3 to clarify \r\nthe effects of “suppress all exceptions”.\r\n• Footnote addition to CLWB instruction indicating operand \r\nencoding requirement.\r\n• Removed PCOMMIT.\r\nSeptember 2016\r\n-026\r\n• Removed CLWB instruction; it now resides in the Intel® 64 \r\nand IA-32 Architectures Software Developer’s Manual.\r\n• Added additional 512-bit instruction extensions in chapter 6.\r\nOctober 2016\r\n-027\r\n• Added TLB CPUID leaf in chapter 2.\r\n• Added VPOPCNTD/Q instruction in chapter 6,and CPUID \r\ndetails in chapter 2.\r\nDecember 2016\r\n-028 • Updated intrinsics for VPOPCNTD/Q instruction in chapter 6. December 2016\r\n-029\r\n• Corrected typo in CPUID leaf 18H.\r\n• Updated operand encoding table format; extracted tuple \r\ninformation from operand encoding.\r\n• Added VPERMB back into chapter 5; inadvertently removed.\r\n• Moved all instructions from chapter 6 to chapter 5.\r\n• Updated operation section of VPMULTISHIFTQB.\r\nApril 2017\r\n-030\r\n• Removed unnecessary information from document (chapters \r\n2, 3 and 4).\r\n• Added table listing recent instruction set extensions \r\nintroduction in Intel 64 and IA-32 Processors.\r\n• Updated CPUID instruction with additional details.\r\n• Added the following instructions: GF2P8AFFINEINVQB, \r\nGF2P8AFFINEQB, GF2P8MULB, VAESDEC, VAESDECLAST, \r\nVAESENC, VAESENCLAST, VPCLMULQDQ, VPCOMPRESS, \r\nVPDPBUSD, VPDPBUSDS, VPDPWSSD, VPDPWSSDS, \r\nVPEXPAND, VPOPCNT, VPSHLD, VPSHLDV, VPSHRD, \r\nVPSHRDV, VPSHUFBITQMB.\r\n• Removed the following instructions: VPMADD52HUQ, \r\nVPMADD52LUQ, VPERMB, VPERMI2B, VPERMT2B, and \r\nVPMULTISHIFTQB. They can be found in the Intel® 64 and \r\nIA-32 Architectures Software Developer’s Manual, Volumes \r\n2A, 2B, 2C & 2D.\r\n• Moved instructions unique to processors based on the \r\nKnights Mill microarchitecture to chapter 3.\r\n• Added chapter 4: EPT-Based Sub-Page Permissions.\r\n• Added chapter 5: Intel® Processor Trace: VMX \r\nImprovements.\r\nOctober 2017",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/7e3ad26f-250f-4012-85cc-c9bfd01bc18c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=64eeed629c6db1e819426b19795927a0f1b0ba84683fae15f69bc287a927b75d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 329
      },
      {
        "segments": [
          {
            "segment_id": "ad6c781a-fdf1-48c8-990d-bc7a6160e100",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "iv Ref. # 319433-032\r\n-031\r\n• Updated change log to correct typo in changes from previous \r\nrelease.\r\n• Updated instructions with imm8 operand missing in operand \r\nencoding table.\r\n• Replaced \"VLMAX\" with \"MAXVL\" to align terminology used \r\nacross documentation.\r\n• Added back information on detection of Intel AVX-512 \r\ninstructions.\r\n• Added Intel® Memory Encryption Technologies instructions \r\nPCONFIG and WBNOINVD. These instructions are also added \r\nto Table 1-1 \"Recent Instruction Set Extensions Introduction \r\nin Intel 64 and IA-32 Processors\". Added Section 1.5 \r\n\"Detection of Intel® Memory Encryption Technologies (Intel®\r\nMKTME) Instructions\".\r\n• CPUID instruction updated with PCONFIG and WBNOINVD \r\ndetails.\r\n• CPUID instruction updated with additional details on leaf \r\n07H: Intel® Xeon Phi™ only features identified and listed.\r\n• CPUID instruction updated with new Intel® SGX features in \r\nleaf 12H.\r\n• CPUID instruction updated with new PCONFIG information \r\nsub-leaf 1BH.\r\n• Updated short descriptions in the following instructions: \r\nVPDPBUSD, VPDPBUSDS, VPDPWSSD and VPDPWSSDS.\r\n• Corrections and clarifications in Chapter 4 \"EPT-Based Sub\u0002Page Permissions\".\r\n• Corrections and clarifications in Chapter 5 \"Intel® Processor \r\nTrace: VMX Improvements \".\r\nJanuary 2018\r\n-032\r\n• Corrected PCONFIG CPUID feature flag on instruction page.\r\n• Minor updates to PCONFIG instruction pages: Changed Table \r\n2-2 to use Hex notation; changed \"RSVD, MBZ\" to \r\n\"Reserved, must be zero\" in two places in Table 2-3.\r\n• Minor typo correction in WBNOINVD instruction description.\r\nJanuary 2018\r\nRevision Description Date",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/ad6c781a-fdf1-48c8-990d-bc7a6160e100.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=426ab148c1bd8b88c15ff43419f9b05eb1b7f3fcbc09de5d3db13ff3da799d5a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 228
      },
      {
        "segments": [
          {
            "segment_id": "8d43d622-8c92-49a7-b7a2-0b391a65119c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 v\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.3 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-3\r\n1.4 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\n1.5 Detection of Intel® Memory Encryption Technologies (Intel® MKTME) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1.6 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\r\n1.7 Compressed Displacement (disp8*N) Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\nCHAPTER 2 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n2.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\r\nGF2P8AFFINEQB — Galois Field Affine Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\nGF2P8MULB — Galois Field Multiply Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\nPCONFIG — Platform Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\nVAESDEC — Perform One Round of an AES Decryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\r\nVAESENC — Perform One Round of an AES Encryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-23\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-25\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register . . . . . . . . . . . . . . . . . . . . 2-28\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-33\r\nVPDPWSSD — Multiply and Add Signed Word Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-35\r\nVPDPWSSDS — Multiply and Add Word Integers with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-37\r\nVPEXPAND — Expand Byte/Word Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD. . . . . . . . . . . . . . . . . . . . . . . . 2-42\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-45\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-48\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-51\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-54\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask . . . . . . . . . . . . . . . . . . . . . . . . . . 2-57\r\nWBNOINVD—Write Back and Do Not Invalidate Cache. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-58\r\nCHAPTER 3 \r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL \r\nMICROARCHITECTURE\r\n3.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . .3-2\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . . . .3-4\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations) . . . . . . . . . . . . . .3-6\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\r\nCHAPTER 4\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.2 VMCS Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.3 Changes to EPT Paging-Structure Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.4 Changes to Guest-Physical Accesses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.5 Sub-Page Permission Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4.5.1 SPPT Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2\r\n4.5.2 Operation of SPPT-based Write-Permission . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/8d43d622-8c92-49a7-b7a2-0b391a65119c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19fb7bb4ab4ff6822aa0eaf18ccc03609b00c075dacf3fbbf8b2df737faf9c02",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 2903
      },
      {
        "segments": [
          {
            "segment_id": "8d43d622-8c92-49a7-b7a2-0b391a65119c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 v\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.3 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-3\r\n1.4 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\n1.5 Detection of Intel® Memory Encryption Technologies (Intel® MKTME) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1.6 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\r\n1.7 Compressed Displacement (disp8*N) Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\nCHAPTER 2 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n2.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\r\nGF2P8AFFINEQB — Galois Field Affine Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\nGF2P8MULB — Galois Field Multiply Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\r\nPCONFIG — Platform Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\nVAESDEC — Perform One Round of an AES Decryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\r\nVAESENC — Perform One Round of an AES Encryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-23\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-25\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register . . . . . . . . . . . . . . . . . . . . 2-28\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-31\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-33\r\nVPDPWSSD — Multiply and Add Signed Word Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-35\r\nVPDPWSSDS — Multiply and Add Word Integers with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-37\r\nVPEXPAND — Expand Byte/Word Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD. . . . . . . . . . . . . . . . . . . . . . . . 2-42\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-45\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-48\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-51\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-54\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask . . . . . . . . . . . . . . . . . . . . . . . . . . 2-57\r\nWBNOINVD—Write Back and Do Not Invalidate Cache. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-58\r\nCHAPTER 3 \r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL \r\nMICROARCHITECTURE\r\n3.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . .3-2\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations) . . . . . . . . . . . . . . .3-4\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations) . . . . . . . . . . . . . .3-6\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\r\nCHAPTER 4\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.2 VMCS Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.3 Changes to EPT Paging-Structure Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.4 Changes to Guest-Physical Accesses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.5 Sub-Page Permission Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4.5.1 SPPT Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2\r\n4.5.2 Operation of SPPT-based Write-Permission . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/8d43d622-8c92-49a7-b7a2-0b391a65119c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19fb7bb4ab4ff6822aa0eaf18ccc03609b00c075dacf3fbbf8b2df737faf9c02",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 2903
      },
      {
        "segments": [
          {
            "segment_id": "7403630d-0196-4084-a254-aba45556b374",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "vi Ref. # 319433-032\r\n4.5.3 SPP-Induced VM Exits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5.3.1 Sub-Page Permissions and EPT Violations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5.4 Invalidating Cached SPP Permissions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.5 Sub-Page Permission Interaction with Intel® TSX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.6 Sub-Page Permission Interaction with Intel® SGX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.7 Memory Type Used for Accessing SPPT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.6 Changes to VM Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.7 Changes to VMX Capability Reporting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\nCHAPTER 5\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2 Architecture Details. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.1 IA32_RTIT_CTL in VMCS Guest State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.2 Supporting EPT for Trace Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.2.1 VM Exits Due to Intel PT Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nExit Qualification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nPreserving Pending Events. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nAdditional VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\n5.2.2.2 Trace Data Management with Output Events. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3\r\n5.2.2.3 Intel PT Output Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3\r\n5.2.3 New VM-Entry Consistency Checks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.2.3.1 Special Treatment for SMM VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.3 Enumeration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/7403630d-0196-4084-a254-aba45556b374.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19dc01caedec0b87bc9fef24af4d1a5200368009353d917fc2846ba6f7d6b90d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1859
      },
      {
        "segments": [
          {
            "segment_id": "7403630d-0196-4084-a254-aba45556b374",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "vi Ref. # 319433-032\r\n4.5.3 SPP-Induced VM Exits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5.3.1 Sub-Page Permissions and EPT Violations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4.5.4 Invalidating Cached SPP Permissions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.5 Sub-Page Permission Interaction with Intel® TSX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.6 Sub-Page Permission Interaction with Intel® SGX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n4.5.7 Memory Type Used for Accessing SPPT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.6 Changes to VM Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\n4.7 Changes to VMX Capability Reporting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\r\nCHAPTER 5\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2 Architecture Details. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.1 IA32_RTIT_CTL in VMCS Guest State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.2 Supporting EPT for Trace Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5.2.2.1 VM Exits Due to Intel PT Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nExit Qualification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nPreserving Pending Events. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\nAdditional VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\r\n5.2.2.2 Trace Data Management with Output Events. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3\r\n5.2.2.3 Intel PT Output Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-3\r\n5.2.3 New VM-Entry Consistency Checks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.2.3.1 Special Treatment for SMM VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\r\n5.3 Enumeration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/7403630d-0196-4084-a254-aba45556b374.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19dc01caedec0b87bc9fef24af4d1a5200368009353d917fc2846ba6f7d6b90d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1859
      },
      {
        "segments": [
          {
            "segment_id": "a6de26f1-36df-45f2-99f8-cde843d5905d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 vii\r\nTABLES\r\nPAGE\r\n1-1 Recent Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1-2 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1-3 Intel® Memory Encryption Technologies Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1-4 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\r\n1-5 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-22\r\n1-6 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-24\r\n1-7 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-25\r\n1-8 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-27\r\n1-9 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-29\r\n1-10 Structured Extended Feature Leaf, Function 0, EBX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-32\r\n1-11 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-35\r\n1-12 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-37\r\n1-13 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\n1-14 EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\n2-1 Inverse Byte Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-3\r\n2-2 PCONFIG Leaf Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2-3 MKTME_KEY_PROGRAM_STRUCT Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2-4 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-5 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-6 PCONFIG Operation Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\n2-7 PCLMULQDQ Quadword Selection of Immediate Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-25\r\n2-8 Pseudo-Op and PCLMULQDQ Implementation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\n4-1 Format of SPPTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4-2 Format of the SPPT L4E . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4-3 Exit Qualification for SPPT-Induced VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-4 Fault Behavior Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n5-1 VMCS Controls for IA32_RTIT_CTL MSR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5-2 VMCS Control for Intel PT Output to Guest Physical Addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5-3 New Asynchronous Exit Qualification Bit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a6de26f1-36df-45f2-99f8-cde843d5905d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=81d319fdc710ef8fb01600b370611e454331f4d226c7eb2e885a2738cecbd016",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 2072
      },
      {
        "segments": [
          {
            "segment_id": "a6de26f1-36df-45f2-99f8-cde843d5905d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 vii\r\nTABLES\r\nPAGE\r\n1-1 Recent Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1-2 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1-3 Intel® Memory Encryption Technologies Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1-4 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\r\n1-5 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-22\r\n1-6 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-24\r\n1-7 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-25\r\n1-8 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-27\r\n1-9 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-29\r\n1-10 Structured Extended Feature Leaf, Function 0, EBX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-32\r\n1-11 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-35\r\n1-12 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-37\r\n1-13 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\n1-14 EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-42\r\n2-1 Inverse Byte Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-3\r\n2-2 PCONFIG Leaf Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2-3 MKTME_KEY_PROGRAM_STRUCT Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\n2-4 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-5 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\r\n2-6 PCONFIG Operation Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\r\n2-7 PCLMULQDQ Quadword Selection of Immediate Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-25\r\n2-8 Pseudo-Op and PCLMULQDQ Implementation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\n4-1 Format of SPPTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4-2 Format of the SPPT L4E . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\r\n4-3 Exit Qualification for SPPT-Induced VM Exits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\r\n4-4 Fault Behavior Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\r\n5-1 VMCS Controls for IA32_RTIT_CTL MSR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5-2 VMCS Control for Intel PT Output to Guest Physical Addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\r\n5-3 New Asynchronous Exit Qualification Bit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a6de26f1-36df-45f2-99f8-cde843d5905d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=81d319fdc710ef8fb01600b370611e454331f4d226c7eb2e885a2738cecbd016",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 2072
      },
      {
        "segments": [
          {
            "segment_id": "e102bd9e-e377-4a14-a617-366535d26099",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "viii Ref. # 319433-032",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e102bd9e-e377-4a14-a617-366535d26099.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=913156c7eb397f902a95c5c197a1bb714b8b2023bdac441ed1d0cc9cbbafaaa5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "6064e0fb-5277-4bac-9fc3-1b67b8690d7a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 ix\r\nFIGURES\r\nPAGE\r\nFigure 1-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\nFigure 1-2. Procedural Flow of Application Detection of 512-bit Instruction Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\nFigure 1-3. Version Information Returned by CPUID in EAX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-23\r\nFigure 1-4. Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-25\r\nFigure 1-5. Feature Information Returned in the EDX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-27\r\nFigure 1-6. Determination of Support for the Processor Brand String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-35\r\nFigure 1-7. Algorithm for Extracting Maximum Processor Frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-36\r\nFigure 3-1. Register Source-Block Dot Product of Two Signed Word Operands with Doubleword Accumulation. . . . . . . . . . . . . . . 3-8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/6064e0fb-5277-4bac-9fc3-1b67b8690d7a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=99f61d192f5216bab35a26a2a4b0f7082dfbc1cdc725a15277ad80fd7e9c357e",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1740c987-df32-4575-be10-30024aa47cdc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "x Ref. # 319433-032",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1740c987-df32-4575-be10-30024aa47cdc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ecd8b52e57e4948b1582de827ffc54da8a66917d91875cf6360d0db3be752380",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 476
      },
      {
        "segments": [
          {
            "segment_id": "cd7315da-af6a-41a6-9ec9-e16487a86141",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND\r\nFEATURES\r\n1.1 ABOUT THIS DOCUMENT\r\nThis document describes the software programming interfaces of Intel® architecture instruction extensions and\r\nfeatures which may be included in future Intel processor generations. Intel does not guarantee the availability\r\nof these interfaces and features in any future product. \r\nThe instruction set extensions cover a diverse range of application domains and programming usages. The 512-\r\nbit SIMD vector SIMD extensions, referred to as Intel® Advanced Vector Extensions 512 (Intel® AVX-512) in\u0002structions, deliver comprehensive set of functionality and higher performance than Intel® AVX and Intel® AVX2\r\ninstructions. Intel AVX, Intel AVX2 and many Intel AVX-512 instructions are covered in Intel® 64 and IA-32 Ar\u0002chitectures Software Developer’s Manual sets. The reader can refer to them for basic and more background in\u0002formation related to various features referenced in this document.\r\nThe base of the 512-bit SIMD instruction extensions are referred to as Intel AVX-512 Foundation instructions.\r\nThey include extensions of the AVX and AVX2 family of SIMD instructions but are encoded using a new encoding\r\nscheme with support for 512-bit vector registers, up to 32 vector registers in 64-bit mode, and conditional pro\u0002cessing using opmask registers. \r\nChapter 2 is devoted to additional 512-bit instruction extensions in the Intel AVX-512 family targeting broad ap\u0002plication domains, and instruction set extensions encoded using the EVEX prefix encoding scheme to operate at\r\nvector lengths smaller than 512-bits. \r\nChapter 3 describes instruction set extensions that are offered on processors based on the Knights Mill microar\u0002chitecture only. \r\nChapter 4 describes EPT-Based Sub-Page Permissions.\r\nChapter 5 describes Intel® Processor Trace: VMX Improvements.\r\n1.2 INSTRUCTION SET EXTENSIONS INTRODUCTION IN INTEL 64 AND IA-32 \r\nPROCESSORS\r\nRecent instruction set extensions are listed in Table 1-1. Within these groups, most instructions are collected into \r\nfunctional subgroups.\r\nTable 1-1. Recent Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Supported in Microarchitecture\r\nSSE4.1 Extensions Intel® Xeon® processor 3100, 3300, 5200, 5400, 7400, \r\n7500 series, Intel® Core™ 2 Extreme processors QX9000 \r\nseries, Intel® Core™ 2 Quad processor Q9000 series, Intel® \r\nCore™ 2 Duo processors 8000 series, T9000 series.\r\nLegacy and later\r\nIntel® Atom™ processor. Silvermont and later\r\nSSE4.2 Extensions, CRC32, \r\nPOPCNT\r\nIntel® Core™ i7 965 processor, Intel® Xeon® processors \r\nX3400, X3500, X5500, X6500, X7500 series.\r\nLegacy and later\r\nIntel® Atom™ processor. Silvermont and later",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/cd7315da-af6a-41a6-9ec9-e16487a86141.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f5d6b6641d7103d4b9cd40670b6d4744fe5f2293ec9b3984bd50485d16cf0c8e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 398
      },
      {
        "segments": [
          {
            "segment_id": "66f867cc-56df-4e94-916f-75d61061c379",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "1-2 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nAESNI, PCLMULQDQ Intel® Xeon® processor E7 series, Intel® Xeon® processors \r\nX3600, X5600, Intel® Core™ i7 980X processor. \r\nUse CPUID to verify presence of AESNI and PCLMULQDQ \r\nacross Intel® Core™ processor families.\r\nWestmere and later\r\nIntel® Atom™ processor. Silvermont and later\r\nIntel AVX Intel® Xeon® processor E3 and E5 families.\r\n2nd Generation Intel® Core™ i7, i5, i3 processor 2xxx families.\r\nSandy Bridge and later\r\nF16C 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge and later\r\nRDRAND 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge and later\r\nIntel® Atom™ processor. Silvermont and later\r\nFS/GS base access 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge and later\r\nIntel® Atom™ processor. Goldmont and later\r\nFMA, AVX2, BMI1, BMI2, \r\nINVPCID, LZCNT, TSX\r\nIntel® Xeon® processor E3/E5/E7 v3 product families.\r\n4th Generation Intel® Core™ processor family.\r\nHaswell and later\r\nMOVBE Intel® Xeon® processor E3/E5/E7 v3 product families.\r\n4th Generation Intel® Core™ processor family.\r\nHaswell and later\r\nIntel® Atom™ processor. Silvermont and later\r\nPREFETCHW Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell and later\r\nIntel® Atom™ processor. Silvermont and later\r\nADX Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell and later\r\nCLAC, STAC Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell and later\r\nIntel® Atom™ processor. Goldmont and later\r\nRDSEED Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell and later\r\nIntel® Atom™ processor. Goldmont and later\r\nAVX512ER, AVX512PF, \r\nPREFETCHWT1\r\nIntel® Xeon Phi™ Processor 3200, 5200, 7200 Series. Knights Landing\r\nAVX512F, AVX512CD Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series. Knights Landing\r\nIntel® Xeon® Processor Scalable Family. Skylake Server and later\r\nTBD Cannon Lake and later\r\nTable 1-1. Recent Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors(Continued)\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Supported in Microarchitecture",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/66f867cc-56df-4e94-916f-75d61061c379.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a7bd49ce2c5abdfda1e2ac99315abc2b8b15cdc098a29471ea79799253f7763a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 367
      },
      {
        "segments": [
          {
            "segment_id": "e4d19662-a7cc-45a4-b058-39df244181bf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-3\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.3 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS \r\nThe majority of AVX-512 Foundation instructions are encoded using the EVEX encoding scheme. EVEX-encoded \r\ninstructions can operate on the 512-bit ZMM register state plus 8 opmask registers. The opmask instructions in \r\nAVX-512 Foundation instructions operate only on opmask registers or with a general purpose register.\r\nProcessor support of AVX-512 Foundation instructions is indicated by CPUID.(EAX=07H, ECX=0):EBX.AVX512F[bit \r\n16] = 1. Detection of AVX-512 Foundation instructions operating on ZMM states and opmask registers need to \r\nfollow the general procedural flow in Figure 1-1.\r\nCLFLUSHOPT, XSAVEC, \r\nXSAVES, MPX\r\nIntel® Xeon® Processor Scalable Family. Skylake Server and later\r\n6th Generation Intel® Core™ processor family. Skylake and later\r\nIntel® Atom™ processor. Goldmont and later\r\nSGX1 6th Generation Intel® Core™ processor family. Skylake and later\r\nIntel® Atom™ processor. Goldmont Plus and later\r\nAVX512DQ, AVX512BW, \r\nAVX512VL\r\nIntel® Xeon® Processor Scalable Family. Skylake Server and later\r\nTBD Cannon Lake and later\r\nCLWB Intel® Xeon® Processor Scalable Family. Skylake Server and later\r\nTBD Ice Lake and later\r\nPKU Intel® Xeon® Processor Scalable Family. Skylake Server and later\r\nAVX512_IFMA, \r\nAVX512_VBMI\r\nTBD Cannon Lake and later\r\nSHA-NI TBD Cannon Lake and later\r\nIntel® Atom™ processor. Goldmont and later\r\nUMIP TBD Cannon Lake and later\r\nIntel® Atom™ processor. Goldmont Plus and later\r\nPTWRITE Intel® Atom™ processor. Goldmont Plus and later\r\nRDPID TBD Ice Lake and later\r\nIntel® Atom™ processor. Goldmont Plus and later\r\nAVX512_4FMAPS, \r\nAVX512_4VNNI\r\nFuture Intel Xeon Phi processor. Knights Mill\r\nAVX512_VPOPCNTDQ Future Intel Xeon Phi processor. Knights Mill\r\nTBD Ice Lake and later\r\nFast Short REP MOV TBD Ice Lake and later\r\nAVX512_VNNI, GFNI, VAES, \r\nAVX512_VBMI2, \r\nVPCLMULQDQ, \r\nAVX512_BITALG\r\nTBD Ice Lake and later\r\nPCONFIG, WBNOINVD TBD Ice Lake Server and later\r\nTable 1-1. Recent Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors(Continued)\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Supported in Microarchitecture",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e4d19662-a7cc-45a4-b058-39df244181bf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=db149b4bfe073c930746a070f376e99a100eb6c61aa40964e697d3e1777a6745",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 310
      },
      {
        "segments": [
          {
            "segment_id": "fc3b38fb-510e-41ab-afd3-7ebb5d160489",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "1-4 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nPrior to using AVX-512 Foundation instructions, the application must identify that the operating system supports \r\nthe XGETBV instruction, the ZMM register state, in addition to processor’s support for ZMM state management \r\nusing XSAVE/XRSTOR and AVX-512 Foundation instructions. The following simplified sequence accomplishes both \r\nand is strongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use1).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Detect CPUID.0x7.0:EBX.AVX512F[bit 16] = 1.\r\n1.4 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 \r\nFAMILY\r\nIn addition to the Intel AVX-512 Foundation instructions, Intel AVX-512 family provides several additional 512-bit \r\nextensions in groups of instructions, each group is enumerated by a CPUID leaf 7 feature flag and can be encoded \r\nvia EVEX.L’L field to support operation at vector lengths smaller than 512 bits. These instruction groups are listed \r\nin Table 1-2.\r\nFigure 1-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions\r\n1. If CPUID.01H:ECX.OSXSAVE reports 1, it also indirectly implies the processor supports XSAVE, XRSTOR, XGETBV, processor extended \r\nstate bit vector XCR0 register. Thus an application may streamline the checking of CPUID feature flags for XSAVE and OSXSAVE. \r\nXSETBV is a privileged instruction.\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F flag \r\nCheck feature flag\r\nCPUID.1H:ECX.OSXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/fc3b38fb-510e-41ab-afd3-7ebb5d160489.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9dc53ea5c89c0f7b11a03329661341890f3c851200c92a9a31eae568810e3f12",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 269
      },
      {
        "segments": [
          {
            "segment_id": "e4a1bc4d-63a4-418b-99c4-a29fa8dbdaa5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-5\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nSoftware must follow the detection procedure for the 512-bit AVX-512 Foundation instructions as described in \r\nSection 1.3.\r\nDetection of other 512-bit sibling instruction groups listed in Table 1-2 (excluding AVX512F) follows the procedure \r\ndescribed in Figure 1-2.\r\nTable 1-2. 512-bit Instruction Groups in the Intel AVX-512 Family\r\nCPUID Leaf 7 Feature Flag Bit Feature Flag abbreviation of 512-bit Instruction Group SW Detection Flow\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 16] AVX512F: AVX-512 Foundation instructions. Figure 1-1\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 06] AVX512_VBMI2: Additional byte, word, dword and qword \r\ncapabilities, an addition to AVX512. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 08]\r\nGFNI: Galois Field New Instructions; this bit is concatenated by \r\nsoftware with either AVX512, AVX, or SSE to indicate the \r\ndifferent supported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 09]\r\nVAES: Vector AES instructions; this bit is concatenated by \r\nsoftware with AVX512 or AVX to indicate the different \r\nsupported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 10]\r\nVPCLMULQDQ: Vector PCLMULQDQ instructions; this bit is \r\nconcatenated by software with AVX512 or AVX to indicate the \r\ndifferent supported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 11] AVX512_VNNI: Vector Neural Network Instructions, an addition \r\nto AVX512. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 12] AVX512_BITALG: Support for VPOPCNT[B,W] and \r\nVPSHUFBITQMB. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 14] AVX512_VPOPCNTDQ: Support for VPOPCNT[D,Q]. Figure 1-2\r\nFigure 1-2. Procedural Flow of Application Detection of 512-bit Instruction Groups\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F and\r\na sibling 512-bit flag\r\nCheck feature flag\r\nCPUID.1H:ECX.OXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e4a1bc4d-63a4-418b-99c4-a29fa8dbdaa5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1b88ce3b8f7860d44939ad6ebafcee9b1b3b8711505ccf54b70f862c45b60d1c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c3768737-6f1b-48b5-ab68-dca86251722b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "1-6 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTo illustrated the detection procedure for 512-bit instructions enumerated by AVX512CD, the following sequence is \r\nstrongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Verify both CPUID.0x7.0:EBX.AVX512F[bit 16] = 1, CPUID.0x7.0:EBX.AVX512CD[bit 28] = 1.\r\nSimilarly, the detection procedure for enumerating 512-bit instructions reported by AVX512DW follows the same \r\nflow.\r\n1.5 DETECTION OF INTEL® MEMORY ENCRYPTION TECHNOLOGIES (INTEL® \r\nMKTME) INSTRUCTIONS\r\nIntel® Memory Encryption Technologies instructions are enumerated by a CPUID feature flag; details are listed in \r\nTable 1-3.\r\nTable 1-3. Intel® Memory Encryption Technologies Instructions\r\nCPUID Leaf Feature Flag Bit Feature Flag abbreviation of Intel® MKTME Instructions\r\nCPUID.(EAX=07H, ECX=0):EDX[bit 18] PCONFIG: Platform configuration\r\nCPUID.(EAX=80000008H, ECX=0):EBX[bit 9] WBNOINVD: Write back and do not invalidate cache",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/c3768737-6f1b-48b5-ab68-dca86251722b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=15de538aaf030e1c53713eebed15a9d2d1dd0e3b8c6425f1fa323626cd34da41",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 431
      },
      {
        "segments": [
          {
            "segment_id": "b1a65f09-05bf-4090-b1ac-9bfb89eaebf6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-7\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.6 CPUID INSTRUCTION \r\nCPUID—CPU Identification\r\nDescription\r\nThe ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can \r\nset and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction \r\noperates the same in non-64-bit modes and 64-bit mode.\r\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The \r\ninstruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). \r\nFor example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value \r\nand the Vendor Identification String in the appropriate registers:\r\nMOV EAX, 00H\r\nCPUID\r\nTable 1-4 shows information returned, depending on the initial value loaded into the EAX register. Table 1-5 shows \r\nthe maximum CPUID input value recognized for each family of IA-32 processors on which CPUID is implemented. \r\nTwo types of information are returned: basic and extended function information. If a value is entered for \r\nCPUID.EAX is invalid for a particular processor, the data for the highest basic information leaf is returned. For \r\nexample, using the Intel Core 2 Duo E6850 processor, the following is true:\r\nCPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *) \r\nCPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) \r\nCPUID.EAX = 0BH (* INVALID: Returns the same information as CPUID.EAX = 0AH. *) \r\nCPUID.EAX = 80000008H (* Returns virtual/physical address size data. *)\r\nCPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0AH. *)\r\nWhen CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence \r\non input ECX value in the basic leaf is honored.\r\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution \r\nguarantees that any modifications to flags, registers, and memory for previous instructions are completed before \r\nthe next instruction is fetched and executed.\r\nSee also:\r\n“Serializing Instructions” in Chapter 8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 3A\r\n\"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architectures Software Devel\u0002oper’s Manual, Volume 3A.\r\nOpcode Instruction 64-Bit Mode Compat/\r\nLeg Mode Description\r\n0F A2 CPUID Valid Valid Returns processor identification and feature information to the EAX, \r\nEBX, ECX, and EDX registers, as determined by input entered in EAX \r\n(in some cases, ECX as well).\r\n1. On Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b1a65f09-05bf-4090-b1ac-9bfb89eaebf6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0b3ff81d8e58e7e9aacc9aee78f8caf1719f615c00730d2a11f7c475f4886f3d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 430
      },
      {
        "segments": [
          {
            "segment_id": "207e3b8a-77d1-4e0f-927c-427bb0922ba8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "1-8 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-4. Information Returned by CPUID Instruction\r\nInitial EAX \r\nValue Information Provided about the Processor\r\nBasic CPUID Information\r\n0H EAX\r\nEBX\r\nECX\r\nEDX\r\nMaximum Input Value for Basic CPUID Information (see Table 1-5)\r\n“Genu”\r\n“ntel”\r\n“ineI”\r\n01H EAX\r\nEBX\r\nECX\r\nEDX\r\nVersion Information: Type, Family, Model, and Stepping ID (see Figure 1-3)\r\nBits 7-0: Brand Index\r\nBits 15-8: CLFLUSH line size (Value ∗ 8 = cache line size in bytes)\r\nBits 23-16: Maximum number of addressable IDs for logical processors in this physical package*. \r\nBits 31-24: Initial APIC ID\r\nFeature Information (see Figure 1-4 and Table 1-7)\r\nFeature Information (see Figure 1-5 and Table 1-8)\r\nNOTES: \r\n* The nearest power-of-2 integer that is not smaller than EBX[23:16] is the maximum number of \r\nunique initial APIC IDs reserved for addressing different logical processors in a physical package.\r\n02H EAX\r\nEBX\r\nECX\r\nEDX\r\nCache and TLB Information (see Table 1-9)\r\nCache and TLB Information\r\nCache and TLB Information\r\nCache and TLB Information\r\n03H EAX Reserved\r\nEBX Reserved\r\nECX Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nEDX Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nNOTES: \r\nProcessor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models,\r\nuse the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. \r\nCPUID leaves > 3 < 80000000 are visible only when IA32_MISC_ENABLES.BOOT_NT4[bit 22] = 0 (default).\r\nDeterministic Cache Parameters Leaf \r\n04H NOTES:\r\nLeaf 04H output depends on the initial value in ECX. \r\nSee also: “INPUT EAX = 4: Returns Deterministic Cache Parameters for each level” on page 1-31.\r\nEAX Bits 4-0: Cache Type Field\r\n0 = Null - No more caches\r\n1 = Data Cache \r\n2 = Instruction Cache\r\n3 = Unified Cache\r\n4-31 = Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/207e3b8a-77d1-4e0f-927c-427bb0922ba8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3b5282e0bef369925b6fb2d7e01c64c78d23a20bcb0df87c899f6d5d94698b60",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 331
      },
      {
        "segments": [
          {
            "segment_id": "74a96962-38d9-49ec-a6de-912d335d9447",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-9\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nBits 7-5: Cache Level (starts at 1) \r\nBits 8: Self Initializing cache level (does not need SW initialization)\r\nBits 9: Fully Associative cache\r\nBits 13-10: Reserved\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this cache*, ** \r\nBits 31-26: Maximum number of addressable IDs for processor cores in the physical \r\npackage*, ***, ****\r\nEBX Bits 11-00: L = System Coherency Line Size*\r\nBits 21-12: P = Physical Line partitions*\r\nBits 31-22: W = Ways of associativity*\r\nECX Bits 31-00: S = Number of Sets*\r\nEDX Bit 0: WBINVD/INVD behavior on lower level caches\r\nBit 10: Write-Back Invalidate/Invalidate\r\n0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads \r\nsharing this cache\r\n1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads \r\nsharing this cache.\r\nBit 1: Cache Inclusiveness\r\n0 = Cache is not inclusive of lower cache levels.\r\n1 = Cache is inclusive of lower cache levels.\r\nBit 2: Complex cache indexing\r\n0 = Direct mapped cache\r\n1 = A complex function is used to index the cache, potentially using\r\nall address bits.\r\nBits 31-03: Reserved = 0\r\nNOTES:\r\n* Add one to the return value to get the result. \r\n** The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique\r\ninitial APIC IDs reserved for addressing different logical processors sharing this cache.\r\n*** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of\r\nunique Core_IDs reserved for addressing different processor cores in a physical package. Core ID is\r\na subset of bits of the initial APIC ID. \r\n****The returned value is constant for valid initial values in ECX. Valid ECX values start from 0. \r\nMONITOR/MWAIT Leaf \r\n05H EAX Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nEBX Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nECX Bit 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported\r\nBit 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled\r\nBits 31-02: Reserved \r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/74a96962-38d9-49ec-a6de-912d335d9447.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a16ca5e0cf36e5221fa3f3dcc26b8f39c7a6ae1bdfe8161776e9a6b14e4901d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 384
      },
      {
        "segments": [
          {
            "segment_id": "a2f64966-0f2d-4c6b-b85d-67235eecd3b8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "1-10 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 03-00: Number of C0* sub C-states supported using MWait\r\nBits 07-04: Number of C1* sub C-states supported using MWAIT\r\nBits 11-08: Number of C2* sub C-states supported using MWAIT\r\nBits 15-12: Number of C3* sub C-states supported using MWAIT\r\nBits 19-16: Number of C4* sub C-states supported using MWAIT\r\nBits 23-20: Number of C5* sub C-states supported using MWAIT\r\nBits 27-24: Number of C6* sub C-states supported using MWAIT\r\nBits 31-28: Number of C7* sub C-states supported using MWAIT\r\nNOTE:\r\n* The definition of C0 through C7 states for MWAIT extension are processor-specific C-states, not\r\nACPI C-states.\r\nThermal and Power Management Leaf \r\n06H EAX\r\nEBX\r\nBit 00: Digital temperature sensor is supported if set\r\nBit 01: Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLE[38]).\r\nBit 02: ARAT. APIC-Timer-always-running feature is supported if set.\r\nBit 03: Reserved \r\nBit 04: PLN. Power limit notification controls are supported if set.\r\nBit 05: ECMD. Clock modulation duty cycle extension is supported if set.\r\nBit 06: PTM. Package thermal management is supported if set.\r\nBit 07: HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, \r\nIA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.\r\nBit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.\r\nBit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.\r\nBit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.\r\nBit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.\r\nBit 12: Reserved.\r\nBit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs \r\nare supported if set.\r\nBit 14: Intel® Turbo Boost Max Technology 3.0 available.\r\nBits 31-15: Reserved \r\nBits 03-00: Number of Interrupt Thresholds in Digital Thermal Sensor\r\nBits 31-04: Reserved \r\nECX Bit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The \r\ncapability to provide a measure of delivered processor performance (since last reset of the coun\u0002ters), as a percentage of the expected processor performance when running at the TSC frequency.\r\nBits 02-01: Reserved = 0\r\nBit 03: The processor supports performance-energy bias preference if\r\nCPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a\r\nnew architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)\r\nBits 31-04: Reserved = 0\r\nEDX Reserved = 0\r\nStructured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)\r\n07H NOTES:\r\nLeaf 07H main leaf (ECX = 0). \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. \r\nEAX Bits 31-00: Reports the maximum number sub-leaves that are supported in leaf 07H.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a2f64966-0f2d-4c6b-b85d-67235eecd3b8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f31ac4cc979780cd78f81c8d030ec93b3b7029158e07cfbbf3754e4e0169f86b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 419
      },
      {
        "segments": [
          {
            "segment_id": "9aa268f9-7841-4403-8e02-2ed19caf06f3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-11\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.\r\nBit 01: IA32_TSC_ADJUST MSR is supported if 1.\r\nBit 02: SGX\r\nBit 03: BMI1\r\nBit 04: HLE\r\nBit 05: AVX2\r\nBit 07: SMEP. Supports Supervisor Mode Execution Protection if 1.\r\nBit 06: Reserved\r\nBit 08: BMI2\r\nBit 09: Supports Enhanced REP MOVSB/STOSB if 1.\r\nBit 10: INVPCID\r\nBit 11: RTM\r\nBit 12: Supports Platform Quality of Service Monitoring (PQM) capability if 1.\r\nBit 13: Deprecates FPU CS and FPU DS values if 1.\r\nBit 14: Intel Memory Protection Extensions\r\nBit 15: Supports Platform Quality of Service Enforcement (PQE) capability if 1.\r\nBit 16: AVX512F\r\nBit 17: AVX512DQ\r\nBit 18: RDSEED\r\nBit 19: ADX\r\nBit 20: SMAP\r\nBit 21: AVX512_IFMA\r\nBit 22: Reserved\r\nBit 23: CLFLUSHOPT\r\nBit 24: CLWB\r\nBit 25: Intel Processor Trace\r\nBit 26: AVX512PF (Intel® Xeon Phi™ only.)\r\nBit 27: AVX512ER (Intel® Xeon Phi™ only.)\r\nBit 28: AVX512CD\r\nBit 29: SHA\r\nBit 30: AVX512BW\r\nBit 31: AVX512VL\r\nECX Bit 00: PREFETCHWT1 (Intel® Xeon Phi™ only.)\r\nBit 01: AVX512_VBMI\r\nBit 02: UMIP. Supports user-mode instruction prevention if 1.\r\nBit 03: PKU. Supports protection keys for user-mode pages if 1.\r\nBit 04: OSPKE. If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instruc\u0002tions).\r\nBit 05: Reserved\r\nBit 06: AVX512_VBMI2\r\nBit 07: Reserved\r\nBit 08: GFNI\r\nBit 09: VAES\r\nBit 10: VPCLMULQDQ\r\nBit 11: AVX512_VNNI\r\nBit 12: AVX512_BITALG\r\nBit 13: Reserved\r\nBit 14: AVX512_VPOPCNTDQ\r\nBits 16-15: Reserved\r\nBits 21-17: The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.\r\nBit 22: RDPID. Supports Read Processor ID if 1.\r\nBits 29 -23: Reserved.\r\nBit 30: SGX_LC. Supports SGX Launch Configuration if 1.\r\nBit 31: Reserved. \r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9aa268f9-7841-4403-8e02-2ed19caf06f3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=00249cdfd6723d3f8be5fd1e3632f4bf6b121c226c0274f75b3e507c64e539cb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "197ca58f-eddd-4a9a-85ff-2d9ba3db82ab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "1-12 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 01-00: Reserved\r\nBit 02: AVX512_4VNNIW\r\nBit 03: AVX512_4FMAPS\r\nBits 17-04: Reserved\r\nBit 18: PCONFIG\r\nBits 31-19: Reserved\r\nStructured Extended Feature Enumeration Sub-leaves (EAX = 07H, ECX = n, n ≥ 1)\r\n07H NOTES:\r\nLeaf 07H output depends on the initial value in ECX. \r\nIf ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.\r\nEAX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEBX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nECX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nDirect Cache Access Information Leaf \r\n09H EAX\r\nEBX\r\nECX\r\nEDX\r\nValue of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)\r\nReserved \r\nReserved \r\nReserved \r\nArchitectural Performance Monitoring Leaf \r\n0AH EAX Bits 07-00: Version ID of architectural performance monitoring\r\nBits 15- 08: Number of general-purpose performance monitoring counter per logical processor\r\nBits 23-16: Bit width of general-purpose, performance monitoring counter \r\nBits 31-24: Length of EBX bit vector to enumerate architectural performance monitoring events\r\nEBX Bit 00: Core cycle event not available if 1\r\nBit 01: Instruction retired event not available if 1\r\nBit 02: Reference cycles event not available if 1\r\nBit 03: Last-level cache reference event not available if 1\r\nBit 04: Last-level cache misses event not available if 1\r\nBit 05: Branch instruction retired event not available if 1\r\nBit 06: Branch mispredict retired event not available if 1\r\nBits 31-07: Reserved = 0\r\nECX\r\nEDX\r\nReserved = 0\r\nBits 04-00: Number of fixed-function performance counters (if Version ID > 1)\r\nBits 12-05: Bit width of fixed-function performance counters (if Version ID > 1)\r\nReserved = 0\r\nExtended Topology Enumeration Leaf \r\n0BH NOTES:\r\nMost of Leaf 0BH output depends on the initial value in ECX. \r\nThe EDX output of leaf 0BH is always valid and does not vary with input value in ECX.\r\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\r\nFor sub-leaves that returns an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\r\nIf an input value N in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with\r\nECX > N also return 0 in ECX[15:8]\r\nEAX Bits 04-00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level \r\ntype*. All logical processors with the same next level ID share current level.\r\nBits 31-05: Reserved.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/197ca58f-eddd-4a9a-85ff-2d9ba3db82ab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0fa480897f0aa422ac1188c624c948b4e9e56f056436f71b9b4b9950afa08227",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 450
      },
      {
        "segments": [
          {
            "segment_id": "153477e5-f001-4231-aec4-76294979f4d7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-13\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bits 15-00: Number of logical processors at this level type. The number reflects configuration as \r\nshipped by Intel**.\r\nBits 31-16: Reserved.\r\nECX Bits 07-00: Level number. Same value in ECX input.\r\nBits 15-08: Level type***.\r\nBits 31-16: Reserved.\r\nEDX Bits 31-00: x2APIC ID the current logical processor.\r\nNOTES:\r\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\r\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in \r\nthis field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical \r\nprocessors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depend\u0002ing on software and platform hardware configurations.\r\n*** The value of the “level type” field is not related to level numbers in any way, higher “level type” \r\nvalues do not mean higher levels. Level type field has the following encoding:\r\n0: invalid\r\n1: SMT\r\n2: Core\r\n3-255: Reserved\r\nProcessor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)\r\n0DH NOTES:\r\nLeaf 0DH main leaf (ECX = 0). \r\nEAX Bits 31-00: Reports the valid bit fields of the lower 32 bits of the XFEATURE_ENABLED_MASK regis\u0002ter. If a bit is 0, the corresponding bit field in XCR0 is reserved.\r\nBit 00: legacy x87 \r\nBit 01: 128-bit SSE\r\nBit 02: 256-bit AVX\r\nBits 04-03: MPX state\r\nBit 07-05: AVX-512 state\r\nBit 08: Used for IA32_XSS\r\nBit 09: PKRU state\r\nBits 31-10: Reserved\r\nEBX Bits 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by \r\nenabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save \r\narea are not enabled.\r\nECX Bit 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the \r\nXSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit \r\nfields in XCR0. \r\nEDX Bit 31-00: Reports the valid bit fields of the upper 32 bits of the XCR0 register. If a bit is 0, the cor\u0002responding bit field in XCR0 is reserved \r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/153477e5-f001-4231-aec4-76294979f4d7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=efcb273d22e3b21f4b2f336c17167e589181a3ddb675fd5da434278104bcf7c7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 366
      },
      {
        "segments": [
          {
            "segment_id": "a32c3d32-942a-4274-ab02-20d092519d99",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "1-14 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX\r\nEBX\r\nECX\r\nEDX\r\nBit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nBits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nBits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 31-10: Reserved\r\nBits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-00: The size in bytes (from the offset specified in EBX) of the save area for an extended \r\nstate feature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-00: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31-02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nPlatform QoS Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\r\nEAX Reserved.\r\nEBX Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.\r\nECX Reserved.\r\nEDX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Monitoring if 1.\r\nBits 31-02: Reserved\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a32c3d32-942a-4274-ab02-20d092519d99.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a7d800f72d714bc440bec20ac8fa6e6b28858c46c94518633db65c8fd7d7ab92",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 533
      },
      {
        "segments": [
          {
            "segment_id": "a32c3d32-942a-4274-ab02-20d092519d99",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "1-14 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX\r\nEBX\r\nECX\r\nEDX\r\nBit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nBits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nBits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 31-10: Reserved\r\nBits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-00: The size in bytes (from the offset specified in EBX) of the save area for an extended \r\nstate feature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-00: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31-02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nPlatform QoS Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\r\nEAX Reserved.\r\nEBX Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.\r\nECX Reserved.\r\nEDX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Monitoring if 1.\r\nBits 31-02: Reserved\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a32c3d32-942a-4274-ab02-20d092519d99.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a7d800f72d714bc440bec20ac8fa6e6b28858c46c94518633db65c8fd7d7ab92",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 533
      },
      {
        "segments": [
          {
            "segment_id": "e8566e44-ca1d-4a65-b4d8-e6e42f37b164",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-15\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nL3 Cache QoS Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nEAX Reserved.\r\nEBX Bits 31-00: Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).\r\nECX Maximum range (zero-based) of RMID of this resource type.\r\nEDX Bit 00: Supports L3 occupancy monitoring if 1.\r\nBits 31-01: Reserved\r\nPlatform QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = 0)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource identification (ResID) starting at bit position 1 of EBX.\r\nEAX Reserved.\r\nEBX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache QoS Enforcement if 1.\r\nBits 31-02: Reserved.\r\nECX Reserved.\r\nEDX Reserved.\r\nL3 Cache QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = ResID =1)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nEAX Bits 04-00: Length of the capacity bit mask for the corresponding ResID.\r\nBits 31-05: Reserved\r\nEBX Bits 31-00: Bit-granular map of isolation/contention of allocation units.\r\nECX Bit 00: Reserved.\r\nBit 01: Updates of COS should be infrequent if 1.\r\nBit 02: Code and Data Prioritization Technology supported if 1.\r\nBits 31-03: Reserved\r\nEDX Bits 15-00: Highest COS number supported for this ResID.\r\nBits 31-16: Reserved\r\nIntel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nEAX Bit 00: SGX1. If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.\r\nBit 01: SGX2. If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.\r\nBits 04-02: Reserved.\r\nBit 05: If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, \r\nand ESETCONTEXT.\r\nBit 06: If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and \r\nELDUC.\r\nBits 31-02: Reserved. \r\nEBX Bits 31-00: MISCSELECT. Bit vector of supported extended SGX features.\r\nECX Bits 31-00: Reserved.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e8566e44-ca1d-4a65-b4d8-e6e42f37b164.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bcaea947872d39713dd63776b7bf88ed8194542abac9993473400809051c5cda",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 351
      },
      {
        "segments": [
          {
            "segment_id": "82ee7e8b-8c79-4571-8c4c-a918712e27c1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "1-16 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 07-00: MaxEnclaveSize_Not64. The maximum supported enclave size in non-64-bit mode is \r\n2^(EDX[7:0]).\r\nBits 15-08: MaxEnclaveSize_64. The maximum supported enclave size in 64-bit mode is \r\n2^(EDX[15:8]).\r\nBits 31-16: Reserved.\r\nIntel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nEAX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.\r\nEBX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.\r\nECX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.\r\nEDX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.\r\nIntel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nFor sub-leaves (ECX = 2 or higher), definition of EDX,ECX,EBX,EAX[31:4] depends on the sub-leaf\r\ntype listed below. \r\nEAX Bit 03-00: Sub-leaf Type\r\n0000b: Indicates this sub-leaf is invalid. \r\n0001b: This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on \r\nthe Enclave Page Cache (EPC) section.\r\nAll other type encodings are reserved.\r\nType 0000b. This sub-leaf is invalid. \r\nEDX:ECX:EBX:EAX return 0.\r\nType 0001b. This sub-leaf enumerates an EPC sections with EDX:ECX, EBX:EAX defined as follows. \r\nEAX[11:04]: Reserved (enumerate 0). \r\nEAX[31:12]: Bits 31:12 of the physical address of the base of the EPC section. \r\nEBX[19:00]: Bits 51:32 of the physical address of the base of the EPC section. \r\nEBX[31:20]: Reserved.\r\nECX[03:00]: EPC section property encoding defined as follows: \r\nIf EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.\r\nIf EAX[3:0] 0001b, then this section has confidentiality and integrity protection.\r\nAll other encodings are reserved.\r\nECX[11:04]: Reserved (enumerate 0). \r\nECX[31:12]: Bits 31:12 of the size of the corresponding EPC section within the Processor \r\nReserved Memory.\r\nEDX[19:00]: Bits 51:32 of the size of the corresponding EPC section within the Processor \r\nReserved Memory. \r\nEDX[31:20]: Reserved.\r\nIntel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)\r\n14H NOTES:\r\nLeaf 14H main leaf (ECX = 0). \r\nEAX Bits 31-00: Reports the maximum sub-leaf supported in leaf 14H.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/82ee7e8b-8c79-4571-8c4c-a918712e27c1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ffc17a7600fae2cf73ba3e77ca8947620d01d1fc2cf3095de7c844510ab83dc1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 395
      },
      {
        "segments": [
          {
            "segment_id": "9df85eff-a9ac-4a09-8c20-8c2e8a983688",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-17\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bit 00: If 1, Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that \r\nIA32_RTIT_CR3_MATCH MSR can be accessed.\r\nBits 01: If 1, Indicates support of Configurable PSB and Cycle-Accurate Mode.\r\nBits 02: If 1, Indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs \r\nacross warm reset.\r\nBits 03: If 1, Indicates support of MTC timing packet and suppression of COFI-based packets.\r\nBits 31-04: Reserved \r\nECX Bit 00: If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output \r\nscheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.\r\nBit 01: If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the \r\nMaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS.\r\nBits 02: If 1, Indicates support of Single-Range Output scheme.\r\nBits 03: If 1, Indicates support of output to Trace Transport subsystem.\r\nBit 30-04: Reserved\r\nBit 31: If 1, Generated packets which contain IP payloads have LIP values, which include the CS base \r\ncomponent.\r\nEDX Bits 31-00: Reserved \r\nIntel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)\r\n14H EAX Bits 02-00: Number of configurable Address Ranges for filtering.\r\nBits 15-03: Reserved\r\nBit 31-16: Bitmap of supported MTC period encodings\r\nEBX Bits 15-00: Bitmap of supported Cycle Threshold value encodings\r\nBit 31-16: Bitmap of supported Configurable PSB frequency encodings\r\nECX Bits 31-00: Reserved\r\nEDX Bits 31-00: Reserved\r\nTime Stamp Counter and Core Crystal Clock Information Leaf \r\n15H NOTES:\r\nIf EBX[31:0] is 0, the TSC and ”core crystal clock” ratio is not enumerated.\r\nEBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock fre\u0002quency.\r\nIf ECX is 0, the core crystal clock frequency is not enumerated.\r\n“TSC frequency” = “core crystal clock frequency” * EBX/EAX.\r\nThe core crystal clock may differ from the reference clock, bus clock, or core clock frequencies.\r\nEAX Bits 31-00: An unsigned integer which is the denominator of the TSC/”core crystal clock” ratio.\r\nEBX Bits 31-00: An unsigned integer which is the numerator of the TSC/”core crystal clock” ratio.\r\nECX Bits 31-00: An unsigned integer which is the nominal frequency of the core crystal clock in Hz.\r\nEDX Bits 31-00: Reserved = 0.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9df85eff-a9ac-4a09-8c20-8c2e8a983688.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=88cb0b88849b8e0a19809fca1b4f9e8f4a48bfad432c98330ebc6da4697e048b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 386
      },
      {
        "segments": [
          {
            "segment_id": "a5789a71-eaae-4a38-9c1f-ede3478c026c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "1-18 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nProcessor Frequency Information Leaf \r\n16H EAX\r\nEBX\r\nECX\r\nEDX\r\nBits 15-00: Processor Base Frequency (in MHz).\r\nBits 31-16: Reserved =0\r\nBits 15-00: Maximum Frequency (in MHz).\r\nBits 31-16: Reserved = 0\r\nBits 15-00: Bus (Reference) Frequency (in MHz).\r\nBits 31-16: Reserved = 0\r\nReserved \r\nNOTES:\r\n* Data is returned from this interface in accordance with the processor's specification and does not \r\nreflect actual values. Suitable use of this data includes the display of processor information in like \r\nmanner to the processor brand string and for determining the appropriate range to use when \r\ndisplaying processor information e.g. frequency history graphs. The returned information should not \r\nbe used for any other purpose as the returned information does not accurately correlate to \r\ninformation / counters returned by other processor interfaces. \r\nWhile a processor may support the Processor Frequency Information leaf, fields that return a value \r\nof zero are not supported.\r\nSystem-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)\r\n17H NOTES:\r\nLeaf 17H main leaf (ECX = 0).\r\nLeaf 17H output depends on the initial value in ECX.\r\nLeaf 17H sub-leaves 1 through 3 reports SOC Vendor Brand String.\r\nLeaf 17H is valid if MaxSOCID_Index >= 3.\r\nLeaf 17H sub-leaves 4 and above are reserved.\r\nEAX Bits 31-00: MaxSOCID_Index. Reports the maximum input value of supported sub-leaf in leaf 17H.\r\nEBX Bits 15-00: SOC Vendor ID.\r\nBit 16: IsVendorScheme. If 1, the SOC Vendor ID field is assigned via an industry standard \r\nenumeration scheme. Otherwise, the SOC Vendor ID field is assigned by Intel.\r\nBits 31-17: Reserved = 0.\r\nECX Bits 31-00: Project ID. A unique number an SOC vendor assigns to its SOC projects.\r\nEDX Bits 31-00: Stepping ID. A unique number within an SOC project that an SOC vendor assigns.\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)\r\n17H EAX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEBX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nECX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEDX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nNOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nSOC Vendor Brand String is a UTF-8 encoded string padded with trailing bytes of 00H.\r\nThe complete SOC Vendor Brand String is constructed by concatenating in ascending order of\r\nEAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a5789a71-eaae-4a38-9c1f-ede3478c026c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=639a5d9930bb375d788ec638260f1f8ec88f99c6a63bb46583706431a6efb278",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 420
      },
      {
        "segments": [
          {
            "segment_id": "4a7999d6-eb52-44d9-b4fb-907af93d3eee",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-19\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)\r\n17H NOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nEAX Bits 31-00: Reserved = 0.\r\nEBX Bits 31-00: Reserved = 0.\r\nECX Bits 31-00: Reserved = 0.\r\nEDX Bits 31-00: Reserved = 0.\r\nDeterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)\r\n18H NOTES:\r\nEach sub-leaf enumerates a different address translations structure. Valid sub-leaves do not need \r\nto be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than \r\nan invalid sub-leaf or than a valid sub-leaf of a higher or lower-level structure. \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31-00: Reports the maximum input value of supported sub-leaf in leaf 18H.\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07-04: Reserved.\r\nBits 10-08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15-11: Reserved.\r\nBits 31-16: W = Ways of associativity.\r\nECX Bits 31-00: S = Number of Sets.\r\nEDX Bits 04-00: Translation cache type field.\r\n00000b: Null (indicates this sub-leaf is not valid).\r\n00001b: Data TLB.\r\n00010b: Instruction TLB.\r\n00011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07-05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13-09: Reserved.\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31-26: Reserved.\r\nDeterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX ≥ 1)\r\n18H NOTES:\r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31-00: Reserved.\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4a7999d6-eb52-44d9-b4fb-907af93d3eee.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e8768bbe88c1aa204535e8a1416d9b049d77db18971be3b2a958088388627593",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 377
      },
      {
        "segments": [
          {
            "segment_id": "b849cdc7-c0f9-4d72-86a7-d69c8a14ed54",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "1-20 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07-04: Reserved.\r\nBits 10-08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15-11: Reserved.\r\nBits 31-16: W = Ways of associativity.\r\nECX Bits 31-00: S = Number of Sets.\r\nEDX Bits 04-00: Translation cache type field.\r\n0000b: Null (indicates this sub-leaf is not valid).\r\n0001b: Data TLB.\r\n0010b: Instruction TLB.\r\n0011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07-05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13-09: Reserved.\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31-26: Reserved.\r\nPCONFIG Information Sub-leaf (EAX = 1BH, ECX ≥ 0)\r\n1BH NOTES:\r\nLeaf 1BH is supported if CPUID.(EAX=07H, ECX=0H):EDX[18] = 1.\r\nFor sub-leaves of 1BH, the definition of EDX, ECX, EBX, EAX depends on the sub-leaf type listed \r\nbelow.\r\n* Currently MKTME is the only defined target and is indicated by identifier 1. An identifier of 0 \r\nindicates an invalid target. If MKTME is a supported target, the MKTME_KEY_PROGRAM leaf of \r\nPCONFIG is available.\r\nEAX Bits 11-00: Sub-leaf type\r\n0: Invalid sub-leaf. On an invalid sub-leaf type returned, subsequent sub-leaves are also invalid. \r\nEBX, ECX and EDX all return 0 for this case.\r\n1: Target Identifier. This sub-leaf enumerates PCONFIG targets supported on the platform. \r\nSoftware must scan until an invalid sub-leaf type is returned. EBX, ECX and EDX are defined below \r\nfor this case.\r\nBits 31-12: 0\r\nEBX * Identifier of target 3n+1 (where n is the sub-leaf number, the initial value of ECX).\r\nECX * Identifier of target 3n+2.\r\nEDX * Identifier of target 3n+3.\r\nUnimplemented CPUID Leaf Functions\r\n40000000H \r\n-\r\n4FFFFFFFH\r\nInvalid. No existing or future CPU will return processor identification or feature information if the \r\ninitial EAX value is in the range 40000000H to 4FFFFFFFH.\r\nExtended Function CPUID Information\r\n80000000H EAX Maximum Input Value for Extended Function CPUID Information (see Table 1-5).\r\nEBX\r\nECX\r\nEDX\r\nReserved\r\nReserved\r\nReserved\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b849cdc7-c0f9-4d72-86a7-d69c8a14ed54.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8f4fb95ca424fbaf90f87500ec61569bc6ef6087f86ee29dd6147004e3be6eb4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 385
      },
      {
        "segments": [
          {
            "segment_id": "e0f2659b-9ac6-44c9-ab0f-20fd4915171a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-21\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n80000001H EAX\r\nEBX\r\nECX\r\nExtended Processor Signature and Feature Bits.\r\nReserved\r\nBit 00: LAHF/SAHF available in 64-bit mode\r\nBits 04-01: Reserved\r\nBit 05: LZCNT available\r\nBits 07-06: Reserved\r\nBit 08: PREFETCHW\r\nBits 31-09: Reserved\r\nEDX Bits 10-00: Reserved\r\nBit 11: SYSCALL/SYSRET available (when in 64-bit mode)\r\nBits 19-12: Reserved = 0\r\nBit 20: Execute Disable Bit available\r\nBits 25-21: Reserved = 0\r\nBit 26: 1-GByte pages are available if 1\r\nBit 27: RDTSCP and IA32_TSC_AUX are available if 1\r\nBits 28: Reserved = 0\r\nBit 29: Intel® 64 Architecture available if 1\r\nBits 31-30: Reserved = 0\r\n80000002H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000003H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000004H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000005H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\n80000006H EAX\r\nEBX\r\nReserved = 0\r\nReserved = 0\r\nECX\r\nEDX\r\nBits 07-00: Cache Line size in bytes\r\nBits 11-08: Reserved\r\nBits 15-12: L2 Associativity field *\r\nBits 31-16: Cache size in 1K units\r\nReserved = 0\r\nNOTES:\r\n* L2 associativity field encodings:\r\n00H - Disabled\r\n01H - Direct mapped\r\n02H - 2-way\r\n04H - 4-way\r\n06H - 8-way\r\n08H - 16-way\r\n0FH - Fully associative\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e0f2659b-9ac6-44c9-ab0f-20fd4915171a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5cd7aed32be2c10a04ef06fc9a8654dfe8cde1b516ade6b4d88ce5f37c8338d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 268
      },
      {
        "segments": [
          {
            "segment_id": "59a54730-c42c-448e-9bc3-b390ebb63e10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "1-22 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0H: Returns CPUID’s Highest Value for Basic Processor Information and the Vendor Identification \r\nString\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the CPUID recognizes for \r\nreturning basic processor information. The value is returned in the EAX register (see Table 1-5) and is processor \r\nspecific.\r\nA vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is “Genuin\u0002eIntel” and is expressed:\r\nEBX ← 756e6547h (* \"Genu\", with G in the low 4 bits of BL *)\r\nEDX ← 49656e69h (* \"ineI\", with i in the low 4 bits of DL *)\r\nECX ← 6c65746eh (* \"ntel\", with n in the low 4 bits of CL *)\r\nINPUT EAX = 80000000H: Returns CPUID’s Highest Value for Extended Processor Information\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the processor recognizes for \r\nreturning extended processor information. The value is returned in the EAX register (see Table 1-5) and is \r\nprocessor specific.\r\n80000007H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nBits 07-00: Reserved = 0\r\nBit 08: Invariant TSC available if 1\r\nBits 31-09: Reserved = 0\r\n80000008H EAX Virtual/Physical Address size \r\nBits 07-00: #Physical Address Bits*\r\nBits 15-08: #Virtual Address Bits\r\nBits 31-16: Reserved = 0\r\nEBX\r\nECX\r\nEDX\r\nBits 08-00: Reserved = 0\r\nBit 09: WBNOINVD is available if 1\r\nBits 31-10: Reserved = 0\r\nReserved = 0\r\nReserved = 0\r\nNOTES:\r\n* If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported\r\nshould come from this field.\r\nTable 1-5. Highest CPUID Source Operand for Intel 64 and IA-32 Processors \r\nIntel 64 or IA-32 Processors Highest Value in EAX\r\nBasic Information Extended Function Information\r\nEarlier Intel486 Processors CPUID Not Implemented CPUID Not Implemented\r\nLater Intel486 Processors and Pentium \r\nProcessors\r\n01H Not Implemented\r\nPentium Pro and Pentium II Processors, \r\nIntel®\r\n Celeron® Processors\r\n02H Not Implemented\r\nPentium III Processors 03H Not Implemented\r\nPentium 4 Processors 02H 80000004H\r\nTable 1-4. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/59a54730-c42c-448e-9bc3-b390ebb63e10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b47128750d110cf9e4f37180616eba95401ddc44b92a0a04a4c0a9a82f763a96",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 357
      },
      {
        "segments": [
          {
            "segment_id": "17d2df37-d8cb-4d61-b330-d910cf2ebf53",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-23\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIA32_BIOS_SIGN_ID Returns Microcode Update Signature\r\nFor processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update \r\nsignature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 10 in \r\nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. \r\nINPUT EAX = 01H: Returns Model, Family, Stepping Information\r\nWhen CPUID executes with EAX set to 01H, version information is returned in EAX (see Figure 1-3). For example: \r\nmodel, family, and processor type for the Intel Xeon processor 5100 series is as follows:\r\n• Model — 1111B\r\n• Family — 0101B\r\n• Processor Type — 00B\r\nSee Table 1-6 for available processor type values. Stepping IDs are provided as needed.\r\nIntel Xeon Processors 02H 80000004H\r\nPentium M Processor 02H 80000004H\r\nPentium 4 Processor supporting Hyper\u0002Threading Technology05H 80000008H\r\nPentium D Processor (8xx) 05H 80000008H\r\nPentium D Processor (9xx) 06H 80000008H\r\nIntel Core Duo Processor 0AH 80000008H\r\nIntel Core 2 Duo Processor 0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5300 \r\nSeries\r\n0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5200, \r\n5300, 5400 Series\r\n0AH 80000008H\r\nIntel Core 2 Duo Processor 8000 Series 0DH 80000008H\r\nIntel Xeon Processor 5200, 5400 Series 0AH 80000008H\r\nFigure 1-3. Version Information Returned by CPUID in EAX\r\nTable 1-5. Highest CPUID Source Operand for Intel 64 and IA-32 Processors (Continued)\r\nIntel 64 or IA-32 Processors Highest Value in EAX\r\nBasic Information Extended Function Information\r\nProcessor Type \r\n31 28 27 20 19 16 15 14 13 12 11 8 7 4 3 0\r\nEAX\r\nFamily (0FH for the Pentium 4 Processor Family)\r\nModel \r\nExtended\r\nFamily ID\r\nExtended\r\nModel ID\r\nFamily\r\nID Model Stepping\r\nID\r\nExtended Family ID (0)\r\nExtended Model ID (0)\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/17d2df37-d8cb-4d61-b330-d910cf2ebf53.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=24f19000742d7034035bd1682680e404314f3b6d69fde863bc6fc9d95564f508",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 294
      },
      {
        "segments": [
          {
            "segment_id": "ad8a8681-cf4b-409a-ad3c-7706759b0a1c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "1-24 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nNOTE\r\nSee \"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A, and Chapter 16 in the Intel® 64 and IA-32 Archi\u0002tectures Software Developer’s Manual, Volume 1, for information on identifying earlier IA-32 \r\nprocessors.\r\nThe Extended Family ID needs to be examined only when the Family ID is 0FH. Integrate the fields into a display \r\nusing the following rule:\r\nIF Family_ID ≠ 0FH\r\nTHEN Displayed_Family = Family_ID;\r\nELSE Displayed_Family = Extended_Family_ID + Family_ID;\r\n(* Right justify and zero-extend 4-bit field. *)\r\nFI;\r\n(* Show Display_Family as HEX field. *)\r\nThe Extended Model ID needs to be examined only when the Family ID is 06H or 0FH. Integrate the field into a \r\ndisplay using the following rule:\r\nIF (Family_ID = 06H or Family_ID = 0FH)\r\nTHEN Displayed_Model = (Extended_Model_ID << 4) + Model_ID;\r\n(* Right justify and zero-extend 4-bit field; display Model_ID as HEX field.*)\r\nELSE Displayed_Model = Model_ID;\r\nFI;\r\n(* Show Display_Model as HEX field. *)\r\nINPUT EAX = 01H: Returns Additional Information in EBX\r\nWhen CPUID executes with EAX set to 01H, additional information is returned to the EBX register: \r\n• Brand index (low byte of EBX) — this number provides an entry into a brand string table that contains brand \r\nstrings for IA-32 processors. More information about this field is provided later in this section. \r\n• CLFLUSH instruction cache line size (second byte of EBX) — this number indicates the size of the cache line \r\nflushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.\r\n• Local APIC ID (high byte of EBX) — this number is the 8-bit ID that is assigned to the local APIC on the \r\nprocessor during power up. This field was introduced in the Pentium 4 processor.\r\nINPUT EAX = 01H: Returns Feature Information in ECX and EDX\r\nWhen CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX.\r\n• Figure 1-4 and Table 1-7 show encodings for ECX.\r\n• Figure 1-5 and Table 1-8 show encodings for EDX.\r\nFor all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.\r\nNOTE\r\nSoftware must confirm that a processor feature is present using feature flags returned by CPUID \r\nprior to using the feature. Software should not depend on future offerings retaining all features.\r\nTable 1-6. Processor Type Field\r\nType Encoding\r\nOriginal OEM Processor 00B\r\nIntel OverDrive® Processor 01B\r\nDual processor (not applicable to Intel486 processors) 10B\r\nIntel reserved 11B",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/ad8a8681-cf4b-409a-ad3c-7706759b0a1c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=254632604a3673532d356e07c4f29ec06b8b0967d77734a11703466aef2843ae",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 433
      },
      {
        "segments": [
          {
            "segment_id": "f1b7cfa8-5a81-402c-a71f-25b2a51d3add",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-25\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nFigure 1-4. Feature Information Returned in the ECX Register\r\nTable 1-7. Feature Information Returned in the ECX Register \r\nBit # Mnemonic Description\r\n0 SSE3 Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\r\n1 PCLMULQDQ A value of 1 indicates the processor supports PCLMULQDQ instruction.\r\n2 DTES64 64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout.\r\n3 MONITOR MONITOR/MWAIT. A value of 1 indicates the processor supports this feature. \r\n4 DS-CPL CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the \r\nDebug Store feature to allow for branch message storage qualified by CPL.\r\n5 VMX Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.\r\n6 SMX Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See \r\nChapter 6, “Safer Mode Extensions Reference”.\r\n7 EST Enhanced Intel SpeedStep® Technology. A value of 1 indicates that the processor supports this \r\ntechnology.\r\n8 TM2 Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology. \r\n9 SSSE3 A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A \r\nvalue of 0 indicates the instruction extensions are not present in the processor.\r\nCNXT-ID — L1 Context ID\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nECX\r\nTM2 — Thermal Monitor 2\r\nEST — Enhanced Intel SpeedStep® Technology\r\nDS-CPL — CPL Qualified Debug Store\r\nMONITOR — MONITOR/MWAIT\r\nPCLMULQDQ — Carryless Multiplication\r\nReserved\r\nCMPXCHG16B\r\nSMX — Safer Mode Extensions\r\nxTPR Update Control\r\nSSSE3 — SSSE3 Extensions\r\nPDCM — Perf/Debug Capability MSR\r\nVMX — Virtual Machine Extensions\r\nSSE4_1 — SSE4.1\r\nOSXSAVE\r\nSSE4_2 — SSE4.2\r\nDCA — Direct Cache Access\r\nx2APIC\r\nPOPCNT\r\nXSAVE\r\nAVX\r\nAES\r\nFMA — Fused Multiply Add\r\nSSE3 — SSE3 Extensions\r\nPCID — Process-context Identifiers\r\n0\r\nDTES64 — 64-bit DS Area\r\nMOVBE\r\nTSC-Deadline\r\nF16C\r\nRDRAND\r\nSDBG",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f1b7cfa8-5a81-402c-a71f-25b2a51d3add.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d5884df717a09379594c3a861a0470eaf8ed10ffacefcfc3be39a612f600dc35",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 353
      },
      {
        "segments": [
          {
            "segment_id": "79dbb91c-f26e-4a8e-8d54-efd1508183d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "1-26 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n10 CNXT-ID L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or \r\nshared mode. A value of 0 indicates this feature is not supported. See definition of the \r\nIA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\r\n11 SDBG A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.\r\n12 FMA A value of 1 indicates the processor supports FMA extensions using YMM state.\r\n13 CMPXCHG16B CMPXCHG16B Available. A value of 1 indicates that the feature is available.\r\n14 xTPR Update \r\nControl\r\nxTPR Update Control. A value of 1 indicates that the processor supports changing \r\nIA32_MISC_ENABLES[bit 23]. \r\n15 PDCM Perfmon and Debug Capability. A value of 1 indicates the processor supports the performance and \r\ndebug feature indication MSR IA32_PERF_CAPABILITIES.\r\n16 Reserved Reserved\r\n17 PCID Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and that \r\nsoftware may set CR4.PCIDE to 1.\r\n18 DCA A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped \r\ndevice.\r\n19 SSE4.1 A value of 1 indicates that the processor supports SSE4.1. \r\n20 SSE4.2 A value of 1 indicates that the processor supports SSE4.2. \r\n21 x2APIC A value of 1 indicates that the processor supports x2APIC feature.\r\n22 MOVBE A value of 1 indicates that the processor supports MOVBE instruction.\r\n23 POPCNT A value of 1 indicates that the processor supports the POPCNT instruction.\r\n24 TSC-Deadline A value of 1 indicates that the processor’s local APIC timer supports one-shot operation using a TSC \r\ndeadline value.\r\n25 AES A value of 1 indicates that the processor supports the AESNI instruction extensions.\r\n26 XSAVE A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states \r\nfeature, the XSETBV/XGETBV instructions, and XCR0.\r\n27 OSXSAVE A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV \r\ninstructions to access XCR0 and to support processor extended state management using \r\nXSAVE/XRSTOR.\r\n28 AVX A value of 1 indicates that processor supports AVX instructions operating on 256-bit YMM state, and \r\nthree-operand encoding of 256-bit and 128-bit SIMD instructions.\r\n29 F16C A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.\r\n30 RDRAND A value of 1 indicates that processor supports RDRAND instruction.\r\n31 Not Used Always return 0.\r\nTable 1-7. Feature Information Returned in the ECX Register (Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/79dbb91c-f26e-4a8e-8d54-efd1508183d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a964fd2b8975c0d5ac8c1ad969f691cfc7da9c49c462ce079a0cf6e567661e21",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 415
      },
      {
        "segments": [
          {
            "segment_id": "bd31f1b7-51ee-44a7-a7bc-9005344941ac",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-27\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nFigure 1-5. Feature Information Returned in the EDX Register\r\nTable 1-8. More on Feature Information Returned in the EDX Register\r\nBit # Mnemonic Description\r\n0 FPU Floating-point Unit On-Chip. The processor contains an x87 FPU.\r\n1 VME Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the \r\nfeature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS \r\nwith the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags. \r\n2 DE Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional \r\ntrapping of accesses to DR4 and DR5. \r\n3 PSE Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the \r\nfeature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and \r\nPTEs. \r\n4 TSC Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\r\n5 MSR Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are \r\nsupported. Some of the MSRs are implementation dependent.\r\nPBE–Pend. Brk. EN.\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nEDX\r\nTM–Therm. Monitor\r\nHTT–Multi-threading\r\nSS–Self Snoop\r\nSSE2–SSE2 Extensions\r\nSSE–SSE Extensions\r\nFXSR–FXSAVE/FXRSTOR\r\nMMX–MMX Technology\r\nACPI–Thermal Monitor and Clock Ctrl\r\nDS–Debug Store\r\nCLFSH–CFLUSH instruction\r\nPSN–Processor Serial Number\r\nPSE-36 – Page Size Extension\r\nPAT–Page Attribute Table\r\nCMOV–Conditional Move/Compare Instruction\r\nMCA–Machine Check Architecture\r\nPGE–PTE Global Bit\r\nMTRR–Memory Type Range Registers\r\nSEP–SYSENTER and SYSEXIT\r\nAPIC–APIC on Chip\r\nCX8–CMPXCHG8B Inst.\r\nMCE–Machine Check Exception\r\nPAE–Physical Address Extensions\r\nMSR–RDMSR and WRMSR Support\r\nTSC–Time Stamp Counter\r\nPSE–Page Size Extensions\r\nDE–Debugging Extensions\r\nVME–Virtual-8086 Mode Enhancement\r\nFPU–x87 FPU on Chip\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/bd31f1b7-51ee-44a7-a7bc-9005344941ac.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2aa6ff2a3193a05b2c6298d7141bb9c1a11143ac6c614fe7d66126a6be72ae1a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 298
      },
      {
        "segments": [
          {
            "segment_id": "f930cda4-347a-4693-8d10-4a339adadf75",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "1-28 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n6 PAE Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 MCE Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 APIC APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 MCA Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual, Volume 3C).\r\n22 ACPI Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 FXSR FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\nTable 1-8. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f930cda4-347a-4693-8d10-4a339adadf75.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=94c1de71d9a133fe3e8acc383d9cf8624327d602eda105a9bd48dd7ad2a967e1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 639
      },
      {
        "segments": [
          {
            "segment_id": "f930cda4-347a-4693-8d10-4a339adadf75",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "1-28 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n6 PAE Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 MCE Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 APIC APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 MCA Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual, Volume 3C).\r\n22 ACPI Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 FXSR FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\nTable 1-8. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f930cda4-347a-4693-8d10-4a339adadf75.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=94c1de71d9a133fe3e8acc383d9cf8624327d602eda105a9bd48dd7ad2a967e1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 639
      },
      {
        "segments": [
          {
            "segment_id": "761b8acb-eb37-4343-beec-a961d1976355",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-29\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal caches \r\nand TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 1-9 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31 PBE Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 1-9. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 1-8. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/761b8acb-eb37-4343-beec-a961d1976355.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec6fb800539cd20cc2ec908daaadb4184b628bb8447926e19bbd7230458bcd52",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 582
      },
      {
        "segments": [
          {
            "segment_id": "761b8acb-eb37-4343-beec-a961d1976355",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-29\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal caches \r\nand TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 1-9 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31 PBE Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 1-9. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 1-8. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/761b8acb-eb37-4343-beec-a961d1976355.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec6fb800539cd20cc2ec908daaadb4184b628bb8447926e19bbd7230458bcd52",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 582
      },
      {
        "segments": [
          {
            "segment_id": "5d507806-f4b8-495a-8cef-288d0a7ba64a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "1-30 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7AH 2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7BH 2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7CH 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7DH 2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\r\n7FH 2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\r\n82H 2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\r\nTable 1-9. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5d507806-f4b8-495a-8cef-288d0a7ba64a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7a36bfabf8acc7390f77034364e27c252efef2f0aeefd3e370fbdd8923013b76",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "5d507806-f4b8-495a-8cef-288d0a7ba64a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "1-30 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7AH 2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7BH 2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7CH 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7DH 2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\r\n7FH 2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\r\n82H 2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\r\nTable 1-9. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5d507806-f4b8-495a-8cef-288d0a7ba64a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7a36bfabf8acc7390f77034364e27c252efef2f0aeefd3e370fbdd8923013b76",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 524
      },
      {
        "segments": [
          {
            "segment_id": "45424f90-b106-4ac8-b23c-d1571a973f81",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-31\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nExample 1-1. Example of Cache and TLB Interpretation\r\nThe first member of the family of Pentium 4 processors returns the following information about caches and TLBs \r\nwhen the CPUID executes with an input value of 2:\r\nEAX 66 5B 50 01H\r\nEBX 0H\r\nECX 0H\r\nEDX 00 7A 70 00H\r\nWhich means:\r\n• The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed \r\nonce with an input value of 2 to retrieve complete information about caches and TLBs.\r\n• The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register \r\ncontains valid 1-byte descriptors.\r\n• Bytes 1, 2, and 3 of register EAX indicate that the processor has:\r\n— 50H - a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages.\r\n— 5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages.\r\n— 66H - an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.\r\n• The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.\r\n• Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has:\r\n— 00H - NULL descriptor.\r\n— 70H - Trace cache: 12 K-μop, 8-way set associative.\r\n— 7AH - a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size.\r\n— 00H - NULL descriptor.\r\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\r\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data \r\nthat describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid \r\nindex values start from 0.\r\nSoftware can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an \r\nindex value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally \r\ndefined fields reported by deterministic cache parameters are documented in Table 1-4.\r\n83H 2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size\r\n84H 2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size\r\n85H 2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size\r\n86H 2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size\r\n87H 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size\r\nB0H Instruction TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB1H Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries\r\nB3H Data TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB4H Data TLB1: 4 KByte pages, 4-way associative, 256 entries\r\nF0H 64-Byte prefetching\r\nF1H 128-Byte prefetching\r\nTable 1-9. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/45424f90-b106-4ac8-b23c-d1571a973f81.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=819f5bb9d91192238ef24b3584e619244ceb521bc3d3c2d001a1e94a73e4c3cd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 481
      },
      {
        "segments": [
          {
            "segment_id": "9be1f063-3a68-4150-9a10-7283b293679e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "1-32 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nThe CPUID leaf 4 also reports data that can be used to derive the topology of processor cores in a physical package. \r\nThis information is constant for all valid index values. Software can query the raw data reported by executing \r\nCPUID with EAX=04H and ECX=0H and use it as part of the topology enumeration algorithm described in Chapter \r\n8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A.\r\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features\r\nWhen CPUID executes with EAX set to 05H, the processor returns information about features available to \r\nMONITOR/MWAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with \r\nMWAIT instruction. The MWAIT instruction optionally provides additional extensions for advanced power manage\u0002ment. See Table 1-4. \r\nINPUT EAX = 06H: Returns Thermal and Power Management Features\r\nWhen CPUID executes with EAX set to 06H, the processor returns information about thermal and power manage\u0002ment features. See Table 1-4. \r\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information\r\nWhen CPUID executes with EAX set to 07H and ECX = 0H, the processor returns information about the maximum \r\nnumber of sub-leaves that contain extended feature flags. See Table 1-4. \r\nWhen CPUID executes with EAX set to 07H and ECX = n (n > 1and less than the number of non-zero bits in \r\nCPUID.(EAX=07H, ECX= 0H).EAX, the processor returns information about extended feature flags. See Table 1-4. \r\nIn sub-leaf 0, only EAX has the number of sub-leaves. In sub-leaf 0, EBX, ECX & EDX all contain extended feature \r\nflags.\r\nINPUT EAX = 09H: Returns Direct Cache Access Information\r\nWhen CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabili\u0002ties. See Table 1-4. \r\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features\r\nWhen CPUID executes with EAX set to 0AH, the processor returns information about support for architectural \r\nperformance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see Table \r\n1-4) is greater than Pn 0. See Table 1-4.\r\nFor each version of architectural performance monitoring capability, software must enumerate this leaf to discover \r\nthe programming facilities and the architectural performance events available in the processor. The details are \r\ndescribed in Chapter 17, “Debug, Branch Profile, TSC, and Quality of Service,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A.\r\nINPUT EAX = 0BH: Returns Extended Topology Information\r\nWhen CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumera\u0002tion data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported \r\nby CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 1-4.\r\nTable 1-10. Structured Extended Feature Leaf, Function 0, EBX Register \r\nBit # Mnemonic Description\r\n0 RWFSGSBASE A value of 1 indicates the processor supports RD/WR FSGSBASE instructions\r\n1-31 Reserved Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9be1f063-3a68-4150-9a10-7283b293679e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=713e1ac580502d6fc9baa2e7650b2a0d94eb62484d4fe28387a5d18cafbc436a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 486
      },
      {
        "segments": [
          {
            "segment_id": "d256e2ec-0d3f-4ae3-a0ed-127e3fed696c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-33\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 1-4. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 1-4. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Platform Quality of Service (PQoS) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 1-4.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Platform Quality of Service (PQoS) Enforcement Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 1-4.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 12H: Returns Intel SGX Enumeration Information\r\nWhen CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capa\u0002bilities. See Table 1-4. \r\nWhen CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attri\u0002butes. See Table 1-4. \r\nWhen CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX \r\nEnclave Page Cache. See Table 1-4.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 1-4. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 1-4. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/d256e2ec-0d3f-4ae3-a0ed-127e3fed696c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1249fe70fea1f1ab13ab9653cbda9eb57d2e86ecc1540ddff1831d90067031d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 648
      },
      {
        "segments": [
          {
            "segment_id": "d256e2ec-0d3f-4ae3-a0ed-127e3fed696c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-33\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 1-4. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 1-4. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Platform Quality of Service (PQoS) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 1-4.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Platform Quality of Service (PQoS) Enforcement Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 1-4.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 12H: Returns Intel SGX Enumeration Information\r\nWhen CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capa\u0002bilities. See Table 1-4. \r\nWhen CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attri\u0002butes. See Table 1-4. \r\nWhen CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX \r\nEnclave Page Cache. See Table 1-4.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 1-4. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 1-4. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/d256e2ec-0d3f-4ae3-a0ed-127e3fed696c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1249fe70fea1f1ab13ab9653cbda9eb57d2e86ecc1540ddff1831d90067031d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 648
      },
      {
        "segments": [
          {
            "segment_id": "3e1e2e74-d602-4f75-9bed-285c08b81e61",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "1-34 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nCounter and Core Crystal Clock. See Table 1-4.\r\nINPUT EAX = 16H: Returns Processor Frequency Information\r\nWhen CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Informa\u0002tion. See Table 1-4. \r\nINPUT EAX = 17H: Returns System-On-Chip Information\r\nWhen CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor \r\nAttribute Enumeration. See Table 1-4. \r\nINPUT EAX = 18H: Returns Deterministic Address Translation Parameters Information\r\nWhen CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address \r\nTranslation Parameters. See Table 1-4. \r\nINPUT EAX = 1BH: Returns PCONFIG Information\r\nWhen CPUID executes with EAX set to 1BH, the processor returns information about PCONFIG capabilities. See \r\nTable 1-3. \r\nMETHODS FOR RETURNING BRANDING INFORMATION\r\nUse the following techniques to access branding information:\r\n1. Processor brand string method; this method also returns the processor’s maximum operating frequency\r\n2. Processor brand index; this method uses a software supplied brand string table.\r\nThese two methods are discussed in the following sections. For methods that are available in early processors, see \r\nSection: “Identification of Earlier IA-32 Processors” in Chapter 16 of the Intel® 64 and IA-32 Architectures Soft\u0002ware Developer’s Manual, Volume 1.\r\nThe Processor Brand String Method\r\nFigure 1-6 describes the algorithm used for detection of the brand string. Processor brand identification software \r\nshould execute this algorithm on all Intel 64 and IA-32 processors. \r\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum \r\noperating frequency of the processor to the EAX, EBX, ECX, and EDX registers.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3e1e2e74-d602-4f75-9bed-285c08b81e61.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ef57033908613a03e6d38a5e304565ca6b1325c904b24b3c91587dc50de070fb",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ad09c1d1-0e97-47db-bfb2-92956b9db855",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-35\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nHow Brand Strings Work\r\nTo use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input \r\nvalue, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL-termi\u0002nated.\r\nTable 1-11 shows the brand string that is returned by the first processor in the Pentium 4 processor family.\r\nFigure 1-6. Determination of Support for the Processor Brand String\r\nTable 1-11. Processor Brand String Returned with Pentium 4 Processor \r\nEAX Input Value Return Values ASCII Equivalent\r\n80000002H EAX = 20202020H\r\nEBX = 20202020H\r\nECX = 20202020H\r\nEDX = 6E492020H\r\n“ ” \r\n“ ”\r\n“ ”\r\n“nI ”\r\n80000003H EAX = 286C6574H\r\nEBX = 50202952H\r\nECX = 69746E65H\r\nEDX = 52286D75H\r\n“(let”\r\n“P )R”\r\n“itne”\r\n“R(mu”\r\n80000004H EAX = 20342029H\r\nEBX = 20555043H\r\nECX = 30303531H\r\nEDX = 007A484DH\r\n“ 4 )”\r\n“ UPC”\r\n“0051”\r\n“\\0zHM”\r\nIF (EAX & 0x80000000)\r\nCPUID\r\nIF (EAX Return Value \r\n = 0x80000004)\r\nCPUID \r\nFunction\r\nSupported\r\nTrue = \r\nExtended\r\nEAX Return Value =\r\nMax. Extended CPUID\r\nFunction Index\r\nInput: EAX= \r\n0x80000000\r\nProcessor Brand\r\nString Not\r\nSupported\r\nFalse\r\nProcessor Brand\r\nString Supported\r\nTrue",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/ad09c1d1-0e97-47db-bfb2-92956b9db855.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=568c41f9b41cc269ce9c8912d5ba170592a0afbc087ae8f3e72f3ec997420e5e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "efde9fbf-ffc2-4d87-9319-535268049d8c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "1-36 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nExtracting the Maximum Processor Frequency from Brand Strings\r\nFigure 1-7 provides an algorithm which software can use to extract the maximum processor operating frequency \r\nfrom the processor brand string.\r\nNOTE\r\nWhen a frequency is given in a brand string, it is the maximum qualified frequency of the processor, \r\nnot the frequency at which the processor is currently running.\r\nThe Processor Brand Index Method\r\nThe brand index method (introduced with Pentium® III Xeon® processors) provides an entry point into a brand \r\nidentification table that is maintained in memory by system software and is accessible from system- and user-level \r\ncode. In this table, each brand index is associate with an ASCII brand identification string that identifies the official \r\nIntel family and model number of a processor.\r\nWhen CPUID executes with EAX set to 01H, the processor returns a brand index to the low byte in EBX. Software \r\ncan then use this index to locate the brand identification string for the processor in the brand identification table. \r\nThe first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do \r\nnot support the brand identification feature. Starting with processor signature family ID = 0FH, model = 03H, \r\nbrand index method is no longer supported. Use brand string method instead.\r\nFigure 1-7. Algorithm for Extracting Maximum Processor Frequency\r\nIF Substring Matched\r\n\"zHM\", or \r\n\"zHG\", or \r\n\"zHT\"\r\nTrue\r\nDetermine \"Multiplier\"\r\nScan \"Brand String\" in\r\nReverse Byte Order\r\nReport Error\r\nFalse\r\nScan Digits \r\nUntil Blank\r\nMatch\r\nSubstring\r\nDetermine \"Freq\" Reverse Digits\r\nTo Decimal Value\r\nMax. Qualified\r\nFrequency =\r\n\"Freq\" x \"Multiplier\" \"Freq\" = X.YZ if\r\nDigits = \"ZY.X\"\r\nIn Reverse Order\r\nIf \"zHM\"\r\nIf \"zHG\"\r\nIf \"zHT\"\r\nMultiplier = 1 x 1012\r\nMultiplier = 1 x 109\r\nMultiplier = 1 x 106",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/efde9fbf-ffc2-4d87-9319-535268049d8c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=de94a82541a95a90802f63ff11beed4d4dbbddd923a6fe1df9dcc363363692d6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 303
      },
      {
        "segments": [
          {
            "segment_id": "850a270b-10b7-4a5a-8173-43fbd0c2205b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-37\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-12 shows brand indices that have identification strings associated with them.\r\nIA-32 Architecture Compatibility\r\nCPUID is not supported in early models of the Intel486 processor or in any IA-32 processor earlier than the \r\nIntel486 processor.\r\nOperation\r\nIA32_BIOS_SIGN_ID MSR ← Update with installed microcode revision number;\r\nCASE (EAX) OF\r\nEAX = 0:\r\nEAX ← Highest basic function input value understood by CPUID;\r\nEBX ← Vendor identification string;\r\nEDX ← Vendor identification string;\r\nECX ← Vendor identification string;\r\nBREAK;\r\nEAX = 1H:\r\nEAX[3:0] ← Stepping ID; \r\nTable 1-12. Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings\r\nBrand Index Brand String\r\n00H This processor does not support the brand identification feature\r\n01H Intel(R) Celeron(R) processor1\r\n02H Intel(R) Pentium(R) III processor1\r\n03H Intel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) \r\nprocessor\r\n04H Intel(R) Pentium(R) III processor\r\n06H Mobile Intel(R) Pentium(R) III processor-M\r\n07H Mobile Intel(R) Celeron(R) processor1\r\n08H Intel(R) Pentium(R) 4 processor\r\n09H Intel(R) Pentium(R) 4 processor\r\n0AH Intel(R) Celeron(R) processor1\r\n0BH Intel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP\r\n0CH Intel(R) Xeon(R) processor MP\r\n0EH Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor\r\n0FH Mobile Intel(R) Celeron(R) processor1\r\n11H Mobile Genuine Intel(R) processor\r\n12H Intel(R) Celeron(R) M processor\r\n13H Mobile Intel(R) Celeron(R) processor1\r\n14H Intel(R) Celeron(R) processor\r\n15H Mobile Genuine Intel(R) processor\r\n16H Intel(R) Pentium(R) M processor\r\n17H Mobile Intel(R) Celeron(R) processor1\r\n18H – 0FFH RESERVED\r\nNOTES:\r\n1.Indicates versions of these processors that were introduced after the Pentium III ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/850a270b-10b7-4a5a-8173-43fbd0c2205b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7621389f2f2280e3d5d81014e52d305bb88c2dc394efc6432beeab781f429562",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 268
      },
      {
        "segments": [
          {
            "segment_id": "717bef1d-27d0-4a12-910e-11beb97e18b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "1-38 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEAX[7:4] ← Model; \r\nEAX[11:8] ← Family; \r\nEAX[13:12] ← Processor type; \r\nEAX[15:14] ← Reserved;\r\nEAX[19:16] ← Extended Model;\r\nEAX[27:20] ← Extended Family;\r\nEAX[31:28] ← Reserved;\r\nEBX[7:0] ← Brand Index; (* Reserved if the value is zero. *)\r\nEBX[15:8] ← CLFLUSH Line Size;\r\nEBX[16:23] ← Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)\r\nEBX[24:31] ← Initial APIC ID;\r\nECX ← Feature flags; (* See Figure 1-4. *)\r\nEDX ← Feature flags; (* See Figure 1-5. *)\r\nBREAK;\r\nEAX = 2H:\r\nEAX ← Cache and TLB information; \r\n EBX ← Cache and TLB information; \r\n ECX ← Cache and TLB information; \r\nEDX ← Cache and TLB information; \r\nBREAK;\r\nEAX = 3H:\r\nEAX ← Reserved; \r\n EBX ← Reserved; \r\n ECX ← ProcessorSerialNumber[31:0]; \r\n(* Pentium III processors only, otherwise reserved. *)\r\nEDX ← ProcessorSerialNumber[63:32]; \r\n(* Pentium III processors only, otherwise reserved. *\r\nBREAK\r\nEAX = 4H:\r\nEAX ← Deterministic Cache Parameters Leaf; (* See Table 1-4. *)\r\nEBX ← Deterministic Cache Parameters Leaf; \r\n ECX ← Deterministic Cache Parameters Leaf; \r\nEDX ← Deterministic Cache Parameters Leaf; \r\nBREAK;\r\nEAX = 5H:\r\nEAX ← MONITOR/MWAIT Leaf; (* See Table 1-4. *)\r\n EBX ← MONITOR/MWAIT Leaf; \r\n ECX ← MONITOR/MWAIT Leaf; \r\nEDX ← MONITOR/MWAIT Leaf; \r\nBREAK;\r\nEAX = 6H:\r\nEAX ← Thermal and Power Management Leaf; (* See Table 1-4. *)\r\n EBX ← Thermal and Power Management Leaf; \r\n ECX ← Thermal and Power Management Leaf; \r\nEDX ← Thermal and Power Management Leaf; \r\nBREAK;\r\nEAX = 7H:\r\nEAX ← Structured Extended Feature Leaf; (* See Table 1-4. *);\r\n EBX ← Structured Extended Feature Leaf; \r\n ECX ← Structured Extended Feature Leaf; \r\nEDX ← Structured Extended Feature Leaf; \r\nBREAK;\r\nEAX = 8H:\r\nEAX ← Reserved = 0;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/717bef1d-27d0-4a12-910e-11beb97e18b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ab1b7aceca9aa9a52a4e86b20c00f60ac8767b4171ece78a4983467431bb2d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 288
      },
      {
        "segments": [
          {
            "segment_id": "4cc9aace-6ed4-46f3-99dc-f6f9a1816dd4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-39\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 9H:\r\nEAX ← Direct Cache Access Information Leaf; (* See Table 1-4. *)\r\n EBX ← Direct Cache Access Information Leaf; \r\n ECX ← Direct Cache Access Information Leaf; \r\nEDX ← Direct Cache Access Information Leaf; \r\nBREAK;\r\nEAX = AH:\r\nEAX ← Architectural Performance Monitoring Leaf; (* See Table 1-4. *)\r\n EBX ← Architectural Performance Monitoring Leaf; \r\n ECX ← Architectural Performance Monitoring Leaf; \r\nEDX ← Architectural Performance Monitoring Leaf; \r\nBREAK\r\nEAX = BH:\r\nEAX ← Extended Topology Enumeration Leaf; (* See Table 1-4. *)\r\nEBX ← Extended Topology Enumeration Leaf; \r\n ECX ← Extended Topology Enumeration Leaf; \r\nEDX ← Extended Topology Enumeration Leaf; \r\nBREAK;\r\nEAX = CH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = DH:\r\nEAX ← Processor Extended State Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← Processor Extended State Enumeration Leaf; \r\n ECX ← Processor Extended State Enumeration Leaf; \r\nEDX ← Processor Extended State Enumeration Leaf; \r\nBREAK;\r\nEAX = EH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = FH:\r\nEAX ← Platform Quality of Service Monitoring Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\n ECX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nEDX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nBREAK;\r\nEAX = 10H:\r\nEAX ← Platform Quality of Service Enforcement Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\n ECX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nEDX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nBREAK;\r\nEAX = 14H:\r\nEAX ← Intel Processor Trace Enumeration Leaf; (* See Table 1-4. *)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4cc9aace-6ed4-46f3-99dc-f6f9a1816dd4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=abb3418a9f12bf1c6f5144130016e7ec42deb1135d51a51870124ba5b4806a39",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 320
      },
      {
        "segments": [
          {
            "segment_id": "703d2fbd-ab65-43ef-8e29-52db556603e9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "1-40 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n EBX ← Intel Processor Trace Enumeration Leaf; \r\n ECX ← Intel Processor Trace Enumeration Leaf; \r\nEDX ← Intel Processor Trace Enumeration Leaf; \r\nBREAK;\r\nEAX = 15H:\r\nEAX ← Time Stamp Counter and Core Crystal Clock Information Leaf; (* See Table 1-4. *)\r\n EBX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\n ECX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nEDX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nBREAK;\r\nEAX = 16H:\r\nEAX ← Processor Frequency Information Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← Processor Frequency Information Enumeration Leaf; \r\n ECX ← Processor Frequency Information Enumeration Leaf; \r\nEDX ← Processor Frequency Information Enumeration Leaf; \r\nBREAK;\r\nEAX = 17H:\r\nEAX ← System-On-Chip Vendor Attribute Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\n ECX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nEDX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nBREAK;\r\nEAX = 18H:\r\nEAX ← Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\n ECX ←Deterministic Address Translation Parameters Enumeration Leaf; \r\nEDX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\nBREAK;\r\nEAX = 1BH:\r\nEAX ← PCONFIG Information Enumeration Leaf; (* See Table 1-4. *)\r\n EBX ← PCONFIG Information Enumeration Leaf; \r\n ECX ←PCONFIG Information Enumeration Leaf; \r\nEDX ← PCONFIG Information Enumeration Leaf; \r\nBREAK;\r\nEAX = 80000000H:\r\nEAX ← Highest extended function input value understood by CPUID;\r\nEBX ← Reserved; \r\nECX ← Reserved; \r\nEDX ← Reserved; \r\nBREAK;\r\nEAX = 80000001H:\r\nEAX ← Reserved; \r\nEBX ← Reserved; \r\nECX ← Extended Feature Bits (* See Table 1-4.*); \r\nEDX ← Extended Feature Bits (* See Table 1-4. *); \r\nBREAK;\r\nEAX = 80000002H:\r\nEAX ← Processor Brand String; \r\nEBX ← Processor Brand String, continued;\r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000003H:\r\nEAX ← Processor Brand String, continued; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/703d2fbd-ab65-43ef-8e29-52db556603e9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2dcddc13ce0f04ef94b568280076da38cacdf26a7c6ee2db18370ae715a6a4d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 320
      },
      {
        "segments": [
          {
            "segment_id": "bdb4710a-c468-48d2-a4b4-b1ae03dc7da7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-41\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000004H:\r\nEAX ← Processor Brand String, continued; \r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued;\r\nBREAK;\r\nEAX = 80000005H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000006H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Cache information; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000007H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000008H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nDEFAULT: (* EAX = Value outside of recognized range for CPUID. *)\r\n(* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)\r\nEAX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEBX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nECX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEDX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nBREAK;\r\nESAC;\r\nFlags Affected\r\nNone.\r\nExceptions (All Operating Modes)\r\n#UD If the LOCK prefix is used.\r\nIn earlier IA-32 processors that do not support the CPUID instruction, execution of the instruction results in an \r\ninvalid opcode (#UD) exception being generated.§",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/bdb4710a-c468-48d2-a4b4-b1ae03dc7da7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2b19d538ec8e7cb32539812eadac903306da73567d29ae311b0fa563c92214ff",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 269
      },
      {
        "segments": [
          {
            "segment_id": "2fea452c-7a4a-4b47-8681-6aba7f7dc194",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "1-42 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.7 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 1-13 and Table 1-14 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 1-13 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword. \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 1-14. Table 1-14 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 1-14. Instruc\u0002tion classified in Table 1-14 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype will be referenced in the instruction operand encoding table in the reference page of each instruction, \r\nproviding the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 1-13. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nFull Mem N/A N/A 16 32 64 Load/store or subDword full vector\r\nTuple1 Scalar\r\n8bit N/A 1 1 1\r\n1Tuple\r\n16bit N/A 2 2 2\r\n32bit 0 4 4 4\r\n64bit 1 8 8 8\r\nTuple1 Fixed\r\n32bit N/A 4 4 4 1 Tuple, memsize not affected by \r\n64bit N/A 8 8 8 EVEX.W\r\nTuple1_4X 32bit 0 161 N/A 16 4FMA(PS)\r\nTuple2\r\n32bit 0 8 8 8\r\nBroadcast (2 elements) 64bit 1 NA 16 16\r\nTuple4\r\n32bit 0 NA 16 16\r\nBroadcast (4 elements) 64bit 1 NA NA 32\r\nTuple8 32bit 0 NA NA 32 Broadcast (8 elements) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/2fea452c-7a4a-4b47-8681-6aba7f7dc194.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d76e5f2f268fb211a9d09ec608d31e2a8b337d4a2cf7fb1c1bf922d3df3f39f1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 517
      },
      {
        "segments": [
          {
            "segment_id": "2fea452c-7a4a-4b47-8681-6aba7f7dc194",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "1-42 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.7 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 1-13 and Table 1-14 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 1-13 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword. \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 1-14. Table 1-14 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 1-14. Instruc\u0002tion classified in Table 1-14 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype will be referenced in the instruction operand encoding table in the reference page of each instruction, \r\nproviding the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 1-13. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nFull Mem N/A N/A 16 32 64 Load/store or subDword full vector\r\nTuple1 Scalar\r\n8bit N/A 1 1 1\r\n1Tuple\r\n16bit N/A 2 2 2\r\n32bit 0 4 4 4\r\n64bit 1 8 8 8\r\nTuple1 Fixed\r\n32bit N/A 4 4 4 1 Tuple, memsize not affected by \r\n64bit N/A 8 8 8 EVEX.W\r\nTuple1_4X 32bit 0 161 N/A 16 4FMA(PS)\r\nTuple2\r\n32bit 0 8 8 8\r\nBroadcast (2 elements) 64bit 1 NA 16 16\r\nTuple4\r\n32bit 0 NA 16 16\r\nBroadcast (4 elements) 64bit 1 NA NA 32\r\nTuple8 32bit 0 NA NA 32 Broadcast (8 elements) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/2fea452c-7a4a-4b47-8681-6aba7f7dc194.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d76e5f2f268fb211a9d09ec608d31e2a8b337d4a2cf7fb1c1bf922d3df3f39f1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 517
      },
      {
        "segments": [
          {
            "segment_id": "e55f89f5-b97e-4dd9-8a52-680d0e5f50e6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 1-43\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nHalf Mem N/A N/A 8 16 32 SubQword Conversion\r\nQuarter Mem N/A N/A 4 8 16 SubDword Conversion\r\nEighth Mem N/A N/A 2 4 8 SubWord Conversion\r\nMem128 N/A N/A 16 16 16 Shift count from memory\r\nMOVDDUP N/A N/A 8 32 64 VMOVDDUP\r\nNOTES:\r\n1. Scalar\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast(Continued)\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e55f89f5-b97e-4dd9-8a52-680d0e5f50e6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3de0e425aac16d6442d844eb2cb98126be8221294110b294968c9e70591729e6",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "5acb5897-5669-4f3f-a4b8-bd01d332e92c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "1-44 Ref. # 319433-032\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5acb5897-5669-4f3f-a4b8-bd01d332e92c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3374c3a903dc62dde28d72e02fb00703efd92b78c1b0b134640b42793a69240d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3d17a460-856a-4dd4-b31d-20fa973a0c80",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-1\r\nINSTRUCTION SET REFERENCE, A-Z\r\nCHAPTER 2\r\nINSTRUCTION SET REFERENCE, A-Z\r\nInstructions described in this document follow the general documentation convention established in Intel 64 and \r\nIA-32 Architectures Software Developer’s Manual Volume 2A. \r\n2.1 INSTRUCTION SET REFERENCE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3d17a460-856a-4dd4-b31d-20fa973a0c80.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5b5c652191c4e7a5f8f09320fd888de47750eebd5699e7a9f89ec6d49b03840c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9067382a-60b5-4b9c-87da-f583c9914d99",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "2-2 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse\r\nInstruction Operand Encoding\r\nDescription\r\nThe AFFINEINVB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine \r\ntransformation is defined by A * inv(x) + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. The \r\ninverse of the bytes in x is defined with respect to the reduction polynomial x8 + x4 + x3 + x + 1.\r\nOne SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register \r\nor memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” \r\nvalues in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of \r\nthe instruction require 16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F3A CF /r /ib\r\nGF2P8AFFINEINVQB xmm1, \r\nxmm2/m128, imm8\r\nA V/V GFNI Computes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nVEX.NDS.128.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nVEX.NDS.256.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.NDS.128.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB xmm1{k1}{z}, \r\nxmm2, xmm3/m128/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.NDS.256.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB ymm1{k1}{z}, \r\nymm2, ymm3/m256/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.NDS.512.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB zmm1{k1}{z}, \r\nzmm2, zmm3/m512/m64bcst, imm8\r\nC V/V AVX512F\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) imm8 (r) NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nC Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9067382a-60b5-4b9c-87da-f583c9914d99.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5d9bc8df57caebefb135c2e10ce7f17dc25f51efaca495c965e5bee74a2b843d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 488
      },
      {
        "segments": [
          {
            "segment_id": "15f23ea9-4ae8-4829-87dd-246d401bb3c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-3\r\nINSTRUCTION SET REFERENCE, A-Z\r\nThe inverse of each byte is given by the following table. The upper nibble is on the vertical axis and the lower nibble \r\nis on the horizontal axis. For example, the inverse of 0x95 is 0x8A.\r\nOperation\r\ndefine affine_inverse_byte(tsrc2qw, src1byte, imm):\r\nFOR i ← 0 to 7:\r\n* parity(x) = 1 if x has an odd number of 1s in it, and 0 otherwise.*\r\n* inverse(x) is defined in the table above *\r\nretbyte.bit[i] ← parity(tsrc2qw.byte[7-i] AND inverse(src1byte)) XOR imm8.bit[i]\r\nreturn retbyte\r\nVGF2P8AFFINEINVQB dest, src1, src2, imm8 (EVEX encoded version)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC2 is memory and EVEX.b==1:\r\ntsrc2 ← SRC2.qword[0]\r\nELSE:\r\ntsrc2 ← SRC2.qword[j]\r\nFOR b ← 0 to 7:\r\nIF k1[j*8+b] OR *no writemask*:\r\nFOR i ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_inverse_byte(tsrc2, SRC1.qword[j].byte[b], imm8)\r\nELSE IF *zeroing*:\r\nDEST.qword[j].byte[b] ← 0\r\n*ELSE DEST.qword[j].byte[b] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nTable 2-1. Inverse Byte Listings\r\n- 0123456789ABCDEF\r\n0 0 1 8D F6 CB 52 7B D1 E8 4F 29 C0 B0 E1 E5 C7\r\n1 74 B4 AA 4B 99 2B 60 5F 58 3F FD CC FF 40 EE B2\r\n2 3A 6E 5A F1 55 4D A8 C9 C1 A 98 15 30 44 A2 C2\r\n3 2C 45 92 6C F3 39 66 42 F2 35 20 6F 77 BB 59 19\r\n4 1D FE 37 67 2D 31 F5 69 A7 64 AB 13 54 25 E9 9\r\n5 ED 5C 5 CA 4C 24 87 BF 18 3E 22 F0 51 EC 61 17\r\n6 16 5E AF D3 49 A6 36 43 F4 47 91 DF 33 93 21 3B\r\n7 79 B7 97 85 10 B5 BA 3C B6 70 D0 6 A1 FA 81 82\r\n8 83 7E 7F 80 96 73 BE 56 9B 9E 95 D9 F7 2 B9 A4\r\n9 DE 6A 32 6D D8 8A 84 72 2A 14 9F 88 F9 DC 89 9A\r\nA FB 7C 2E C3 8F B8 65 48 26 C8 12 4A CE E7 D2 62\r\nB C E0 1F EF 11 75 78 71 A5 8E 76 3D BD BC 86 57\r\nC B 28 2F A3 DA D4 E4 F A9 27 53 4 1B FC AC E6\r\nD 7A 7 AE 63 C5 DB E2 EA 94 8B C4 D5 9D F8 90 6B\r\nE B1 D D6 EB C6 E CF AD 8 4E D7 E3 5D 50 1E B3\r\nF 5B 23 38 34 68 46 3 8C DD 9C 7D A0 CD 1A 41 1C",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/15f23ea9-4ae8-4829-87dd-246d401bb3c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9cc6bdc0302befbeef51ff0cb7bb7372a0dae70b0eacd401b4e2bb006300a421",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 440
      },
      {
        "segments": [
          {
            "segment_id": "3c9c2ee9-55d2-4fc3-a77d-8092bc41c244",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "2-4 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVGF2P8AFFINEINVQB dest, src1, src2, imm8 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (2, 128), (4, 256)\r\nFOR j ← 0 TO KL-1:\r\nFOR b ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_inverse_byte(SRC2.qword[j], SRC1.qword[j].byte[b], imm8)\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8AFFINEINVQB srcdest, src1, imm8 (128b SSE encoded version)\r\nFOR j ← 0 TO 1:\r\nFOR b ← 0 to 7:\r\nSRCDEST.qword[j].byte[b] ← affine_inverse_byte(SRC1.qword[j], SRCDEST.qword[j].byte[b], imm8)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nGF2P8AFFINEINVQB __m128i _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m128i _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m128i _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3c9c2ee9-55d2-4fc3-a77d-8092bc41c244.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a530a43559502f4b456242214f89549f78cbc9415982d25816b1a4e420b51c08",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "fef6694b-82ec-430f-8719-b253dcec3d72",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-5\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8AFFINEQB — Galois Field Affine Transformation\r\nInstruction Operand Encoding\r\nDescription\r\nThe AFFINEB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine \r\ntransformation is defined by A * x + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. One SIMD \r\nregister (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory \r\noperand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the \r\nfirst register. The “b” vector is constant for all calculations and contained in the immediate byte.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of \r\nthe instruction require16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F3A CE /r /ib\r\nGF2P8AFFINEQB xmm1, \r\nxmm2/m128, imm8\r\nA V/V GFNI Computes affine transformation in the finite \r\nfield GF(2^8).\r\nVEX.NDS.128.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nVEX.NDS.256.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.NDS.128.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB xmm1{k1}{z}, \r\nxmm2, xmm3/m128/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.NDS.256.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB ymm1{k1}{z}, \r\nymm2, ymm3/m256/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.NDS.512.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB zmm1{k1}{z}, \r\nzmm2, zmm3/m512/m64bcst, imm8\r\nC V/V AVX512F\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) imm8 (r) NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nC Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/fef6694b-82ec-430f-8719-b253dcec3d72.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=72e902f90480f16405a71c52dfba561e1c750b1c45ba67284065c0d0d0a641e0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 470
      },
      {
        "segments": [
          {
            "segment_id": "16ca0792-e0ba-48cd-aa52-1224a7e091cc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "2-6 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\ndefine parity(x):\r\nt ← 0 // single bit\r\nFOR i ← 0 to 7:\r\nt = t xor x.bit[i]\r\nreturn t\r\ndefine affine_byte(tsrc2qw, src1byte, imm):\r\nFOR i ← 0 to 7:\r\n* parity(x) = 1 if x has an odd number of 1s in it, and 0 otherwise.*\r\nretbyte.bit[i] ← parity(tsrc2qw.byte[7-i] AND src1byte) XOR imm8.bit[i]\r\nreturn retbyte\r\nVGF2P8AFFINEQB dest, src1, src2, imm8 (EVEX encoded version)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC2 is memory and EVEX.b==1:\r\ntsrc2 ← SRC2.qword[0]\r\nELSE:\r\ntsrc2 ← SRC2.qword[j]\r\nFOR b ← 0 to 7:\r\nIF k1[j*8+b] OR *no writemask*:\r\nDEST.qword[j].byte[b] ← affine_byte(tsrc2, SRC1.qword[j].byte[b], imm8)\r\nELSE IF *zeroing*:\r\nDEST.qword[j].byte[b] ← 0\r\n*ELSE DEST.qword[j].byte[b] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVGF2P8AFFINEQB dest, src1, src2, imm8 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (2, 128), (4, 256)\r\nFOR j ← 0 TO KL-1:\r\nFOR b ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_byte(SRC2.qword[j], SRC1.qword[j].byte[b], imm8)\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8AFFINEQB srcdest, src1, imm8 (128b SSE encoded version)\r\nFOR j ← 0 TO 1:\r\nFOR b ← 0 to 7:\r\nSRCDEST.qword[j].byte[b] ← affine_byte(SRC1.qword[j], SRCDEST.qword[j].byte[b], imm8)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nGF2P8AFFINEQB __m128i _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);\r\nGF2P8AFFINEQB __m128i _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEQB __m128i _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEQB __m256i _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);\r\nGF2P8AFFINEQB __m256i _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEQB __m256i _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEQB __m512i _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);\r\nGF2P8AFFINEQB __m512i _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);\r\nGF2P8AFFINEQB __m512i _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/16ca0792-e0ba-48cd-aa52-1224a7e091cc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e7336194225f209ac835cf198175c768036511caa177c32f6452a7099c667c24",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "94c4e3d7-a176-49d0-88fc-af534fede0fc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-7\r\nINSTRUCTION SET REFERENCE, A-Z\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/94c4e3d7-a176-49d0-88fc-af534fede0fc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=47d5e64292f336ae7f7750feb04ff6387d3e49ffda33a49e548941ef18596dda",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 278
      },
      {
        "segments": [
          {
            "segment_id": "53370929-057f-45b4-9b0c-cd4042faccc5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "2-8 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8MULB — Galois Field Multiply Bytes\r\nInstruction Operand Encoding\r\nDescription\r\nThe instruction multiplies elements in the finite field GF(28), operating on a byte (field element) in the first source \r\noperand and the corresponding byte in a second source operand. The field GF(28) is represented in polynomial \r\nrepresentation with the reduction polynomial x8 + x4 + x3 + x + 1.\r\nThis instruction does not support broadcasting.\r\nThe EVEX encoded form of this instruction supports memory fault suppression. The SSE encoded forms of the \r\ninstruction require16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F38 CF /r\r\nGF2P8MULB xmm1, xmm2/m128\r\nA V/V GFNI Multiplies elements in the finite field GF(2^8). \r\nVEX.NDS.128.66.0F38.W0 CF /r\r\nVGF2P8MULB xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nVEX.NDS.256.66.0F38.W0 CF /r\r\nVGF2P8MULB ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.NDS.128.66.0F38.W0 CF /r\r\nVGF2P8MULB xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nC V/V AVX512VL\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.NDS.256.66.0F38.W0 CF /r\r\nVGF2P8MULB ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nC V/V AVX512VL\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.NDS.512.66.0F38.W0 CF /r\r\nVGF2P8MULB zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nC V/V AVX512F\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) NA NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nC Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/53370929-057f-45b4-9b0c-cd4042faccc5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=11a98c5dbe6315dbe08f4dc8d1301da6a0926c4af0a55a55b1440df06ca9b8f3",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "0ad30f0a-b9c5-439e-b8fd-9ca84c60ab0e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-9\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\ndefine gf2p8mul_byte(src1byte, src2byte):\r\ntword ← 0\r\nFOR i ← 0 to 7:\r\nIF src2byte.bit[i]:\r\ntword ← tword XOR (src1byte<< i)\r\n* carry out polynomial reduction by the characteristic polynomial p*\r\nFOR i ← 14 downto 8:\r\np ← 0x11B << (i-8) *0x11B = 0000_0001_0001_1011 in binary*\r\nIF tword.bit[i]:\r\ntword ← tword XOR p\r\nreturn tword.byte[0]\r\nVGF2P8MULB dest, src1, src2 (EVEX encoded version)\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[j] ← gf2p8mul_byte(SRC1.byte[j], SRC2.byte[j])\r\nELSE iF *zeroing*:\r\nDEST.byte[j] ← 0\r\n* ELSE DEST.byte[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVGF2P8MULB dest, src1, src2 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (16, 128), (32, 256)\r\nFOR j ← 0 TO KL-1:\r\nDEST.byte[j] ← gf2p8mul_byte(SRC1.byte[j], SRC2.byte[j])\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8MULB srcdest, src1 (128b SSE encoded version)\r\nFOR j ← 0 TO 15:\r\nSRCDEST.byte[j] ← gf2p8mul_byte(SRCDEST.byte[j], SRC1.byte[j])\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVGF2P8MULB __m128i _mm_gf2p8mul_epi8(__m128i, __m128i);\r\nVGF2P8MULB __m128i _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);\r\nVGF2P8MULB __m128i _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);\r\nVGF2P8MULB __m256i _mm256_gf2p8mul_epi8(__m256i, __m256i);\r\nVGF2P8MULB __m256i _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);\r\nVGF2P8MULB __m256i _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);\r\nVGF2P8MULB __m512i _mm512_gf2p8mul_epi8(__m512i, __m512i);\r\nVGF2P8MULB __m512i _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);\r\nVGF2P8MULB __m512i _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/0ad30f0a-b9c5-439e-b8fd-9ca84c60ab0e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdd200cd85b9f501bef5720c556c3f0bea980751a266c36507e969cb4343b1bd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 478
      },
      {
        "segments": [
          {
            "segment_id": "0a6680b7-e7a0-4282-b50c-c99f3fe23c7d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "2-10 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nPCONFIG — Platform Configuration\r\nInstruction Operand Encoding\r\nDescription\r\nThe PCONFIG instruction is invoked by software for configuring platform features. PCONFIG supports multiple \r\nleaves and a leaf function is invoked by setting the appropriate leaf value in EAX. RBX, RCX, and RDX have leaf\u0002specific purposes. An attempt to execute an undefined leaf results in a #GP(0). Addresses and operands are 32 bits \r\noutside 64-bit mode (IA32_EFER.LMA = 0 || CS.L = 0) and are 64 bits in 64-bit mode (IA32_EFER.LMA = 1 && CS.L \r\n= 1). CS.D value has no impact on address calculation.\r\nTable 2-2 shows the leaf encodings for PCONFIG.\r\nThe MKTME_KEY_PROGRAM leaf of PCONFIG is used by software to manage the key associated with a KeyID. The \r\nleaf function is invoked by setting the leaf value of 0 in EAX and the address of MKTME_KEY_PROGRAM_STRUCT in \r\nRBX. Successful execution of the leaf clears RAX (set to zero) and ZF, CF, PF, AF, OF, and SF are cleared. In case of \r\nfailure, the failure reason is indicated in RAX with ZF set to 1 and CF, PF, AF, OF, and SF are cleared. The \r\nMKTME_KEY_PROGRAM leaf works using the MKTME_KEY_PROGRAM_STRUCT in memory shown in Table 2-3.\r\nA description of each of the fields in MKTME_KEY_PROGRAM_STRUCT is provided below:\r\n• KEYID: Key Identifier being programmed to the MKTME engine.\r\n• KEYID_CTRL: The KEYID_CTRL field carries two sub-fields used by software to control the behavior of a \r\nKeyID: Command and KeyID encryption algorithm. \r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n0F 01 C5\r\nPCONFIG \r\nA V/V PCONFIG This instruction is used to execute functions \r\nfor configuring platform features.\r\nEAX: Leaf function to be invoked.\r\nRBX/RCX/RDX: Leaf-specific purpose.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA NA NA NA NA\r\nTable 2-2. PCONFIG Leaf Encodings\r\nLeaf Encoding Description\r\nINVALID_TARGET 00000000H Invalid target identifier.\r\nMKTME_KEY_PROGRAM 00000001H This leaf is used to program the key and encryption mode associated \r\nwith a KeyID.\r\nRESERVED 00000002H - FFFFFFFFH Reserved for future use (#GP(0) if used).\r\nTable 2-3. MKTME_KEY_PROGRAM_STRUCT Format\r\nField Offset (bytes) Size (bytes) Comments\r\nKEYID 0 2 Key Identifier.\r\nKEYID_CTRL 2 4 KeyID control:\r\n• Bits [7:0]: COMMAND.\r\n• Bits [23:8]: ENC_ALG.\r\n• Bits [31:24]: Reserved, must be zero.\r\nRESERVED 6 58 Reserved, must be zero.\r\nKEY_FIELD_1 64 64 Software supplied KeyID data key or entropy for KeyID data key.\r\nKEY_FIELD_2 128 64 Software supplied KeyID tweak key or entropy for KeyID tweak key.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/0a6680b7-e7a0-4282-b50c-c99f3fe23c7d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e40ebf1abf3275f1ede2448ab5c8e41b71107f6a6875cdeab54829fd3bce3aa4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 416
      },
      {
        "segments": [
          {
            "segment_id": "35dd6f9a-50fc-4cc9-83e0-454dfb7b74b6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-11\r\nINSTRUCTION SET REFERENCE, A-Z\r\nThe command used controls the encryption mode for a KeyID. Table 2-4 provides a summary of the \r\ncommands supported.\r\nThe encryption algorithm field (ENC_ALG) allows software to select one of the activated encryption algorithms \r\nfor the KeyID. The BIOS can activate a set of algorithms to allow for use when programming keys using the \r\nIA32_TME_ACTIVATE MSR (does not apply to KeyID 0 which uses TME policy). The ISA checks to ensure that \r\nthe algorithm selected by software is one of the algorithms that has been activated by the BIOS.\r\n• KEY_FIELD_1: This field carries the software supplied data key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom data key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\n• KEY_FIELD_2: This field carries the software supplied tweak key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom tweak key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\nAll KeyIDs use the TME key on MKTME activation. Software can at any point decide to change the key for a \r\nKeyID using the PCONFIG instruction. Change of keys for a KeyID does NOT change the state of the TLB \r\ncaches or memory pipeline. It is software's responsibility to take appropriate actions to ensure correct \r\nbehavior.\r\nTable 2-5 shows the return values associated with the MKTME_KEY_PROGRAM leaf of PCONFIG. On \r\ninstruction execution, RAX is populated with the return value.\r\nTable 2-4. Supported Key Programming Commands\r\nCommand Encoding Description\r\nKEYID_SET_KEY_DIRECT 0 Software uses this mode to directly program a key for use with KeyID.\r\nKEYID_SET_KEY_RANDOM 1 CPU generates and assigns an ephemeral key for use with a KeyID. Each time the \r\ninstruction is executed, the CPU generates a new key using a hardware random \r\nnumber generator and the keys are discarded on reset.\r\nKEYID_CLEAR_KEY 2 Clear the (software programmed) key associated with the KeyID. On execution of this \r\ncommand, the KeyID gets TME behavior (encrypt with platform TME key).\r\nKEYID_NO_ENCRYPT 3 Do not encrypt memory when this KeyID is in use.\r\nTable 2-5. Supported Key Programming Commands\r\nReturn Value Encoding Description\r\nPROG_SUCCESS 0 KeyID was successfully programmed.\r\nINVALID_PROG_CMD 1 Invalid KeyID programming command.\r\nENTROPY_ERROR 2 Insufficient entropy.\r\nINVALID_KEYID 3 KeyID not valid.\r\nINVALID_ENC_ALG 4 Invalid encryption algorithm chosen (not supported).\r\nDEVICE_BUSY 5 Failure to access key table.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/35dd6f9a-50fc-4cc9-83e0-454dfb7b74b6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec837d5fd4ba4f9f21aaa03edead73c4cfb754170f2995d026da4a952122d1d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 559
      },
      {
        "segments": [
          {
            "segment_id": "35dd6f9a-50fc-4cc9-83e0-454dfb7b74b6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-11\r\nINSTRUCTION SET REFERENCE, A-Z\r\nThe command used controls the encryption mode for a KeyID. Table 2-4 provides a summary of the \r\ncommands supported.\r\nThe encryption algorithm field (ENC_ALG) allows software to select one of the activated encryption algorithms \r\nfor the KeyID. The BIOS can activate a set of algorithms to allow for use when programming keys using the \r\nIA32_TME_ACTIVATE MSR (does not apply to KeyID 0 which uses TME policy). The ISA checks to ensure that \r\nthe algorithm selected by software is one of the algorithms that has been activated by the BIOS.\r\n• KEY_FIELD_1: This field carries the software supplied data key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom data key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\n• KEY_FIELD_2: This field carries the software supplied tweak key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom tweak key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\nAll KeyIDs use the TME key on MKTME activation. Software can at any point decide to change the key for a \r\nKeyID using the PCONFIG instruction. Change of keys for a KeyID does NOT change the state of the TLB \r\ncaches or memory pipeline. It is software's responsibility to take appropriate actions to ensure correct \r\nbehavior.\r\nTable 2-5 shows the return values associated with the MKTME_KEY_PROGRAM leaf of PCONFIG. On \r\ninstruction execution, RAX is populated with the return value.\r\nTable 2-4. Supported Key Programming Commands\r\nCommand Encoding Description\r\nKEYID_SET_KEY_DIRECT 0 Software uses this mode to directly program a key for use with KeyID.\r\nKEYID_SET_KEY_RANDOM 1 CPU generates and assigns an ephemeral key for use with a KeyID. Each time the \r\ninstruction is executed, the CPU generates a new key using a hardware random \r\nnumber generator and the keys are discarded on reset.\r\nKEYID_CLEAR_KEY 2 Clear the (software programmed) key associated with the KeyID. On execution of this \r\ncommand, the KeyID gets TME behavior (encrypt with platform TME key).\r\nKEYID_NO_ENCRYPT 3 Do not encrypt memory when this KeyID is in use.\r\nTable 2-5. Supported Key Programming Commands\r\nReturn Value Encoding Description\r\nPROG_SUCCESS 0 KeyID was successfully programmed.\r\nINVALID_PROG_CMD 1 Invalid KeyID programming command.\r\nENTROPY_ERROR 2 Insufficient entropy.\r\nINVALID_KEYID 3 KeyID not valid.\r\nINVALID_ENC_ALG 4 Invalid encryption algorithm chosen (not supported).\r\nDEVICE_BUSY 5 Failure to access key table.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/35dd6f9a-50fc-4cc9-83e0-454dfb7b74b6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ec837d5fd4ba4f9f21aaa03edead73c4cfb754170f2995d026da4a952122d1d3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 559
      },
      {
        "segments": [
          {
            "segment_id": "bbed2dd1-af1c-49cc-89d5-460030f77a77",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "2-12 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nPCONFIG Virtualization\r\nSoftware in VMX root mode can control the execution of PCONFIG in VMX non-root mode using the following execu\u0002tion controls introduced for PCONFIG:\r\n• PCONFIG_ENABLE: This control is a single bit control and enables the PCONFIG instruction in VMX non-root \r\nmode. If 0, the execution of PCONFIG in VMX non-root mode causes #UD. Otherwise, execution of PCONFIG \r\nworks according to PCONFIG_EXITING.\r\n• PCONFIG_EXITING: This is a 64b control and allows VMX root mode to cause a VM-exit for various leaf \r\nfunctions of PCONFIG. This control does not have any effect if the PCONFIG_ENABLE control is clear.\r\nPCONFIG Concurrency\r\nIn a scenario, where the MKTME_KEY_PROGRAM leaf of PCONFIG is executed concurrently on multiple logical \r\nprocessors, only one logical processor will succeed in updating the key table. PCONFIG execution will return with an \r\nerror code (DEVICE_BUSY) on other logical processors and software must retry. In cases where the instruction \r\nexecution fails with a DEVICE_BUSY error code, the key table is not updated, thereby ensuring that either the key \r\ntable is updated in its entirety with the information for a KeyID, or it is not updated at all. In order to accomplish \r\nthis, the MKTME_KEY_PROGRAM leaf of PCONFIG maintains a writer lock for updating the key table. This lock is \r\nreferred to as the Key table lock and denoted in the instruction flows as KEY_TABLE_LOCK. The lock can either be \r\nunlocked, when no logical processor is holding the lock (also the initial state of the lock) or be in an exclusive state \r\nwhere a logical processor is trying to update the key table. There can be only one logical processor holding the lock \r\nin exclusive state. The lock, being exclusive, can only be acquired when the lock is in unlocked state.\r\nPCONFIG uses the following syntax to acquire KEY_TABLE_LOCK in exclusive mode and release the lock:\r\nKEY_TABLE_LOCK.ACQUIRE(WRITE)\r\nKEY_TABLE_LOCK.RELEASE()\r\nOperation\r\n(* #UD if PCONFIG is not enumerated or CPL>0 *)\r\nif (CPUID.7.0:EDX[18] == 0 OR CPL > 0) #UD;\r\nif (in VMX non-root mode)\r\n{\r\nif (VMCS.PCONFIG_ENABLE == 1)\r\n{\r\nif ((EAX > 62 AND VMCS.PCONFIG_EXITING[63] ==1) OR \r\n (EAX < 63 AND VMCS.PCONFIG_EXITING[EAX] == 1))\r\n{\r\nSet VMCS.EXIT_REASON = PCONFIG; //No Exit qualification\r\nDeliver VMEXIT;\r\n}\r\n}\r\nelse\r\n{ \r\n#UD\r\nTable 2-6. PCONFIG Operation Variables\r\nVariable Name Type Size \r\n(Bytes)\r\nDescription\r\nTMP_KEY_PROGRAM_STRUCT MKTME_KEY_PROGRAM_STRUCT 192 Structure holding the key programming structure.\r\nTMP_RND_DATA_KEY UINT128 16 Random data key generated for random key \r\nprogramming option.\r\nTMP_RND_TWEAK_KEY UINT128 16 Random tweak key generated for random key \r\nprogramming option.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/bbed2dd1-af1c-49cc-89d5-460030f77a77.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f257a9a7fd62cbf56739bf60536972e5f96a67358766547deb5755a67316fe97",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 420
      },
      {
        "segments": [
          {
            "segment_id": "bc74a917-0a07-48b5-a025-e490d498ac06",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-13\r\nINSTRUCTION SET REFERENCE, A-Z\r\n}\r\n}\r\n(* #GP(0) for an unsupported leaf *)\r\nif(EAX != 0) #GP(0)\r\n(* KEY_PROGRAM leaf flow *)\r\nif (EAX == 0)\r\n{\r\n(* #GP(0) if TME_ACTIVATE MSR is not locked or does not enable TME or multiple keys are not enabled *)\r\nif (IA32_TME_ACTIVATE.LOCK != 1 OR IA32_TME_ACTIVATE.ENABLE != 1 OR IA32_TME_ACTIVATE.MK_TME_KEYID_BITS == 0) \r\n#GP(0)\r\n(* Check MKTME_KEY_PROGRAM_STRUCT is 256B aligned *)\r\nif(DS:RBX is not 256B aligned) #GP(0);\r\n(* Check that MKTME_KEY_PROGRAM_STRUCT is read accessible *)\r\n<<DS: RBX should be read accessible>>\r\n(* Copy MKTME_KEY_PROGRAM_STRUCT to a temporary variable *)\r\nTMP_KEY_PROGRAM_STRUCT = DS:RBX.*;\r\n(* RSVD field check *)\r\nif(TMP_KEY_PROGRAM_STRUCT.RSVD != 0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.RSVD !=0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1.BYTES[63:16] != 0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2.BYTES[63:16] != 0) #GP(0);\r\n(* Check for a valid command *)\r\nif(TMP_KEY_PROGRAM_STRUCT. KEYID_CTRL.COMMAND is not a valid command)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_PROG_CMD;\r\ngoto EXIT;\r\n}\r\n(* Check that the KEYID being operated upon is a valid KEYID *)\r\nif(TMP_KEY_PROGRAM_STRUCT.KEYID > \r\n2^IA32_TME_ACTIVATE.MK_TME_KEYID_BITS - 1\r\nOR TMP_KEY_PROGRAM_STRUCT.KEYID > \r\nIA32_TME_CAPABILITY.MK_TME_MAX_KEYS \r\nOR TMP_KEY_PROGRAM_STRUCT.KEYID == 0) \r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_KEYID;\r\ngoto EXIT;\r\n}\r\n(* Check that only one algorithm is requested for the KeyID and it is one of the activated algorithms *)\r\nif(NUM_BITS(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG) != 1 || \r\n(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG & \r\nIA32_TME_ACTIVATE. MK_TME_CRYPTO_ALGS == 0))",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/bc74a917-0a07-48b5-a025-e490d498ac06.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=630936c0ffe5182f415f9934006da14e89a352cba39b6ebaa9d4bf5cd69a1928",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "39cc3172-f28f-435b-8ef1-d80b16fa7c20",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "2-14 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_ENC_ALG;\r\ngoto EXIT;\r\n}\r\n(* Try to acquire exclusive lock *)\r\nif (NOT KEY_TABLE_LOCK.ACQUIRE(WRITE))\r\n{\r\n//PCONFIG failure\r\nRFLAGS.ZF = 1;\r\nRAX = DEVICE_BUSY;\r\ngoto EXIT;\r\n}\r\n(* Lock is acquired and key table will be updated as per the command \r\nBefore this point no changes to the key table are made *)\r\nswitch(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.COMMAND)\r\n{\r\ncase KEYID_SET_KEY_DIRECT:\r\n<<Write \r\nDATA_KEY=TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1,\r\nTWEAK_KEY=TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2,\r\nENCRYPTION_MODE=ENCRYPT_WITH_KEYID_KEY,\r\nto MKTME Key table at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\ncase KEYID_SET_KEY_RANDOM:\r\nTMP_RND_DATA_KEY = <<Generate a random key using hardware RNG>>\r\nif (NOT ENOUGH ENTROPY)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = ENTROPY_ERROR;\r\ngoto EXIT;\r\n}\r\nTMP_RND_TWEAK_KEY = <<Generate a random key using hardware RNG>>\r\nif (NOT ENOUGH ENTROPY)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = ENTROPY_ERROR;\r\ngoto EXIT;\r\n}\r\n(* Mix user supplied entropy to the data key and tweak key *)\r\nTMP_RND_DATA_KEY = TMP_RND_KEY XOR \r\nTMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1.BYTES[15:0];\r\nTMP_RND_TWEAK_KEY = TMP_RND_TWEAK_KEY XOR \r\nTMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2.BYTES[15:0];\r\n<<Write \r\nDATA_KEY=TMP_RND_DATA_KEY, \r\nTWEAK_KEY=TMP_RND_TWEAK_KEY,\r\nENCRYPTION_MODE=ENCRYPT_WITH_KEYID_KEY,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/39cc3172-f28f-435b-8ef1-d80b16fa7c20.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f771daad2669707c806db69f68492378a3bb2ea158856b50a02cc45e02e85094",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b9cb33c1-7246-4c52-b39e-53d4f4864ca9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-15\r\nINSTRUCTION SET REFERENCE, A-Z\r\n>>\r\nbreak;\r\ncase KEYID_CLEAR_KEY:\r\n<<Write\r\nDATA_KEY='0,\r\nTWEAK_KEY='0,\r\nENCRYPTION_MODE = ENCRYPT_WITH_TME_KEY,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\ncase KD_NO_ENCRYPT:\r\n<<Write \r\nENCRYPTION_MODE=NO_ENCRYPTION,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\n}\r\nRAX = 0;\r\nRFLAGS.ZF = 0;\r\n//Release Lock\r\nKEY_TABLE_LOCK(RELEASE);\r\nEXIT:\r\nRFLAGS.CF=0;\r\nRFLAGS.PF=0;\r\nRFLAGS.AF=0;\r\nRFLAGS.OF=0;\r\nRFLAGS.SF=0;\r\n}\r\nend_of_flow\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nTBD",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b9cb33c1-7246-4c52-b39e-53d4f4864ca9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a91809a63eeb49e557746a0defd67da99e679af2b13228b37857b1dfb220f860",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 435
      },
      {
        "segments": [
          {
            "segment_id": "a1bc8aa2-180d-4158-aba2-df1bf59f15cb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "2-16 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nProtected Mode Exceptions\r\n#GP(0) If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability are not enabled in IA32_TME_ACTIVATE MSR.\r\nIf the memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\nIf a memory operand effective address is outside the DS segment limit.\r\n#PF(fault-code) If a page fault occurs in accessing memory operands.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf current privilege level is not 0.\r\nIf CPUID.7.0:EDX[bit 18] = 0\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.\r\nReal Address Mode Exceptions\r\n#GP If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability is not enabled in IA32_TME_ACTIVATE MSR.\r\nIf a memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf current privilege level is not 0.\r\nIf CPUID.7.0:EDX.PCONFIG[bit 18] = 0\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.\r\nVirtual 8086 Mode Exceptions\r\n#UD PCONFIG instruction is not recognized in virtual-8086 mode.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\n#GP(0) If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability is not enabled in IA32_TME_ACTIVATE MSR.\r\nIf a memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\nIf a memory operand is non-canonical form.\r\n#PF(fault-code) If a page fault occurs in accessing memory operands.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf the current privilege level is not 0.\r\nIf CPUID.7.0:EDX.PCONFIG[bit 18] = 0.\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a1bc8aa2-180d-4158-aba2-df1bf59f15cb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6f86fd042e04fa5020d448d4d5c48fec3bc091e30ab0ba3e6b9a77d9765c73b1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 305
      },
      {
        "segments": [
          {
            "segment_id": "47741741-9106-49ba-8d7a-606e97c61f53",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-17\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDEC — Perform One Round of an AES Decryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the \r\nround key from the second source operand, operating on a 128-bit data (state) from the first source operand, and \r\nstore the result in the destination operand.\r\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDEC\u0002CLAST instruction.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESDEC\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.NDS.256.66.0F38.WIG DE /r \r\nVAESDEC ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from ymm2 with a \r\n128-bit round key from ymm3/m256; store the \r\nresult in ymm1.\r\nEVEX.NDS.128.66.0F38.WIG DE /r\r\nVAESDEC xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from xmm2 with a \r\n128-bit round key from xmm3/m128; store the \r\nresult in xmm1.\r\nEVEX.NDS.256.66.0F38.WIG DE /r\r\nVAESDEC ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from ymm2 with a \r\n128-bit round key from ymm3/m256; store the \r\nresult in ymm1.\r\nEVEX.NDS.512.66.0F38.WIG DE /r\r\nVAESDEC zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from zmm2 with a \r\n128-bit round key from zmm3/m512; store the \r\nresult in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/47741741-9106-49ba-8d7a-606e97c61f53.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7b3f81be3ebee3b0beea3470a7b2b2c085a5e98a3ea404650abdf7924aa0a53b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "5a0247b6-0e67-472c-bb26-7c40e8566c7d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "2-18 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDEC (128b and 256b VEX encoded versions)\r\n(KL,V) = (1,128), (2,256)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESDEC (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESDEC __m256i _mm256_aesdec_epi128(__m256i, __m256i);\r\nVAESDEC __m512i _mm512_aesdec_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5a0247b6-0e67-472c-bb26-7c40e8566c7d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2f7ee80bb6f4767c6be0748e757d030811b06b378c1cd6f438560c3a6548bfbc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 509
      },
      {
        "segments": [
          {
            "segment_id": "4b94ea16-4c36-4adb-88f4-8a67a85cd783",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-19\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the \r\nround key from the second source operand, operating on a 128-bit data (state) from the first source operand, and \r\nstore the result in the destination operand.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESDECLAST\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.NDS.256.66.0F38.WIG DF /r \r\nVAESDECLAST ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from ymm3/m256; \r\nstore the result in ymm1.\r\nEVEX.NDS.128.66.0F38.WIG DF /r\r\nVAESDECLAST xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, oper\u0002ating on a 128-bit data (state) from xmm2 with \r\na 128-bit round key from xmm3/m128; store \r\nthe result in xmm1.\r\nEVEX.NDS.256.66.0F38.WIG DF /r\r\nVAESDECLAST ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from ymm3/m256; \r\nstore the result in ymm1.\r\nEVEX.NDS.512.66.0F38.WIG DF /r\r\nVAESDECLAST zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from zmm2 \r\nwith a 128-bit round key from zmm3/m512; \r\nstore the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4b94ea16-4c36-4adb-88f4-8a67a85cd783.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e6374eed56670c73a954e08107ce3f20af90c92d50dc2491a604020715bbee48",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4f26835b-3a1c-4a42-a25b-0844197f0520",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "2-20 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDECLAST (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESDECLAST (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESDECLAST __m256i _mm256_aesdeclast_epi128(__m256i, __m256i);\r\nVAESDECLAST __m512i _mm512_aesdeclast_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4f26835b-3a1c-4a42-a25b-0844197f0520.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4d2d13392efb1d1698f24a3698c45c53e81bb4a98f2961877a38e46f74f2ca98",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 478
      },
      {
        "segments": [
          {
            "segment_id": "be58bbc2-3c72-4251-ad53-d0c508a78aab",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-21\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENC — Perform One Round of an AES Encryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs a single round of an AES encryption flow using a round key from the second source \r\noperand, operating on 128-bit data (state) from the first source operand, and store the result in the destination \r\noperand.\r\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC\u0002CLAST instruction.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESENC\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.NDS.256.66.0F38.WIG DC /r \r\nVAESENC ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from the \r\nymm3/m256; store the result in ymm1.\r\nEVEX.NDS.128.66.0F38.WIG DC /r\r\nVAESENC xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from xmm2 \r\nwith a 128-bit round key from the \r\nxmm3/m128; store the result in xmm1.\r\nEVEX.NDS.256.66.0F38.WIG DC /r\r\nVAESENC ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from the \r\nymm3/m256; store the result in ymm1.\r\nEVEX.NDS.512.66.0F38.WIG DC /r\r\nVAESENC zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from zmm2 \r\nwith a 128-bit round key from the \r\nzmm3/m512; store the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/be58bbc2-3c72-4251-ad53-d0c508a78aab.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=69d7a8fdd5aed960e7cdb0321c5e471b1d1d13ed543ea427c34137b48841b874",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9c92d559-7f2f-44a4-832d-601c23ba878d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "2-22 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENC (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR I ← 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESENC (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i ← 0 to KL-1:\r\nSTATE ← SRC1.xmm[i] // xmm[i] is the i’th xmm word in the SIMD register\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESENC __m256i _mm256_aesenc_epi128(__m256i, __m256i);\r\nVAESENC __m512i _mm512_aesenc_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9c92d559-7f2f-44a4-832d-601c23ba878d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7cdbb7d164341bd44748b5d57b65416b7e5bd991c4ae957d6503eaf0be9f54bd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 498
      },
      {
        "segments": [
          {
            "segment_id": "5bc736bb-1c5b-468c-84ab-cac1775ecc44",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-23\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs the last round of an AES encryption flow using a round key from the second source \r\noperand, operating on 128-bit data (state) from the first source operand, and store the result in the destination \r\noperand.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESENCLAST\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.NDS.256.66.0F38.WIG DD /r \r\nVAESENCLAST ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nymm2 with a 128 bit round key from \r\nymm3/m256; store the result in ymm1.\r\nEVEX.NDS.128.66.0F38.WIG DD /r\r\nVAESENCLAST xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nxmm2 with a 128 bit round key from \r\nxmm3/m128; store the result in xmm1.\r\nEVEX.NDS.256.66.0F38.WIG DD /r\r\nVAESENCLAST ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nymm2 with a 128 bit round key from \r\nymm3/m256; store the result in ymm1.\r\nEVEX.NDS.512.66.0F38.WIG DD /r\r\nVAESENCLAST zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nzmm2 with a 128 bit round key from \r\nzmm3/m512; store the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5bc736bb-1c5b-468c-84ab-cac1775ecc44.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5c71541fdc31db974507336e77f863c9b89ae2ade0b5bd9658da0483d99f5683",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "742045a9-aba3-4d1b-b912-ae8e7892ca0f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "2-24 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENCLAST (128b and 256b VEX encoded versions)\r\n(KL, VL) = (1,128), (2,256)\r\nFOR I=0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST.xmm[i]← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESENCLAST (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESENCLAST __m256i _mm256_aesenclast_epi128(__m256i, __m256i);\r\nVAESENCLAST __m512i _mm512_aesenclast_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/742045a9-aba3-4d1b-b912-ae8e7892ca0f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dc336b0a3b4665fda18cfcd87b78e4d92dc15f032873b7db29984dbd1fa57b36",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 454
      },
      {
        "segments": [
          {
            "segment_id": "1cc82d53-dbb7-4793-890a-158d3a1b3e44",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-25\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword\r\nInstruction Operand Encoding\r\nDescription\r\nPerforms a carry-less multiplication of two quadwords, selected from the first source and second source operand \r\naccording to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to \r\nuse according to the table below, other bits of the immediate byte are ignored.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nNOTES:\r\nSRC2 denotes the second source operand, which can be a register or memory; SRC1 denotes the first source and \r\ndestination operand.\r\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The \r\nsecond source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. Bits (VL_MAX\u00021:128) of the corresponding YMM destination register remain unchanged.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.NDS.256.66.0F3A.WIG 44 /r /ib \r\nVPCLMULQDQ ymm1, ymm2, \r\nymm3/m256, imm8\r\nA V/V VPCLMULQDQ Carry-less multiplication of one quadword of \r\nymm2 by one quadword of ymm3/m256, stores \r\nthe 128-bit result in ymm1. The immediate is \r\nused to determine which quadwords of ymm2 \r\nand ymm3/m256 should be used.\r\nEVEX.NDS.128.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX512VL\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nxmm2 by one quadword of xmm3/m128, stores \r\nthe 128-bit result in xmm1. The immediate is \r\nused to determine which quadwords of xmm2 \r\nand xmm3/m128 should be used.\r\nEVEX.NDS.256.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX512VL\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nymm2 by one quadword of ymm3/m256, stores \r\nthe 128-bit result in ymm1. The immediate is \r\nused to determine which quadwords of ymm2 \r\nand ymm3/m256 should be used.\r\nEVEX.NDS.512.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ zmm1, zmm2, \r\nzmm3/m512, imm8\r\nB V/V AVX512F\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nzmm2 by one quadword of zmm3/m512, stores \r\nthe 128-bit result in zmm1. The immediate is \r\nused to determine which quadwords of zmm2 \r\nand zmm3/m512 should be used.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nTable 2-7. PCLMULQDQ Quadword Selection of Immediate Byte\r\nimm[4] imm[0] PCLMULQDQ Operation\r\n0 0 CL_MUL( SRC2[63:0], SRC1[63:0] )\r\n0 1 CL_MUL( SRC2[63:0], SRC1[127:64] )\r\n1 0 CL_MUL( SRC2[127:64], SRC1[63:0] )\r\n1 1 CL_MUL( SRC2[127:64], SRC1[127:64] )",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1cc82d53-dbb7-4793-890a-158d3a1b3e44.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d6a1ed4cffde70b4ef7050289780359a4d9bed51e96bfbfe045f0be2abd152e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      },
      {
        "segments": [
          {
            "segment_id": "f2303f46-5162-4ca5-8c6f-d15fb12b4fb6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "2-26 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nCompilers and assemblers may implement the following pseudo-op syntax to simply programming and emit the \r\nrequired encoding for imm8.\r\nOperation\r\ndefine PCLMUL128(X,Y): // helper function\r\nFOR i ← 0 to 63:\r\nTMP [ i ] ← X[ 0 ] and Y[ i ]\r\nFOR j ← 1 to i:\r\nTMP [ i ] ← TMP [ i ] xor (X[ j ] and Y[ i - j ])\r\nDEST[ i ] ← TMP[ i ]\r\nFOR i ← 64 to 126:\r\nTMP [ i ] ← 0\r\nFOR j ← i - 63 to 63:\r\nTMP [ i ] ← TMP [ i ] xor (X[ j ] and Y[ i - j ])\r\nDEST[ i ] ← TMP[ i ]\r\nDEST[127] ← 0;\r\nRETURN DEST // 128b vector\r\nPCLMULQDQ (SSE version)\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.qword[1]\r\nDEST[127:0] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:128] (Unmodified)\r\nVPCLMULQDQ (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR i= 0 to KL-1:\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.xmm[i].qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.xmm[i].qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.xmm[i].qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.xmm[i].qword[1]\r\nDEST.xmm[i] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:VL] ← 0\r\nTable 2-8. Pseudo-Op and PCLMULQDQ Implementation\r\nPseudo-Op Imm8 Encoding\r\nPCLMULLQLQDQ xmm1, xmm2 0000_0000B\r\nPCLMULHQLQDQ xmm1, xmm2 0000_0001B\r\nPCLMULLQHQDQ xmm1, xmm2 0001_0000B\r\nPCLMULHQHQDQ xmm1, xmm2 0001_0001B",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f2303f46-5162-4ca5-8c6f-d15fb12b4fb6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=00dae383f4094dfa9c275e9790bc82caa1a8ea265a882704e49924cfea8b741b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "13767190-477e-4463-ad36-db606fcfdeeb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-27\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCLMULQDQ (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.xmm[i].qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.xmm[i].qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.xmm[i].qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.xmm[i].qword[1]\r\nDEST.xmm[i] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPCLMULQDQ __m256i _mm256_clmulepi64_epi128(__m256i, __m256i, const int);\r\nVPCLMULQDQ __m512i _mm512_clmulepi64_epi128(__m512i, __m512i, const int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/13767190-477e-4463-ad36-db606fcfdeeb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2dcddf7b4843d6d1036035d30ddb5062209d539eb46462822a3258558a7cf381",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 322
      },
      {
        "segments": [
          {
            "segment_id": "9cc0e5dd-0e36-4354-b568-8831938b90a7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "2-28 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register\r\nInstruction Operand Encoding\r\nDescription\r\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the desti\u0002nation operand (first operand), based on the active elements determined by the writemask operand. Note: \r\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nMoves up to 512 bits of packed byte values from the source operand (second operand) to the destination operand \r\n(first operand). This instruction is used to store partial contents of a vector register into a byte vector or single \r\nmemory location using the active elements in operand writemask.\r\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z \r\nmust be zero.\r\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the \r\nsource operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper \r\nbits are zeroed.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:r/m (w) ModRM:reg (r) NA NA\r\nB NA ModRM:r/m (w) ModRM:reg (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9cc0e5dd-0e36-4354-b568-8831938b90a7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e4b23bcbe31af426298a17a59e2bf43e041fcd41fbddac6acf55814e1334551",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 555
      },
      {
        "segments": [
          {
            "segment_id": "9cc0e5dd-0e36-4354-b568-8831938b90a7",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "2-28 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register\r\nInstruction Operand Encoding\r\nDescription\r\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the desti\u0002nation operand (first operand), based on the active elements determined by the writemask operand. Note: \r\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nMoves up to 512 bits of packed byte values from the source operand (second operand) to the destination operand \r\n(first operand). This instruction is used to store partial contents of a vector register into a byte vector or single \r\nmemory location using the active elements in operand writemask.\r\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z \r\nmust be zero.\r\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the \r\nsource operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper \r\nbits are zeroed.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:r/m (w) ModRM:reg (r) NA NA\r\nB NA ModRM:r/m (w) ModRM:reg (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9cc0e5dd-0e36-4354-b568-8831938b90a7.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4e4b23bcbe31af426298a17a59e2bf43e041fcd41fbddac6acf55814e1334551",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 555
      },
      {
        "segments": [
          {
            "segment_id": "8abf4186-ec70-4291-99ea-903ab4b68dfc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-29\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPCOMPRESSB store form\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[k] ← SRC.byte[j]\r\nk ← k +1\r\nVPCOMPRESSB reg-reg form\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[k] ← SRC.byte[j]\r\nk ← k + 1\r\nIF *merging-masking*:\r\n*DEST[VL-1:k*8] remains unchanged*\r\nELSE DEST[VL-1:k*8] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPCOMPRESSW store form\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[k] ← SRC.word[j]\r\nk ← k + 1\r\nVPCOMPRESSW reg-reg form\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[k] ← SRC.word[j]\r\nk ← k + 1\r\nIF *merging-masking*:\r\n*DEST[VL-1:k*16] remains unchanged*\r\nELSE DEST[VL-1:k*16] ← 0\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/8abf4186-ec70-4291-99ea-903ab4b68dfc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3fcecf182baf7cbc2ed927f73622dcb4f03dcca1b6d2695f25efd6f1dece05d3",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ebe5199f-04a1-46e4-ae37-dc9ac3923af0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 84,
            "page_width": 612,
            "page_height": 792,
            "content": "2-30 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPCOMPRESSB __m128i _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);\r\nVPCOMPRESSB __m128i _mm_maskz_compress_epi8(__mmask16, __m128i);\r\nVPCOMPRESSB __m256i _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);\r\nVPCOMPRESSB __m256i _mm256_maskz_compress_epi8(__mmask32, __m256i);\r\nVPCOMPRESSB __m512i _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);\r\nVPCOMPRESSB __m512i _mm512_maskz_compress_epi8(__mmask64, __m512i);\r\nVPCOMPRESSB void _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);\r\nVPCOMPRESSB void _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);\r\nVPCOMPRESSB void _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);\r\nVPCOMPRESSW __m128i _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);\r\nVPCOMPRESSW __m128i _mm_maskz_compress_epi16(__mmask8, __m128i); \r\nVPCOMPRESSW __m256i _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);\r\nVPCOMPRESSW __m256i _mm256_maskz_compress_epi16(__mmask16, __m256i);\r\nVPCOMPRESSW __m512i _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);\r\nVPCOMPRESSW __m512i _mm512_maskz_compress_epi16(__mmask32, __m512i);\r\nVPCOMPRESSW void _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);\r\nVPCOMPRESSW void _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);\r\nVPCOMPRESSW void _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/ebe5199f-04a1-46e4-ae37-dc9ac3923af0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e019f404705b5ce89aae6858b0240f0b69d8bc3815027c2d5af7db2a66400b35",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 275
      },
      {
        "segments": [
          {
            "segment_id": "3c28410c-b408-4b7a-9c7e-f38e4cb399d1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-31\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second \r\nsource operand, producing intermediate signed word results. The word results are then summed and accumulated \r\nin the destination dword element size operand.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPBUSD dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\n// Byte elements of SRC1 are zero-extended to 16b and\r\n// byte elements of SRC2 are sign extended to 16b before multiplication.\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1word ← ZERO_EXTEND(SRC1.byte[4*i]) * SIGN_EXTEND(t.byte[0])\r\np2word ← ZERO_EXTEND(SRC1.byte[4*i+1]) * SIGN_EXTEND(t.byte[1])\r\np3word ← ZERO_EXTEND(SRC1.byte[4*i+2]) * SIGN_EXTEND(t.byte[2])\r\np4word ← ZERO_EXTEND(SRC1.byte[4*i+3]) * SIGN_EXTEND(t.byte[3])\r\nDEST.dword[i] ← ORIGDEST.dword[i] + p1word + p2word + p3word + p4word\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 50 /r\r\nVPDPBUSD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs of signed bytes in \r\nxmm3/m128/m32bcst with corresponding \r\nunsigned bytes of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1 under writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 50 /r\r\nVPDPBUSD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs of signed bytes in \r\nymm3/m256/m32bcst with corresponding \r\nunsigned bytes of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1 under writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 50 /r\r\nVPDPBUSD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 4 pairs of signed bytes in \r\nzmm3/m512/m32bcst with corresponding \r\nunsigned bytes of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1 under writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3c28410c-b408-4b7a-9c7e-f38e4cb399d1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ea993e2726ba51ebf4994f214dccce72a622677b7a363544b8cdc05744fed5f1",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b219d0b4-9ec3-4d57-b157-49c834b50134",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 86,
            "page_width": 612,
            "page_height": 792,
            "content": "2-32 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPBUSD __m128i _mm_dpbusd_epi32(__m128i, __m128i, __m128i);\r\nVPDPBUSD __m128i _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPBUSD __m128i _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPBUSD __m256i _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);\r\nVPDPBUSD __m256i _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPBUSD __m256i _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPBUSD __m512i _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);\r\nVPDPBUSD __m512i _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPBUSD __m512i _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b219d0b4-9ec3-4d57-b157-49c834b50134.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d4e404606ee4ff829aba377886e9d3f1c7e17a20e176cbe1434a6a0f1a2c1c53",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 404
      },
      {
        "segments": [
          {
            "segment_id": "06436ab2-ed47-4e9f-aac7-b04dbbae862d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 87,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-33\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second \r\nsource operand, producing intermediate signed word results. The word results are then summed and accumulated \r\nin the destination dword element size operand. If the intermediate sum overflows a 32b signed number the result \r\nis saturated to either 0x7FFF_FFFF for positive numbers of 0x8000_0000 for negative numbers.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPBUSDS dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\n// Byte elements of SRC1 are zero-extended to 16b and\r\n// byte elements of SRC2 are sign extended to 16b before multiplication.\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1word ← ZERO_EXTEND(SRC1.byte[4*i]) * SIGN_EXTEND(t.byte[0])\r\np2word ← ZERO_EXTEND(SRC1.byte[4*i+1]) * SIGN_EXTEND(t.byte[1])\r\np3word ← ZERO_EXTEND(SRC1.byte[4*i+2]) * SIGN_EXTEND(t.byte[2])\r\np4word ← ZERO_EXTEND(SRC1.byte[4*i+3]) *SIGN_EXTEND(t.byte[3])\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(ORIGDEST.dword[i] + p1word + p2word + p3word + p4word)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 51 /r\r\nVPDPBUSDS xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs signed bytes in \r\nxmm3/m128/m32bcst with corresponding \r\nunsigned bytes of xmm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in xmm1, under \r\nwritemask k1.\r\nEVEX.DDS.256.66.0F38.W0 51 /r\r\nVPDPBUSDS ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs signed bytes in \r\nymm3/m256/m32bcst with corresponding \r\nunsigned bytes of ymm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in ymm1, under \r\nwritemask k1.\r\nEVEX.DDS.512.66.0F38.W0 51 /r\r\nVPDPBUSDS zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 4 pairs signed bytes in \r\nzmm3/m512/m32bcst with corresponding \r\nunsigned bytes of zmm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in zmm1, under \r\nwritemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/06436ab2-ed47-4e9f-aac7-b04dbbae862d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2eed12b1fe7e1fbccda13bab56fd5f1eacd0c2adb588db1296a12965375db4ef",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "27dbc20d-9f95-4bac-a429-873841d7f596",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 88,
            "page_width": 612,
            "page_height": 792,
            "content": "2-34 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPBUSDS __m128i _mm_dpbusds_epi32(__m128i, __m128i, __m128i);\r\nVPDPBUSDS __m128i _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPBUSDS __m128i _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPBUSDS __m256i _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);\r\nVPDPBUSDS __m256i _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPBUSDS __m256i _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPBUSDS __m512i _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);\r\nVPDPBUSDS __m512i _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPBUSDS __m512i _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/27dbc20d-9f95-4bac-a429-873841d7f596.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=85e286dc23cc6cfb8a114e07997c0a7d5a663ccffa9b2102b9df72c17937769e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 435
      },
      {
        "segments": [
          {
            "segment_id": "cc8f4651-f655-42a7-ae45-ca77b9a2fc50",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 89,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-35\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPWSSD — Multiply and Add Signed Word Integers\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second \r\nsource operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then \r\nsummed and accumulated in the destination operand.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPWSSD dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1dword ← SRC1.word[2*i] * t.word[0]\r\np2dword ← SRC1.word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← ORIGDEST.dword[i] + p1dword + p2dword\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 52 /r\r\nVPDPWSSD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs signed words in \r\nxmm3/m128/m32bcst with corresponding \r\nsigned words of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1, under writemask k1.\r\nEVEX.DDS.256.66.0F38.W0 52 /r\r\nVPDPWSSD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs signed words in \r\nymm3/m256/m32bcst with corresponding \r\nsigned words of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1, under writemask k1.\r\nEVEX.DDS.512.66.0F38.W0 52 /r\r\nVPDPWSSD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 2 pairs signed words in \r\nzmm3/m512/m32bcst with corresponding \r\nsigned words of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1, under writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/cc8f4651-f655-42a7-ae45-ca77b9a2fc50.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d6d2e195028fbecd4f76bcd8e05283ecdcb019f4559e30a0ce113939c430d44f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "3e9d8f23-7d97-4747-8d73-8f564e87f84b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 90,
            "page_width": 612,
            "page_height": 792,
            "content": "2-36 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPWSSD __m128i _mm_dpwssd_epi32(__m128i, __m128i, __m128i);\r\nVPDPWSSD __m128i _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPWSSD __m128i _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPWSSD __m256i _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);\r\nVPDPWSSD __m256i _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPWSSD __m256i _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPWSSD __m512i _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);\r\nVPDPWSSD __m512i _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPWSSD __m512i _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3e9d8f23-7d97-4747-8d73-8f564e87f84b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdeb4567d08a443be1e889222460edb9d301125b26aefcd5d7a4a6d3fc939b7d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "4d851b4c-be91-4154-9930-63f8b2bd2498",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-37\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPWSSDS — Multiply and Add Word Integers with Saturation\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second \r\nsource operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then \r\nsummed and accumulated in the destination operand. If the intermediate sum overflows a 32b signed number, the \r\nresult is saturated to either 0x7FFF_FFFF for positive numbers of 0x8000_0000 for negative numbers.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPWSSDS dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1dword ← SRC1.word[2*i] * t.word[0]\r\np2dword ← SRC1.word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(ORIGDEST.dword[i] + p1dword + p2dword)\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W0 53 /r\r\nVPDPWSSDS xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs of signed words in \r\nxmm3/m128/m32bcst with corresponding \r\nsigned words of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1, with signed saturation, under \r\nwritemask k1.\r\nEVEX.DDS.256.66.0F38.W0 53 /r\r\nVPDPWSSDS ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs of signed words in \r\nymm3/m256/m32bcst with corresponding \r\nsigned words of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1, with signed saturation, under \r\nwritemask k1.\r\nEVEX.DDS.512.66.0F38.W0 53 /r\r\nVPDPWSSDS zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 2 pairs of signed words in \r\nzmm3/m512/m32bcst with corresponding \r\nsigned words of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1, with signed saturation, under \r\nwritemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4d851b4c-be91-4154-9930-63f8b2bd2498.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=18a700e5bde2354dd9fa40fb33e761545dcf4724bdc397f9c7c0ce58d691d6a4",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "bfa642e2-3994-4fd2-8670-c3ce6a883691",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "2-38 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPWSSDS __m128i _mm_dpwssds_epi32(__m128i, __m128i, __m128i);\r\nVPDPWSSDS __m128i _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPWSSDS __m128i _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPWSSDS __m256i _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);\r\nVPDPWSSDS __m256i _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPWSSDS __m256i _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPWSSDS __m512i _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);\r\nVPDPWSSDS __m512i _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPWSSDS __m512i _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/bfa642e2-3994-4fd2-8670-c3ce6a883691.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6554732c5c972e4050d02b90a82ba78ac2cb4bcd7588c48f808ced0c8a871eff",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 398
      },
      {
        "segments": [
          {
            "segment_id": "a8535392-5aa8-4839-8613-3d3d73327a06",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-39\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPEXPAND — Expand Byte/Word Values\r\nInstruction Operand Encoding\r\nDescription\r\nExpands (loads) up to 64 byte integer values or 32 word integer values from the source operand (memory \r\noperand) to the destination operand (register operand), based on the active elements determined by the \r\nwritemask operand.\r\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 62 /r\r\nVPEXPANDB xmm1{k1}{z}, m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed byte values \r\nfrom m128 to xmm1 with writemask k1.\r\nEVEX.128.66.0F38.W0 62 /r\r\nVPEXPANDB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 62 /r\r\nVPEXPANDB ymm1{k1}{z}, m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed byte values \r\nfrom m256 to ymm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 62 /r\r\nVPEXPANDB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 62 /r\r\nVPEXPANDB zmm1{k1}{z}, m512\r\nA V/V AVX512_VBMI2 Expands up to 512 bits of packed byte values \r\nfrom m512 to zmm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 62 /r\r\nVPEXPANDB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Expands up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 62 /r\r\nVPEXPANDW xmm1{k1}{z}, m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed word values \r\nfrom m128 to xmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 62 /r\r\nVPEXPANDW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 62 /r\r\nVPEXPANDW ymm1{k1}{z}, m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed word values \r\nfrom m256 to ymm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 62 /r\r\nVPEXPANDW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 62 /r\r\nVPEXPANDW zmm1{k1}{z}, m512\r\nA V/V AVX512_VBMI2 Expands up to 512 bits of packed word values \r\nfrom m512 to zmm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 62 /r\r\nVPEXPANDW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Expands up to 512 bits of packed byte integer \r\nvalues from zmm2 to zmm1 with writemask \r\nk1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:reg (w) ModRM:r/m (r) NA NA\r\nB NA ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a8535392-5aa8-4839-8613-3d3d73327a06.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=77d3e04091359c6b365b329ecdf0ed628f6394b2ce1ed3bfa308f694dc22073c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 412
      },
      {
        "segments": [
          {
            "segment_id": "0c4ba0ff-ac3f-4be9-8ad8-9a27f373d92d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "2-40 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nMoves 128, 256 or 512 bits of packed byte integer values from the source operand (memory operand) to the desti\u0002nation operand (register operand). This instruction is used to load from an int8 vector register or memory location \r\nwhile inserting the data into sparse elements of destination vector register using the active elements pointed out \r\nby the operand writemask.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOperation\r\nVPEXPANDB\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[j] ← SRC.byte[k];\r\nk ← k + 1\r\nELSE:\r\nIF *merging-masking*:\r\n*DEST.byte[j] remains unchanged*\r\nELSE: ; zeroing-masking\r\nDEST.byte[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPEXPANDW\r\n(KL, VL) = (8,128), (16,256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[j] ← SRC.word[k];\r\nk ← k + 1\r\nELSE:\r\nIF *merging-masking*:\r\n*DEST.word[j] remains unchanged*\r\nELSE: ; zeroing-masking\r\nDEST.word[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/0c4ba0ff-ac3f-4be9-8ad8-9a27f373d92d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=874decd6af1b6fb19cc87147bd68244ee0d55409833fe3d998cd7f800e10a48d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "be8e7003-ec54-4235-8596-ad9df0ae9e09",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-41\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPEXPAND __m128i _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);\r\nVPEXPAND __m128i _mm_maskz_expand_epi8(__mmask16, __m128i);\r\nVPEXPAND __m128i _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);\r\nVPEXPAND __m128i _mm_maskz_expandloadu_epi8(__mmask16, const void*);\r\nVPEXPAND __m256i _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);\r\nVPEXPAND __m256i _mm256_maskz_expand_epi8(__mmask32, __m256i);\r\nVPEXPAND __m256i _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);\r\nVPEXPAND __m256i _mm256_maskz_expandloadu_epi8(__mmask32, const void*);\r\nVPEXPAND __m512i _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);\r\nVPEXPAND __m512i _mm512_maskz_expand_epi8(__mmask64, __m512i);\r\nVPEXPAND __m512i _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);\r\nVPEXPAND __m512i _mm512_maskz_expandloadu_epi8(__mmask64, const void*);\r\nVPEXPANDW __m128i _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);\r\nVPEXPANDW __m128i _mm_maskz_expand_epi16(__mmask8, __m128i);\r\nVPEXPANDW __m128i _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);\r\nVPEXPANDW __m128i _mm_maskz_expandloadu_epi16(__mmask8, const void *);\r\nVPEXPANDW __m256i _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);\r\nVPEXPANDW __m256i _mm256_maskz_expand_epi16(__mmask16, __m256i);\r\nVPEXPANDW __m256i _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);\r\nVPEXPANDW __m256i _mm256_maskz_expandloadu_epi16(__mmask16, const void*);\r\nVPEXPANDW __m512i _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);\r\nVPEXPANDW __m512i _mm512_maskz_expand_epi16(__mmask32, __m512i);\r\nVPEXPANDW __m512i _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);\r\nVPEXPANDW __m512i _mm512_maskz_expandloadu_epi16(__mmask32, const void*);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/be8e7003-ec54-4235-8596-ad9df0ae9e09.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a07086370d8e22dd8366ea5a39945d9caf49b4317d122efe72d2aa51c4b63744",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 334
      },
      {
        "segments": [
          {
            "segment_id": "f42aae9d-a6ec-4f37-a724-aabb4deec0e8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "2-42 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., \r\nzmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory \r\nfault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature Flag Description\r\nEVEX.128.66.0F38.W0 54 /r\r\nVPOPCNTB xmm1{k1}{z}, \r\nxmm2/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128 and puts the result in xmm1 with \r\nwritemask k1.\r\nEVEX.256.66.0F38.W0 54 /r\r\nVPOPCNTB ymm1{k1}{z}, \r\nymm2/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256 and puts the result in ymm1 with \r\nwritemask k1.\r\nEVEX.512.66.0F38.W0 54 /r\r\nVPOPCNTB zmm1{k1}{z}, \r\nzmm2/m512\r\nA V/V AVX512_BITALG Counts the number of bits set to one in \r\nzmm2/m512 and puts the result in zmm1 with \r\nwritemask k1.\r\nEVEX.128.66.0F38.W1 54 /r\r\nVPOPCNTW xmm1{k1}{z}, \r\nxmm2/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128 and puts the result in xmm1 with \r\nwritemask k1.\r\nEVEX.256.66.0F38.W1 54 /r\r\nVPOPCNTW ymm1{k1}{z}, \r\nymm2/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256 and puts the result in ymm1 with \r\nwritemask k1.\r\nEVEX.512.66.0F38.W1 54 /r\r\nVPOPCNTW zmm1{k1}{z}, \r\nzmm2/m512\r\nA V/V AVX512_BITALG Counts the number of bits set to one in \r\nzmm2/m512 and puts the result in zmm1 with \r\nwritemask k1.\r\nEVEX.128.66.0F38.W0 55 /r\r\nVPOPCNTD xmm1{k1}{z}, \r\nxmm2/m128/m32bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128/m32bcst and puts the result in \r\nxmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 55 /r\r\nVPOPCNTD ymm1{k1}{z}, \r\nymm2/m256/m32bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256/m32bcst and puts the result in \r\nymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 55 /r\r\nVPOPCNTD zmm1{k1}{z}, \r\nzmm2/m512/m32bcst\r\nB V/V AVX512_VPOPCNTDQ Counts the number of bits set to one in \r\nzmm2/m512/m32bcst and puts the result in \r\nzmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 55 /r\r\nVPOPCNTQ xmm1{k1}{z}, \r\nxmm2/m128/m64bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128/m32bcst and puts the result in \r\nxmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 55 /r\r\nVPOPCNTQ ymm1{k1}{z}, \r\nymm2/m256/m64bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256/m32bcst and puts the result in \r\nymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 55 /r\r\nVPOPCNTQ zmm1{k1}{z}, \r\nzmm2/m512/m64bcst\r\nB V/V AVX512_VPOPCNTDQ Counts the number of bits set to one in \r\nzmm2/m512/m64bcst and puts the result in \r\nzmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) ModRM:r/m (r) NA NA\r\nB Full ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f42aae9d-a6ec-4f37-a724-aabb4deec0e8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c1122a2c2f5abe139c5a4079e70bcac4fce534bf3a6ae4d4eea61a49658636da",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 449
      },
      {
        "segments": [
          {
            "segment_id": "717faa3f-f7c1-4cea-8eb2-0ffa6092c7a1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-43\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPOPCNTB\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.byte[j] ← POPCNT(SRC.byte[j])\r\nELSE IF *merging-masking*:\r\n*DEST.byte[j] remains unchanged*\r\nELSE:\r\nDEST.byte[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPOPCNTW\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] ← POPCNT(SRC.word[j])\r\nELSE IF *merging-masking*:\r\n*DEST.word[j] remains unchanged*\r\nELSE:\r\nDEST.word[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPOPCNTD\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nIF SRC is broadcast memop:\r\nt ← SRC.dword[0]\r\nELSE:\r\nt ← SRC.dword[j]\r\nDEST.dword[j] ← POPCNT(t)\r\nELSE IF *merging-masking*:\r\n*DEST..dword[j] remains unchanged*\r\nELSE:\r\nDEST..dword[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPOPCNTQ\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nIF SRC is broadcast memop:\r\nt ← SRC.qword[0]\r\nELSE:\r\nt ← SRC.qword[j]\r\nDEST.qword[j] ← POPCNT(t)\r\nELSE IF *merging-masking*:\r\n*DEST..qword[j] remains unchanged*\r\nELSE:\r\nDEST..qword[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/717faa3f-f7c1-4cea-8eb2-0ffa6092c7a1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f024c1fafe2aa341ecfbdcc8c29d955785c5b56fb98931a2e17cd4a38798f64",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "485963d0-7c75-4730-8189-2a28307ee347",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "2-44 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPOPCNTW __m128i _mm_popcnt_epi16(__m128i);\r\nVPOPCNTW __m128i _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);\r\nVPOPCNTW __m128i _mm_maskz_popcnt_epi16(__mmask8, __m128i);\r\nVPOPCNTW __m256i _mm256_popcnt_epi16(__m256i);\r\nVPOPCNTW __m256i _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);\r\nVPOPCNTW __m256i _mm256_maskz_popcnt_epi16(__mmask16, __m256i);\r\nVPOPCNTW __m512i _mm512_popcnt_epi16(__m512i);\r\nVPOPCNTW __m512i _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);\r\nVPOPCNTW __m512i _mm512_maskz_popcnt_epi16(__mmask32, __m512i);\r\nVPOPCNTQ __m128i _mm_popcnt_epi64(__m128i);\r\nVPOPCNTQ __m128i _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);\r\nVPOPCNTQ __m128i _mm_maskz_popcnt_epi64(__mmask8, __m128i);\r\nVPOPCNTQ __m256i _mm256_popcnt_epi64(__m256i);\r\nVPOPCNTQ __m256i _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);\r\nVPOPCNTQ __m256i _mm256_maskz_popcnt_epi64(__mmask8, __m256i);\r\nVPOPCNTQ __m512i _mm512_popcnt_epi64(__m512i);\r\nVPOPCNTQ __m512i _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);\r\nVPOPCNTQ __m512i _mm512_maskz_popcnt_epi64(__mmask8, __m512i);\r\nVPOPCNTD __m128i _mm_popcnt_epi32(__m128i);\r\nVPOPCNTD __m128i _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);\r\nVPOPCNTD __m128i _mm_maskz_popcnt_epi32(__mmask8, __m128i);\r\nVPOPCNTD __m256i _mm256_popcnt_epi32(__m256i);\r\nVPOPCNTD __m256i _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);\r\nVPOPCNTD __m256i _mm256_maskz_popcnt_epi32(__mmask8, __m256i);\r\nVPOPCNTD __m512i _mm512_popcnt_epi32(__m512i);\r\nVPOPCNTD __m512i _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);\r\nVPOPCNTD __m512i _mm512_maskz_popcnt_epi32(__mmask16, __m512i);\r\nVPOPCNTB __m128i _mm_popcnt_epi8(__m128i);\r\nVPOPCNTB __m128i _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);\r\nVPOPCNTB __m128i _mm_maskz_popcnt_epi8(__mmask16, __m128i);\r\nVPOPCNTB __m256i _mm256_popcnt_epi8(__m256i);\r\nVPOPCNTB __m256i _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);\r\nVPOPCNTB __m256i _mm256_maskz_popcnt_epi8(__mmask32, __m256i);\r\nVPOPCNTB __m512i _mm512_popcnt_epi8(__m512i);\r\nVPOPCNTB __m512i _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);\r\nVPOPCNTB __m512i _mm512_maskz_popcnt_epi8(__mmask64, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/485963d0-7c75-4730-8189-2a28307ee347.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e42c9eb4b4a3afde3d5a97d3e4cd3f6b220771b3b369fd058d41d432beef2e27",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 347
      },
      {
        "segments": [
          {
            "segment_id": "41b48369-7552-464c-9888-9a2b091470d5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 99,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-45\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the left by constant value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.NDS.128.66.0F3A.W1 70 /r /ib\r\nVPSHLDW xmm1{k1}{z}, xmm2, \r\nxmm3/m128, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W1 70 /r /ib\r\nVPSHLDW ymm1{k1}{z}, ymm2, \r\nymm3/m256, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W1 70 /r /ib\r\nVPSHLDW zmm1{k1}{z}, zmm2, \r\nzmm3/m512, imm8\r\nA V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.NDS.128.66.0F3A.W0 71 /r /ib\r\nVPSHLDD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W0 71 /r /ib\r\nVPSHLDD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W0 71 /r /ib\r\nVPSHLDD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.NDS.128.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)\r\nB Full ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/41b48369-7552-464c-9888-9a2b091470d5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=58dd3d84b170fecb1a4a576f1c2302f9e6f230ae8b7e54f44194e45cff849554",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "daa19174-d8df-472d-bcef-49779582ea34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 100,
            "page_width": 612,
            "page_height": 792,
            "content": "2-46 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHLDW DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.word[j], SRC3.word[j]) << (imm8 & 15)\r\nDEST.word[j] ← tmp.word[1]\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDD DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.dword[j], tsrc3) << (imm8 & 31)\r\nDEST.dword[j] ← tmp.dword[1]\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDQ DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.qword[j], tsrc3) << (imm8 & 63)\r\nDEST.qword[j] ← tmp.qword[1]\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/daa19174-d8df-472d-bcef-49779582ea34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=67fd5fdae8d064eb9aeec7792bea2b87a7a67578c04ee3f3700dc4fbcfe3d029",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "2821dcf3-e4a6-463b-8920-50f0e5e0278a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-47\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHLDD __m128i _mm_shldi_epi32(__m128i, __m128i, int);\r\nVPSHLDD __m128i _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDD __m128i _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);\r\nVPSHLDD __m256i _mm256_shldi_epi32(__m256i, __m256i, int);\r\nVPSHLDD __m256i _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHLDD __m256i _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);\r\nVPSHLDD __m512i _mm512_shldi_epi32(__m512i, __m512i, int);\r\nVPSHLDD __m512i _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);\r\nVPSHLDD __m512i _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);\r\nVPSHLDQ __m128i _mm_shldi_epi64(__m128i, __m128i, int);\r\nVPSHLDQ __m128i _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDQ __m128i _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);\r\nVPSHLDQ __m256i _mm256_shldi_epi64(__m256i, __m256i, int);\r\nVPSHLDQ __m256i _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHLDQ __m256i _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);\r\nVPSHLDQ __m512i _mm512_shldi_epi64(__m512i, __m512i, int);\r\nVPSHLDQ __m512i _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);\r\nVPSHLDQ __m512i _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);\r\nVPSHLDW __m128i _mm_shldi_epi16(__m128i, __m128i, int);\r\nVPSHLDW __m128i _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDW __m128i _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);\r\nVPSHLDW __m256i _mm256_shldi_epi16(__m256i, __m256i, int);\r\nVPSHLDW __m256i _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);\r\nVPSHLDW __m256i _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);\r\nVPSHLDW __m512i _mm512_shldi_epi16(__m512i, __m512i, int);\r\nVPSHLDW __m512i _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);\r\nVPSHLDW __m512i _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/2821dcf3-e4a6-463b-8920-50f0e5e0278a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c99bbb4c813d44491eca1cf9ba136e97a3ae39662c7d456c2f189c11df29f11f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 364
      },
      {
        "segments": [
          {
            "segment_id": "3b7ed4ab-072b-4590-8190-f3a78bcba926",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 102,
            "page_width": 612,
            "page_height": 792,
            "content": "2-48 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the left by variable value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W1 70 /r\r\nVPSHLDVW xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.DDS.256.66.0F38.W1 70 /r\r\nVPSHLDVW ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.DDS.512.66.0F38.W1 70 /r\r\nVPSHLDVW zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nEVEX.DDS.128.66.0F38.W0 71 /r\r\nVPSHLDVD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.DDS.256.66.0F38.W0 71 /r\r\nVPSHLDVD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.DDS.512.66.0F38.W0 71 /r\r\nVPSHLDVD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nEVEX.DDS.128.66.0F38.W1 71 /r\r\nVPSHLDVQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.DDS.256.66.0F38.W1 71 /r\r\nVPSHLDVQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.DDS.512.66.0F38.W1 71 /r\r\nVPSHLDVQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA\r\nB Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3b7ed4ab-072b-4590-8190-f3a78bcba926.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fbd6ac7d278aa21fdd8c7c64fcf2ce255c6e2c2101734b9d79bd3946545fb6b7",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b62feb14-1d02-49cc-bf97-cc936dd708c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 103,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-49\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nFUNCTION concat(a,b):\r\nIF words:\r\nd.word[1] ← a\r\nd.word[0] ← b\r\nreturn d\r\nELSE IF dwords:\r\nq.dword[1] ← a\r\nq.dword[0] ← b\r\nreturn q\r\nELSE IF qwords:\r\no.qword[1] ← a\r\no.qword[0] ← b\r\nreturn o\r\nVPSHLDVW DEST, SRC2, SRC3\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.word[j], SRC2.word[j]) << (SRC3.word[j] & 15)\r\nDEST.word[j] ← tmp.word[1]\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDVD DEST, SRC2, SRC3\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.dword[j], SRC2.dword[j]) << (tsrc3 & 31)\r\nDEST.dword[j] ← tmp.dword[1]\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b62feb14-1d02-49cc-bf97-cc936dd708c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=52bb93fd8a8deeebe40ace48d28421e17ebf8efeded1586143dddc09ca767f7d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 472
      },
      {
        "segments": [
          {
            "segment_id": "e3ef56be-7626-493e-91bb-a3f29c7f853f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "2-50 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLDVQ DEST, SRC2, SRC3\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.qword[j], SRC2.qword[j]) << (tsrc3 & 63)\r\nDEST.qword[j] ← tmp.qword[1]\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHLDVW __m128i _mm_shldv_epi16(__m128i, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVW __m256i _mm256_shldv_epi16(__m256i, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHLDVQ __m512i _mm512_shldv_epi64(__m512i, __m512i, __m512i);\r\nVPSHLDVQ __m512i _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);\r\nVPSHLDVQ __m512i _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);\r\nVPSHLDVW __m128i _mm_shldv_epi16(__m128i, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVW __m256i _mm256_shldv_epi16(__m256i, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHLDVW __m512i _mm512_shldv_epi16(__m512i, __m512i, __m512i);\r\nVPSHLDVW __m512i _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);\r\nVPSHLDVW __m512i _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);\r\nVPSHLDVD __m128i _mm_shldv_epi32(__m128i, __m128i, __m128i);\r\nVPSHLDVD __m128i _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVD __m128i _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVD __m256i _mm256_shldv_epi32(__m256i, __m256i, __m256i);\r\nVPSHLDVD __m256i _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHLDVD __m256i _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHLDVD __m512i _mm512_shldv_epi32(__m512i, __m512i, __m512i);\r\nVPSHLDVD __m512i _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPSHLDVD __m512i _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e3ef56be-7626-493e-91bb-a3f29c7f853f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=22f23cadc7cacfe2da692551e1734a5fef7c779458c0d6a5ceea80582aaa0ed7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 235
      },
      {
        "segments": [
          {
            "segment_id": "6cb31564-29b6-49d2-acf1-788c4edeb4eb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-51\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the right by constant value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.NDS.128.66.0F3A.W1 72 /r /ib\r\nVPSHRDW xmm1{k1}{z}, xmm2, \r\nxmm3/m128, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W1 72 /r /ib\r\nVPSHRDW ymm1{k1}{z}, ymm2, \r\nymm3/m256, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W1 72 /r /ib\r\nVPSHRDW zmm1{k1}{z}, zmm2, \r\nzmm3/m512, imm8\r\nA V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.NDS.128.66.0F3A.W0 73 /r /ib\r\nVPSHRDD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W0 73 /r /ib\r\nVPSHRDD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W0 73 /r /ib\r\nVPSHRDD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.NDS.128.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.NDS.256.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.NDS.512.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)\r\nB Full ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/6cb31564-29b6-49d2-acf1-788c4edeb4eb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4c783b64e9decb22e8c07c8e056ea7021528b56e8ee2089860f49729b94061f6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "3d1bb7a3-84a5-41e7-acd5-b6ebb7d9e06b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "2-52 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHRDW DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] ← concat(SRC3.word[j], SRC2.word[j]) >> (imm8 & 15)\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDD DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.dword[j] ← concat(tsrc3, SRC2.dword[j]) >> (imm8 & 31)\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDQ DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.qword[j] ← concat(tsrc3, SRC2.qword[j]) >> (imm8 & 63)\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/3d1bb7a3-84a5-41e7-acd5-b6ebb7d9e06b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9f016905a72545605ab901b8a539e9efbd723eb57784f59ce666b3796074aa7a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b827e7db-a75d-48ce-a2a6-63d0a3242821",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-53\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHRDQ __m128i _mm_shrdi_epi64(__m128i, __m128i, int);\r\nVPSHRDQ __m128i _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDQ __m128i _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);\r\nVPSHRDQ __m256i _mm256_shrdi_epi64(__m256i, __m256i, int);\r\nVPSHRDQ __m256i _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHRDQ __m256i _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);\r\nVPSHRDQ __m512i _mm512_shrdi_epi64(__m512i, __m512i, int);\r\nVPSHRDQ __m512i _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);\r\nVPSHRDQ __m512i _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);\r\nVPSHRDD __m128i _mm_shrdi_epi32(__m128i, __m128i, int);\r\nVPSHRDD __m128i _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDD __m128i _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);\r\nVPSHRDD __m256i _mm256_shrdi_epi32(__m256i, __m256i, int);\r\nVPSHRDD __m256i _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHRDD __m256i _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);\r\nVPSHRDD __m512i _mm512_shrdi_epi32(__m512i, __m512i, int);\r\nVPSHRDD __m512i _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);\r\nVPSHRDD __m512i _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);\r\nVPSHRDW __m128i _mm_shrdi_epi16(__m128i, __m128i, int);\r\nVPSHRDW __m128i _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDW __m128i _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);\r\nVPSHRDW __m256i _mm256_shrdi_epi16(__m256i, __m256i, int);\r\nVPSHRDW __m256i _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);\r\nVPSHRDW __m256i _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);\r\nVPSHRDW __m512i _mm512_shrdi_epi16(__m512i, __m512i, int);\r\nVPSHRDW __m512i _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);\r\nVPSHRDW __m512i _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/b827e7db-a75d-48ce-a2a6-63d0a3242821.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=103c695918c82f9c1e18aba47e550217a33f2888a9655b5297c40ee192d568f2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 355
      },
      {
        "segments": [
          {
            "segment_id": "2c50d674-15a9-4127-b5db-1426238e2d92",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "2-54 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the right by variable value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.128.66.0F38.W1 72 /r\r\nVPSHRDVW xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.DDS.256.66.0F38.W1 72 /r\r\nVPSHRDVW ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.DDS.512.66.0F38.W1 72 /r\r\nVPSHRDVW zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nEVEX.DDS.128.66.0F38.W0 73 /r\r\nVPSHRDVD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.DDS.256.66.0F38.W0 73 /r\r\nVPSHRDVD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.DDS.512.66.0F38.W0 73 /r\r\nVPSHRDVD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nEVEX.DDS.128.66.0F38.W1 73 /r\r\nVPSHRDVQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.DDS.256.66.0F38.W1 73 /r\r\nVPSHRDVQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.DDS.512.66.0F38.W1 73 /r\r\nVPSHRDVQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA\r\nB Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/2c50d674-15a9-4127-b5db-1426238e2d92.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5bc57eb7ce6520640dfde1074dec8ac2bf52ed85ef607f060c5d1dbb24d4be29",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "dd0c482e-97be-4b75-b89d-3ac48cc68e81",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 109,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-55\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHRDVW DEST, SRC2, SRC3\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] ← concat(SRC2.word[j], DEST.word[j]) >> (SRC3.word[j] & 15)\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDVD DEST, SRC2, SRC3\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.dword[j] ← concat(SRC2.dword[j], DEST.dword[j]) >> (tsrc3 & 31)\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDVQ DEST, SRC2, SRC3\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.qword[j] ← concat(SRC2.qword[j], DEST.qword[j]) >> (tsrc3 & 63)\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/dd0c482e-97be-4b75-b89d-3ac48cc68e81.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9879062c98c8dbf84b7b40add27f8997e9bea59f19662ba2547549ca85b5f158",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 489
      },
      {
        "segments": [
          {
            "segment_id": "019f6a9c-5c3d-40f2-bc44-e8fc42e7817b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 110,
            "page_width": 612,
            "page_height": 792,
            "content": "2-56 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHRDVQ __m128i _mm_shrdv_epi64(__m128i, __m128i, __m128i);\r\nVPSHRDVQ __m128i _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVQ __m128i _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVQ __m256i _mm256_shrdv_epi64(__m256i, __m256i, __m256i);\r\nVPSHRDVQ __m256i _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHRDVQ __m256i _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHRDVQ __m512i _mm512_shrdv_epi64(__m512i, __m512i, __m512i);\r\nVPSHRDVQ __m512i _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);\r\nVPSHRDVQ __m512i _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);\r\nVPSHRDVD __m128i _mm_shrdv_epi32(__m128i, __m128i, __m128i);\r\nVPSHRDVD __m128i _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVD __m128i _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVD __m256i _mm256_shrdv_epi32(__m256i, __m256i, __m256i);\r\nVPSHRDVD __m256i _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHRDVD __m256i _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHRDVD __m512i _mm512_shrdv_epi32(__m512i, __m512i, __m512i);\r\nVPSHRDVD __m512i _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPSHRDVD __m512i _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nVPSHRDVW __m128i _mm_shrdv_epi16(__m128i, __m128i, __m128i);\r\nVPSHRDVW __m128i _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVW __m128i _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVW __m256i _mm256_shrdv_epi16(__m256i, __m256i, __m256i);\r\nVPSHRDVW __m256i _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHRDVW __m256i _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHRDVW __m512i _mm512_shrdv_epi16(__m512i, __m512i, __m512i);\r\nVPSHRDVW __m512i _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);\r\nVPSHRDVW __m512i _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/019f6a9c-5c3d-40f2-bc44-e8fc42e7817b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8e9b3b9c175a100b7d733dde21fe836c07daa7d0be836ce17b5ca792fe46b73d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 175
      },
      {
        "segments": [
          {
            "segment_id": "c7d6f9aa-56f7-4406-9432-051f2707d829",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 111,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-57\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask\r\nInstruction Operand Encoding\r\nDescription\r\nThe VPSHUFBITQMB instruction performs a bit gather select using second source as control and first source as \r\ndata. Each bit uses 6 control bits (2nd source operand) to select which data bit is going to be gathered (first source \r\noperand). A given bit can only access 64 different bits of data (first 64 destination bits can access first 64 data bits, \r\nsecond 64 destination bits can access second 64 data bits, etc.).\r\nControl data for each output bit is stored in 8 bit elements of SRC2, but only the 6 least significant bits of each \r\nelement are used.\r\nThis instruction uses write masking (zeroing only). This instruction supports memory fault suppression.\r\nThe first source operand is a ZMM register. The second source operand is a ZMM register or a memory location. The \r\ndestination operand is a mask register.\r\nOperation\r\nVPSHUFBITQMB DEST, SRC1, SRC2\r\n(KL, VL) = (16,128), (32,256), (64, 512)\r\nFOR i ← 0 TO KL/8-1: //Qword\r\nFOR j ← 0 to 7: // Byte\r\nIF k2[i*8+j] or *no writemask*:\r\nm ← SRC2.qword[i].byte[j] & 0x3F\r\nk1[i*8+j] ← SRC1.qword[i].bit[m]\r\nELSE:\r\nk1[i*8+j] ← 0\r\nk1[MAX_KL-1:KL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHUFBITQMB __mmask16 _mm_bitshuffle_epi64_mask(__m128i, __m128i);\r\nVPSHUFBITQMB __mmask16 _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);\r\nVPSHUFBITQMB __mmask32 _mm256_bitshuffle_epi64_mask(__m256i, __m256i);\r\nVPSHUFBITQMB __mmask32 _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);\r\nVPSHUFBITQMB __mmask64 _mm512_bitshuffle_epi64_mask(__m512i, __m512i);\r\nVPSHUFBITQMB __mmask64 _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.NDS.128.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nExtract values in xmm2 using control bits of \r\nxmm3/m128 with writemask k2 and leave the \r\nresult in mask register k1.\r\nEVEX.NDS.256.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nExtract values in ymm2 using control bits of \r\nymm3/m256 with writemask k2 and leave the \r\nresult in mask register k1.\r\nEVEX.NDS.512.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_BITALG Extract values in zmm2 using control bits of \r\nzmm3/m512 with writemask k2 and leave the \r\nresult in mask register k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/c7d6f9aa-56f7-4406-9432-051f2707d829.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9c5eda17546942abe5b648c887ed7db1aa1dc18bd71e5c1f4cad5df5178207ef",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 365
      },
      {
        "segments": [
          {
            "segment_id": "70652060-93d2-4dc0-a353-c8d53b9d37e0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "2-58 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z\r\nWBNOINVD—Write Back and Do Not Invalidate Cache\r\nInstruction Operand Encoding\r\nDescription\r\nThe WBNOINVD instruction writes back all modified cache lines in the processor’s internal cache to main memory \r\nbut does not invalidate (flush) the internal caches.\r\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back \r\noperation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache \r\nwrite-back signal. The amount of time or cycles for WBNOINVD to complete will vary due to size and other factors \r\nof different cache hierarchies. As a consequence, the use of the WBNOINVD instruction can have an impact on \r\nlogical processor interrupt/event response time. \r\nThe WBNOINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of \r\na program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see \r\n“Serializing Instructions” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A).\r\nIn situations where cache coherency with main memory is not a concern, software can use the INVD instruction. \r\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\r\nIA-32 Architecture Compatibility\r\nThe WBNOINVD instruction is implementation dependent, and its function may be implemented differently on \r\nfuture Intel 64 and IA-32 processors.\r\nOperation\r\nWriteBack(InternalCaches);\r\nContinue; (* Continue execution *)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nWBNOINVD void _wbnoinvd(void);\r\nFlags Affected\r\nNone.\r\nProtected Mode Exceptions\r\n#GP(0) If the current privilege level is not 0.\r\n#UD If the LOCK prefix is used.\r\nReal-Address Mode Exceptions\r\n#UD If the LOCK prefix is used.\r\nOpcode /\r\nInstruction\r\nOp/ \r\nEn\r\n64/32 bit \r\nMode \r\nSupport\r\nCPUID \r\nFeature \r\nFlag\r\nDescription\r\nF3 0F 09\r\nWBNOINVD\r\nA V/V WBNOINVD Write back and do not flush internal caches; \r\ninitiate writing-back without flushing of external \r\ncaches.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA NA NA NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/70652060-93d2-4dc0-a353-c8d53b9d37e0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9c9c208fcea1bebec1f56bbad06438f0fd300561a8fa1e893f1215fe373bbf8e",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a56e8565-0ed8-4c22-8209-98044f47e1cf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 2-59\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVirtual-8086 Mode Exceptions\r\n#GP(0) WBNOINVD cannot be executed at the virtual-8086 mode.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\nSame exceptions as in protected mode.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a56e8565-0ed8-4c22-8209-98044f47e1cf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13192fd2a9f9b214364ce482fcb26c250cad183006c1ef6c87a453360302da23",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c9e11eae-94ff-4c5b-afd7-76946b4b5594",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 114,
            "page_width": 612,
            "page_height": 792,
            "content": "2-60 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE, A-Z",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/c9e11eae-94ff-4c5b-afd7-76946b4b5594.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=82ce34ef8cca57ebaab63f2b34d38e13af519753414b74c208d9320434ce98d9",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "893fc78c-336e-4ca3-b218-d5e08c6ad417",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 115,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 3-1\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nCHAPTER 3\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON\r\nTHE KNIGHTS MILL MICROARCHITECTURE\r\nThis chapter describes the instruction set that is unique to processors based on the Knights Mill microarchitecture.\r\n3.1 INSTRUCTION SET REFERENCE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/893fc78c-336e-4ca3-b218-d5e08c6ad417.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ce06ed1664eae5f608b8cef3c360a9240e5ded8de2e7fddf936cb3155148e2fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 423
      },
      {
        "segments": [
          {
            "segment_id": "f661d4b3-e176-4281-a3fe-d457f454d9b0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "3-2 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nV4FMADDPS/V4FNMADDPS — Packed Single-Precision Floating-Point Fused Multiply-Add \r\n(4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a \r\nsequentially selected memory operand in each of the four steps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest \r\nsignificant mask bits is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation \r\nportion of this instruction.\r\nRounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. \r\nPre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational excep\u0002tions of the second FMA, etc.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 9A /r\r\nV4FMADDPS zmm1{k1}{z}, zmm2+3, \r\nm128\r\nA V/V AVX512_4FMAPS Multiply packed single-precision floating-point \r\nvalues from source register block indicated by \r\nzmm2 by values from m128 and accumulate the \r\nresult in zmm1.\r\nEVEX.DDS.512.F2.0F38.W0 AA /r\r\nV4FNMADDPS zmm1{k1}{z}, \r\nzmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply and negate packed single-precision \r\nfloating-point values from source register block \r\nindicated by zmm2 by values from m128 and \r\naccumulate the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f661d4b3-e176-4281-a3fe-d457f454d9b0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b371d75844f2dea263f4342bd38f119ac08d4372dde705d7d78a6adacfcfb85a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a03b99e8-db4b-48fc-9ab8-b2de658fb5d4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 3-3\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\ndefine NFMA_PS(kl, vl, dest, k1, msrc, regs_loaded, src_base, posneg):\r\ntmpdest ← dest\r\n// reg[] is an array representing the SIMD register file.\r\nFOR j ← 0 to regs_loaded-1:\r\nFOR i ← 0 to kl-1:\r\nIF k1[i] or *no writemask*:\r\nIF posneg = 0:\r\ntmpdest.single[i] ← RoundFPControl_MXCSR(tmpdest.single[i] - reg[src_base + j ].single[i] * msrc.single[j])\r\nELSE:\r\ntmpdest.single[i] ← RoundFPControl_MXCSR(tmpdest.single[i] + reg[src_base + j ].single[i] * msrc.single[j])\r\nELSE IF *zeroing*:\r\ntmpdest.single[i] ← 0\r\ndest ← tmpdst\r\ndest[MAX_VL-1:VL] ← 0\r\nV4FMADDPS and V4FNMADDPS dest{k1}, src1, msrc (AVX512)\r\nKL, VL = (16,512)\r\nregs_loaded ← 4\r\nsrc_base ← src_reg_id & ~3 // for src1 operand\r\nposneg ← 0 if negative form, 1 otherwise\r\nNFMA_PS(kl, vl, dest, k1, msrc, regs_loaded, src_base, posneg)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nV4FMADDPS __m512 _mm512_4fmadd_ps( __m512, __m512x4, __m128 *);\r\nV4FMADDPS __m512 _mm512_mask_4fmadd_ps(__m512, __mmask16, __m512x4, __m128 *);\r\nV4FMADDPS __m512 _mm512_maskz_4fmadd_ps(__mmask16, __m512, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_4fnmadd_ps(__m512, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_mask_4fnmadd_ps(__m512, __mmask16, __m512x4, __m128 *);\r\nV4FNMADDPS __m512 _mm512_maskz_4fnmadd_ps(__mmask16, __m512, __m512x4, __m128 *);\r\nSIMD Floating-Point Exceptions\r\nOverflow, Underflow, Invalid, Precision, Denormal.\r\nOther Exceptions\r\nSee Type E2; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a03b99e8-db4b-48fc-9ab8-b2de658fb5d4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4129c0cda5fdcfc234b7fa0d4104698fae10e47e0a614b686b66e542b27116fd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 505
      },
      {
        "segments": [
          {
            "segment_id": "9d537449-aa84-4889-9be4-0dcb4046701a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "3-4 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nV4FMADDSS/V4FNMADDSS —Scalar Single-Precision Floating-Point Fused Multiply-Add \r\n(4-iterations) \r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a \r\nsequentially selected memory operand in each of the four steps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that \r\noperand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if the least significant \r\nmask bit is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation \r\nportion of this instruction.\r\nRounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computa\u0002tional exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, \r\netc.\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\ndefine NFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg):\r\ntmpdest ← dest\r\n// reg[] is an array representing the SIMD register file.\r\nIF k1[0] or *no writemask*:\r\nFOR j ← 0 to regs_loaded - 1:\r\nIF posneg = 0:\r\ntmpdest.single[0] ← RoundFPControl_MXCSR(tmpdest.single[0] - reg[src_base + j ].single[0] * msrc.single[j])\r\nELSE:\r\ntmpdest.single[0] ← RoundFPControl_MXCSR(tmpdest.single[0] + reg[src_base + j ].single[0] * msrc.single[j])\r\nELSE IF *zeroing*:\r\ntmpdest.single[0] ← 0\r\ndest ← tmpdst\r\ndest[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.LLIG.F2.0F38.W0 9B /r\r\nV4FMADDSS xmm1{k1}{z}, \r\nxmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply scalar single-precision floating-point \r\nvalues from source register block indicated by \r\nxmm2 by values from m128 and accumulate the \r\nresult in xmm1.\r\nEVEX.DDS.LLIG.F2.0F38.W0 AB /r\r\nV4FNMADDSS xmm1{k1}{z}, \r\nxmm2+3, m128\r\nA V/V AVX512_4FMAPS Multiply and negate scalar single-precision \r\nfloating-point values from source register block \r\nindicated by xmm2 by values from m128 and \r\naccumulate the result in xmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/9d537449-aa84-4889-9be4-0dcb4046701a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b81b4da1139dded9ac1891bd20015aafd118e052f71f07940bdb903074e8fe79",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "a8de2e86-051c-473d-af4b-b7f2cf9131e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 3-5\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nV4FMADDSS and V4FNMADDSS dest{k1}, src1, msrc (AVX512)\r\nVL = 128\r\nregs_loaded ← 4\r\nsrc_base ← src_reg_id & ~3 // for src1 operand\r\nposneg ← 0 if negative form, 1 otherwise\r\nNFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nV4FMADDSS __m128 _mm_4fmadd_ss(__m128, __m128x4, __m128 *);\r\nV4FMADDSS __m128 _mm_mask_4fmadd_ss(__m128, __mmask8, __m128x4, __m128 *);\r\nV4FMADDSS __m128 _mm_maskz_4fmadd_ss(__mmask8, __m128, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_4fnmadd_ss(__m128, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_mask_4fnmadd_ss(__m128, __mmask8, __m128x4, __m128 *);\r\nV4FNMADDSS __m128 _mm_maskz_4fnmadd_ss(__mmask8, __m128, __m128x4, __m128 *);\r\nSIMD Floating-Point Exceptions\r\nOverflow, Underflow, Invalid, Precision, Denormal.\r\nOther Exceptions\r\nSee Type E2; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/a8de2e86-051c-473d-af4b-b7f2cf9131e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=aa9bd1dc7dcf227c890fbf86dc8c8ac5639394cd559d4ce6ddf8fd04073895bb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 488
      },
      {
        "segments": [
          {
            "segment_id": "31cb050c-ed67-437b-bf99-7f98566b43be",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "3-6 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nVP4DPWSSDS — Dot Product of Signed Words with Dword Accumulation and Saturation \r\n(4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with \r\ndoubleword accumulation and signed saturation. The memory operand is sequentially selected in each of the four \r\nsteps.\r\nIn the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest \r\n16-bits of the mask is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation \r\nportion of this instruction.\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\nVP4DPWSSDS dest, src1, src2\r\n(KL,VL) = (16,512)\r\nN ← 4\r\nORIGDEST ← DEST\r\nsrc_base ← src_reg_id & ~ (N-1) // for src1 operand\r\nFOR i ← 0 to KL-1:\r\nIF k1[i] or *no writemask*:\r\nFOR m ← 0 to N-1:\r\nt ← SRC2.dword[m]\r\np1dword ← reg[src_base+m].word[2*i] * t.word[0]\r\np2dword ← reg[src_base+m].word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(DEST.dword[i] + p1dword + p2dword)\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 53 /r\r\nVP4DPWSSDS zmm1{k1}{z}, \r\nzmm2+3, m128\r\nA V/V AVX512_4VNNIW Multiply signed words from source register block \r\nindicated by zmm2 by signed words from m128 \r\nand accumulate the resulting dword results with \r\nsigned saturation in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/31cb050c-ed67-437b-bf99-7f98566b43be.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6c934b531ffded75412b1479875bb4406445f660ef1ced19e2fd64e1ab7c0c45",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f6de8d6e-f199-4283-93d0-798212f2c27c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 3-7\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVP4DPWSSDS __m512i _mm512_4dpwssds_epi32(__m512i, __m512ix4, __m128i *);\r\nVP4DPWSSDS __m512i _mm512_mask_4dpwssds_epi32(__m512i, __mmask16, __m512ix4, __m128i *);\r\nVP4DPWSSDS __m512i _mm512_maskz_4dpwssds_epi32(__mmask16, __m512i, __m512ix4, __m128i *);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f6de8d6e-f199-4283-93d0-798212f2c27c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ca80be9901bcefa8a3e8075db1a820c9ddeb01d921fce24219bb512bfaad1949",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 385
      },
      {
        "segments": [
          {
            "segment_id": "e9e6006c-37d8-476c-8480-9018c56b0245",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 122,
            "page_width": 612,
            "page_height": 792,
            "content": "3-8 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nVP4DPWSSD — Dot Product of Signed Words with Dword Accumulation (4-iterations)\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction computes 4 sequential register source-block dot-products of two signed word operands with \r\ndoubleword accumulation; see Figure 3-1 below. The memory operand is sequentially selected in each of the four \r\nsteps.\r\nIn the above box, the notation of “+3”' is used to denote that the instruction accesses 4 source registers based on \r\nthat operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.\r\nThis instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest \r\n16-bits of the mask is set to 1 or if a “no masking” encoding is used.\r\nThe tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation \r\nportion of this instruction.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.DDS.512.F2.0F38.W0 52 /r\r\nVP4DPWSSD zmm1{k1}{z}, zmm2+3, \r\nm128\r\nA V/V AVX512_4VNNIW Multiply signed words from source register block \r\nindicated by zmm2 by signed words from m128 \r\nand accumulate resulting signed dwords in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nFigure 3-1. Register Source-Block Dot Product of Two Signed Word Operands with Doubleword Accumulation1\r\nNOTES:\r\n1. For illustration purposes, one source-block dot product instance is shown out of\r\nthe four.\r\nb1 b0 b1 b0\r\nc1 c0\r\nc1=c1+a2*b0+a3*b1 c0=c0+a0*b0+a1*b1\r\na3 a2 a1 a0\r\n16b 16b 16b 16b\r\n32b 32b\r\n32b 32b",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/e9e6006c-37d8-476c-8480-9018c56b0245.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=761b00834bcc68cb3d716bde657300da29f92e1935e0151f64ce5ece54f30fb7",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "0f279a7b-0505-4533-be38-8bd9741c169a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 123,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 3-9\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE\r\nOperation\r\nsrc_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.\r\nVP4DPWSSD dest, src1, src2\r\n(KL,VL) = (16,512)\r\nN ← 4\r\nORIGDEST ← DEST\r\nsrc_base ← src_reg_id & ~ (N-1) // for src1 operand\r\nFOR i ← 0 to KL-1:\r\nIF k1[i] or *no writemask*:\r\nFOR m ← 0 to N-1:\r\nt ← SRC2.dword[m]\r\np1dword ← reg[src_base+m].word[2*i] * t.word[0]\r\np2dword ← reg[src_base+m].word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← DEST.dword[i] + p1dword + p2dword\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVP4DPWSSD __m512i _mm512_4dpwssd_epi32(__m512i, __m512ix4, __m128i *);\r\nVP4DPWSSD __m512i _mm512_mask_4dpwssd_epi32(__m512i, __mmask16, __m512ix4, __m128i *);\r\nVP4DPWSSD __m512i _mm512_maskz_4dpwssd_epi32(__mmask16, __m512i, __m512ix4, __m128i *);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4; additionally\r\n#UD If the EVEX broadcast bit is set to 1.\r\n#UD If the MODRM.mod = 0b11.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/0f279a7b-0505-4533-be38-8bd9741c169a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=baa7a416ad1288d43c6540aa15a35153513460f3b5d76b82f2563a82ed472077",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "28881ac8-ce43-4231-8cb2-3ca562aa0c6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 124,
            "page_width": 612,
            "page_height": 792,
            "content": "3-10 Ref. # 319433-032\r\nINSTRUCTION SET REFERENCE UNIQUE TO PROCESSORS BASED ON THE KNIGHTS MILL MICROARCHITECTURE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/28881ac8-ce43-4231-8cb2-3ca562aa0c6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=465c64ed00b1d7fe997f789b2e44453bbcae3f2d9459a5823ceb8b80f5d1ef29",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 446
      },
      {
        "segments": [
          {
            "segment_id": "dff99942-6a74-4f00-af58-a4d7bf4a5212",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 125,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 4-1\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\nCHAPTER 4\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.1 INTRODUCTION\r\nThis chapter describes an EPT-based sub-page permissions capability to allow Virtual Machine Monitors (VMM) to \r\nspecify write-permission for guest physical memory at a sub-page (128 byte) granularity. When this capability is \r\nutilized, the CPU establishes write-access permissions for sub-page regions of 4-KByte pages as specified by the \r\nVMM. EPT-based sub-page permissions is intended to enable fine-grained memory write enforcement by a VMM for \r\nsecurity (guest OS monitoring).\r\n4.2 VMCS CHANGES\r\nA new secondary processor-based VM-execution control is defined as “sub-page write permission”. The bit position \r\nof this control is 23.\r\nIf bit 31 of the primary processor-based VM-execution controls is 0, the logical processor operates as if the sub\u0002page write permission VM-execution control is 0. \r\nA new 64-bit control field is defined as “sub-page permission table pointer” (SPPTP). The encodings for this field \r\nare 00002030H (all 64 bits in 64-bit mode; low 32 bits in legacy mode) and 00002031H (high 32 bits).\r\n4.3 CHANGES TO EPT PAGING-STRUCTURE ENTRIES\r\nBit 61 of an EPT PTE is defined as a “Sub-Page Permission” (SPP bit). Setting this bit allows write permissions for \r\nthe mapped page to be enforced on a sub-page basis (see Section 6.4). The processor ignores this bit in all other \r\nEPT paging-structure entries (as it does if the “sub-page write permission” VM-execution control is 0).\r\n4.4 CHANGES TO GUEST-PHYSICAL ACCESSES\r\nIf the logical processor is in VMX non-root operation with EPT enabled, and if the sub-page write permission VM\u0002execution control (see Section 4.2) is 0, an EPT violation occurs if a memory store uses a guest-physical address \r\nand the write-access bit (bit 1) is clear in any of the EPT paging-structure entries used to translate the guest phys\u0002ical address. (This is same as legacy behavior.)\r\nIf the sub-page write permission VM-execution control is 1, treatment of write accesses to guest-physical accesses \r\ndepends on the state of the accumulated write-access bit (position 1) and sub-page permission bit (position 61) in \r\nthe leaf EPT paging-structure used to translate guest-physical addresses.\r\nIf EPT translates a guest-physical address using a 4-KByte page, the accumulated write-access bit is 0, and the SPP \r\nbit set to 1 in the EPT PTE, the processor uses the guest-physical address to select from a VMM-managed Sub-Page \r\nPermission Table (SPPT) a write permission bit for the 128-byte sub-page region being accessed within the 4-KByte \r\npage. If the sub-page region write permission bit is set, the write is allowed; otherwise the write is disallowed and \r\nresults in an EPT violation normally.\r\nIn other cases, the processor does not consult the SPPT. Guest-physical pages mapped via leaf EPT-paging-struc\u0002tures for which the accumulated write-access bit and the SPP bits are both clear (0) generate EPT violations on \r\nmemory writes accesses. Guest-physical pages mapped via EPT-paging-structure for which the accumulated write\u0002access bit is set (1) allow writes, effectively ignoring the SPP bit on the leaf EPT-paging structure.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/dff99942-6a74-4f00-af58-a4d7bf4a5212.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=33cef9aed5167d24c61cdb75533373e90b8c99f272d16143a0ed400f09833036",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 487
      },
      {
        "segments": [
          {
            "segment_id": "204e618d-c31a-4ddd-9159-8ff55817ffdf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 126,
            "page_width": 612,
            "page_height": 792,
            "content": "4-2 Ref. # 319433-032\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.5 SUB-PAGE PERMISSION TABLE\r\nThe sub-page permission table is referenced via a 64-bit control field called Sub-Page Permission Table Pointer \r\n(SPPTP) which contains a 4K-aligned physical address. The SPPT allows specification of write-permissions for 32 \r\n128 byte sub-page regions for 4KB guest-physical memory pages accessed via the EPT. The format of SPPTP is \r\nshown in Table 4-1 below.\r\nThe memory type used for SPPT accesses will be the memory type reported in IA32_VMX_BASIC MSR. \r\nWhen SPPT is in use, write accesses to any guest-physical addresses produced via a mapping for a 4KB page in the \r\nEPT can be controlled at a 128 byte granularity sub-page region within the 4KB guest-physical page. Note that \r\nreads and instruction fetches are not affected by the SPPT.\r\n4.5.1 SPPT Overview\r\nSPPT is active when the sub-page write permission VM-execution control is 1. SPPT looks up the guest-physical \r\naddresses to derive a 64 bit sub-page permission value containing sub-page region write permissions. The lookup \r\nfrom guest-physical addresses to the sub-page region permissions is determined by a set of SPPT paging struc\u0002tures. Section 4.5.2 gives the details of the SPPT structures.\r\nWhen the sub-page write permission VM-execution control is 1, the SPPT is used to look up write permission bits \r\nfor the 128 byte sub-page regions contained in the 4KB guest-physical page. EPT specifies the 4KB page-level priv\u0002ileges that software is allowed when accessing the guest-physical address, whereas SPPT defines the write permis\u0002sions for software at the 128 byte granularity regions within a 4KB page. Similar to EPT, a logical processor uses \r\nSPPT to look up sub-page region write permissions for guest-physical addresses only when those addresses are \r\nused to access memory.\r\n4.5.2 Operation of SPPT-based Write-Permission\r\nThe SPPT translation mechanism uses only bits 47:7 of a guest-physical address. The SPPT is a 4-level paging \r\nstructure. Four SPPT paging structures are accessed to look up a sub-page region write permission bit for a guest\u0002physical address. The 48 bits are partitioned by the logical processor to traverse the SPPT paging structures as \r\nfollows.\r\n— A 4KB naturally aligned SPPT L4 table is located at the physical address specified in bits 51:12 of the SPPTP. \r\nAn SPPT L4 table comprises 512 64-bit entries (SPPT L4Es). An SPPT L4E is selected at the physical address \r\ndefined as follows.\r\n• Bits 63:52 are all 0.\r\n• Bits 51:12 are from the SPPTP.\r\n• Bits 11:3 are bits 47:39 of the guest-physical address.\r\n• Bits 2:0 are all 0.\r\nThe format of a SPPT L4E is given in Table 4-2.\r\nTable 4-1. Format of SPPTP\r\nBit Position Contents\r\n11:0 Reserved.\r\nM-1:12 Bits M-1:12 of the physical address of the 4-KByte aligned SPPT L4 table.1\r\nNOTES:\r\n1. M is the physical-address width supported by the processor.\r\n63:M Reserved (must be 0).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/204e618d-c31a-4ddd-9159-8ff55817ffdf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bc3786572233049e99ff94a07016811ebcde2714b3d973f84c67a75ef77d62bc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "abc7a758-024c-4924-b381-bbfb8684a55a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 127,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 4-3\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n— A 4KB naturally aligned SPPT L3 table is located at the physical address specified in bits 51:12 of the SPPT \r\nL4E. An SPPT L3 table comprises 512 64-bit entries (SPPT L3Es). An SPPT L3E is selected at the physical \r\naddress defined as follows.\r\n• Bits 63:52 are all 0.\r\n• Bits 51:12 are from the SPPT L4E.\r\n• Bits 11:3 are bits 38:30 of the guest-physical address.\r\n• Bits 2:0 are all 0.\r\nThe format of the SPPT L3E is the same as that given in Table 4-2 for for SPPT L4Es. The SPPT L3E \r\nreferences a 4KB naturally aligned SPPT L2 Table.\r\n— A 4KB naturally aligned SPPT L2 table is located at the physical address specified in bits 51:12 of the SPPT \r\nL3E. An SPPT L2 table comprises 512 64-bit entries (SPPT L2Es). An SPPT L2E is selected at the physical \r\naddress defined as follows.\r\n• Bits 63:52 are all 0.\r\n• Bits 51:12 are from the SPPT L3E.\r\n• Bits 11:3 are bits 29:21 of the guest-physical address.\r\n• Bits 2:0 are all 0.\r\nThe format of a SPPT L2E is the same as that given in Table 4-2 for SPPT L4Es. The SPPT L2E references a \r\n4KB naturally aligned SPPT L1 Table.\r\n— A 4KB naturally aligned SPPT L1 table is located at the physical address specified in bits 51:12 of the SPPT \r\nL2E. An SPPT L1 table comprises 512 64-bit entries (SPPT L1Es). An SPPT L1E is selected at the physical \r\naddress defined as follows.\r\n• Bits 63:52 are all 0.\r\n• Bits 51:12 are from the SPPT L2E.\r\n• Bits 11:3 are bits 20:12 of the guest-physical address.\r\n• Bits 2:0 are all 0.\r\nThe processor then consults bit 2i of the SPPT L1E, where i is the value of bits 11:7 of the guest-physical \r\naddress; a write access to the guest-physical address is allowed if the bit is 1. (The odd bits in the SPPT L1E \r\nare reserved and must be 0.)\r\nTable 4-2. Format of the SPPT L4E\r\nBit Position Contents\r\n0 Valid entry when set; indicates whether the entry is present.\r\n11:1 Reserved (must be 0).\r\nM-1:12 Physical address of 4KB naturally aligned SPPT L3 table referenced by this entry.1\r\nNOTES:\r\n1. M is the physical-address width supported by the processor. Software can determine a processor's physical\u0002address width by executing CPUID with 80000008H in EAX. The physical-address width is returned in bits 7:0\r\nof EAX.\r\n63:M Reserved (must be 0).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/abc7a758-024c-4924-b381-bbfb8684a55a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e5df7c2628c7eaa974c3286843d6573b5336945b1f3f44079ecb388728aaf36a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 417
      },
      {
        "segments": [
          {
            "segment_id": "1a1da846-fa99-40b2-a81f-7b208b7daa00",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 128,
            "page_width": 612,
            "page_height": 792,
            "content": "4-4 Ref. # 319433-032\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.5.3 SPP-Induced VM Exits\r\nAccesses using guest-physical addresses may cause SPP-induced VM exits due to an SPPT misconfiguration or an \r\nSPPT miss. The basic VM exit reason reported for SPP-induced VM exits is 66.\r\nAn SPPT misconfiguration VM exit occurs when, in the course of an SPPT lookup, an SPPT paging-structure entry is \r\nencountered that sets a reserved bit. See Section 4.5.3.1 for which bits are reserved in SPPT paging-structure \r\nentries.\r\nAn SPPT miss VM exit occurs when, in the course of an SPPT lookup, an SPPT paging-structure entry is encountered \r\nin which the valid bit is clear.\r\nSPPT misconfigurations and SPPT misses can occur only due to an attempt to write memory with a guest-physical \r\naddress.\r\nSPP-induced VM exits save an exit qualification with the format given in Table 4-3. These VM exits also save a \r\nguest-linear address and a guest-physical address.\r\nGuest Linear Address: In addition to the existing cases for which this field is reported, for a VM exit due to an \r\nSPPT misconfiguration or SPPT miss, this field receives a linear address that caused the SPPT misconfiguration or \r\nSPPT miss VM exit.\r\nGuest Physical Address: In addition to the existing cases for which this field is reported, for a VM exit due to an \r\nSPPT misconfiguration or SPPT miss, this field receives the guest-physical address that caused the SPPT misconfig\u0002uration or SPPT miss VM exit.\r\n4.5.3.1 Sub-Page Permissions and EPT Violations\r\nMemory writes that consult but are not permitted by the SPPT cause EPT violations normally.\r\nFor memory writes that access memory across sub-page regions on the same 4K page, the processor will check \r\nwriteability of both sub-pages and will generate an EPT violation if either of the accessed sub-page regions is not \r\nwriteable.\r\nFor memory writes that access adjoining 4-KByte pages, the processor may ignores the SPP bit in either of the EPT \r\nPTEs that map those pages (operating as if it were 0).\r\nSub-page write permissions are intended principally for simple instructions (such as AND, MOV, OR, TEST, XCHG, \r\nINC, XOR, etc.). Execution of an instruction that normally performs multiple memory-writes may or may not ignore \r\nthe sub-page permissions and cause EPT violations unconditionally if an accessed page is mapped with an EPT PTE \r\nin which the W bit is 0.\r\nAccesses to any guest-physical address that translates to an address on the APIC-access page that also is specified \r\nby the VMM to have sub-page permissions associated with it may operate as if the virtualize APIC accesses VM\u0002execution control is 0.\r\nProcessor writes to guest paging structures (to set accessed and dirty flags) ignore sub-page permissions and \r\nalways cause EPT violations when attempting to write to guest-physical addresses to which EPT does not allow \r\nwrites. The same is true for processor reads of guest paging structures (during linear-address translation) if \r\naccessed and dirty flags for EPT are enabled. (This is because, when accessed and dirty flags for EPT are enabled, \r\nprocessor reads of guest paging structures are treated as writes).\r\nTable 4-3. Exit Qualification for SPPT-Induced VM Exits\r\nBit Position Contents\r\n10:0 Not used.\r\n11 SPPT VM exit type. Set for SPPT miss; cleared for SPPT misconfiguration VM exit.\r\n12 NMI unblocking due to IRET.\r\n63:13 Not used.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1a1da846-fa99-40b2-a81f-7b208b7daa00.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fd6e28cbb4963bdfa1f700d28c6b3af11417e05f178cc8d5dcbeeba7e55e01b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 541
      },
      {
        "segments": [
          {
            "segment_id": "1a1da846-fa99-40b2-a81f-7b208b7daa00",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 128,
            "page_width": 612,
            "page_height": 792,
            "content": "4-4 Ref. # 319433-032\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.5.3 SPP-Induced VM Exits\r\nAccesses using guest-physical addresses may cause SPP-induced VM exits due to an SPPT misconfiguration or an \r\nSPPT miss. The basic VM exit reason reported for SPP-induced VM exits is 66.\r\nAn SPPT misconfiguration VM exit occurs when, in the course of an SPPT lookup, an SPPT paging-structure entry is \r\nencountered that sets a reserved bit. See Section 4.5.3.1 for which bits are reserved in SPPT paging-structure \r\nentries.\r\nAn SPPT miss VM exit occurs when, in the course of an SPPT lookup, an SPPT paging-structure entry is encountered \r\nin which the valid bit is clear.\r\nSPPT misconfigurations and SPPT misses can occur only due to an attempt to write memory with a guest-physical \r\naddress.\r\nSPP-induced VM exits save an exit qualification with the format given in Table 4-3. These VM exits also save a \r\nguest-linear address and a guest-physical address.\r\nGuest Linear Address: In addition to the existing cases for which this field is reported, for a VM exit due to an \r\nSPPT misconfiguration or SPPT miss, this field receives a linear address that caused the SPPT misconfiguration or \r\nSPPT miss VM exit.\r\nGuest Physical Address: In addition to the existing cases for which this field is reported, for a VM exit due to an \r\nSPPT misconfiguration or SPPT miss, this field receives the guest-physical address that caused the SPPT misconfig\u0002uration or SPPT miss VM exit.\r\n4.5.3.1 Sub-Page Permissions and EPT Violations\r\nMemory writes that consult but are not permitted by the SPPT cause EPT violations normally.\r\nFor memory writes that access memory across sub-page regions on the same 4K page, the processor will check \r\nwriteability of both sub-pages and will generate an EPT violation if either of the accessed sub-page regions is not \r\nwriteable.\r\nFor memory writes that access adjoining 4-KByte pages, the processor may ignores the SPP bit in either of the EPT \r\nPTEs that map those pages (operating as if it were 0).\r\nSub-page write permissions are intended principally for simple instructions (such as AND, MOV, OR, TEST, XCHG, \r\nINC, XOR, etc.). Execution of an instruction that normally performs multiple memory-writes may or may not ignore \r\nthe sub-page permissions and cause EPT violations unconditionally if an accessed page is mapped with an EPT PTE \r\nin which the W bit is 0.\r\nAccesses to any guest-physical address that translates to an address on the APIC-access page that also is specified \r\nby the VMM to have sub-page permissions associated with it may operate as if the virtualize APIC accesses VM\u0002execution control is 0.\r\nProcessor writes to guest paging structures (to set accessed and dirty flags) ignore sub-page permissions and \r\nalways cause EPT violations when attempting to write to guest-physical addresses to which EPT does not allow \r\nwrites. The same is true for processor reads of guest paging structures (during linear-address translation) if \r\naccessed and dirty flags for EPT are enabled. (This is because, when accessed and dirty flags for EPT are enabled, \r\nprocessor reads of guest paging structures are treated as writes).\r\nTable 4-3. Exit Qualification for SPPT-Induced VM Exits\r\nBit Position Contents\r\n10:0 Not used.\r\n11 SPPT VM exit type. Set for SPPT miss; cleared for SPPT misconfiguration VM exit.\r\n12 NMI unblocking due to IRET.\r\n63:13 Not used.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/1a1da846-fa99-40b2-a81f-7b208b7daa00.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fd6e28cbb4963bdfa1f700d28c6b3af11417e05f178cc8d5dcbeeba7e55e01b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 541
      },
      {
        "segments": [
          {
            "segment_id": "271d705d-480a-4ce3-a6af-76e294f0713a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 129,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 4-5\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.5.4 Invalidating Cached SPP Permissions\r\nSub-page permissions may be cached by the CPU. Any modification to the sub-page permissions specified in SPPT \r\nentries must be invalidated using INVEPT. The EPTP switching VM function may flush any information cached about \r\nsub-page permissions, as well as intermediate EPT and SPPT caches.\r\n4.5.5 Sub-Page Permission Interaction with Intel® TSX\r\nInstructions that begin or execute within a transactional region may attempt to write to guest-physical addresses \r\nto which EPT does not allow writes. Such cases result in transactional aborts.\r\nThis behavior is retained even with sub-page permissions. A write by an instruction that begins or executes within \r\na transactional region ignores sub-page permissions and causes a transactional abort if EPT does not allow writes \r\nto the guest-physical address.\r\n4.5.6 Sub-Page Permission Interaction with Intel® SGX\r\nA VMM cannot access memory in the enclave page cache (EPC) and cannot easily determine how to protect those \r\npages selectively with SPP.\r\nThe checking of sub-page permissions takes priority over EPC-specific access control. Memory writes by an enclave \r\nto addresses within the enclave's ELRANGE ignore sub-page permissions and will cause EPT violations when made \r\nto guest-physical addresses to which EPT does not allow writes. The same is true for writes to the EPC by SGX \r\ninstructions. Memory writes by an enclaves to addresses outside its ELRANGE are treated normally and may be \r\nallowed based on sub-page permissions.\r\nThe fault behavior summarized in Table 4-4 below.\r\nTable 4-4. Fault Behavior Summary\r\nID Enclave Access APIC Access In EPC EPTE.W EPTE.SPP Comments\r\n1 0 0 NA X X See notes1.\r\nNOTES:\r\n1. Fault behavior as per SPP architecture described in this chapter.\r\n2 0 1 NA X 0 See notes2.\r\n2. Fault behavior as per the APIC virtualization architecture.\r\n3 0 1 NA 1 1 See notes3.\r\n3. (SPP is ignored since EPT is writeable)\r\n If violation of EPT permissions then EPT violation\r\n Else If Implementation_supports_vAPIC_AND_SPP_Together\r\n Then APIC redirection or exit\r\n Else Access Allowed\r\n4 0 1 NA 0 1 See notes4.\r\n4. If violation of EPT permissions then EPT violation exit\r\nElse If Implementation_supports_vAPIC_AND_SPP_Together\r\n If write access then EPT violation\r\n Else APIC redirection or exit\r\nElse If write access - fault behavior per SPP architecture in this specification\r\n Else If read/execute access - access allowed\r\n5 1 X X X 0 See notes5.\r\n6 1 X X X 1 See notes6.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/271d705d-480a-4ce3-a6af-76e294f0713a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8d5fbf8622d8f09fd23c3cdccef073b908c10dc500e2bff4e75db0806e7ddf23",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 399
      },
      {
        "segments": [
          {
            "segment_id": "d7482807-6109-4a2d-bb6a-eda5c8c40e3d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 130,
            "page_width": 612,
            "page_height": 792,
            "content": "4-6 Ref. # 319433-032\r\nEPT-BASED SUB-PAGE PERMISSIONS\r\n4.5.7 Memory Type Used for Accessing SPPT\r\nThe memory type used for any such reference will be the memory type reported in IA32_VMX_BASIC MSR. Bits \r\n53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data \r\nstructures referenced by pointers in the VMCS. Software should ensure that the VMCS and referenced data struc\u0002tures are located at physical addresses that are mapped to WB memory type by the MTRRs.\r\n4.6 CHANGES TO VM ENTRIES\r\nIf the activate secondary controls and sub-page write permission VM-execution controls are both 1, VM entries \r\nensure that the enable EPT VM-execution control is 1. Additionally, the sub-page permission table control field is \r\nchecked for consistency per Section 4.5. VM entry fails if these checks fail. When such a failure occurs, control is \r\npassed to the next instruction, RFLAGS.ZF is set to 1 to indicate the failure, and the VM-instruction error field is \r\nloaded with value 7, indicating “VM entry with invalid control field(s)”. This check may be performed in any order \r\nwith respect to other checks on VMX controls and the host-state area. Different processors may thus give different \r\nerror numbers for the same VMCS.\r\n4.7 CHANGES TO VMX CAPABILITY REPORTING\r\nSection 4.2 specified that secondary processor-based VM-execution control 23 is defined as “sub-page write \r\npermission”. A processor that supports the 1-setting of the control sets bit 55 of the \r\nIA32_VMX_PROCBASED_CTLS2 MSR (index 48BH). RDMSR of that MSR returns 1 in bit 23 of EDX.\r\n5. If violation of EPT permissions then EPT violation\r\n Else If PA not in EPC then #PF\r\n Else If PA matches APIC access page then #PF\r\n Else If violation of EPCM permissions then #PF\r\n Else Access Allowed\r\n6. If violation of EPT permissions – EPT violation\r\n Else EPT violation (SPP on enclave access)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/d7482807-6109-4a2d-bb6a-eda5c8c40e3d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7255c29bd79c8f00cff18922bff1e5d5bd2e066864f9a06655ea49449c964a59",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 307
      },
      {
        "segments": [
          {
            "segment_id": "f6dcd9ef-df37-4204-8eaf-11079848c0ff",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 131,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 5-1\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\nCHAPTER 5\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.1 INTRODUCTION\r\nIntel® Processor Trace (Intel® PT) is an extension of Intel® Architecture that captures information about software \r\nexecution using dedicated hardware facilities that cause only minimal performance perturbation to the software \r\nbeing traced. Details on the Intel PT infrastructure and trace capabilities can be found in the Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual, Volume 3C.\r\nThis chapter describes the architecture for VMX support improvements made for Intel PT. The suite of architecture \r\nchanges described below serve to simplify the process of virtualizing Intel PT for use by a guest software. There are \r\ntwo primary elements to this new architecture support.\r\n1. Addition of a new guest IA32_RTIT_CTL value field to the VMCS. — This serves to speed and simplify \r\nthe process of disabling trace on VM exit, and restoring it on VM entry.\r\n2. Enabling use of EPT to redirect PT output. — This enables the VMM to elect to virtualize the PT output \r\nbuffer using EPT. In this mode, the CPU will treat PT output addresses as Guest Physical Addresses (GPAs) \r\nand translate them using EPT. This means that output reads (of the ToPA table), output writes (of trace out\u0002put), and other output events can cause EPT violations.\r\n5.2 ARCHITECTURE DETAILS\r\n5.2.1 IA32_RTIT_CTL in VMCS Guest State\r\nA new 64-bit field will be added to the VMCS Guest State, to hold the value of IA32_RTIT_CTL. This field will use \r\nencodings 2814H and 2815H. On VM exit, the MSR value will be written to this field unconditionally. Additionally, \r\nthere are two new controls to govern use of this field; see Table 5-1 below.\r\n5.2.2 Supporting EPT for Trace Output\r\nIn order to enable use of EPT to redirect PT trace output, a new secondary processor-based VM-execution control \r\nis added; see Table 5-2 below.\r\nTable 5-1. VMCS Controls for IA32_RTIT_CTL MSR\r\nName Position Description\r\nClear IA32_RTIT_CTL on exit. Exit control 25. When set, the IA32_RTIT_CTL MSR will be cleared on VM exit, after it has \r\nbeen saved. This disables PT before entering the VMX host.\r\nLoad IA32_RTIT_CTL on entry. Entry control 18. When set, the IA32_RTIT_CTL MSR will be written with the value of the \r\nassociated Guest State field of the VMCS on VM entry. This restores PT \r\nbefore entering the guest.\r\nVM entry fails if the value to be loaded sets reserved bits or a reserved \r\nvalues in an encoded field.\r\nTable 5-2. VMCS Control for Intel PT Output to Guest Physical Addresses\r\nName Position Description\r\nGuest PT uses Guest Physical \r\nAddresses.\r\nExecution control 24. When set, all PT output addresses, including those in the \r\nIA32_RTIT_OUTPUT_BASE MSR and in ToPA tables, will be treated as guest \r\nphysical addresses (GPAs) and translated with EPT.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f6dcd9ef-df37-4204-8eaf-11079848c0ff.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5acb2e9a6639fbf3823e68664ffe1260d81d54292d2038a8a823af69d5e90e29",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 462
      },
      {
        "segments": [
          {
            "segment_id": "12e8f62c-e070-449f-8c12-5f9dd909a9d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 132,
            "page_width": 612,
            "page_height": 792,
            "content": "5-2 Ref. # 319433-032\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\nSetting this new VM-execution control to 1 requires also setting the VM-exit and VM-entry controls described above \r\nin Table 5-1. This ensures that PT is disabled before entering root operation, where EPT does not apply. See details \r\non new consistency checks in Section 5.2.3.\r\n5.2.2.1 VM Exits Due to Intel PT Output\r\nTreating PT output addresses as guest-physical addresses introduces the possibility of taking events on PT output \r\nreads and writes. Event possibilities include EPT violations, EPT misconfigurations, PML log-full VM exits, and APIC \r\naccess VM exits.\r\nExit Qualification\r\nIntel PT output reads and writes are asynchronous to instruction execution, as a result of the internal buffering of \r\ntrace data. Trace packets are output some unpredictable number of cycles after the completion of the instructions \r\nor events that generated them. For this reason, any VM exit caused by Intel PT output will set the following new exit \r\nqualification bit.\r\nThere is no guest linear address relevant for EPT violations resulting from Intel PT output reads and writes. For this \r\nreason, these VM exits clear bit 7 of the exit qualification, which is set only if the guest linear-address is valid.\r\nPreserving Pending Events\r\nA VM entry that enables Intel PT can cause an immediate VM exit, if PT output is configured to use GPA addressing \r\nand the access to the page causes a VM exit (e.g., EPT violation). This VM exit will be taken after the completion of \r\nthe VM entry, but before other events which may be pending or injected by the VM entry. To ensure that no events \r\nare lost, VM exits caused by PT output will take the following measures.\r\n• The guest pending debug exceptions field in the VMCS is not cleared, and the value saved will match the \r\nbehavior of existing VM exits (e.g., INIT) that do not clear the field.\r\n• The VMCS VM-entry interrupt information field is saved to the VMCS IDT-vectoring information field. \r\nThis serves to simplify the process of re-injecting the event on the next VM entry. Note that this \r\nintroduces a scenario where Pending MTF VM exit can be set in the IDT-vectoring information field.\r\nAdditional VM Exits\r\nEPT violations caused by Intel PT output will always cause VM exits; virtualization exceptions (#VEs) are not \r\nsupported.\r\nIntel PT output accesses to the APIC-access page cause VM exits unconditionally, with no virtualization by the \r\nprocessor. This is consistent with other guest-physical accesses to the APIC-access page.\r\nIf the “Guest PT uses Guest Physical Addresses” VM-execution control is 1 and IA32_RTIT_CTL.TraceEn = 1, any \r\ninvocation of the VM function 0 (EPTP switching) causes a VM exit. The VM exit gives a VMM the opportunity to \r\ndisable tracing (if desired for certain EPT contexts) and ensures that the processor does not retain a PT-specific \r\nEPT-based translation across a change of EPTP. Reporting is the same as any VM exit caused by a VM function, \r\nsetting the basic exit reason to 59 (indicating “VMFUNC”) and saving the length of the VMFUNC instruction into the \r\nVM-exit instruction-length field.\r\nTable 5-3. New Asynchronous Exit Qualification Bit\r\nName Position Description\r\nAsynchronous to Instruction \r\nExecution.\r\nExit qualification bit \r\n16 for EPT \r\nviolations, PML log\u0002full VM exits, and \r\nAPIC-access VM \r\nexits due to guest\u0002physical accesses.\r\nThis VM exit results neither from the instruction referenced by the RIP \r\nsaved into the VMCS, nor from any event delivery recorded in the VMCS \r\nIDT-vectoring fields.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/12e8f62c-e070-449f-8c12-5f9dd909a9d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7c4001de1ad1d5c28648dcc2023cecc60fb5db39abe065e80883c569162ddb39",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 572
      },
      {
        "segments": [
          {
            "segment_id": "12e8f62c-e070-449f-8c12-5f9dd909a9d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 132,
            "page_width": 612,
            "page_height": 792,
            "content": "5-2 Ref. # 319433-032\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\nSetting this new VM-execution control to 1 requires also setting the VM-exit and VM-entry controls described above \r\nin Table 5-1. This ensures that PT is disabled before entering root operation, where EPT does not apply. See details \r\non new consistency checks in Section 5.2.3.\r\n5.2.2.1 VM Exits Due to Intel PT Output\r\nTreating PT output addresses as guest-physical addresses introduces the possibility of taking events on PT output \r\nreads and writes. Event possibilities include EPT violations, EPT misconfigurations, PML log-full VM exits, and APIC \r\naccess VM exits.\r\nExit Qualification\r\nIntel PT output reads and writes are asynchronous to instruction execution, as a result of the internal buffering of \r\ntrace data. Trace packets are output some unpredictable number of cycles after the completion of the instructions \r\nor events that generated them. For this reason, any VM exit caused by Intel PT output will set the following new exit \r\nqualification bit.\r\nThere is no guest linear address relevant for EPT violations resulting from Intel PT output reads and writes. For this \r\nreason, these VM exits clear bit 7 of the exit qualification, which is set only if the guest linear-address is valid.\r\nPreserving Pending Events\r\nA VM entry that enables Intel PT can cause an immediate VM exit, if PT output is configured to use GPA addressing \r\nand the access to the page causes a VM exit (e.g., EPT violation). This VM exit will be taken after the completion of \r\nthe VM entry, but before other events which may be pending or injected by the VM entry. To ensure that no events \r\nare lost, VM exits caused by PT output will take the following measures.\r\n• The guest pending debug exceptions field in the VMCS is not cleared, and the value saved will match the \r\nbehavior of existing VM exits (e.g., INIT) that do not clear the field.\r\n• The VMCS VM-entry interrupt information field is saved to the VMCS IDT-vectoring information field. \r\nThis serves to simplify the process of re-injecting the event on the next VM entry. Note that this \r\nintroduces a scenario where Pending MTF VM exit can be set in the IDT-vectoring information field.\r\nAdditional VM Exits\r\nEPT violations caused by Intel PT output will always cause VM exits; virtualization exceptions (#VEs) are not \r\nsupported.\r\nIntel PT output accesses to the APIC-access page cause VM exits unconditionally, with no virtualization by the \r\nprocessor. This is consistent with other guest-physical accesses to the APIC-access page.\r\nIf the “Guest PT uses Guest Physical Addresses” VM-execution control is 1 and IA32_RTIT_CTL.TraceEn = 1, any \r\ninvocation of the VM function 0 (EPTP switching) causes a VM exit. The VM exit gives a VMM the opportunity to \r\ndisable tracing (if desired for certain EPT contexts) and ensures that the processor does not retain a PT-specific \r\nEPT-based translation across a change of EPTP. Reporting is the same as any VM exit caused by a VM function, \r\nsetting the basic exit reason to 59 (indicating “VMFUNC”) and saving the length of the VMFUNC instruction into the \r\nVM-exit instruction-length field.\r\nTable 5-3. New Asynchronous Exit Qualification Bit\r\nName Position Description\r\nAsynchronous to Instruction \r\nExecution.\r\nExit qualification bit \r\n16 for EPT \r\nviolations, PML log\u0002full VM exits, and \r\nAPIC-access VM \r\nexits due to guest\u0002physical accesses.\r\nThis VM exit results neither from the instruction referenced by the RIP \r\nsaved into the VMCS, nor from any event delivery recorded in the VMCS \r\nIDT-vectoring fields.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/12e8f62c-e070-449f-8c12-5f9dd909a9d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7c4001de1ad1d5c28648dcc2023cecc60fb5db39abe065e80883c569162ddb39",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 572
      },
      {
        "segments": [
          {
            "segment_id": "f26d2428-7d78-458b-944f-d4e30a808307",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 133,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 5-3\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.2.2.2 Trace Data Management with Output Events\r\nBecause PT packet data is buffered within the CPU before being written out through the memory subsystem or \r\nother trace transport mechanism, the CPU takes measures to ensure that buffered trace data is not lost on the PT \r\ndisable during VM exit. This requires ensuring that there is sufficient space left in the current output page to write \r\nout the buffer. Without such care, buffered trace data could be lost, and the resulting trace corrupted.\r\nThe CPU will employ an early page lookup mechanism in order to avoid trace corruption. It will try to cache the \r\nphysical addresses (PAs) of the current PT output block and the next PT output block, in order to ensure no event \r\nis needed when transitioning from the current block to the next. An output block is defined as the smaller of the EPT \r\npage and the PT output buffer segment, which is either a ToPA output region or the single-range output buffer. \r\nUsing this scheme, the CPU will always lookup the translation for the next block when it begins writing the current \r\nblock, so that any events needed in order to translate the next block base address can be taken long before writes \r\nto that next block commence.\r\nWhen PT is enabled, the CPU will lookup the first 2 output block translations, and cache the resulting PAs internally. \r\nPT enable flows include WRMSR (as well as loads from the MSR-load areas by VMX transitions), XRSTORS, VM \r\nentry, and RSM.\r\nIf either EPT lookup requires a VM exit, the exit will be taken before tracing begins. However, the value of \r\nIA32_RTIT_CTL saved into the new VMCS field will have the new value, with TraceEn set. This ensures that the \r\nsubsequent VM entry will try again to enable PT.\r\nThese VM exits resulting from the use of Intel PT are taken after the completion of the current instruction or oper\u0002ation. On VM entry, any Intel PT-induced VM exit will be taken after transition to the guest completes, but before \r\nany event injection or guest instructions execute.\r\nOnce the PAs for the first two output blocks are cached (this could require multiple events, and hence multiple VM \r\nexits/VM entries), tracing will commence. Henceforth, anytime an output block is filled with trace data, output will \r\ntransition to the next (cached) output block, and the CPU will lookup the EPT translation for the output block that \r\nfollows the new current block. Here again, an event may need to be taken, which would result in a VM exit. If the \r\nlookup encounters a ToPA entry with the STOP bit set, it will cease to lookup further entries beyond that entry.\r\nThis early page lookup mechanism serves to reduce the likelihood that the trace could fill all available, translated \r\noutput blocks. The CPU should typically have the current and next block cached and ready for output. In cases \r\nwhere trace data nonetheless has to be dropped, which could happen if an EPT violation VM exit for the next page \r\ntranslation is not taken for an extended period of time, the CPU will signal an internal buffer overflow and drop \r\npackets until the new translation can be cached.\r\n5.2.2.3 Intel PT Output Errors\r\nImproper configuration of Intel PT output can result in operation errors that cause tracing to be disabled. See the \r\nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 35.3.9, “Operational Errors” \r\nfor details.\r\nWhen Intel PT output is redirected using EPT, all address-based checks continue to be executed using the guest \r\nphysical address specified in the ToPA table or MSR, with one exception. Checks against restricted memory (see the \r\nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 35.2.6.4, “Restricted Memory \r\nAccess” for details) are done using the translated, platform physical address to which output will be written.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f26d2428-7d78-458b-944f-d4e30a808307.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eb27f7d4e67183058daaa5a1e043b9bafefeb7135e8ec341657f3b30b6eb07ee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 649
      },
      {
        "segments": [
          {
            "segment_id": "f26d2428-7d78-458b-944f-d4e30a808307",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 133,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 5-3\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.2.2.2 Trace Data Management with Output Events\r\nBecause PT packet data is buffered within the CPU before being written out through the memory subsystem or \r\nother trace transport mechanism, the CPU takes measures to ensure that buffered trace data is not lost on the PT \r\ndisable during VM exit. This requires ensuring that there is sufficient space left in the current output page to write \r\nout the buffer. Without such care, buffered trace data could be lost, and the resulting trace corrupted.\r\nThe CPU will employ an early page lookup mechanism in order to avoid trace corruption. It will try to cache the \r\nphysical addresses (PAs) of the current PT output block and the next PT output block, in order to ensure no event \r\nis needed when transitioning from the current block to the next. An output block is defined as the smaller of the EPT \r\npage and the PT output buffer segment, which is either a ToPA output region or the single-range output buffer. \r\nUsing this scheme, the CPU will always lookup the translation for the next block when it begins writing the current \r\nblock, so that any events needed in order to translate the next block base address can be taken long before writes \r\nto that next block commence.\r\nWhen PT is enabled, the CPU will lookup the first 2 output block translations, and cache the resulting PAs internally. \r\nPT enable flows include WRMSR (as well as loads from the MSR-load areas by VMX transitions), XRSTORS, VM \r\nentry, and RSM.\r\nIf either EPT lookup requires a VM exit, the exit will be taken before tracing begins. However, the value of \r\nIA32_RTIT_CTL saved into the new VMCS field will have the new value, with TraceEn set. This ensures that the \r\nsubsequent VM entry will try again to enable PT.\r\nThese VM exits resulting from the use of Intel PT are taken after the completion of the current instruction or oper\u0002ation. On VM entry, any Intel PT-induced VM exit will be taken after transition to the guest completes, but before \r\nany event injection or guest instructions execute.\r\nOnce the PAs for the first two output blocks are cached (this could require multiple events, and hence multiple VM \r\nexits/VM entries), tracing will commence. Henceforth, anytime an output block is filled with trace data, output will \r\ntransition to the next (cached) output block, and the CPU will lookup the EPT translation for the output block that \r\nfollows the new current block. Here again, an event may need to be taken, which would result in a VM exit. If the \r\nlookup encounters a ToPA entry with the STOP bit set, it will cease to lookup further entries beyond that entry.\r\nThis early page lookup mechanism serves to reduce the likelihood that the trace could fill all available, translated \r\noutput blocks. The CPU should typically have the current and next block cached and ready for output. In cases \r\nwhere trace data nonetheless has to be dropped, which could happen if an EPT violation VM exit for the next page \r\ntranslation is not taken for an extended period of time, the CPU will signal an internal buffer overflow and drop \r\npackets until the new translation can be cached.\r\n5.2.2.3 Intel PT Output Errors\r\nImproper configuration of Intel PT output can result in operation errors that cause tracing to be disabled. See the \r\nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 35.3.9, “Operational Errors” \r\nfor details.\r\nWhen Intel PT output is redirected using EPT, all address-based checks continue to be executed using the guest \r\nphysical address specified in the ToPA table or MSR, with one exception. Checks against restricted memory (see the \r\nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 35.2.6.4, “Restricted Memory \r\nAccess” for details) are done using the translated, platform physical address to which output will be written.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f26d2428-7d78-458b-944f-d4e30a808307.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=eb27f7d4e67183058daaa5a1e043b9bafefeb7135e8ec341657f3b30b6eb07ee",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 649
      },
      {
        "segments": [
          {
            "segment_id": "5cfe22b0-b38a-45ba-acbc-306ee0f81ebb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 134,
            "page_width": 612,
            "page_height": 792,
            "content": "5-4 Ref. # 319433-032\r\nINTEL® PROCESSOR TRACE: VMX IMPROVEMENTS\r\n5.2.3 New VM-Entry Consistency Checks\r\nThe following consistency checks will cause the VM entry to fall through to the next sequential instruction, and \r\nRFLAGS.ZF to be set, if failed.\r\n• If the “Guest PT uses Guest Physical Addresses” execution control is 1, the “Clear IA32_RTIT_CTL on \r\nexit” exit control and the “Load IA32_RTIT_CTL on entry” entry control must also be 1. This ensures \r\nthat the processor will not switch from treating Intel PT output addresses as GPAs to treating them as \r\nPPAs.\r\n• If the “Guest PT uses Guest Physical Addresses” execution control is 1, the \"enable EPT\" execution \r\ncontrol must also be 1.\r\nIf the following consistency check fails, VM entry fails by loading processor state from the guest-state area of the \r\nVMCS.\r\n• If the “Load IA32_RTIT_CTL on entry” is 1, IA32_RTIT_CTL.TraceEn must be zero.\r\nThe lower 16 bits of the exit reason VMCS field will hold value 33, indicating failure due to invalid guest state.\r\n5.2.3.1 Special Treatment for SMM VM Exits\r\nThe consistency checks above do not ensure that an SMM VM exit that occurs with the 1-setting of the “Guest PT \r\nuses Guest Physical Addresses” VM-execution control will find the “Clear IA32_RTIT_CTL on exit” VM-exit control \r\nset to 1. For this reason, such VM exits always clear the IA32_RTIT_CTL MSR, regardless of the setting of the VM\u0002exit control.\r\n5.3 ENUMERATION\r\nSection 5.2 identified three new controls in the VMCS. The following paragraphs provide details of how processors \r\nenumerate for support of those controls:\r\n• “Guest PT uses Guest Physical Addresses” is a new secondary processor-based VM-execution control, located \r\nat bit position 24. Processors supporting the 1-setting of this control enumerate that support by setting bit 56 \r\nof the IA32_VMX_PROCBASED_CTLS2 MSR (index 48BH).\r\n• “Clear IA32_RTIT_CTL on exit” is a new VM-exit control, located at bit position 25. Processors supporting the 1-\r\nsettings of this control enumerate that support by setting bit 57 in both the IA32_VMX_EXIT_CTLS MSR (index \r\n483H) and the IA32_VMX_TRUE_EXIT_CTLS MSR (index 48FH).\r\n• “Load IA32_RTIT_CTL on entry” is a new VM-entry control, located at bit position 18. Processors supporting the \r\n1-settings of this control enumerate that support by setting bit 50 in both the IA32_VMX_ENTRY_CTLS MSR \r\n(index 484H) and the IA32_VMX_TRUE_ENTRY_CTLS MSR (index 490H).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/5cfe22b0-b38a-45ba-acbc-306ee0f81ebb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3389f6baab8365e7ab6304df9cc2584be4faf041f790bbfb039ac9ec2ba668a9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 381
      },
      {
        "segments": [
          {
            "segment_id": "cd22cfe3-82b7-428a-9333-38ecd97a1243",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 135,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 I\r\nINDEX\r\nB\r\nBrand information 1-34\r\nprocessor brand index 1-36\r\nprocessor brand string 1-34\r\nC\r\nCache and TLB information 1-29\r\nCache Inclusiveness 1-9\r\nCLFLUSH instruction\r\nCPUID flag 1-28\r\nCMOVcc flag 1-28\r\nCMOVcc instructions\r\nCPUID flag 1-28\r\nCMPXCHG16B instruction\r\nCPUID bit 1-26\r\nCMPXCHG8B instruction\r\nCPUID flag 1-28\r\nCPUID instruction 1-7, 1-28\r\n36-bit page size extension 1-28\r\nAPIC on-chip 1-28\r\nbasic CPUID information 1-8\r\ncache and TLB characteristics 1-8, 1-29\r\nCLFLUSH flag 1-28\r\nCLFLUSH instruction cache line size 1-24\r\nCMPXCHG16B flag 1-26\r\nCMPXCHG8B flag 1-28\r\nCPL qualified debug store 1-25\r\ndebug extensions, CR4.DE 1-27\r\ndebug store supported 1-28\r\ndeterministic cache parameters leaf 1-8, 1-10, 1-12, 1-13, 1-14, 1-15, 1-16, 1-17\r\nextended function information 1-20\r\nfeature information 1-27\r\nFPU on-chip 1-27\r\nFSAVE flag 1-28\r\nFXRSTOR flag 1-28\r\nIA-32e mode available 1-21\r\ninput limits for EAX 1-22\r\nL1 Context ID 1-26\r\nlocal APIC physical ID 1-24\r\nmachine check architecture 1-28\r\nmachine check exception 1-28\r\nmemory type range registers 1-28\r\nMONITOR feature information 1-32\r\nMONITOR/MWAIT flag 1-25\r\nMONITOR/MWAIT leaf 1-9, 1-10, 1-11, 1-12, 1-13, 1-18\r\nMWAIT feature information 1-32\r\npage attribute table 1-28\r\npage size extension 1-27\r\nperformance monitoring features 1-32\r\nphysical address bits 1-22\r\nphysical address extension 1-28\r\npower management 1-32, 1-33, 1-34\r\nprocessor brand index 1-24, 1-34\r\nprocessor brand string 1-21, 1-34\r\nprocessor serial number 1-28\r\nprocessor type field 1-24\r\nRDMSR flag 1-27\r\nreturned in EBX 1-24\r\nreturned in ECX & EDX 1-24\r\nself snoop 1-29\r\nSpeedStep technology 1-25\r\nSS2 extensions flag 1-29",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/cd22cfe3-82b7-428a-9333-38ecd97a1243.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f748ebd09942f803a8f4dcb0904c10b3b960471b7124901b74336ceba14609fe",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4fa0640a-bf9a-4eea-943b-39fcce1a3386",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 136,
            "page_width": 612,
            "page_height": 792,
            "content": "II Ref. # 319433-032\r\nSSE extensions flag 1-29\r\nSSE3 extensions flag 1-25\r\nSSSE3 extensions flag 1-25\r\nSYSENTER flag 1-28\r\nSYSEXIT flag 1-28\r\nthermal management 1-32, 1-33, 1-34\r\nthermal monitor 1-25, 1-28, 1-29\r\ntime stamp counter 1-27\r\nusing CPUID 1-7\r\nvendor ID string 1-22\r\nversion information 1-8, 1-31\r\nvirtual 8086 Mode flag 1-27\r\nvirtual address bits 1-22\r\nWRMSR flag 1-27\r\nF\r\nFeature information, processor 1-7\r\nFXRSTOR instruction\r\nCPUID flag 1-28\r\nFXSAVE instruction\r\nCPUID flag 1-28\r\nI\r\nIA-32e mode\r\nCPUID flag 1-21\r\nInstruction set\r\ngrouped by processor 1-1\r\nL\r\nL1 Context ID 1-26 M\r\nMachine check architecture\r\nCPUID flag 1-28\r\ndescription 1-28\r\nMMX instructions\r\nCPUID flag for technology 1-28\r\nModel & family information 1-31\r\nMONITOR instruction\r\nCPUID flag 1-25\r\nfeature data 1-32\r\nMWAIT instruction\r\nCPUID flag 1-25\r\nfeature data 1-32\r\nP\r\nPending break enable 1-29\r\nPerformance-monitoring counters\r\nCPUID inquiry for 1-32\r\nR\r\nRDMSR instruction\r\nCPUID flag 1-27\r\nS\r\nSelf Snoop 1-29\r\nSpeedStep technology 1-25\r\nSSE extensions\r\nCPUID flag 1-29\r\nSSE2 extensions\r\nCPUID flag 1-29\r\nSSE3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/4fa0640a-bf9a-4eea-943b-39fcce1a3386.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d28203a82a0c34bb8b720909fe89923086052df89e0a1af30d8622af7ff42653",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f742001d-ee95-4e5a-94c6-2d855cd477b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 137,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-032 III\r\nCPUID flag 1-25\r\nSSE3 extensions\r\nCPUID flag 1-25\r\nSSSE3 extensions\r\nCPUID flag 1-25\r\nStepping information 1-31\r\nSYSENTER instruction\r\nCPUID flag 1-28\r\nSYSEXIT instruction\r\nCPUID flag 1-28\r\nT\r\nThermal Monitor\r\nCPUID flag 1-29\r\nThermal Monitor 2 1-25\r\nCPUID flag 1-25\r\nTime Stamp Counter 1-27\r\nV\r\nVersion information, processor 1-7\r\nVPERMI2B - Full Permute of Bytes from Two Tables Overwriting the Index 3-4\r\nVPMULTISHIFTQB – Select Packed Unaligned Bytes from Quadword Source 2-33\r\nW\r\nWBINVD instruction 2-58\r\nWBINVD/INVD bit 1-9\r\nWRMSR instruction\r\nCPUID flag 1-27\r\nX\r\nXFEATURE_ENALBED_MASK 1-4\r\nXRSTOR 1-4, 1-33\r\nXSAVE 1-4, 1-26, 1-33",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/a906755a-32b5-4013-a032-1d5bc6502072/images/f742001d-ee95-4e5a-94c6-2d855cd477b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041458Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cdc6e2829f8e647cdd025e1ac4834451180b7292c3d1b1a819051b2ef1c2732c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 503
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No response"
        }
      ]
    }
  }
}