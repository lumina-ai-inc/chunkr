{
  "file_name": "Intel Architecture - Instruction Set Extensions and Future Features - Programming Reference - May 2019 (319433-037).pdf",
  "task_id": "900764ae-e7ad-4c7c-b731-36d3664b9562",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "1a337884-0183-4b46-8602-d1584ed02ad0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Intel® Architecture\r\nInstruction Set Extensions and Future Features\r\nProgramming Reference\r\n319433-037\r\nMAY 2019",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/1a337884-0183-4b46-8602-d1584ed02ad0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2e088691ef34f9dc53bff9cb579aad4e0424a8d1792dc24718f3327cec59cc66",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1ff9a064-2a42-487e-b1ae-1c7703f99fa9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "ii Ref. # 319433-037\r\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\r\nmore at intel.com, or from the OEM or retailer.\r\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\r\nfrom such losses.\r\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\r\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\r\nmatter disclosed herein.\r\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\r\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica\u0002tions. Current characterized errata are available on request.\r\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\r\nwithout notice. Intel does not guarantee the availability of these interfaces in any future product. Contact your Intel representative to obtain the\r\nlatest Intel product specifications and roadmaps.\r\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\r\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\r\nIntel, the Intel logo, Intel Deep Learning Boost, Intel DL Boost, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are\r\ntrademarks of Intel Corporation in the U.S. and/or other countries.\r\n*Other names and brands may be claimed as the property of others.\r\nCopyright © 1997-2019, Intel Corporation. All Rights Reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/1ff9a064-2a42-487e-b1ae-1c7703f99fa9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=337ba0e8ac8b8611920a668be143d4b62d45b3eea82b4ee5e3954feddec164b9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 295
      },
      {
        "segments": [
          {
            "segment_id": "215b57d2-1f79-4d54-b41d-6abf0b28164a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 iii\r\nRevision History\r\nRevision Description Date\r\n-025\r\n• Removed instructions that now reside in the Intel® 64 and \r\nIA-32 Architectures Software Developer’s Manual.\r\n• Minor updates to chapter 1.\r\n• Updates to Table 2-1, Table 2-2 and Table 2-8 (leaf 07H) to \r\nindicate support for AVX512_4VNNIW and AVX512_4FMAPS.\r\n• Minor update to Table 2-8 (leaf 15H) regarding ECX \r\ndefinition.\r\n• Minor updates to Section 4.6.2 and Section 4.6.3 to clarify \r\nthe effects of “suppress all exceptions”.\r\n• Footnote addition to CLWB instruction indicating operand \r\nencoding requirement.\r\n• Removed PCOMMIT.\r\nSeptember 2016\r\n-026\r\n• Removed CLWB instruction; it now resides in the Intel® 64 \r\nand IA-32 Architectures Software Developer’s Manual.\r\n• Added additional 512-bit instruction extensions in chapter 6.\r\nOctober 2016\r\n-027\r\n• Added TLB CPUID leaf in chapter 2.\r\n• Added VPOPCNTD/Q instruction in chapter 6,and CPUID \r\ndetails in chapter 2.\r\nDecember 2016\r\n-028 • Updated intrinsics for VPOPCNTD/Q instruction in chapter 6. December 2016\r\n-029\r\n• Corrected typo in CPUID leaf 18H.\r\n• Updated operand encoding table format; extracted tuple \r\ninformation from operand encoding.\r\n• Added VPERMB back into chapter 5; inadvertently removed.\r\n• Moved all instructions from chapter 6 to chapter 5.\r\n• Updated operation section of VPMULTISHIFTQB.\r\nApril 2017\r\n-030\r\n• Removed unnecessary information from document (chapters \r\n2, 3 and 4).\r\n• Added table listing recent instruction set extensions \r\nintroduction in Intel 64 and IA-32 Processors.\r\n• Updated CPUID instruction with additional details.\r\n• Added the following instructions: GF2P8AFFINEINVQB, \r\nGF2P8AFFINEQB, GF2P8MULB, VAESDEC, VAESDECLAST, \r\nVAESENC, VAESENCLAST, VPCLMULQDQ, VPCOMPRESS, \r\nVPDPBUSD, VPDPBUSDS, VPDPWSSD, VPDPWSSDS, \r\nVPEXPAND, VPOPCNT, VPSHLD, VPSHLDV, VPSHRD, \r\nVPSHRDV, VPSHUFBITQMB.\r\n• Removed the following instructions: VPMADD52HUQ, \r\nVPMADD52LUQ, VPERMB, VPERMI2B, VPERMT2B, and \r\nVPMULTISHIFTQB. They can be found in the Intel® 64 and \r\nIA-32 Architectures Software Developer’s Manual, Volumes \r\n2A, 2B, 2C & 2D.\r\n• Moved instructions unique to processors based on the \r\nKnights Mill microarchitecture to chapter 3.\r\n• Added chapter 4: EPT-Based Sub-Page Permissions.\r\n• Added chapter 5: Intel® Processor Trace: VMX \r\nImprovements.\r\nOctober 2017",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/215b57d2-1f79-4d54-b41d-6abf0b28164a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2b4875f5d744732aa7c51ec6b1bf04ef7e9a1fc1ff581502e987d1a43018da0e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 329
      },
      {
        "segments": [
          {
            "segment_id": "e18f5305-ac42-4482-b5df-80ef41a6d4b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "iv Ref. # 319433-037\r\n-031\r\n• Updated change log to correct typo in changes from previous \r\nrelease.\r\n• Updated instructions with imm8 operand missing in operand \r\nencoding table.\r\n• Replaced “VLMAX” with “MAXVL” to align terminology used \r\nacross documentation.\r\n• Added back information on detection of Intel AVX-512 \r\ninstructions.\r\n• Added Intel® Memory Encryption Technologies instructions \r\nPCONFIG and WBNOINVD. These instructions are also added \r\nto Table 1-1 “Recent Instruction Set Extensions Introduction \r\nin Intel 64 and IA-32 Processors”. Added Section 1.5 \r\n“Detection of Intel® Memory Encryption Technologies (Intel®\r\nMKTME) Instructions”.\r\n• CPUID instruction updated with PCONFIG and WBNOINVD \r\ndetails.\r\n• CPUID instruction updated with additional details on leaf \r\n07H: Intel® Xeon Phi™ only features identified and listed.\r\n• CPUID instruction updated with new Intel® SGX features in \r\nleaf 12H.\r\n• CPUID instruction updated with new PCONFIG information \r\nsub-leaf 1BH.\r\n• Updated short descriptions in the following instructions: \r\nVPDPBUSD, VPDPBUSDS, VPDPWSSD and VPDPWSSDS.\r\n• Corrections and clarifications in Chapter 4 “EPT-Based Sub\u0002Page Permissions”.\r\n• Corrections and clarifications in Chapter 5 “Intel® Processor \r\nTrace: VMX Improvements”.\r\nJanuary 2018\r\n-032\r\n• Corrected PCONFIG CPUID feature flag on instruction page.\r\n• Minor updates to PCONFIG instruction pages: Changed Table \r\n2-2 to use Hex notation; changed “RSVD, MBZ” to \r\n“Reserved, must be zero” in two places in Table 2-3.\r\n• Minor typo correction in WBNOINVD instruction description.\r\nJanuary 2018\r\n-033\r\n• Updated Table 1-1 “Recent Instruction Set Extensions / \r\nFeatures Introduction in Intel® 64 and IA-32 Processors” .\r\n• Added Section 1.6, “Detection of Future Instructions”.\r\n• Added CLDEMOTE, MOVDIRI, MOVDIR64B, TPAUSE, \r\nUMONITOR and UMWAIT instructions.\r\n• Updated the CPUID instruction with details on new \r\ninstructions/features added, as well as new power \r\nmanagement details and information on hardware feedback \r\ninterface ISA extensions.\r\n• Corrections to PCONFIG instruction.\r\n• Moved instructions unique to processors based on the \r\nKnights Mill microarchitecture to the Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual.\r\n• Added Chapter 5 “Hardware Feedback Interface ISA \r\nExtensions”.\r\n• Added Chapter 6 “AC Split Lock Detection”.\r\nMarch 2018\r\n-034\r\n• Added clarification to leaf 07H in the CPUID instruction.\r\n• Added MSR index for IA32_UMWAIT_CONTROL MSR.\r\n• Updated registers in TPAUSE and UMWAIT instructions.\r\n• Updated TPAUSE and UMWAIT intrinsics.\r\nMay 2018\r\nRevision Description Date",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e18f5305-ac42-4482-b5df-80ef41a6d4b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=44218cf48b949778361cf2fb9db1e52997b344a6d319b57ec2197ab309c9d770",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 370
      },
      {
        "segments": [
          {
            "segment_id": "f3165e38-fdfe-4ed2-8891-7028348705a0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 v\r\n-035\r\n• Updated Table 1-1 “Recent Instruction Set Extensions / \r\nFeatures Introduction in Intel® 64 and IA-32 Processors” to \r\nlist the AVX512_VNNI instruction set architecture on a \r\nseparate line due to presence on future processors available \r\nsooner than previously listed.\r\n• Updated CPUID instruction in various places.\r\n• Removal of NDD/DDS/NDS terms from instructions. Note: \r\nPreviously, the terms NDS, NDD and DDS were used in \r\ninstructions with an EVEX (or VEX) prefix. These terms \r\nindicated that the vvvv field was valid for encoding, and \r\nspecified register usage. These terms are no longer \r\nnecessary and are redundant with the instruction operand \r\nencoding tables provided with each instruction. The \r\ninstruction operand encoding tables give explicit details on all \r\noperands, indicating where every operand is stored and if \r\nthey are read or written. If vvvv is not listed as an operand in \r\nthe instruction operand encoding table, then EVEX (or VEX) \r\nvvvv must be 0b1111.\r\n• Added additional #GP exception condition to TPAUSE and \r\nUMWAIT.\r\n• Updated Chapter 5 “Hardware Feedback Interface ISA \r\nExtensions” as follows: changed scheduler/software to \r\noperating system or OS, changed LP0 Scheduler Feedback to \r\nLP0 Capability Values, various description updates, clarified \r\nthat capability updates are independent, and added an \r\nupdate to clarify that bits 0 and 1 will always be set together \r\nin Section 5.1.4.\r\n• Added IA32_CORE_CAPABILITY MSR to Chapter 6 “AC Split \r\nLock Detection”.\r\nOctober 2018\r\n-036\r\n• Added AVX512_BF16 instructions in chapter 2; related \r\nCPUID information updated in chapter 1.\r\n• Added new section to chapter 1 describing bfloat16 format.\r\n• CPUID leaf updates to align with the Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual.\r\n• Removed CLDEMOTE, TPAUSE, UMONITOR, and UMWAIT \r\ninstructions; they now reside in the Intel® 64 and IA-32 \r\nArchitectures Software Developer’s Manual.\r\n• Changes now marked by green change bars and green font \r\nin order to view changes at a text level.\r\nApril 2019\r\n-037\r\n• Removed chapter 3, “EPT-Based Sub-Page Permissions”, \r\nchapter 4, “Intel® Processor Trace: VMX Improvements”, \r\nand chapter 6, “Split Lock Detection”; this information is in \r\nthe Intel® 64 and IA-32 Architectures Software Developer’s \r\nManual.\r\n• Removed MOVDIRI and MOVDIR64B instructions; they now \r\nreside in the Intel® 64 and IA-32 Architectures Software \r\nDeveloper’s Manual.\r\n• Updated Table 1-1 with new features in future processors.\r\n• Updated Table 1-2 with support for AVX512_VP2INTERSECT.\r\n• Updated Table 1-4 with support for ENQCMD: Enqueue \r\nStores.\r\n• Added ENQCMD/ENQCMDS and \r\nVP2INTERSECTD/VP2INTERSECTQ instructions, and updated \r\nCPUID accordingly.\r\n• Added new chapter: Chapter 3, Enqueue Stores and Process \r\nAddress Space Identifiers (PASIDs).\r\nMay 2019\r\nRevision Description Date",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/f3165e38-fdfe-4ed2-8891-7028348705a0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c7f0d30868689253922da5b75d2c5d1fc0cbb7441bd22f1bee1095b836cd8a95",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "1dffa938-b62e-4f95-ab90-fe0359497fbc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "vi Ref. # 319433-037",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/1dffa938-b62e-4f95-ab90-fe0359497fbc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f1bb347e52983c006019ace1dd925b98b17d7f8092830f06e27fe88e9459d683",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 431
      },
      {
        "segments": [
          {
            "segment_id": "eaaec308-9465-4f65-b2c2-0891ebb1a16c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 vii\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Instruction Set Extensions and Feature Introduction in Intel® 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.3 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\n1.4 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1.5 Detection of Intel® Memory Encryption Technologies (Intel® MKTME) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1.6 Detection of Future Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\n1.7 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-8\r\n1.8 Compressed Displacement (disp8*N) Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n1.9 bfloat16 Floating-Point Format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-48\r\nCHAPTER 2 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n2.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nENQCMD — Enqueue Command. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\r\nENQCMDS — Enqueue Command Supervisor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\r\nGF2P8AFFINEQB — Galois Field Affine Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\nGF2P8MULB — Galois Field Multiply Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\r\nPCONFIG — Platform Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\nVAESDEC — Perform One Round of an AES Decryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-22\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-24\r\nVAESENC — Perform One Round of an AES Encryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\r\nVCVTNE2PS2BF16 — Convert Two Packed Single Data to One Packed BF16 Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-30\r\nVCVTNEPS2BF16 — Convert Packed Single Data to Packed BF16 Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-32\r\nVDPBF16PS — Dot Product of BF16 Pairs Accumulated into Packed Single Precision. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-34\r\nVP2INTERSECTD/VP2INTERSECTQ — Compute Intersection Between DWORDS/QUADWORDS to a Pair of Mask \r\nRegisters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-36\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register . . . . . . . . . . . . . . . . . . . . 2-41\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46\r\nVPDPWSSD — Multiply and Add Signed Word Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-48\r\nVPDPWSSDS — Multiply and Add Signed Word Integers with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-50\r\nVPEXPAND — Expand Byte/Word Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-52\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD. . . . . . . . . . . . . . . . . . . . . . . . 2-55\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-58\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-61\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-64\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-67\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask . . . . . . . . . . . . . . . . . . . . . . . . . . 2-70\r\nWBNOINVD—Write Back and Do Not Invalidate Cache. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-71\r\nCHAPTER 3\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\n3.1 The IA32_PASID MSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2 The PASID State Component for the XSAVE Feature Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.3 PASID Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\n3.3.1 PASID Translation Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-2\r\n3.3.2 The PASID Translation Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.3.3 VMX Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/eaaec308-9465-4f65-b2c2-0891ebb1a16c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a397e5295b2732288d7702ffae47f6daf8422d9c390f14a6a99a9ba872d81e9c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3165
      },
      {
        "segments": [
          {
            "segment_id": "eaaec308-9465-4f65-b2c2-0891ebb1a16c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 vii\r\nREVISION HISTORY\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.1 About This Document. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.2 Instruction Set Extensions and Feature Introduction in Intel® 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1\r\n1.3 Detection of AVX-512 Foundation Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\n1.4 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1.5 Detection of Intel® Memory Encryption Technologies (Intel® MKTME) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1.6 Detection of Future Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\n1.7 CPUID Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\r\nCPUID—CPU Identification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-8\r\n1.8 Compressed Displacement (disp8*N) Support in EVEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n1.9 bfloat16 Floating-Point Format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-48\r\nCHAPTER 2 \r\nINSTRUCTION SET REFERENCE, A-Z\r\n2.1 Instruction SET Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1\r\nENQCMD — Enqueue Command. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\r\nENQCMDS — Enqueue Command Supervisor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\r\nGF2P8AFFINEQB — Galois Field Affine Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\r\nGF2P8MULB — Galois Field Multiply Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\r\nPCONFIG — Platform Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\nVAESDEC — Perform One Round of an AES Decryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-22\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-24\r\nVAESENC — Perform One Round of an AES Encryption Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-26\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\r\nVCVTNE2PS2BF16 — Convert Two Packed Single Data to One Packed BF16 Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-30\r\nVCVTNEPS2BF16 — Convert Packed Single Data to Packed BF16 Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-32\r\nVDPBF16PS — Dot Product of BF16 Pairs Accumulated into Packed Single Precision. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-34\r\nVP2INTERSECTD/VP2INTERSECTQ — Compute Intersection Between DWORDS/QUADWORDS to a Pair of Mask \r\nRegisters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-36\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register . . . . . . . . . . . . . . . . . . . . 2-41\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-44\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-46\r\nVPDPWSSD — Multiply and Add Signed Word Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-48\r\nVPDPWSSDS — Multiply and Add Signed Word Integers with Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-50\r\nVPEXPAND — Expand Byte/Word Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-52\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD. . . . . . . . . . . . . . . . . . . . . . . . 2-55\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-58\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-61\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-64\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-67\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask . . . . . . . . . . . . . . . . . . . . . . . . . . 2-70\r\nWBNOINVD—Write Back and Do Not Invalidate Cache. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-71\r\nCHAPTER 3\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\n3.1 The IA32_PASID MSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.2 The PASID State Component for the XSAVE Feature Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n3.3 PASID Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2\r\n3.3.1 PASID Translation Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-2\r\n3.3.2 The PASID Translation Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-3\r\n3.3.3 VMX Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/eaaec308-9465-4f65-b2c2-0891ebb1a16c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a397e5295b2732288d7702ffae47f6daf8422d9c390f14a6a99a9ba872d81e9c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 3165
      },
      {
        "segments": [
          {
            "segment_id": "48f7a8bf-2082-4e92-b88e-c22e121348b3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "viii Ref. # 319433-037\r\nCHAPTER 4\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS\r\n4.1 Hardware Feedback Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4.1.1 Hardware Feedback Interface Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4.1.2 Hardware Feedback Interface Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4.1.3 Hardware Feedback Interface Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\r\n4.1.4 Hardware Feedback Interface Enumeration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/48f7a8bf-2082-4e92-b88e-c22e121348b3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=81e078432180eb6644ed1ac70928011011af414124cabc9a5edcff27a884d121",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 410
      },
      {
        "segments": [
          {
            "segment_id": "9d31427b-4550-4fb9-a560-f00d9b17979c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 ix\r\nTABLES\r\nPAGE\r\n1-1 Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors. . . . . . . . . . . . . . . . . . . . . 1-1\r\n1-2 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1-3 Intel® Memory Encryption Technologies Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1-4 Future Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\n1-5 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-9\r\n1-6 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-27\r\n1-7 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-28\r\n1-8 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-30\r\n1-9 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-31\r\n1-10 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-33\r\n1-11 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-39\r\n1-12 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-41\r\n1-13 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n1-14 EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n2-1 Inverse Byte Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8\r\n2-2 PCONFIG Leaf Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\n2-3 MKTME_KEY_PROGRAM_STRUCT Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\n2-4 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\r\n2-5 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\r\n2-6 PCONFIG Operation Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\r\n2-7 PCLMULQDQ Quadword Selection of Immediate Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\n2-8 Pseudo-Op and PCLMULQDQ Implementation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\n3-1 IA32_PASID MSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n4-1 Hardware Feedback Interface Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4-2 Hardware Feedback Interface Global Header Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4-3 Hardware Feedback Interface Logical Processor Entry Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/9d31427b-4550-4fb9-a560-f00d9b17979c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0e813be7ca6406b5e27cfa08536e8736fb01ec5c430289d88e2fa77a9437a7f4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1822
      },
      {
        "segments": [
          {
            "segment_id": "9d31427b-4550-4fb9-a560-f00d9b17979c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 ix\r\nTABLES\r\nPAGE\r\n1-1 Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors. . . . . . . . . . . . . . . . . . . . . 1-1\r\n1-2 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-5\r\n1-3 Intel® Memory Encryption Technologies Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\n1-4 Future Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7\r\n1-5 Information Returned by CPUID Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-9\r\n1-6 Highest CPUID Source Operand for Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-27\r\n1-7 Processor Type Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-28\r\n1-8 Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-30\r\n1-9 More on Feature Information Returned in the EDX Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-31\r\n1-10 Encoding of Cache and TLB Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-33\r\n1-11 Processor Brand String Returned with Pentium 4 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-39\r\n1-12 Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-41\r\n1-13 Compressed Displacement (DISP8*N) Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n1-14 EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-47\r\n2-1 Inverse Byte Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8\r\n2-2 PCONFIG Leaf Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\n2-3 MKTME_KEY_PROGRAM_STRUCT Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-15\r\n2-4 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\r\n2-5 Supported Key Programming Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\r\n2-6 PCONFIG Operation Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\r\n2-7 PCLMULQDQ Quadword Selection of Immediate Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-38\r\n2-8 Pseudo-Op and PCLMULQDQ Implementation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-39\r\n3-1 IA32_PASID MSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1\r\n4-1 Hardware Feedback Interface Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4-2 Hardware Feedback Interface Global Header Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\r\n4-3 Hardware Feedback Interface Logical Processor Entry Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/9d31427b-4550-4fb9-a560-f00d9b17979c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0e813be7ca6406b5e27cfa08536e8736fb01ec5c430289d88e2fa77a9437a7f4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1822
      },
      {
        "segments": [
          {
            "segment_id": "a4d19aae-01bf-49dc-9b8c-7aea6df194e1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "x Ref. # 319433-037",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/a4d19aae-01bf-49dc-9b8c-7aea6df194e1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9bfefa743c3c3629033929d16abca460844c0f9089525dc65d122b3e668b761a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 4
      },
      {
        "segments": [
          {
            "segment_id": "296d75eb-c26e-4586-8391-6f8398668c17",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 xi\r\nFIGURES\r\nPAGE\r\nFigure 1-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\nFigure 1-2. Procedural Flow of Application Detection of 512-bit Instruction Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\nFigure 1-3. Version Information Returned by CPUID in EAX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-28\r\nFigure 1-4. Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-29\r\nFigure 1-5. Feature Information Returned in the EDX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-31\r\nFigure 1-6. Determination of Support for the Processor Brand String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-39\r\nFigure 1-7. Algorithm for Extracting Maximum Processor Frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-40\r\nFigure 1-8. Comparison of BF16 to FP16 and FP32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-48\r\nFigure 2-1. 64-Byte Data Written to Enqueue Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\nFigure 3-1. PASID Translation Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/296d75eb-c26e-4586-8391-6f8398668c17.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13ab12c2288fc40d358b8ce5a618f5213e81ce4ee15035a3fbede0c48f8b1c86",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 683
      },
      {
        "segments": [
          {
            "segment_id": "296d75eb-c26e-4586-8391-6f8398668c17",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 xi\r\nFIGURES\r\nPAGE\r\nFigure 1-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-4\r\nFigure 1-2. Procedural Flow of Application Detection of 512-bit Instruction Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\r\nFigure 1-3. Version Information Returned by CPUID in EAX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-28\r\nFigure 1-4. Feature Information Returned in the ECX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-29\r\nFigure 1-5. Feature Information Returned in the EDX Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-31\r\nFigure 1-6. Determination of Support for the Processor Brand String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-39\r\nFigure 1-7. Algorithm for Extracting Maximum Processor Frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-40\r\nFigure 1-8. Comparison of BF16 to FP16 and FP32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-48\r\nFigure 2-1. 64-Byte Data Written to Enqueue Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-2\r\nFigure 3-1. PASID Translation Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/296d75eb-c26e-4586-8391-6f8398668c17.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=13ab12c2288fc40d358b8ce5a618f5213e81ce4ee15035a3fbede0c48f8b1c86",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 683
      },
      {
        "segments": [
          {
            "segment_id": "8bb9c0e3-98cd-425f-bf8b-c3b4030319e8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "xii Ref. # 319433-037",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/8bb9c0e3-98cd-425f-bf8b-c3b4030319e8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a39adb075eccb302a7b532a1a0c2e94297e1bc0f9bab16b4fbee67a0e420c6b5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9025b10e-6ac6-41c9-a8a0-ee3581495db9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nCHAPTER 1\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND\r\nFEATURES\r\n1.1 ABOUT THIS DOCUMENT\r\nThis document describes the software programming interfaces of Intel® architecture instruction extensions and\r\nfeatures which may be included in future Intel processor generations. Intel does not guarantee the availability\r\nof these interfaces and features in any future product. \r\nThe instruction set extensions cover a diverse range of application domains and programming usages. The 512-\r\nbit SIMD vector SIMD extensions, referred to as Intel® Advanced Vector Extensions 512 (Intel® AVX-512) in\u0002structions, deliver comprehensive set of functionality and higher performance than Intel® AVX and Intel® AVX2\r\ninstructions. Intel AVX, Intel AVX2 and many Intel AVX-512 instructions are covered in Intel® 64 and IA-32 Ar\u0002chitectures Software Developer’s Manual sets. The reader can refer to them for basic and more background in\u0002formation related to various features referenced in this document.\r\nThe base of the 512-bit SIMD instruction extensions are referred to as Intel AVX-512 Foundation instructions.\r\nThey include extensions of the AVX and AVX2 family of SIMD instructions but are encoded using a new encoding\r\nscheme with support for 512-bit vector registers, up to 32 vector registers in 64-bit mode, and conditional pro\u0002cessing using opmask registers. \r\nChapter 2 is devoted to additional 512-bit instruction extensions in the Intel AVX-512 family targeting broad ap\u0002plication domains, and instruction set extensions encoded using the EVEX prefix encoding scheme to operate at\r\nvector lengths smaller than 512-bits. \r\nChapter 3 describes ENQCMD/ENQCMDS details and virtualization support. \r\nChapter 4 describes Hardware Feedback Interface ISA Extensions.\r\n1.2 INSTRUCTION SET EXTENSIONS AND FEATURE INTRODUCTION IN INTEL®\r\n64 AND IA-32 PROCESSORS\r\nRecent instruction set extensions and features are listed in Table 1-1. Within these groups, most instructions and \r\nfeatures are collected into functional subgroups.\r\nTable 1-1. Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Introduced in Microarchitecture\r\nSSE4.1 Extensions Intel® Xeon® processor 3100, 3300, 5200, 5400, 7400, \r\n7500 series, Intel® Core™ 2 Extreme processors QX9000 \r\nseries, Intel® Core™ 2 Quad processor Q9000 series, Intel® \r\nCore™ 2 Duo processors 8000 series, T9000 series.\r\nLegacy\r\nIntel® Atom™ processor. Silvermont\r\nSSE4.2 Extensions, CRC32, \r\nPOPCNT\r\nIntel® Core™ i7 965 processor, Intel® Xeon® processors \r\nX3400, X3500, X5500, X6500, X7500 series.\r\nLegacy\r\nIntel® Atom™ processor. Silvermont\r\nAESNI, PCLMULQDQ Intel® Xeon® processor E7 series, Intel® Xeon® processors \r\nX3600, X5600, Intel® Core™ i7 980X processor. \r\nUse CPUID to verify presence of AESNI and PCLMULQDQ \r\nacross Intel® Core™ processor families.\r\nWestmere\r\nIntel® Atom™ processor. Silvermont",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/9025b10e-6ac6-41c9-a8a0-ee3581495db9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3743d47571ba68701537375fbabcd08bae4a60209b6db383c52a88b63a2bf6b8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 422
      },
      {
        "segments": [
          {
            "segment_id": "904c2834-2d5a-4a29-8e3e-02622ca1904e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "1-2 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIntel AVX Intel® Xeon® processor E3 and E5 families.\r\n2nd Generation Intel® Core™ i7, i5, i3 processor 2xxx families.\r\nSandy Bridge\r\nF16C 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge\r\nRDRAND 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge\r\nIntel® Atom™ processor. Silvermont\r\nFS/GS base access 3rd Generation Intel® Core™ processors, Intel® Xeon® \r\nprocessor E3-1200 v2 product family, Next Generation Intel® \r\nXeon® processors, Intel® Xeon® processor E5 v2 and E7 v2 \r\nfamilies.\r\nIvy Bridge\r\nIntel® Atom™ processor. Goldmont\r\nFMA, AVX2, BMI1, BMI2, \r\nINVPCID, LZCNT, TSX\r\nIntel® Xeon® processor E3/E5/E7 v3 product families.\r\n4th Generation Intel® Core™ processor family.\r\nHaswell\r\nMOVBE Intel® Xeon® processor E3/E5/E7 v3 product families.\r\n4th Generation Intel® Core™ processor family.\r\nHaswell\r\nIntel® Atom™ processor. Silvermont\r\nPREFETCHW Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell\r\nIntel® Atom™ processor. Silvermont\r\nADX Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell\r\nCLAC, STAC Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell\r\nIntel® Atom™ processor. Goldmont\r\nRDSEED Intel® Core™ M processor family; 5th Generation Intel® Core™ \r\nprocessor family.\r\nBroadwell\r\nIntel® Atom™ processor. Goldmont\r\nAVX512ER, AVX512PF, \r\nPREFETCHWT1\r\nIntel® Xeon Phi™ Processor 3200, 5200, 7200 Series. Knights Landing\r\nAVX512F, AVX512CD Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series. Knights Landing\r\nIntel® Xeon® Processor Scalable Family. Skylake Server\r\nIntel® Core™ i3-8121U processor. Cannon Lake\r\nCLFLUSHOPT, XSAVEC, \r\nXSAVES, MPX\r\nIntel® Xeon® Processor Scalable Family. Skylake Server\r\n6th Generation Intel® Core™ processor family. Skylake\r\nIntel® Atom™ processor. Goldmont\r\nSGX1 6th Generation Intel® Core™ processor family. Skylake\r\nIntel® Atom™ processor. Goldmont Plus\r\nTable 1-1. Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors(Continued)\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Introduced in Microarchitecture",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/904c2834-2d5a-4a29-8e3e-02622ca1904e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d0f0b9ab16c33271a4af98febdcbceccb7f2fbfed19027a7b746125d95a96d08",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 331
      },
      {
        "segments": [
          {
            "segment_id": "4d11dee9-5906-4728-8b5e-0b0a6cd14d26",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-3\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nAVX512DQ, AVX512BW, \r\nAVX512VL\r\nIntel® Xeon® Processor Scalable Family. Skylake Server\r\nIntel® Core™ i3-8121U processor. Cannon Lake\r\nCLWB Intel® Xeon® Processor Scalable Family. Skylake Server\r\nTBD Future, Ice Lake\r\nTBD Future, Tremont\r\nPKU Intel® Xeon® Processor Scalable Family. Skylake Server\r\nAVX512_IFMA, \r\nAVX512_VBMI\r\nIntel® Core™ i3-8121U processor. Cannon Lake\r\nSHA-NI Intel® Core™ i3-8121U processor. Cannon Lake\r\nIntel® Atom™ processor. Goldmont\r\nUMIP Intel® Core™ i3-8121U processor. Cannon Lake\r\nIntel® Atom™ processor. Goldmont Plus\r\nPTWRITE Intel® Atom™ processor. Goldmont Plus\r\nRDPID TBD Future, Ice Lake\r\nIntel® Atom™ processor. Goldmont Plus\r\nAVX512_4FMAPS, \r\nAVX512_4VNNIW\r\nIntel® Xeon Phi™ Processor 7215, 7285, 7295 Series. Knights Mill\r\nAVX512_VNNI Future versions of Intel® Xeon® Processor Scalable Family. Cascade Lake\r\nAVX512_VPOPCNTDQ Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series. Knights Mill\r\nTBD Future, Ice Lake\r\nFast Short REP MOV TBD Future, Ice Lake\r\nVAES, GFNI (AVX/AVX512), \r\nAVX512_VBMI2, \r\nVPCLMULQDQ, \r\nAVX512_BITALG\r\nTBD Future, Ice Lake\r\nGFNI(SSE) TBD Future, Ice Lake\r\nTBD Future, Tremont\r\nPCONFIG, WBNOINVD TBD Future, Ice Lake Server\r\nENCLV TBD Future, Ice Lake Server\r\nTBD Future, Tremont\r\nSplit Lock Detection TBD Future, Ice Lake\r\nTBD Future, Tremont\r\nCLDEMOTE TBD Future, Tremont\r\nDirect stores: MOVDIRI, \r\nMOVDIR64B \r\nTBD Future, Tremont\r\nTBD Future, Tiger Lake\r\nUser wait: TPAUSE, \r\nUMONITOR, UMWAIT\r\nTBD Future, Tremont\r\nAVX512_BF16 TBD Future, Cooper Lake\r\nCET: Control-flow \r\nEnforcement Technology1\r\nTBD Future, Tiger Lake\r\nTable 1-1. Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors(Continued)\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Introduced in Microarchitecture",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4d11dee9-5906-4728-8b5e-0b0a6cd14d26.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=21bc952b9613b4c99e11446c1013d76221bddc1c6778c119dbe7217fb8c2a82a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 247
      },
      {
        "segments": [
          {
            "segment_id": "610baf7c-24fa-43da-ac1a-f98ba3de3c7f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 16,
            "page_width": 612,
            "page_height": 792,
            "content": "1-4 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.3 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS \r\nThe majority of AVX-512 Foundation instructions are encoded using the EVEX encoding scheme. EVEX-encoded \r\ninstructions can operate on the 512-bit ZMM register state plus 8 opmask registers. The opmask instructions in \r\nAVX-512 Foundation instructions operate only on opmask registers or with a general purpose register.\r\nProcessor support of AVX-512 Foundation instructions is indicated by CPUID.(EAX=07H, ECX=0):EBX.AVX512F[bit \r\n16] = 1. Detection of AVX-512 Foundation instructions operating on ZMM states and opmask registers need to \r\nfollow the general procedural flow in Figure 1-1.\r\nPrior to using AVX-512 Foundation instructions, the application must identify that the operating system supports \r\nthe XGETBV instruction, the ZMM register state, in addition to processor’s support for ZMM state management \r\nusing XSAVE/XRSTOR and AVX-512 Foundation instructions. The following simplified sequence accomplishes both \r\nand is strongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use1).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Detect CPUID.0x7.0:EBX.AVX512F[bit 16] = 1.\r\nAVX512_VP2INTERSECT TBD Future, Tiger Lake\r\nEnqueue Stores: ENQCMD \r\nand ENQCMDS\r\nTBD Future, Sapphire Rapids\r\nNOTES:\r\n1. Details on Control-flow Enforcement Technology can be found here: CET specification\r\nFigure 1-1. Procedural Flow of Application Detection of AVX-512 Foundation Instructions\r\n1. If CPUID.01H:ECX.OSXSAVE reports 1, it also indirectly implies the processor supports XSAVE, XRSTOR, XGETBV, processor extended \r\nstate bit vector XCR0 register. Thus an application may streamline the checking of CPUID feature flags for XSAVE and OSXSAVE. \r\nXSETBV is a privileged instruction.\r\nTable 1-1. Recent Instruction Set Extensions / Features Introduction in Intel® 64 and IA-32 Processors(Continued)\r\nInstruction Set \r\nArchitecture\r\nProcessor Generation Introduction Introduced in Microarchitecture\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F flag \r\nCheck feature flag\r\nCPUID.1H:ECX.OSXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/610baf7c-24fa-43da-ac1a-f98ba3de3c7f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f2cf798b50d5cea27895c0c2049081a1cdd884f6c511c5fe2e97e4b2986ed72",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 341
      },
      {
        "segments": [
          {
            "segment_id": "66b85ed8-5bea-4d20-9a27-db6a7f413263",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 17,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-5\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.4 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 \r\nFAMILY\r\nIn addition to the Intel AVX-512 Foundation instructions, Intel AVX-512 family provides several additional 512-bit \r\nextensions in groups of instructions, each group is enumerated by a CPUID leaf 7 feature flag and can be encoded \r\nvia EVEX.L’L field to support operation at vector lengths smaller than 512 bits. These instruction groups are listed \r\nin Table 1-2.\r\nSoftware must follow the detection procedure for the 512-bit AVX-512 Foundation instructions as described in \r\nSection 1.3.\r\nDetection of other 512-bit sibling instruction groups listed in Table 1-2 (excluding AVX512F) follows the procedure \r\ndescribed in Figure 1-2.\r\nTable 1-2. 512-bit Instruction Groups in the Intel AVX-512 Family\r\nCPUID Leaf 7 Feature Flag Bit Feature Flag abbreviation of 512-bit Instruction Group SW Detection Flow\r\nCPUID.(EAX=07H, ECX=0):EBX[bit 16] AVX512F: AVX-512 Foundation instructions. Figure 1-1\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 06] AVX512_VBMI2: Additional byte, word, dword and qword \r\ncapabilities, an addition to AVX512. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 08]\r\nGFNI: Galois Field New Instructions; this bit is concatenated by \r\nsoftware with either AVX512, AVX, or SSE to indicate the \r\ndifferent supported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 09]\r\nVAES: Vector AES instructions; this bit is concatenated by \r\nsoftware with AVX512 or AVX to indicate the different \r\nsupported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 10]\r\nVPCLMULQDQ: Vector PCLMULQDQ instructions; this bit is \r\nconcatenated by software with AVX512 or AVX to indicate the \r\ndifferent supported instructions.\r\nFigure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 11] AVX512_VNNI: Vector Neural Network Instructions, an addition \r\nto AVX512. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 12] AVX512_BITALG: Support for VPOPCNT[B,W] and \r\nVPSHUFBITQMB. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 14] AVX512_VPOPCNTDQ: Support for VPOPCNT[D,Q]. Figure 1-2\r\nCPUID.(EAX=07H, ECX=1):EAX[bit 05] AVX512_BF16: Support for BFLOAT16 instructions. Figure 1-2\r\nCPUID.(EAX=07H, ECX=0):EDX[bit 08] AVX512_VP2INTERSECT: Support for VP2INTERSECT[D,Q] Figure 1-2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/66b85ed8-5bea-4d20-9a27-db6a7f413263.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=161e20d9ad6a2c805671e20ddf0680994e3d2a7fa91e80fe2d06a6b5b3a820d5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 297
      },
      {
        "segments": [
          {
            "segment_id": "dec542bc-cb2e-4362-bc66-d17f29aacfa0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 18,
            "page_width": 612,
            "page_height": 792,
            "content": "1-6 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTo illustrated the detection procedure for 512-bit instructions enumerated by AVX512CD, the following sequence is \r\nstrongly recommended.\r\n1) Detect CPUID.1:ECX.OSXSAVE[bit 27] = 1 (XGETBV enabled for application use).\r\n2) Execute XGETBV and verify that XCR0[7:5] = ‘111b’ (OPMASK state, upper 256-bit of ZMM0-ZMM15 and \r\nZMM16-ZMM31 state are enabled by OS) and that XCR0[2:1] = ‘11b’ (XMM state and YMM state are enabled by \r\nOS).\r\n3) Verify both CPUID.0x7.0:EBX.AVX512F[bit 16] = 1, CPUID.0x7.0:EBX.AVX512CD[bit 28] = 1.\r\nSimilarly, the detection procedure for enumerating 512-bit instructions reported by AVX512DW follows the same \r\nflow.\r\n1.5 DETECTION OF INTEL® MEMORY ENCRYPTION TECHNOLOGIES (INTEL® \r\nMKTME) INSTRUCTIONS\r\nIntel® Memory Encryption Technologies instructions are enumerated by a CPUID feature flag; details are listed in \r\nTable 1-3.\r\nFigure 1-2. Procedural Flow of Application Detection of 512-bit Instruction Groups\r\nTable 1-3. Intel® Memory Encryption Technologies Instructions\r\nCPUID Leaf Feature Flag Bit Feature Flag Abbreviation of Intel® MKTME Instructions\r\nCPUID.(EAX=07H, ECX=0):EDX[bit 18] PCONFIG: Platform configuration\r\nCPUID.(EAX=80000008H, ECX=0):EBX[bit 9] WBNOINVD: Write back and do not invalidate cache\r\nImplied HW support for\r\nCheck enabled state in\r\nXCR0 via XGETBV\r\nCheck AVX512F and\r\na sibling 512-bit flag\r\nCheck feature flag\r\nCPUID.1H:ECX.OXSAVE = 1? \r\nOS provides processor\r\nextended state management\r\nStates ok to use\r\nXSAVE, XRSTOR, XGETBV, XCR0\r\nenabled Instructions\r\nYes \r\nYMM,ZMM\r\nOpmask,",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/dec542bc-cb2e-4362-bc66-d17f29aacfa0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=03cee0478f8e16da9905abaf949b5b6d28fb4e5005497d728a18d6515637a417",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "fe6476a7-3289-489b-abe5-8666bad61198",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 19,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-7\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.6 DETECTION OF FUTURE INSTRUCTIONS\r\nFuture instructions are enumerated by a CPUID feature flag; details are listed in Table 1-4.\r\nTable 1-4. Future Instructions\r\nCPUID Leaf Feature Flag Bit Feature Flag Abbreviation\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 25] CLDEMOTE: Cache Line Demote \r\nCPUID.(EAX=07H, ECX=0):EDX[bit 4] Fast Short REP MOV\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 5] WAITPKG: Wait and Pause Enhancements\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 27] MOVDIRI: Direct Stores\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 28] MOVDIR64B: Direct Stores\r\nCPUID.(EAX=07H, ECX=0):ECX[bit 29] ENQCMD: Enqueue Stores",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/fe6476a7-3289-489b-abe5-8666bad61198.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5815f7fe8f7275f192a0fc3cd3f36650f36c9afd22db3b3ed385dcf711bce01e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 302
      },
      {
        "segments": [
          {
            "segment_id": "63b4eda8-ad05-4191-9b5d-6190d92b8842",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 20,
            "page_width": 612,
            "page_height": 792,
            "content": "1-8 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.7 CPUID INSTRUCTION \r\nCPUID—CPU Identification\r\nDescription\r\nThe ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can \r\nset and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction oper\u0002ates the same in non-64-bit modes and 64-bit mode.\r\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The \r\ninstruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). \r\nFor example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value \r\nand the Vendor Identification String in the appropriate registers:\r\nMOV EAX, 00H\r\nCPUID\r\nTable 1-5 shows information returned, depending on the initial value loaded into the EAX register. Table 1-6 shows \r\nthe maximum CPUID input value recognized for each family of IA-32 processors on which CPUID is implemented. \r\nTwo types of information are returned: basic and extended function information. If a value is entered for \r\nCPUID.EAX is invalid for a particular processor, the data for the highest basic information leaf is returned. For \r\nexample, using the Intel Core 2 Duo E6850 processor, the following is true:\r\nCPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *) \r\nCPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) \r\nCPUID.EAX = 0BH (* INVALID: Returns the same information as CPUID.EAX = 0AH. *)2\r\nCPUID.EAX =1FH (* Returns V2 Extended Topology Enumeration leaf. *)2\r\nCPUID.EAX = 80000008H (* Returns virtual/physical address size data. *)\r\nCPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0AH. *)\r\nWhen CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence \r\non input ECX value in the basic leaf is honored.\r\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution \r\nguarantees that any modifications to flags, registers, and memory for previous instructions are completed before \r\nthe next instruction is fetched and executed.\r\nSee also:\r\n“Serializing Instructions” in Chapter 8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 3A.\r\n\"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architectures Software Devel\u0002oper’s Manual, Volume 3A.\r\nOpcode Instruction 64-Bit Mode Compat/\r\nLeg Mode Description\r\n0F A2 CPUID Valid Valid Returns processor identification and feature information to the EAX, \r\nEBX, ECX, and EDX registers, as determined by input entered in EAX \r\n(in some cases, ECX as well).\r\n1. On Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes.\r\n2. CPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of CPUID leaf 1FH before using \r\nleaf 0BH.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/63b4eda8-ad05-4191-9b5d-6190d92b8842.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6898148faba55bea8043bc28e57e3d92616a9d054952fa5b4903cd6eb21099ad",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "f88fab5b-780b-4917-9036-690ba0064dc8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 21,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-9\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-5. Information Returned by CPUID Instruction\r\nInitial EAX \r\nValue Information Provided about the Processor\r\nBasic CPUID Information\r\n0H EAX\r\nEBX\r\nECX\r\nEDX\r\nMaximum Input Value for Basic CPUID Information (see Table 1-6)\r\n“Genu”\r\n“ntel”\r\n“ineI”\r\n01H EAX\r\nEBX\r\nECX\r\nEDX\r\nVersion Information: Type, Family, Model, and Stepping ID (see Figure 1-3)\r\nBits 7-0: Brand Index\r\nBits 15-8: CLFLUSH line size (Value ∗ 8 = cache line size in bytes)\r\nBits 23-16: Maximum number of addressable IDs for logical processors in this physical package*. \r\nBits 31-24: Initial APIC ID**\r\nFeature Information (see Figure 1-4 and Table 1-8)\r\nFeature Information (see Figure 1-5 and Table 1-9)\r\nNOTES: \r\n* The nearest power-of-2 integer that is not smaller than EBX[23:16] is the maximum number of \r\nunique initial APIC IDs reserved for addressing different logical processors in a physical package.\r\n**The 8-bit initial APIC ID in EBX[31:24] is replaced by the 32-bit x2APIC ID, available in Leaf 0BH \r\nand Leaf 1FH.\r\n02H EAX\r\nEBX\r\nECX\r\nEDX\r\nCache and TLB Information (see Table 1-10)\r\nCache and TLB Information\r\nCache and TLB Information\r\nCache and TLB Information\r\n03H EAX Reserved\r\nEBX Reserved\r\nECX Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nEDX Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the \r\nvalue in this register is reserved.)\r\nNOTES: \r\nProcessor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models,\r\nuse the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. \r\nCPUID leaves > 3 < 80000000 are visible only when IA32_MISC_ENABLES.BOOT_NT4[bit 22] = 0 (default).\r\nDeterministic Cache Parameters Leaf \r\n04H NOTES:\r\nLeaf 04H output depends on the initial value in ECX. \r\nSee also: “INPUT EAX = 4: Returns Deterministic Cache Parameters for each level” on page 1-36.\r\nEAX Bits 4-0: Cache Type Field\r\n0 = Null - No more caches\r\n1 = Data Cache \r\n2 = Instruction Cache\r\n3 = Unified Cache\r\n4-31 = Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/f88fab5b-780b-4917-9036-690ba0064dc8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b933ff1c0832010443f079eb4300b44ac5ef44f5213a74a8b9de7c61193e3125",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 352
      },
      {
        "segments": [
          {
            "segment_id": "b41fb2b0-df03-484d-9fd7-d4a15351f5d5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 22,
            "page_width": 612,
            "page_height": 792,
            "content": "1-10 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nBits 7-5: Cache Level (starts at 1) \r\nBits 8: Self Initializing cache level (does not need SW initialization)\r\nBits 9: Fully Associative cache\r\nBits 13-10: Reserved\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this cache*, ** \r\nBits 31-26: Maximum number of addressable IDs for processor cores in the physical \r\npackage*, ***, ****\r\nEBX Bits 11-00: L = System Coherency Line Size*\r\nBits 21-12: P = Physical Line partitions*\r\nBits 31-22: W = Ways of associativity*\r\nECX Bits 31-00: S = Number of Sets*\r\nEDX Bit 0: WBINVD/INVD behavior on lower level caches\r\nBit 10: Write-Back Invalidate/Invalidate\r\n0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads \r\nsharing this cache\r\n1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads \r\nsharing this cache.\r\nBit 1: Cache Inclusiveness\r\n0 = Cache is not inclusive of lower cache levels.\r\n1 = Cache is inclusive of lower cache levels.\r\nBit 2: Complex cache indexing\r\n0 = Direct mapped cache\r\n1 = A complex function is used to index the cache, potentially using\r\nall address bits.\r\nBits 31-03: Reserved = 0\r\nNOTES:\r\n* Add one to the return value to get the result. \r\n** The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique\r\ninitial APIC IDs reserved for addressing different logical processors sharing this cache.\r\n*** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of\r\nunique Core_IDs reserved for addressing different processor cores in a physical package. Core ID is\r\na subset of bits of the initial APIC ID. \r\n****The returned value is constant for valid initial values in ECX. Valid ECX values start from 0. \r\nMONITOR/MWAIT Leaf \r\n05H EAX Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nEBX Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity) \r\nBits 31-16: Reserved = 0\r\nECX Bit 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported\r\nBit 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled\r\nBits 31-02: Reserved \r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b41fb2b0-df03-484d-9fd7-d4a15351f5d5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=87422881106d53ac15907023fc72c10e150f88a387b4119623719937c5f117a4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 384
      },
      {
        "segments": [
          {
            "segment_id": "0a5c0772-571c-44dd-a743-a80d6371d93a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 23,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-11\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 03-00: Number of C0* sub C-states supported using MWait\r\nBits 07-04: Number of C1* sub C-states supported using MWAIT\r\nBits 11-08: Number of C2* sub C-states supported using MWAIT\r\nBits 15-12: Number of C3* sub C-states supported using MWAIT\r\nBits 19-16: Number of C4* sub C-states supported using MWAIT\r\nBits 23-20: Number of C5* sub C-states supported using MWAIT\r\nBits 27-24: Number of C6* sub C-states supported using MWAIT\r\nBits 31-28: Number of C7* sub C-states supported using MWAIT\r\nNOTE:\r\n* The definition of C0 through C7 states for MWAIT extension are processor-specific C-states, not\r\nACPI C-states.\r\nThermal and Power Management Leaf \r\n06H EAX Bit 00: Digital temperature sensor is supported if set\r\nBit 01: Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLE[38]).\r\nBit 02: ARAT. APIC-Timer-always-running feature is supported if set.\r\nBit 03: Reserved \r\nBit 04: PLN. Power limit notification controls are supported if set.\r\nBit 05: ECMD. Clock modulation duty cycle extension is supported if set.\r\nBit 06: PTM. Package thermal management is supported if set.\r\nBit 07: HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, \r\nIA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set.\r\nBit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.\r\nBit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.\r\nBit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.\r\nBit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.\r\nBit 12: Reserved.\r\nBit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs \r\nare supported if set.\r\nBit 14: Intel® Turbo Boost Max Technology 3.0 available.\r\nBit 15: HWP Capabilities. Highest Performance change is supported if set.\r\nBit 16: HWP PECI override is supported if set.\r\nBit 17: Flexible HWP is supported if set. \r\nBit 18: Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.\r\nBit 19: HW_FEEDBACK. IA32_HW_FEEDBACK_PTR, IA32_HW_FEEDBACK_CONFIG, \r\nIA32_PACKAGE_THERM_STATUS bit 26 and IA32_PACKAGE_THERM_INTERRUPT bit 25 are sup\u0002ported if set.\r\nBit 20: Ignoring Idle Logical Processor HWP request is supported if set.\r\nBits 31 - 21: Reserved.\r\nEBX Bits 03-00: Number of Interrupt Thresholds in Digital Thermal Sensor\r\nBits 31-04: Reserved \r\nECX Bit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The \r\ncapability to provide a measure of delivered processor performance (since last reset of the coun\u0002ters), as a percentage of the expected processor performance when running at the TSC frequency.\r\nBits 02-01: Reserved = 0\r\nBit 03: The processor supports performance-energy bias preference if\r\nCPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a\r\nnew architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)\r\nBits 31-04: Reserved = 0\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/0a5c0772-571c-44dd-a743-a80d6371d93a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=74c4a53691de87d7b5febc109c3f2d987b38369eec3ccc88bc5f85db2afdb3d2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 441
      },
      {
        "segments": [
          {
            "segment_id": "19e39260-3eae-47dd-805b-b2abdfa492df",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 24,
            "page_width": 612,
            "page_height": 792,
            "content": "1-12 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 7-0: Bitmap of supported hardware feedback interface capabilities.\r\n0 = When set to 1, indicates support for performance capability reporting.\r\n1 = When set to 1, indicates support for energy efficiency capability reporting.\r\n2-7 = Reserved\r\nBits 11-8: Enumerates the size of the hardware feedback interface structure in number of 4 KB \r\npages using minus-one notation.\r\nBits 31-16: Index (starting at 0) of this logical processor’s row in the hardware feedback interface \r\nstructure. Note that the index may be same for multiple logical processors on some parts. On some \r\nparts the indices may not be contiguous, i.e., there may be unused rows in the table.\r\nNOTE:\r\nBits 0 and 1 will always be set together.\r\nStructured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)\r\n07H NOTES:\r\nLeaf 07H main leaf (ECX = 0). \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. \r\nEAX Bits 31-00: Reports the maximum number sub-leaves that are supported in leaf 07H.\r\nEBX Bit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.\r\nBit 01: IA32_TSC_ADJUST MSR is supported if 1.\r\nBit 02: SGX\r\nBit 03: BMI1\r\nBit 04: HLE\r\nBit 05: AVX2\r\nBit 07: SMEP. Supports Supervisor Mode Execution Protection if 1.\r\nBit 06: Reserved\r\nBit 08: BMI2\r\nBit 09: Supports Enhanced REP MOVSB/STOSB if 1.\r\nBit 10: INVPCID\r\nBit 11: RTM\r\nBit 12: Supports Platform Quality of Service Monitoring (PQM) capability if 1.\r\nBit 13: Deprecates FPU CS and FPU DS values if 1.\r\nBit 14: Intel Memory Protection Extensions\r\nBit 15: Supports Platform Quality of Service Enforcement (PQE) capability if 1.\r\nBit 16: AVX512F\r\nBit 17: AVX512DQ\r\nBit 18: RDSEED\r\nBit 19: ADX\r\nBit 20: SMAP\r\nBit 21: AVX512_IFMA\r\nBit 22: Reserved\r\nBit 23: CLFLUSHOPT\r\nBit 24: CLWB\r\nBit 25: Intel Processor Trace\r\nBit 26: AVX512PF (Intel® Xeon Phi™ only.)\r\nBit 27: AVX512ER (Intel® Xeon Phi™ only.)\r\nBit 28: AVX512CD\r\nBit 29: SHA\r\nBit 30: AVX512BW\r\nBit 31: AVX512VL\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/19e39260-3eae-47dd-805b-b2abdfa492df.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=15b5aa3210a512118cbb34a1eab8abc39e7eee03f24cf4ae5f5ab6eba2214c0c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 345
      },
      {
        "segments": [
          {
            "segment_id": "110e7baf-603e-4a38-a5aa-f276c45427d1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 25,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-13\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nECX Bit 00: PREFETCHWT1 (Intel® Xeon Phi™ only.)\r\nBit 01: AVX512_VBMI\r\nBit 02: UMIP. Supports user-mode instruction prevention if 1.\r\nBit 03: PKU. Supports protection keys for user-mode pages if 1.\r\nBit 04: OSPKE. If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instruc\u0002tions).\r\nBit 05: WAITPKG\r\nBit 06: AVX512_VBMI2\r\nBit 07: Reserved\r\nBit 08: GFNI\r\nBit 09: VAES\r\nBit 10: VPCLMULQDQ\r\nBit 11: AVX512_VNNI\r\nBit 12: AVX512_BITALG\r\nBit 13: Reserved\r\nBit 14: AVX512_VPOPCNTDQ (Intel® Xeon Phi™ only.)\r\nBits 16 -15: Reserved\r\nBits 21-17: The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.\r\nBit 22: RDPID and IA32_TSC_AUX are available if 1.\r\nBits 24 - 23: Reserved\r\nBit 25: CLDEMOTE. Supports cache line demote if 1.\r\nBit 26: Reserved\r\nBit 27: MOVDIRI. Supports MOVDIRI if 1.\r\nBit 28: MOVDIR64B. Supports MOVDIR64B if 1.\r\nBit 29: ENQCMD: Supports Enqueue Stores if 1.\r\nBit 30: SGX_LC. Supports SGX Launch Configuration if 1.\r\nBit 31: Reserved\r\nEDX Bits 01-00: Reserved\r\nBit 02: AVX512_4VNNIW (Intel® Xeon Phi™ only.)\r\nBit 03: AVX512_4FMAPS (Intel® Xeon Phi™ only.)\r\nBit 04: Fast Short REP MOV\r\nBits 07-05: Reserved\r\nBit 08: AVX512_VP2INTERSECT\r\nBits 17-09: Reserved\r\nBit 18: PCONFIG\r\nBits 25-19: Reserved\r\nBit 26: Enumerates support for indirect branch restricted speculation (IBRS) and the indirect branch \r\npredictor barrier (IBPB). Processors that set this bit support the IA32_SPEC_CTRL MSR and the \r\nIA32_PRED_CMD MSR. They allow software to set IA32_SPEC_CTRL[0] (IBRS) and \r\nIA32_PRED_CMD[0] (IBPB).\r\nBit 27: Enumerates support for single thread indirect branch predictors (STIBP). Processors that set \r\nthis bit support the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[1] (STIBP).\r\nBit 28: Reserved\r\nBit 29: Enumerates support for the IA32_ARCH_CAPABILITIES MSR.\r\nBit 30: Enumerates support for the IA32_CORE_CAPABILITIES MSR.\r\nBit 31: Enumerates support for Speculative Store Bypass Disable (SSBD). Processors that set this bit \r\nsupport the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[2] (SSBD).\r\nNOTE:\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/110e7baf-603e-4a38-a5aa-f276c45427d1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=db7aafa751d0a55aaa3123da1a4eb51c083b7141fcd388f4ac3d7112e83ef112",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 367
      },
      {
        "segments": [
          {
            "segment_id": "70aacac0-f366-4ccb-a199-a3f902fb42ec",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 26,
            "page_width": 612,
            "page_height": 792,
            "content": "1-14 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nStructured Extended Feature Enumeration Sub-leaf (EAX = 07H, ECX = 1)\r\n07H NOTES:\r\nLeaf 07H output depends on the initial value in ECX. \r\nIf ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.\r\nEAX This field reports 0 if the sub-leaf index, n, is invalid*.\r\nBits 04-00: Reserved.\r\nBit 05: AVX512_BF16. Vector Neural Network Instructions supporting BFLOAT16 inputs and conver\u0002sion instructions from IEEE single precision.\r\nBits 31-06: Reserved.\r\nEBX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nECX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nStructured Extended Feature Enumeration Sub-leaves (EAX = 07H, ECX = n, n ≥ 2)\r\n07H NOTES:\r\nLeaf 07H output depends on the initial value in ECX. \r\nIf ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.\r\nEAX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEBX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nECX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nDirect Cache Access Information Leaf \r\n09H EAX\r\nEBX\r\nECX\r\nEDX\r\nValue of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)\r\nReserved \r\nReserved \r\nReserved \r\nArchitectural Performance Monitoring Leaf \r\n0AH EAX Bits 07-00: Version ID of architectural performance monitoring\r\nBits 15- 08: Number of general-purpose performance monitoring counter per logical processor\r\nBits 23-16: Bit width of general-purpose, performance monitoring counter \r\nBits 31-24: Length of EBX bit vector to enumerate architectural performance monitoring events\r\nEBX Bit 00: Core cycle event not available if 1\r\nBit 01: Instruction retired event not available if 1\r\nBit 02: Reference cycles event not available if 1\r\nBit 03: Last-level cache reference event not available if 1\r\nBit 04: Last-level cache misses event not available if 1\r\nBit 05: Branch instruction retired event not available if 1\r\nBit 06: Branch mispredict retired event not available if 1\r\nBits 31-07: Reserved = 0\r\nECX\r\nEDX\r\nReserved = 0\r\nBits 04-00: Number of fixed-function performance counters (if Version ID > 1)\r\nBits 12-05: Bit width of fixed-function performance counters (if Version ID > 1)\r\nReserved = 0\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/70aacac0-f366-4ccb-a199-a3f902fb42ec.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3fc049da34a905ccd111edfaf61c038f67bb91b7f3119c89026339687c7db9cf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 420
      },
      {
        "segments": [
          {
            "segment_id": "87e0b407-bb23-4bc4-9fea-f7b028e7e5b0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 27,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-15\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nExtended Topology Enumeration Leaf \r\n0BH NOTES:\r\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the exis\u0002tence of Leaf 1FH before using leaf 0BH.\r\nMost of Leaf 0BH output depends on the initial value in ECX. \r\nThe EDX output of leaf 0BH is always valid and does not vary with input value in ECX.\r\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\r\nFor sub-leaves that returns an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\r\nIf an input value N in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with\r\nECX > N also return 0 in ECX[15:8]\r\nEAX Bits 04-00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level \r\ntype*. All logical processors with the same next level ID share current level.\r\nBits 31-05: Reserved.\r\nEBX Bits 15-00: Number of logical processors at this level type. The number reflects configuration as \r\nshipped by Intel**.\r\nBits 31-16: Reserved.\r\nECX Bits 07-00: Level number. Same value in ECX input.\r\nBits 15-08: Level type***.\r\nBits 31-16: Reserved.\r\nEDX Bits 31-00: x2APIC ID the current logical processor.\r\nNOTES:\r\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\r\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in \r\nthis field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical \r\nprocessors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depend\u0002ing on software and platform hardware configurations.\r\n*** The value of the “level type” field is not related to level numbers in any way, higher “level type” \r\nvalues do not mean higher levels. Level type field has the following encoding:\r\n0: invalid\r\n1: SMT\r\n2: Core\r\n3-255: Reserved\r\nProcessor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)\r\n0DH NOTES:\r\nLeaf 0DH main leaf (ECX = 0). \r\nEAX Bits 31-00: Reports the valid bit fields of the lower 32 bits of the XFEATURE_ENABLED_MASK regis\u0002ter. If a bit is 0, the corresponding bit field in XCR0 is reserved.\r\nBit 00: legacy x87 \r\nBit 01: 128-bit SSE\r\nBit 02: 256-bit AVX\r\nBits 04-03: MPX state\r\nBit 07-05: AVX-512 state\r\nBit 08: Used for IA32_XSS\r\nBit 09: PKRU state\r\nBits 12-10: Reserved.\r\nBit 13: Used for IA32_XSS.\r\nBits 31-14: Reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/87e0b407-bb23-4bc4-9fea-f7b028e7e5b0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=476a0fde028104843384e9e1eb9a5389b63431a29591531828f914adb51337f1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 422
      },
      {
        "segments": [
          {
            "segment_id": "1942f101-b4bc-438a-b6fa-3868d0552ecd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "1-16 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bits 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by \r\nenabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save \r\narea are not enabled.\r\nECX Bit 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the \r\nXSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit \r\nfields in XCR0. \r\nEDX Bit 31-00: Reports the valid bit fields of the upper 32 bits of the XCR0 register. If a bit is 0, the cor\u0002responding bit field in XCR0 is reserved \r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX Bit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nEBX Bits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nECX Bits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 12-10: Reserved.\r\nBit 13: HWP state.\r\nBits 31-14: Reserved.\r\nEDX Bits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-00: The size in bytes (from the offset specified in EBX) of the save area for an extended \r\nstate feature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-00: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31-02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/1942f101-b4bc-438a-b6fa-3868d0552ecd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=71f923ab49ea2b5ea30a5860fd44d5f60ebf967f181f16347468ecb5d653e4a3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 572
      },
      {
        "segments": [
          {
            "segment_id": "1942f101-b4bc-438a-b6fa-3868d0552ecd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 28,
            "page_width": 612,
            "page_height": 792,
            "content": "1-16 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bits 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by \r\nenabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save \r\narea are not enabled.\r\nECX Bit 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the \r\nXSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit \r\nfields in XCR0. \r\nEDX Bit 31-00: Reports the valid bit fields of the upper 32 bits of the XCR0 register. If a bit is 0, the cor\u0002responding bit field in XCR0 is reserved \r\nProcessor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)\r\n0DH EAX Bit 00: XSAVEOPT is available\r\nBit 01: Supports XSAVEC and the compacted form of XRSTOR if set\r\nBit 02: Supports XGETBV with ECX = 1 if set\r\nBit 03: Supports XSAVES/XRSTORS and IA32_XSS if set\r\nBits 31-04: Reserved\r\nEBX Bits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.\r\nECX Bits 31-00: Reports the supported bits of the lower 32 bits of the IA32_XSS MSR. IA32_XSS[n] can \r\nbe set to 1 only if ECX[n] is 1.\r\nBits 07-00: Used for XCR0\r\nBit 08: PT state\r\nBit 09: Used for XCR0\r\nBits 12-10: Reserved.\r\nBit 13: HWP state.\r\nBits 31-14: Reserved.\r\nEDX Bits 31-00: Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] \r\ncan be set to 1 only if EDX[n] is 1.\r\nBits 31-00: Reserved\r\nProcessor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)\r\n0DH NOTES:\r\nLeaf 0DH output depends on the initial value in ECX. \r\nEach sub-leaf index (starting at position 2) is supported if it corresponds to a supported bit in \r\neither the XCR0 register or the IA32_XSS MSR.\r\n* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is \r\ninvalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤\r\n63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].\r\nEAX Bits 31-00: The size in bytes (from the offset specified in EBX) of the save area for an extended \r\nstate feature associated with a valid sub-leaf index, n. This field reports 0 if the sub-leaf index, n, is \r\ninvalid*.\r\nEBX Bits 31-00: The offset in bytes of this extended state component’s save area from the beginning of \r\nthe XSAVE/XRSTOR area.\r\nThis field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.\r\nECX Bit 0 is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is \r\nclear if bit n is instead supported in XCR0.\r\nBit 1 is set if, when the compacted format of an XSAVE area is used, this extended state component \r\nlocated on the next 64-byte boundary following the preceding state component (otherwise, it is \r\nlocated immediately following the preceding state component).\r\nBits 31-02 are reserved.\r\nThis field reports 0 if the sub-leaf index, n, is invalid*.\r\nEDX This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/1942f101-b4bc-438a-b6fa-3868d0552ecd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=71f923ab49ea2b5ea30a5860fd44d5f60ebf967f181f16347468ecb5d653e4a3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 572
      },
      {
        "segments": [
          {
            "segment_id": "8d3de066-23f9-4960-9e6d-2d013aa98da9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 29,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-17\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIntel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource type starting at bit position 1 of EDX.\r\nEAX Reserved.\r\nEBX Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.\r\nECX Reserved.\r\nEDX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache Intel RDT Monitoring if 1.\r\nBits 31-02: Reserved\r\nL3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)\r\n0FH NOTES:\r\nLeaf 0FH output depends on the initial value in ECX. \r\nEAX Reserved.\r\nEBX Bits 31-00: Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes) and \r\nMemory Bandwidth Monitoring (MBM) metrics.\r\nECX Maximum range (zero-based) of RMID of this resource type.\r\nEDX Bit 00: Supports L3 occupancy monitoring if 1.\r\nBit 01: Supports L3 Total Bandwidth monitoring if 1.\r\nBit 02: Supports L3 Local Bandwidth monitoring if 1.\r\nBits 31-03: Reserved\r\nIntel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nSub-leaf index 0 reports valid resource identification (ResID) starting at bit position 1 of EBX.\r\nEAX Reserved.\r\nEBX Bit 00: Reserved.\r\nBit 01: Supports L3 Cache Allocation Technology if 1.\r\nBit 02: Supports L2 Cache Allocation Technology if 1.\r\nBit 03: Supports Memory Bandwidth Allocation if 1.\r\nBits 31-04: Reserved.\r\nECX Reserved.\r\nEDX Reserved.\r\nL3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID =1)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nEAX Bits 04-00: Length of the capacity bit mask for the corresponding ResID using minus-one notation.\r\nBits 31-05: Reserved\r\nEBX Bits 31-00: Bit-granular map of isolation/contention of allocation units.\r\nECX Bit 00: Reserved.\r\nBit 01: Updates of COS should be infrequent if 1.\r\nBit 02: Code and Data Prioritization Technology supported if 1.\r\nBits 31-03: Reserved\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/8d3de066-23f9-4960-9e6d-2d013aa98da9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=59e81de0b108edccbe89e11075a0df696fe982862d249e741b4bbe62819074e1",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 352
      },
      {
        "segments": [
          {
            "segment_id": "936eecc4-256d-4957-afd7-909c53e8c878",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 30,
            "page_width": 612,
            "page_height": 792,
            "content": "1-18 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEDX Bits 15-00: Highest COS number supported for this ResID.\r\nBits 31-16: Reserved\r\nL2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID =2)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nEAX Bits 04 - 00: Length of the capacity bit mask for the corresponding ResID using minus-one notation.\r\nBits 31 - 05: Reserved.\r\nEBX Bits 31 - 00: Bit-granular map of isolation/contention of allocation units.\r\nECX Bits 31 - 00: Reserved.\r\nEDX Bits 15 - 00: Highest COS number supported for this ResID.\r\nBits 31 - 16: Reserved.\r\nMemory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID =3)\r\n10H NOTES:\r\nLeaf 10H output depends on the initial value in ECX. \r\nEAX Bits 11 - 00: Reports the maximum MBA throttling value supported for the corresponding ResID \r\nusing minus-one notation.\r\nBits 31 - 12: Reserved.\r\nEBX Bits 31 - 00: Reserved.\r\nECX Bits 01 - 00: Reserved.\r\nBit 02: Reports whether the response of the delay values is linear. \r\nBits 31 - 03: Reserved.\r\nEDX Bits 15 - 00: Highest COS number supported for this ResID.\r\nBits 31 - 16: Reserved.\r\nIntel® Software Guard Extensions (Intel® SGX) Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nEAX Bit 00: SGX1. If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.\r\nBit 01: SGX2. If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.\r\nBits 04-02: Reserved.\r\nBit 05: If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, \r\nand ESETCONTEXT.\r\nBit 06: If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and \r\nELDUC.\r\nBits 31-07: Reserved. \r\nEBX Bits 31-00: MISCSELECT. Bit vector of supported extended Intel SGX features.\r\nECX Bits 31-00: Reserved.\r\nEDX Bits 07-00: MaxEnclaveSize_Not64. The maximum supported enclave size in non-64-bit mode is \r\n2^(EDX[7:0]).\r\nBits 15-08: MaxEnclaveSize_64. The maximum supported enclave size in 64-bit mode is \r\n2^(EDX[15:8]).\r\nBits 31-16: Reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/936eecc4-256d-4957-afd7-909c53e8c878.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=48b272addfeb14e6289dc79a5d89edd503752b5a345b3de0405d59a3dedd06a8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 363
      },
      {
        "segments": [
          {
            "segment_id": "b40b9ebd-cf4a-401f-b375-41e5ac43427a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 31,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-19\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIntel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nEAX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.\r\nEBX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.\r\nECX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.\r\nEDX Bit 31-00: Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.\r\nIntel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)\r\n12H NOTES:\r\nLeaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1. \r\nFor sub-leaves (ECX = 2 or higher), definition of EDX,ECX,EBX,EAX[31:4] depends on the sub-leaf\r\ntype listed below. \r\nEAX Bit 03-00: Sub-leaf Type\r\n0000b: Indicates this sub-leaf is invalid. \r\n0001b: This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on \r\nthe Enclave Page Cache (EPC) section.\r\nAll other type encodings are reserved.\r\nType 0000b. This sub-leaf is invalid. \r\nEDX:ECX:EBX:EAX return 0.\r\nType 0001b. This sub-leaf enumerates an EPC sections with EDX:ECX, EBX:EAX defined as follows. \r\nEAX[11:04]: Reserved (enumerate 0). \r\nEAX[31:12]: Bits 31:12 of the physical address of the base of the EPC section. \r\nEBX[19:00]: Bits 51:32 of the physical address of the base of the EPC section. \r\nEBX[31:20]: Reserved.\r\nECX[03:00]: EPC section property encoding defined as follows: \r\nIf EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.\r\nIf EAX[3:0] 0001b, then this section has confidentiality and integrity protection.\r\nAll other encodings are reserved.\r\nECX[11:04]: Reserved (enumerate 0). \r\nECX[31:12]: Bits 31:12 of the size of the corresponding EPC section within the Processor \r\nReserved Memory.\r\nEDX[19:00]: Bits 51:32 of the size of the corresponding EPC section within the Processor \r\nReserved Memory. \r\nEDX[31:20]: Reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b40b9ebd-cf4a-401f-b375-41e5ac43427a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=df9bef744a854e8e5597c477189a61346f68a5089fbc1a45cafb33982faf3fa9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 333
      },
      {
        "segments": [
          {
            "segment_id": "ec5da638-48f6-4a48-b71c-000ad5cb710a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 32,
            "page_width": 612,
            "page_height": 792,
            "content": "1-20 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIntel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)\r\n14H NOTES:\r\nLeaf 14H main leaf (ECX = 0). \r\nEAX Bits 31-00: Reports the maximum sub-leaf supported in leaf 14H.\r\nEBX Bit 00: If 1, Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_-\r\nMATCH MSR can be accessed.\r\nBits 01: If 1, Indicates support of Configurable PSB and Cycle-Accurate Mode.\r\nBits 02: If 1, Indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs \r\nacross warm reset.\r\nBits 03: If 1, Indicates support of MTC timing packet and suppression of COFI-based packets.\r\nBit 04: If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_R\u0002TIT_CTL[5] (FUPonPTW), and PTWRITE can generate packets.\r\nBit 05: If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), \r\nenabling Power Event Trace packet generation.\r\nBits 31-06: Reserved \r\nECX Bit 00: If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output \r\nscheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.\r\nBit 01: If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the \r\nMaskOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS.\r\nBits 02: If 1, Indicates support of Single-Range Output scheme.\r\nBits 03: If 1, Indicates support of output to Trace Transport subsystem.\r\nBit 30-04: Reserved\r\nBit 31: If 1, generated packets which contain IP payloads have LIP values, which include the CS base \r\ncomponent.\r\nEDX Bits 31-00: Reserved \r\nIntel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)\r\n14H EAX Bits 02-00: Number of configurable Address Ranges for filtering.\r\nBits 15-03: Reserved\r\nBit 31-16: Bitmap of supported MTC period encodings\r\nEBX Bits 15-00: Bitmap of supported Cycle Threshold value encodings\r\nBit 31-16: Bitmap of supported Configurable PSB frequency encodings\r\nECX Bits 31-00: Reserved\r\nEDX Bits 31-00: Reserved\r\nTime Stamp Counter and Core Crystal Clock Information Leaf \r\n15H NOTES:\r\nIf EBX[31:0] is 0, the TSC and ”core crystal clock” ratio is not enumerated.\r\nEBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock fre\u0002quency.\r\nIf ECX is 0, the core crystal clock frequency is not enumerated.\r\n“TSC frequency” = “core crystal clock frequency” * EBX/EAX.\r\nThe core crystal clock may differ from the reference clock, bus clock, or core clock frequencies.\r\nEAX Bits 31-00: An unsigned integer which is the denominator of the TSC/”core crystal clock” ratio.\r\nEBX Bits 31-00: An unsigned integer which is the numerator of the TSC/”core crystal clock” ratio.\r\nECX Bits 31-00: An unsigned integer which is the nominal frequency of the core crystal clock in Hz.\r\nEDX Bits 31-00: Reserved = 0.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ec5da638-48f6-4a48-b71c-000ad5cb710a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7c3ff72e8ba36b8ad127de4b26d09c472dc32de9d382c7d05c5f2d376183ff4a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 461
      },
      {
        "segments": [
          {
            "segment_id": "addfcb70-b5f3-4168-b5ba-705013a7d659",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 33,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-21\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nProcessor Frequency Information Leaf \r\n16H EAX\r\nEBX\r\nECX\r\nEDX\r\nBits 15-00: Processor Base Frequency (in MHz).\r\nBits 31-16: Reserved =0\r\nBits 15-00: Maximum Frequency (in MHz).\r\nBits 31-16: Reserved = 0\r\nBits 15-00: Bus (Reference) Frequency (in MHz).\r\nBits 31-16: Reserved = 0\r\nReserved \r\nNOTES:\r\n* Data is returned from this interface in accordance with the processor's specification and does not \r\nreflect actual values. Suitable use of this data includes the display of processor information in like \r\nmanner to the processor brand string and for determining the appropriate range to use when \r\ndisplaying processor information e.g. frequency history graphs. The returned information should not \r\nbe used for any other purpose as the returned information does not accurately correlate to \r\ninformation / counters returned by other processor interfaces. \r\nWhile a processor may support the Processor Frequency Information leaf, fields that return a value \r\nof zero are not supported.\r\nSystem-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)\r\n17H NOTES:\r\nLeaf 17H main leaf (ECX = 0).\r\nLeaf 17H output depends on the initial value in ECX.\r\nLeaf 17H sub-leaves 1 through 3 reports SOC Vendor Brand String.\r\nLeaf 17H is valid if MaxSOCID_Index >= 3.\r\nLeaf 17H sub-leaves 4 and above are reserved.\r\nEAX Bits 31-00: MaxSOCID_Index. Reports the maximum input value of supported sub-leaf in leaf 17H.\r\nEBX Bits 15-00: SOC Vendor ID.\r\nBit 16: IsVendorScheme. If 1, the SOC Vendor ID field is assigned via an industry standard \r\nenumeration scheme. Otherwise, the SOC Vendor ID field is assigned by Intel.\r\nBits 31-17: Reserved = 0.\r\nECX Bits 31-00: Project ID. A unique number an SOC vendor assigns to its SOC projects.\r\nEDX Bits 31-00: Stepping ID. A unique number within an SOC project that an SOC vendor assigns.\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)\r\n17H EAX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEBX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nECX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nEDX Bit 31-00: SOC Vendor Brand String. UTF-8 encoded string.\r\nNOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nSOC Vendor Brand String is a UTF-8 encoded string padded with trailing bytes of 00H.\r\nThe complete SOC Vendor Brand String is constructed by concatenating in ascending order of\r\nEAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/addfcb70-b5f3-4168-b5ba-705013a7d659.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6eb3a740da518118b3ab4b52b93f002d1e65ef223feb05e120b5307047b01957",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 420
      },
      {
        "segments": [
          {
            "segment_id": "30bc222b-959c-4061-9451-8e79e7c772f2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 34,
            "page_width": 612,
            "page_height": 792,
            "content": "1-22 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nSystem-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)\r\n17H NOTES:\r\nLeaf 17H output depends on the initial value in ECX.\r\nEAX Bits 31-00: Reserved = 0.\r\nEBX Bits 31-00: Reserved = 0.\r\nECX Bits 31-00: Reserved = 0.\r\nEDX Bits 31-00: Reserved = 0.\r\nDeterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)\r\n18H NOTES:\r\nEach sub-leaf enumerates a different address translations structure. Valid sub-leaves do not need \r\nto be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than \r\nan invalid sub-leaf or than a valid sub-leaf of a higher or lower-level structure. \r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31-00: Reports the maximum input value of supported sub-leaf in leaf 18H.\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07-04: Reserved.\r\nBits 10-08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15-11: Reserved.\r\nBits 31-16: W = Ways of associativity.\r\nECX Bits 31-00: S = Number of Sets.\r\nEDX Bits 04-00: Translation cache type field.\r\n00000b: Null (indicates this sub-leaf is not valid).\r\n00001b: Data TLB.\r\n00010b: Instruction TLB.\r\n00011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07-05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13-09: Reserved.\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31-26: Reserved.\r\nDeterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX ≥ 1)\r\n18H NOTES:\r\nIf ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n \r\nexceeds the value that sub-leaf 0 returns in EAX.\r\n* Add one to the return value to get the result.\r\nEAX Bits 31-00: Reserved.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/30bc222b-959c-4061-9451-8e79e7c772f2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c600c2b5ad35d1b791b73ef8feb23adb8c3ae7671a10301229cd3d20b0244b21",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 377
      },
      {
        "segments": [
          {
            "segment_id": "827464ca-a935-4bff-8aed-7e81adb801fa",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 35,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-23\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX Bit 00: 4K page size entries supported by this structure.\r\nBit 01: 2MB page size entries supported by this structure.\r\nBit 02: 4MB page size entries supported by this structure.\r\nBit 03: 1 GB page size entries supported by this structure.\r\nBits 07-04: Reserved.\r\nBits 10-08: Partitioning (0: Soft partitioning between the logical processors sharing this structure).\r\nBits 15-11: Reserved.\r\nBits 31-16: W = Ways of associativity.\r\nECX Bits 31-00: S = Number of Sets.\r\nEDX Bits 04-00: Translation cache type field.\r\n0000b: Null (indicates this sub-leaf is not valid).\r\n0001b: Data TLB.\r\n0010b: Instruction TLB.\r\n0011b: Unified TLB.\r\nAll other encodings are reserved.\r\nBits 07-05: Translation cache level (starts at 1).\r\nBit 08: Fully associative structure.\r\nBits 13-09: Reserved.\r\nBits 25-14: Maximum number of addressable IDs for logical processors sharing this translation \r\ncache*\r\nBits 31-26: Reserved.\r\nPCONFIG Information Sub-leaf (EAX = 1BH, ECX ≥ 0)\r\n1BH NOTES:\r\nLeaf 1BH is supported if CPUID.(EAX=07H, ECX=0H):EDX[18] = 1.\r\nFor sub-leaves of 1BH, the definition of EDX, ECX, EBX, EAX depends on the sub-leaf type listed \r\nbelow.\r\n* Currently MKTME is the only defined target and is indicated by identifier 1. An identifier of 0 \r\nindicates an invalid target. If MKTME is a supported target, the MKTME_KEY_PROGRAM leaf of \r\nPCONFIG is available.\r\nEAX Bits 11-00: Sub-leaf type\r\n0: Invalid sub-leaf. On an invalid sub-leaf type returned, subsequent sub-leaves are also invalid. \r\nEBX, ECX and EDX all return 0 for this case.\r\n1: Target Identifier. This sub-leaf enumerates PCONFIG targets supported on the platform. \r\nSoftware must scan until an invalid sub-leaf type is returned. EBX, ECX and EDX are defined below \r\nfor this case.\r\nBits 31-12: 0\r\nEBX * Identifier of target 3n+1 (where n is the sub-leaf number, the initial value of ECX).\r\nECX * Identifier of target 3n+2.\r\nEDX * Identifier of target 3n+3.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/827464ca-a935-4bff-8aed-7e81adb801fa.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=76df08cef22a604d5f7885b6240922aff2201ccb12fd20c9c0c8620eac8a27fb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 330
      },
      {
        "segments": [
          {
            "segment_id": "994517d2-dc44-477a-8774-97454cbfcb10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 36,
            "page_width": 612,
            "page_height": 792,
            "content": "1-24 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nV2 Extended Topology Enumeration Leaf \r\n1FH NOTES:\r\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the exis\u0002tence of Leaf 1FH and using this if available.\r\nMost of Leaf 1FH output depends on the initial value in ECX. \r\nThe EDX output of leaf 1FH is always valid and does not vary with input value in ECX.\r\nOutput value in ECX[7:0] always equals input value in ECX[7:0].\r\nSub-leaf index 0 enumerates SMT level. Each subsequent higher sub-leaf index enumerates a \r\nhigher-level topological entity in hierarchical order.\r\nFor sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.\r\n If an input value n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with \r\nECX > n also return 0 in ECX[15:8].\r\nEAX Bits 04 - 00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level \r\ntype*. All logical processors with the same next level ID share current level.\r\nBits 31 - 05: Reserved.\r\nEBX Bits 15 - 00: Number of logical processors at this level type. The number reflects configuration as \r\nshipped by Intel**.\r\nBits 31- 16: Reserved.\r\nECX Bits 07 - 00: Level number. Same value in ECX input.\r\nBits 15 - 08: Level type***.\r\nBits 31 - 16: Reserved.\r\nEDX Bits 31- 00: x2APIC ID the current logical processor.\r\nNOTES:\r\n* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.\r\n** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in \r\nthis field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical \r\nprocessors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depend\u0002ing on software and platform hardware configurations. \r\n*** The value of the “level type” field is not related to level numbers in any way, higher “level type” \r\nvalues do not mean higher levels. Level type field has the following encoding:\r\n0: Invalid.\r\n1: SMT.\r\n2: Core.\r\n3: Module.\r\n4: Tile.\r\n5: Die.\r\n6-255: Reserved.\r\nUnimplemented CPUID Leaf Functions\r\n40000000H \r\n-\r\n4FFFFFFFH\r\nInvalid. No existing or future CPU will return processor identification or feature information if the \r\ninitial EAX value is in the range 40000000H to 4FFFFFFFH.\r\nExtended Function CPUID Information\r\n80000000H EAX Maximum Input Value for Extended Function CPUID Information (see Table 1-6).\r\nEBX\r\nECX\r\nEDX\r\nReserved\r\nReserved\r\nReserved\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/994517d2-dc44-477a-8774-97454cbfcb10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a0faa61e203935b4cd4807c929461a9dd09be4858ed866128d172d6386c033be",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 427
      },
      {
        "segments": [
          {
            "segment_id": "e48299ef-740f-4506-970b-08984d72be33",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 37,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-25\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n80000001H EAX\r\nEBX\r\nECX\r\nExtended Processor Signature and Feature Bits.\r\nReserved\r\nBit 00: LAHF/SAHF available in 64-bit mode\r\nBits 04-01: Reserved\r\nBit 05: LZCNT available\r\nBits 07-06: Reserved\r\nBit 08: PREFETCHW\r\nBits 31-09: Reserved\r\nEDX Bits 10-00: Reserved\r\nBit 11: SYSCALL/SYSRET available (when in 64-bit mode)\r\nBits 19-12: Reserved = 0\r\nBit 20: Execute Disable Bit available\r\nBits 25-21: Reserved = 0\r\nBit 26: 1-GByte pages are available if 1\r\nBit 27: RDTSCP and IA32_TSC_AUX are available if 1\r\nBits 28: Reserved = 0\r\nBit 29: Intel® 64 Architecture available if 1\r\nBits 31-30: Reserved = 0\r\n80000002H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000003H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000004H EAX\r\nEBX\r\nECX\r\nEDX\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\nProcessor Brand String Continued\r\n80000005H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\n80000006H EAX\r\nEBX\r\nReserved = 0\r\nReserved = 0\r\nECX\r\nEDX\r\nBits 07-00: Cache Line size in bytes\r\nBits 11-08: Reserved\r\nBits 15-12: L2 Associativity field *\r\nBits 31-16: Cache size in 1K units\r\nReserved = 0\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e48299ef-740f-4506-970b-08984d72be33.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f609c2b65ad92c010557ade27f3644112ff6ab89720b740e2b825a2f515395c8",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 239
      },
      {
        "segments": [
          {
            "segment_id": "4c432e2e-b90e-4793-ac10-6bcd3967f7b9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 38,
            "page_width": 612,
            "page_height": 792,
            "content": "1-26 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0H: Returns CPUID’s Highest Value for Basic Processor Information and the Vendor Identification \r\nString\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the CPUID recognizes for \r\nreturning basic processor information. The value is returned in the EAX register (see Table 1-6) and is processor \r\nspecific.\r\nA vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is “Genu\u0002ineIntel” and is expressed:\r\nEBX ← 756e6547h (* \"Genu\", with G in the low 4 bits of BL *)\r\nEDX ← 49656e69h (* \"ineI\", with i in the low 4 bits of DL *)\r\nECX ← 6c65746eh (* \"ntel\", with n in the low 4 bits of CL *)\r\nINPUT EAX = 80000000H: Returns CPUID’s Highest Value for Extended Processor Information\r\nWhen CPUID executes with EAX set to 0H, the processor returns the highest value the processor recognizes for \r\nreturning extended processor information. The value is returned in the EAX register (see Table 1-6) and is \r\nprocessor specific.\r\nNOTES:\r\n* L2 associativity field encodings:\r\n00H - Disabled 08H - 16 ways\r\n01H - 1 way (direct mapped) 09H - Reserved\r\n02H - 2 ways 0AH - 32 ways\r\n03H - Reserved 0BH - 48 ways\r\n04H - 4 ways 0CH - 64 ways\r\n05H - Reserved 0DH - 96 ways\r\n06H - 8 ways 0EH - 128 ways\r\n07H - See CPUID leaf 04H, sub-leaf 2** 0FH - Fully associative\r\n** CPUID leaf 04H provides details of deterministic cache parameters, including the L2 cache in sub\u0002leaf 2\r\n80000007H EAX\r\nEBX\r\nECX\r\nEDX\r\nReserved = 0\r\nReserved = 0\r\nReserved = 0\r\nBits 07-00: Reserved = 0\r\nBit 08: Invariant TSC available if 1\r\nBits 31-09: Reserved = 0\r\n80000008H EAX Virtual/Physical Address size \r\nBits 07-00: #Physical Address Bits*\r\nBits 15-08: #Virtual Address Bits\r\nBits 31-16: Reserved = 0\r\nEBX\r\nECX\r\nEDX\r\nBits 08-00: Reserved = 0\r\nBit 09: WBNOINVD is available if 1\r\nBits 31-10: Reserved = 0\r\nReserved = 0\r\nReserved = 0\r\nNOTES:\r\n* If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported\r\nshould come from this field.\r\nTable 1-5. Information Returned by CPUID Instruction(Continued)\r\nInitial EAX \r\nValue Information Provided about the Processor",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4c432e2e-b90e-4793-ac10-6bcd3967f7b9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=51b0bebbe7f7b61f888a746abca1263b412d99b63476baa3d2586b6df6a4f8e2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 379
      },
      {
        "segments": [
          {
            "segment_id": "b07a89cb-7b6a-4b4d-8850-ad9c931e7197",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 39,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-27\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nIA32_BIOS_SIGN_ID Returns Microcode Update Signature\r\nFor processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update \r\nsignature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 10 in \r\nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. \r\nINPUT EAX = 01H: Returns Model, Family, Stepping Information\r\nWhen CPUID executes with EAX set to 01H, version information is returned in EAX (see Figure 1-3). For example: \r\nmodel, family, and processor type for the Intel Xeon processor 5100 series is as follows:\r\n• Model — 1111B\r\n• Family — 0101B\r\n• Processor Type — 00B\r\nSee Table 1-7 for available processor type values. Stepping IDs are provided as needed.\r\nTable 1-6. Highest CPUID Source Operand for Intel 64 and IA-32 Processors \r\nIntel 64 or IA-32 Processors Highest Value in EAX\r\nBasic Information Extended Function Information\r\nEarlier Intel486 Processors CPUID Not Implemented CPUID Not Implemented\r\nLater Intel486 Processors and Pentium \r\nProcessors\r\n01H Not Implemented\r\nPentium Pro and Pentium II Processors, \r\nIntel®\r\n Celeron® Processors\r\n02H Not Implemented\r\nPentium III Processors 03H Not Implemented\r\nPentium 4 Processors 02H 80000004H\r\nIntel Xeon Processors 02H 80000004H\r\nPentium M Processor 02H 80000004H\r\nPentium 4 Processor supporting Hyper\u0002Threading Technology05H 80000008H\r\nPentium D Processor (8xx) 05H 80000008H\r\nPentium D Processor (9xx) 06H 80000008H\r\nIntel Core Duo Processor 0AH 80000008H\r\nIntel Core 2 Duo Processor 0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5300 \r\nSeries\r\n0AH 80000008H\r\nIntel Xeon Processor 3000, 5100, 5200, \r\n5300, 5400 Series\r\n0AH 80000008H\r\nIntel Core 2 Duo Processor 8000 Series 0DH 80000008H\r\nIntel Xeon Processor 5200, 5400 Series 0AH 80000008H",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b07a89cb-7b6a-4b4d-8850-ad9c931e7197.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=11fc1ec7d1d719af79d7bfadd310c994b431092d5b32f9bfa829eb812222da5f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 277
      },
      {
        "segments": [
          {
            "segment_id": "80b42d8e-8d8f-4955-b5a8-3c7852d2a713",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 40,
            "page_width": 612,
            "page_height": 792,
            "content": "1-28 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nNOTE\r\nSee \"Caching Translation Information\" in Chapter 4, “Paging,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A, and Chapter 16 in the Intel® 64 and IA-32 Archi\u0002tectures Software Developer’s Manual, Volume 1, for information on identifying earlier IA-32 \r\nprocessors.\r\nThe Extended Family ID needs to be examined only when the Family ID is 0FH. Integrate the fields into a display \r\nusing the following rule:\r\nIF Family_ID ≠ 0FH\r\nTHEN Displayed_Family = Family_ID;\r\nELSE Displayed_Family = Extended_Family_ID + Family_ID;\r\n(* Right justify and zero-extend 4-bit field. *)\r\nFI;\r\n(* Show Display_Family as HEX field. *)\r\nThe Extended Model ID needs to be examined only when the Family ID is 06H or 0FH. Integrate the field into a \r\ndisplay using the following rule:\r\nIF (Family_ID = 06H or Family_ID = 0FH)\r\nTHEN Displayed_Model = (Extended_Model_ID << 4) + Model_ID;\r\n(* Right justify and zero-extend 4-bit field; display Model_ID as HEX field.*)\r\nELSE Displayed_Model = Model_ID;\r\nFI;\r\n(* Show Display_Model as HEX field. *)\r\nINPUT EAX = 01H: Returns Additional Information in EBX\r\nWhen CPUID executes with EAX set to 01H, additional information is returned to the EBX register: \r\nFigure 1-3. Version Information Returned by CPUID in EAX\r\nTable 1-7. Processor Type Field\r\nType Encoding\r\nOriginal OEM Processor 00B\r\nIntel OverDrive® Processor 01B\r\nDual processor (not applicable to Intel486 processors) 10B\r\nIntel reserved 11B\r\nProcessor Type \r\n31 28 27 20 19 16 15 14 13 12 11 8 7 4 3 0\r\nEAX\r\nFamily (0FH for the Pentium 4 Processor Family)\r\nModel \r\nExtended\r\nFamily ID\r\nExtended\r\nModel ID\r\nFamily\r\nID Model Stepping\r\nID\r\nExtended Family ID (0)\r\nExtended Model ID (0)\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/80b42d8e-8d8f-4955-b5a8-3c7852d2a713.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5abe85fa14f5b734db756e0d4bf45be1572507ec139f1e8055018698cb55df10",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 284
      },
      {
        "segments": [
          {
            "segment_id": "bd37ed50-098d-4d46-a15a-2690cfb6b32f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 41,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-29\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n• Brand index (low byte of EBX) — this number provides an entry into a brand string table that contains brand \r\nstrings for IA-32 processors. More information about this field is provided later in this section. \r\n• CLFLUSH instruction cache line size (second byte of EBX) — this number indicates the size of the cache line \r\nflushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.\r\n• Local APIC ID (high byte of EBX) — this number is the 8-bit ID that is assigned to the local APIC on the \r\nprocessor during power up. This field was introduced in the Pentium 4 processor.\r\nINPUT EAX = 01H: Returns Feature Information in ECX and EDX\r\nWhen CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX.\r\n• Figure 1-4 and Table 1-8 show encodings for ECX.\r\n• Figure 1-5 and Table 1-9 show encodings for EDX.\r\nFor all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.\r\nNOTE\r\nSoftware must confirm that a processor feature is present using feature flags returned by CPUID \r\nprior to using the feature. Software should not depend on future offerings retaining all features.\r\nFigure 1-4. Feature Information Returned in the ECX Register\r\nCNXT-ID — L1 Context ID\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nECX\r\nTM2 — Thermal Monitor 2\r\nEST — Enhanced Intel SpeedStep® Technology\r\nDS-CPL — CPL Qualified Debug Store\r\nMONITOR — MONITOR/MWAIT\r\nPCLMULQDQ — Carryless Multiplication\r\nReserved\r\nCMPXCHG16B\r\nSMX — Safer Mode Extensions\r\nxTPR Update Control\r\nSSSE3 — SSSE3 Extensions\r\nPDCM — Perf/Debug Capability MSR\r\nVMX — Virtual Machine Extensions\r\nSSE4_1 — SSE4.1\r\nOSXSAVE\r\nSSE4_2 — SSE4.2\r\nDCA — Direct Cache Access\r\nx2APIC\r\nPOPCNT\r\nXSAVE\r\nAVX\r\nAES\r\nFMA — Fused Multiply Add\r\nSSE3 — SSE3 Extensions\r\nPCID — Process-context Identifiers\r\n0\r\nDTES64 — 64-bit DS Area\r\nMOVBE\r\nTSC-Deadline\r\nF16C\r\nRDRAND\r\nSDBG",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/bd37ed50-098d-4d46-a15a-2690cfb6b32f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2cd2b3eb4458e51b5a77cdd3ff8ce58749e43befe00032fbfb61965656860335",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 353
      },
      {
        "segments": [
          {
            "segment_id": "43c2a746-d71a-40f6-a96d-b27dd6fc451f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "1-30 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-8. Feature Information Returned in the ECX Register \r\nBit # Mnemonic Description\r\n0 SSE3 Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\r\n1 PCLMULQDQ A value of 1 indicates the processor supports PCLMULQDQ instruction.\r\n2 DTES64 64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout.\r\n3 MONITOR MONITOR/MWAIT. A value of 1 indicates the processor supports this feature. \r\n4 DS-CPL CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the \r\nDebug Store feature to allow for branch message storage qualified by CPL.\r\n5 VMX Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.\r\n6 SMX Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See \r\nChapter 6, “Safer Mode Extensions Reference”.\r\n7 EST Enhanced Intel SpeedStep® Technology. A value of 1 indicates that the processor supports this \r\ntechnology.\r\n8 TM2 Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology. \r\n9 SSSE3 A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A \r\nvalue of 0 indicates the instruction extensions are not present in the processor.\r\n10 CNXT-ID L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or \r\nshared mode. A value of 0 indicates this feature is not supported. See definition of the \r\nIA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\r\n11 SDBG A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.\r\n12 FMA A value of 1 indicates the processor supports FMA extensions using YMM state.\r\n13 CMPXCHG16B CMPXCHG16B Available. A value of 1 indicates that the feature is available.\r\n14 xTPR Update \r\nControl\r\nxTPR Update Control. A value of 1 indicates that the processor supports changing \r\nIA32_MISC_ENABLES[bit 23]. \r\n15 PDCM Perfmon and Debug Capability. A value of 1 indicates the processor supports the performance and \r\ndebug feature indication MSR IA32_PERF_CAPABILITIES.\r\n16 Reserved Reserved\r\n17 PCID Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and that \r\nsoftware may set CR4.PCIDE to 1.\r\n18 DCA A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped \r\ndevice.\r\n19 SSE4.1 A value of 1 indicates that the processor supports SSE4.1. \r\n20 SSE4.2 A value of 1 indicates that the processor supports SSE4.2. \r\n21 x2APIC A value of 1 indicates that the processor supports x2APIC feature.\r\n22 MOVBE A value of 1 indicates that the processor supports MOVBE instruction.\r\n23 POPCNT A value of 1 indicates that the processor supports the POPCNT instruction.\r\n24 TSC-Deadline A value of 1 indicates that the processor’s local APIC timer supports one-shot operation using a TSC \r\ndeadline value.\r\n25 AES A value of 1 indicates that the processor supports the AESNI instruction extensions.\r\n26 XSAVE A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states \r\nfeature, the XSETBV/XGETBV instructions, and XCR0.\r\n27 OSXSAVE A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV \r\ninstructions to access XCR0 and to support processor extended state management using \r\nXSAVE/XRSTOR.\r\n28 AVX A value of 1 indicates that processor supports AVX instructions operating on 256-bit YMM state, and \r\nthree-operand encoding of 256-bit and 128-bit SIMD instructions.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/43c2a746-d71a-40f6-a96d-b27dd6fc451f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b3171cbea854dac2e018c336003bff5cc5e51ab4cb60ab0b160bf9c233369cd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 575
      },
      {
        "segments": [
          {
            "segment_id": "43c2a746-d71a-40f6-a96d-b27dd6fc451f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 42,
            "page_width": 612,
            "page_height": 792,
            "content": "1-30 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-8. Feature Information Returned in the ECX Register \r\nBit # Mnemonic Description\r\n0 SSE3 Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\r\n1 PCLMULQDQ A value of 1 indicates the processor supports PCLMULQDQ instruction.\r\n2 DTES64 64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout.\r\n3 MONITOR MONITOR/MWAIT. A value of 1 indicates the processor supports this feature. \r\n4 DS-CPL CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the \r\nDebug Store feature to allow for branch message storage qualified by CPL.\r\n5 VMX Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology.\r\n6 SMX Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See \r\nChapter 6, “Safer Mode Extensions Reference”.\r\n7 EST Enhanced Intel SpeedStep® Technology. A value of 1 indicates that the processor supports this \r\ntechnology.\r\n8 TM2 Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology. \r\n9 SSSE3 A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A \r\nvalue of 0 indicates the instruction extensions are not present in the processor.\r\n10 CNXT-ID L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or \r\nshared mode. A value of 0 indicates this feature is not supported. See definition of the \r\nIA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\r\n11 SDBG A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.\r\n12 FMA A value of 1 indicates the processor supports FMA extensions using YMM state.\r\n13 CMPXCHG16B CMPXCHG16B Available. A value of 1 indicates that the feature is available.\r\n14 xTPR Update \r\nControl\r\nxTPR Update Control. A value of 1 indicates that the processor supports changing \r\nIA32_MISC_ENABLES[bit 23]. \r\n15 PDCM Perfmon and Debug Capability. A value of 1 indicates the processor supports the performance and \r\ndebug feature indication MSR IA32_PERF_CAPABILITIES.\r\n16 Reserved Reserved\r\n17 PCID Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and that \r\nsoftware may set CR4.PCIDE to 1.\r\n18 DCA A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped \r\ndevice.\r\n19 SSE4.1 A value of 1 indicates that the processor supports SSE4.1. \r\n20 SSE4.2 A value of 1 indicates that the processor supports SSE4.2. \r\n21 x2APIC A value of 1 indicates that the processor supports x2APIC feature.\r\n22 MOVBE A value of 1 indicates that the processor supports MOVBE instruction.\r\n23 POPCNT A value of 1 indicates that the processor supports the POPCNT instruction.\r\n24 TSC-Deadline A value of 1 indicates that the processor’s local APIC timer supports one-shot operation using a TSC \r\ndeadline value.\r\n25 AES A value of 1 indicates that the processor supports the AESNI instruction extensions.\r\n26 XSAVE A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states \r\nfeature, the XSETBV/XGETBV instructions, and XCR0.\r\n27 OSXSAVE A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV \r\ninstructions to access XCR0 and to support processor extended state management using \r\nXSAVE/XRSTOR.\r\n28 AVX A value of 1 indicates that processor supports AVX instructions operating on 256-bit YMM state, and \r\nthree-operand encoding of 256-bit and 128-bit SIMD instructions.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/43c2a746-d71a-40f6-a96d-b27dd6fc451f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4b3171cbea854dac2e018c336003bff5cc5e51ab4cb60ab0b160bf9c233369cd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 575
      },
      {
        "segments": [
          {
            "segment_id": "4a4a28bf-81f9-408c-884b-73302e4f96c0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 43,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-31\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n29 F16C A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.\r\n30 RDRAND A value of 1 indicates that processor supports RDRAND instruction.\r\n31 Not Used Always return 0.\r\nFigure 1-5. Feature Information Returned in the EDX Register\r\nTable 1-9. More on Feature Information Returned in the EDX Register\r\nBit # Mnemonic Description\r\n0 FPU Floating-point Unit On-Chip. The processor contains an x87 FPU.\r\n1 VME Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the \r\nfeature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS \r\nwith the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags. \r\n2 DE Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional \r\ntrapping of accesses to DR4 and DR5. \r\nTable 1-8. Feature Information Returned in the ECX Register (Continued)\r\nBit # Mnemonic Description\r\nPBE–Pend. Brk. EN.\r\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r\nEDX\r\nTM–Therm. Monitor\r\nHTT–Multi-threading\r\nSS–Self Snoop\r\nSSE2–SSE2 Extensions\r\nSSE–SSE Extensions\r\nFXSR–FXSAVE/FXRSTOR\r\nMMX–MMX Technology\r\nACPI–Thermal Monitor and Clock Ctrl\r\nDS–Debug Store\r\nCLFSH–CFLUSH instruction\r\nPSN–Processor Serial Number\r\nPSE-36 – Page Size Extension\r\nPAT–Page Attribute Table\r\nCMOV–Conditional Move/Compare Instruction\r\nMCA–Machine Check Architecture\r\nPGE–PTE Global Bit\r\nMTRR–Memory Type Range Registers\r\nSEP–SYSENTER and SYSEXIT\r\nAPIC–APIC on Chip\r\nCX8–CMPXCHG8B Inst.\r\nMCE–Machine Check Exception\r\nPAE–Physical Address Extensions\r\nMSR–RDMSR and WRMSR Support\r\nTSC–Time Stamp Counter\r\nPSE–Page Size Extensions\r\nDE–Debugging Extensions\r\nVME–Virtual-8086 Mode Enhancement\r\nFPU–x87 FPU on Chip\r\nReserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4a4a28bf-81f9-408c-884b-73302e4f96c0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=489cbed71c2a35b9e66e5305883eab34340334fc348931c6f47df93baf12894c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 269
      },
      {
        "segments": [
          {
            "segment_id": "9ff74abd-5fca-44a1-974e-56619dbc01f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "1-32 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n3 PSE Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the \r\nfeature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and \r\nPTEs. \r\n4 TSC Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\r\n5 MSR Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are \r\nsupported. Some of the MSRs are implementation dependent.\r\n6 PAE Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 MCE Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 APIC APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 MCA Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 3C).\r\nTable 1-9. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/9ff74abd-5fca-44a1-974e-56619dbc01f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=830758632f824ef7e268e91aa9e4d431794fe49a3c8e80b103414956f3b8bed7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 622
      },
      {
        "segments": [
          {
            "segment_id": "9ff74abd-5fca-44a1-974e-56619dbc01f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 44,
            "page_width": 612,
            "page_height": 792,
            "content": "1-32 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n3 PSE Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the \r\nfeature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and \r\nPTEs. \r\n4 TSC Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\r\n5 MSR Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are \r\nsupported. Some of the MSRs are implementation dependent.\r\n6 PAE Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table \r\nentry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of \r\n4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is \r\nimplementation specific. \r\n7 MCE Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the \r\nfeature. This feature does not define the model-specific implementations of machine-check error logging, \r\nreporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor \r\nversion to do model specific processing of the exception, or test for the presence of the Machine Check \r\nfeature.\r\n8 CX8 CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly \r\nlocked and atomic). \r\n9 APIC APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to \r\nmemory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some \r\nprocessors permit the APIC to be relocated). \r\n10 Reserved Reserved \r\n11 SEP SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. \r\n12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe \r\nwhat memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are \r\nsupported. \r\n13 PGE Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries \r\nthat are common to different processes and need not be flushed. The CR4.PGE bit controls this feature. \r\n14 MCA Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for \r\nerror reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The \r\nMCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported. \r\n15 CMOV Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is \r\npresent as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported \r\n16 PAT Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range \r\nRegisters (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear \r\naddress on a 4KB granularity.\r\n17 PSE-36 36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported \r\nwith 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are \r\nencoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and \r\nmay be up to 40 bits in size.\r\n18 PSN Processor Serial Number. The processor supports the 96-bit processor identification number feature and the \r\nfeature is enabled.\r\n19 CLFSH CLFLUSH Instruction. CLFLUSH Instruction is supported.\r\n20 Reserved Reserved\r\n21 DS Debug Store. The processor supports the ability to write debug information into a memory resident buffer. \r\nThis feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see \r\nChapter 23, “Introduction to Virtual-Machine Extensions,” in the Intel® 64 and IA-32 Architectures \r\nSoftware Developer’s Manual, Volume 3C).\r\nTable 1-9. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/9ff74abd-5fca-44a1-974e-56619dbc01f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=830758632f824ef7e268e91aa9e4d431794fe49a3c8e80b103414956f3b8bed7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 622
      },
      {
        "segments": [
          {
            "segment_id": "fe30903d-ecd4-47db-9d22-0bcf3ba8cd59",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-33\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal \r\ncaches and TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 1-10 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n22 ACPI Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 FXSR FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31 PBE Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 1-10. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\nTable 1-9. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/fe30903d-ecd4-47db-9d22-0bcf3ba8cd59.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c1ea17d69d1f5839cd32e8c7a4bd09ac03a04d9ee718cd8e264fc7d3bc04402e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 589
      },
      {
        "segments": [
          {
            "segment_id": "fe30903d-ecd4-47db-9d22-0bcf3ba8cd59",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 45,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-33\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 02H: Cache and TLB Information Returned in EAX, EBX, ECX, EDX\r\nWhen CPUID executes with EAX set to 02H, the processor returns information about the processor’s internal \r\ncaches and TLBs in the EAX, EBX, ECX, and EDX registers. \r\nThe encoding is as follows:\r\n• The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction \r\nmust be executed with an input value of 02H to get a complete description of the processor’s caches and TLBs. \r\nThe first member of the family of Pentium 4 processors will return a 01H.\r\n• The most significant bit (bit 31) of each register indicates whether the register contains valid information (set \r\nto 0) or is reserved (set to 1).\r\n• If a register contains valid information, the information is contained in 1 byte descriptors. Table 1-10 shows the \r\nencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not \r\ndefined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The \r\ndescriptors may appear in any order.\r\n22 ACPI Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that \r\nallow processor temperature to be monitored and processor performance to be modulated in predefined duty \r\ncycles under software control.\r\n23 MMX Intel MMX Technology. The processor supports the Intel MMX technology.\r\n24 FXSR FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and \r\nrestore of the floating-point context. Presence of this bit also indicates that CR4.OSFXSR is available for an \r\noperating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\r\n25 SSE SSE. The processor supports the SSE extensions.\r\n26 SSE2 SSE2. The processor supports the SSE2 extensions.\r\n27 SS Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of \r\nits own cache structure for transactions issued to the bus.\r\n28 HTT Max APIC IDs reserved field is Valid. A value of 0 for HTT indicates there is only a single logical processor in \r\nthe package and software should assume only a single APIC ID is reserved. A value of 1 for HTT indicates the \r\nvalue in CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical processors in this package) is \r\nvalid for the package.\r\n29 TM Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\r\n30 Reserved Reserved\r\n31 PBE Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the \r\nstop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the \r\nprocessor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the \r\nIA32_MISC_ENABLE MSR enables this capability.\r\nTable 1-10. Encoding of Cache and TLB Descriptors \r\nDescriptor Value Cache or TLB Description\r\n00H Null descriptor\r\n01H Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries\r\n02H Instruction TLB: 4 MByte pages, 4-way set associative, 2 entries\r\n03H Data TLB: 4 KByte pages, 4-way set associative, 64 entries\r\n04H Data TLB: 4 MByte pages, 4-way set associative, 8 entries\r\n05H Data TLB1: 4 MByte pages, 4-way set associative, 32 entries\r\n06H 1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\r\n08H 1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\r\nTable 1-9. More on Feature Information Returned in the EDX Register(Continued)\r\nBit # Mnemonic Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/fe30903d-ecd4-47db-9d22-0bcf3ba8cd59.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c1ea17d69d1f5839cd32e8c7a4bd09ac03a04d9ee718cd8e264fc7d3bc04402e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 589
      },
      {
        "segments": [
          {
            "segment_id": "af51c65c-c692-4af5-8c04-f3821141aa2f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "1-34 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 1-10. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/af51c65c-c692-4af5-8c04-f3821141aa2f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6ad5779569cf7d13534517cf19bde56f5440dd5c8148ead2f2680e9b91082f7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 527
      },
      {
        "segments": [
          {
            "segment_id": "af51c65c-c692-4af5-8c04-f3821141aa2f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 46,
            "page_width": 612,
            "page_height": 792,
            "content": "1-34 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n0AH 1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\r\n0BH Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\r\n0CH 1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\r\n22H 3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\r\n23H 3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n25H 3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n29H 3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\r\n2CH 1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n30H 1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size\r\n40H No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\r\n41H 2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\r\n42H 2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\r\n43H 2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\r\n44H 2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\r\n45H 2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\r\n46H 3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size\r\n47H 3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size\r\n49H 3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H);\r\n2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size\r\n4AH 3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\r\n4BH 3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\r\n4CH 3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\r\n4DH 3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\r\n4EH 2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\r\n50H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\r\n51H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\r\n52H Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\r\n56H Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\r\n57H Data TLB0: 4 KByte pages, 4-way associative, 16 entries\r\n5BH Data TLB: 4 KByte and 4 MByte pages, 64 entries\r\n5CH Data TLB: 4 KByte and 4 MByte pages,128 entries\r\n5DH Data TLB: 4 KByte and 4 MByte pages,256 entries\r\n60H 1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\r\n66H 1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\r\n67H 1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\r\n68H 1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\r\n70H Trace cache: 12 K-μop, 8-way set associative\r\n71H Trace cache: 16 K-μop, 8-way set associative\r\n72H Trace cache: 32 K-μop, 8-way set associative\r\n78H 2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\r\n79H 2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\nTable 1-10. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/af51c65c-c692-4af5-8c04-f3821141aa2f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c6ad5779569cf7d13534517cf19bde56f5440dd5c8148ead2f2680e9b91082f7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 527
      },
      {
        "segments": [
          {
            "segment_id": "069605d8-eaa2-442a-b4d2-abe65c1e55dc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 47,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-35\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nExample 1-1. Example of Cache and TLB Interpretation\r\nThe first member of the family of Pentium 4 processors returns the following information about caches and TLBs \r\nwhen the CPUID executes with an input value of 2:\r\nEAX 66 5B 50 01H\r\nEBX 0H\r\nECX 0H\r\nEDX 00 7A 70 00H\r\nWhich means:\r\n• The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed \r\nonce with an input value of 2 to retrieve complete information about caches and TLBs.\r\n• The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register \r\ncontains valid 1-byte descriptors.\r\n• Bytes 1, 2, and 3 of register EAX indicate that the processor has:\r\n— 50H - a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages.\r\n— 5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages.\r\n— 66H - an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.\r\n• The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.\r\n• Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has:\r\n— 00H - NULL descriptor.\r\n— 70H - Trace cache: 12 K-μop, 8-way set associative.\r\n— 7AH - a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size.\r\n— 00H - NULL descriptor.\r\n7AH 2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7BH 2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7CH 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\r\n7DH 2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\r\n7FH 2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\r\n82H 2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\r\n83H 2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size\r\n84H 2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size\r\n85H 2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size\r\n86H 2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size\r\n87H 2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size\r\nB0H Instruction TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB1H Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries\r\nB3H Data TLB: 4 KByte pages, 4-way set associative, 128 entries\r\nB4H Data TLB1: 4 KByte pages, 4-way associative, 256 entries\r\nF0H 64-Byte prefetching\r\nF1H 128-Byte prefetching\r\nTable 1-10. Encoding of Cache and TLB Descriptors (Continued)\r\nDescriptor Value Cache or TLB Description",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/069605d8-eaa2-442a-b4d2-abe65c1e55dc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=05b401baa1b684ad321eb90a864b8a8b992b951eddcbf5d11661b4421fa42344",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 460
      },
      {
        "segments": [
          {
            "segment_id": "d3cdadb5-97f2-4ff1-9c60-d4b537ffbcba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "1-36 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\r\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data \r\nthat describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid \r\nindex values start from 0.\r\nSoftware can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an \r\nindex value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally \r\ndefined fields reported by deterministic cache parameters are documented in Table 1-5.\r\nThe CPUID leaf 4 also reports data that can be used to derive the topology of processor cores in a physical package. \r\nThis information is constant for all valid index values. Software can query the raw data reported by executing \r\nCPUID with EAX=04H and ECX=0H and use it as part of the topology enumeration algorithm described in Chapter \r\n8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A.\r\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features\r\nWhen CPUID executes with EAX set to 05H, the processor returns information about features available to \r\nMONITOR/MWAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with \r\nMWAIT instruction. The MWAIT instruction optionally provides additional extensions for advanced power manage\u0002ment. See Table 1-5. \r\nINPUT EAX = 06H: Returns Thermal and Power Management Features\r\nWhen CPUID executes with EAX set to 06H, the processor returns information about thermal and power manage\u0002ment features. See Table 1-5. \r\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information\r\nWhen CPUID executes with EAX set to 07H and ECX = 0H, the processor returns information about the maximum \r\nnumber of sub-leaves that contain extended feature flags. See Table 1-5. \r\nWhen CPUID executes with EAX set to 07H and ECX = n (n > 1and less than the number of non-zero bits in \r\nCPUID.(EAX=07H, ECX= 0H).EAX, the processor returns information about extended feature flags. See Table 1-5. \r\nIn sub-leaf 0, only EAX has the number of sub-leaves. In sub-leaf 0, EBX, ECX & EDX all contain extended feature \r\nflags.\r\nINPUT EAX = 09H: Returns Direct Cache Access Information\r\nWhen CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabili\u0002ties. See Table 1-5. \r\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features\r\nWhen CPUID executes with EAX set to 0AH, the processor returns information about support for architectural \r\nperformance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see Table \r\n1-5) is greater than Pn 0. See Table 1-5.\r\nFor each version of architectural performance monitoring capability, software must enumerate this leaf to discover \r\nthe programming facilities and the architectural performance events available in the processor. The details are \r\ndescribed in Chapter 17, “Debug, Branch Profile, TSC, and Quality of Service,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A.\r\nINPUT EAX = 0BH: Returns Extended Topology Information\r\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of Leaf 1FH \r\nbefore using leaf 0BH.\r\nWhen CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumera\u0002tion data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported \r\nby CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 1-5.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/d3cdadb5-97f2-4ff1-9c60-d4b537ffbcba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=332702d0f55ac121df9234770fb4c93c8eaab224d16bea50f0dcace3c7b3734a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "d3cdadb5-97f2-4ff1-9c60-d4b537ffbcba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 48,
            "page_width": 612,
            "page_height": 792,
            "content": "1-36 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level\r\nWhen CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data \r\nthat describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid \r\nindex values start from 0.\r\nSoftware can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an \r\nindex value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally \r\ndefined fields reported by deterministic cache parameters are documented in Table 1-5.\r\nThe CPUID leaf 4 also reports data that can be used to derive the topology of processor cores in a physical package. \r\nThis information is constant for all valid index values. Software can query the raw data reported by executing \r\nCPUID with EAX=04H and ECX=0H and use it as part of the topology enumeration algorithm described in Chapter \r\n8, “Multiple-Processor Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A.\r\nINPUT EAX = 05H: Returns MONITOR and MWAIT Features\r\nWhen CPUID executes with EAX set to 05H, the processor returns information about features available to \r\nMONITOR/MWAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with \r\nMWAIT instruction. The MWAIT instruction optionally provides additional extensions for advanced power manage\u0002ment. See Table 1-5. \r\nINPUT EAX = 06H: Returns Thermal and Power Management Features\r\nWhen CPUID executes with EAX set to 06H, the processor returns information about thermal and power manage\u0002ment features. See Table 1-5. \r\nINPUT EAX = 07H: Returns Structured Extended Feature Enumeration Information\r\nWhen CPUID executes with EAX set to 07H and ECX = 0H, the processor returns information about the maximum \r\nnumber of sub-leaves that contain extended feature flags. See Table 1-5. \r\nWhen CPUID executes with EAX set to 07H and ECX = n (n > 1and less than the number of non-zero bits in \r\nCPUID.(EAX=07H, ECX= 0H).EAX, the processor returns information about extended feature flags. See Table 1-5. \r\nIn sub-leaf 0, only EAX has the number of sub-leaves. In sub-leaf 0, EBX, ECX & EDX all contain extended feature \r\nflags.\r\nINPUT EAX = 09H: Returns Direct Cache Access Information\r\nWhen CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabili\u0002ties. See Table 1-5. \r\nINPUT EAX = 0AH: Returns Architectural Performance Monitoring Features\r\nWhen CPUID executes with EAX set to 0AH, the processor returns information about support for architectural \r\nperformance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see Table \r\n1-5) is greater than Pn 0. See Table 1-5.\r\nFor each version of architectural performance monitoring capability, software must enumerate this leaf to discover \r\nthe programming facilities and the architectural performance events available in the processor. The details are \r\ndescribed in Chapter 17, “Debug, Branch Profile, TSC, and Quality of Service,” in the Intel® 64 and IA-32 Architec\u0002tures Software Developer’s Manual, Volume 3A.\r\nINPUT EAX = 0BH: Returns Extended Topology Information\r\nCPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends first checking for the existence of Leaf 1FH \r\nbefore using leaf 0BH.\r\nWhen CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumera\u0002tion data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported \r\nby CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports a non-zero value. See Table 1-5.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/d3cdadb5-97f2-4ff1-9c60-d4b537ffbcba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=332702d0f55ac121df9234770fb4c93c8eaab224d16bea50f0dcace3c7b3734a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "e794df80-0d34-44a6-941d-4f7b276507ad",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-37\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 1-5. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 1-5. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 1-5.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Intel Resource Director Technology (Intel RDT) Allocation Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 1-5.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 12H: Returns Intel SGX Enumeration Information\r\nWhen CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capa\u0002bilities. See Table 1-5. \r\nWhen CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attri\u0002butes. See Table 1-5. \r\nWhen CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX \r\nEnclave Page Cache. See Table 1-5.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 1-5. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 1-5. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Nominal Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e794df80-0d34-44a6-941d-4f7b276507ad.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fb7b49c74406a87769318586f0aedfe63e14f6602c5acf67d5839e4419bd5b3f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 651
      },
      {
        "segments": [
          {
            "segment_id": "e794df80-0d34-44a6-941d-4f7b276507ad",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 49,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-37\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nINPUT EAX = 0DH: Returns Processor Extended States Enumeration Information\r\nWhen CPUID executes with EAX set to 0DH and ECX = 0H, the processor returns information about the bit-vector \r\nrepresentation of all processor state extensions that are supported in the processor and storage size requirements \r\nof the XSAVE/XRSTOR area. See Table 1-5. \r\nWhen CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns \r\ninformation about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. \r\nSee Table 1-5. Software can use the forward-extendable technique depicted below to query the valid sub-leaves \r\nand obtain size and offset information for each processor extended state save area:\r\nFor i = 2 to 62 // sub-leaf 1 is reserved\r\nIF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX\r\nExecute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; \r\nFI;\r\nINPUT EAX = 0FH: Returns Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Information\r\nWhen CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS monitoring resource types that are supported in the processor and maximum range of RMID \r\nvalues the processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds \r\nto a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that soft\u0002ware must use to query QoS monitoring capability available for that type. See Table 1-5.\r\nWhen CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the \r\nIA32_QM_CTR MSR.\r\nINPUT EAX = 10H: Returns Intel Resource Director Technology (Intel RDT) Allocation Enumeration Information\r\nWhen CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector \r\nrepresentation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit \r\n1, corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or \r\nResID) that software must use to query QoS enforcement capability available for that type. See Table 1-5.\r\nWhen CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns infor\u0002mation about available classes of service and range of QoS mask MSRs that software can use to configure each \r\nclass of services using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.\r\nINPUT EAX = 12H: Returns Intel SGX Enumeration Information\r\nWhen CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capa\u0002bilities. See Table 1-5. \r\nWhen CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attri\u0002butes. See Table 1-5. \r\nWhen CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX \r\nEnclave Page Cache. See Table 1-5.\r\nINPUT EAX = 14H: Returns Intel Processor Trace Enumeration Information\r\nWhen CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor \r\nTrace extensions. See Table 1-5. \r\nWhen CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in \r\nCPUID.(EAX=14H, ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor \r\nTrace. See Table 1-5. \r\nINPUT EAX = 15H: Returns Time Stamp Counter and Nominal Core Crystal Clock Information\r\nWhen CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e794df80-0d34-44a6-941d-4f7b276507ad.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=fb7b49c74406a87769318586f0aedfe63e14f6602c5acf67d5839e4419bd5b3f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 651
      },
      {
        "segments": [
          {
            "segment_id": "3f2b119e-d422-4aed-95b0-10d73bc2500b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 50,
            "page_width": 612,
            "page_height": 792,
            "content": "1-38 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nCounter and Core Crystal Clock. See Table 1-5.\r\nINPUT EAX = 16H: Returns Processor Frequency Information\r\nWhen CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Informa\u0002tion. See Table 1-5. \r\nINPUT EAX = 17H: Returns System-On-Chip Information\r\nWhen CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor \r\nAttribute Enumeration. See Table 1-5. \r\nINPUT EAX = 18H: Returns Deterministic Address Translation Parameters Information\r\nWhen CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address \r\nTranslation Parameters. See Table 1-5. \r\nINPUT EAX = 1BH: Returns PCONFIG Information\r\nWhen CPUID executes with EAX set to 1BH, the processor returns information about PCONFIG capabilities. See \r\nTable 1-3. \r\nINPUT EAX = 1FH: Returns V2 Extended Topology Information\r\nWhen CPUID executes with EAX set to 1FH, the processor returns information about extended topology enumera\u0002tion data. Software must detect the presence of CPUID leaf 1FH by verifying (a) the highest leaf index supported \r\nby CPUID is >= 1FH, and (b) CPUID.1FH:EBX[15:0] reports a non-zero value. See Table 1-5. \r\nMETHODS FOR RETURNING BRANDING INFORMATION\r\nUse the following techniques to access branding information:\r\n1. Processor brand string method; this method also returns the processor’s maximum operating frequency\r\n2. Processor brand index; this method uses a software supplied brand string table.\r\nThese two methods are discussed in the following sections. For methods that are available in early processors, see \r\nSection: “Identification of Earlier IA-32 Processors” in Chapter 16 of the Intel® 64 and IA-32 Architectures Soft\u0002ware Developer’s Manual, Volume 1.\r\nThe Processor Brand String Method\r\nFigure 1-6 describes the algorithm used for detection of the brand string. Processor brand identification software \r\nshould execute this algorithm on all Intel 64 and IA-32 processors. \r\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum \r\noperating frequency of the processor to the EAX, EBX, ECX, and EDX registers.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/3f2b119e-d422-4aed-95b0-10d73bc2500b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=46c5f13c6550ed411492363bd4ec9fbaa92a755bdcbf50d6100ba816d18cc0f2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 328
      },
      {
        "segments": [
          {
            "segment_id": "dae99faf-c05a-4660-98d1-aa00857a019f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 51,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-39\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nHow Brand Strings Work\r\nTo use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input \r\nvalue, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL-termi\u0002nated.\r\nTable 1-11 shows the brand string that is returned by the first processor in the Pentium 4 processor family.\r\nFigure 1-6. Determination of Support for the Processor Brand String\r\nTable 1-11. Processor Brand String Returned with Pentium 4 Processor \r\nEAX Input Value Return Values ASCII Equivalent\r\n80000002H EAX = 20202020H\r\nEBX = 20202020H\r\nECX = 20202020H\r\nEDX = 6E492020H\r\n“ ” \r\n“ ”\r\n“ ”\r\n“nI ”\r\n80000003H EAX = 286C6574H\r\nEBX = 50202952H\r\nECX = 69746E65H\r\nEDX = 52286D75H\r\n“(let”\r\n“P )R”\r\n“itne”\r\n“R(mu”\r\n80000004H EAX = 20342029H\r\nEBX = 20555043H\r\nECX = 30303531H\r\nEDX = 007A484DH\r\n“ 4 )”\r\n“ UPC”\r\n“0051”\r\n“\\0zHM”\r\nIF (EAX & 0x80000000)\r\nCPUID\r\nIF (EAX Return Value \r\n = 0x80000004)\r\nCPUID \r\nFunction\r\nSupported\r\nTrue = \r\nExtended\r\nEAX Return Value =\r\nMax. Extended CPUID\r\nFunction Index\r\nInput: EAX= \r\n0x80000000\r\nProcessor Brand\r\nString Not\r\nSupported\r\nFalse\r\nProcessor Brand\r\nString Supported\r\nTrue",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/dae99faf-c05a-4660-98d1-aa00857a019f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=321102b16ae4dbf15c2c9df68d1ef9ed2483fe39a921a8fa923f2a3e860007a2",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "15a5aabb-9f1d-4452-97ae-2b0f67b92dbd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 52,
            "page_width": 612,
            "page_height": 792,
            "content": "1-40 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nExtracting the Maximum Processor Frequency from Brand Strings\r\nFigure 1-7 provides an algorithm which software can use to extract the maximum processor operating frequency \r\nfrom the processor brand string.\r\nNOTE\r\nWhen a frequency is given in a brand string, it is the maximum qualified frequency of the processor, \r\nnot the frequency at which the processor is currently running.\r\nThe Processor Brand Index Method\r\nThe brand index method (introduced with Pentium® III Xeon® processors) provides an entry point into a brand \r\nidentification table that is maintained in memory by system software and is accessible from system- and user-level \r\ncode. In this table, each brand index is associate with an ASCII brand identification string that identifies the official \r\nIntel family and model number of a processor.\r\nWhen CPUID executes with EAX set to 01H, the processor returns a brand index to the low byte in EBX. Software \r\ncan then use this index to locate the brand identification string for the processor in the brand identification table. \r\nThe first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do \r\nnot support the brand identification feature. Starting with processor signature family ID = 0FH, model = 03H, \r\nbrand index method is no longer supported. Use brand string method instead.\r\nFigure 1-7. Algorithm for Extracting Maximum Processor Frequency\r\nIF Substring Matched\r\n\"zHM\", or \r\n\"zHG\", or \r\n\"zHT\"\r\nTrue\r\nDetermine \"Multiplier\"\r\nScan \"Brand String\" in\r\nReverse Byte Order\r\nReport Error\r\nFalse\r\nScan Digits \r\nUntil Blank\r\nMatch\r\nSubstring\r\nDetermine \"Freq\" Reverse Digits\r\nTo Decimal Value\r\nMax. Qualified\r\nFrequency =\r\n\"Freq\" x \"Multiplier\" \"Freq\" = X.YZ if\r\nDigits = \"ZY.X\"\r\nIn Reverse Order\r\nIf \"zHM\"\r\nIf \"zHG\"\r\nIf \"zHT\"\r\nMultiplier = 1 x 1012\r\nMultiplier = 1 x 109\r\nMultiplier = 1 x 106",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/15a5aabb-9f1d-4452-97ae-2b0f67b92dbd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cc56d12cc6edd5852df97fadf3edeeeffc1b6fdb21aaa22760049188bbd7aabf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 499
      },
      {
        "segments": [
          {
            "segment_id": "a9907105-9d55-4b94-80be-c436e97058f9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 53,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-41\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nTable 1-12 shows brand indices that have identification strings associated with them.\r\nIA-32 Architecture Compatibility\r\nCPUID is not supported in early models of the Intel486 processor or in any IA-32 processor earlier than the \r\nIntel486 processor.\r\nOperation\r\nIA32_BIOS_SIGN_ID MSR ← Update with installed microcode revision number;\r\nCASE (EAX) OF\r\nEAX = 0:\r\nEAX ← Highest basic function input value understood by CPUID;\r\nEBX ← Vendor identification string;\r\nEDX ← Vendor identification string;\r\nECX ← Vendor identification string;\r\nBREAK;\r\nEAX = 1H:\r\nEAX[3:0] ← Stepping ID; \r\nTable 1-12. Mapping of Brand Indices; and Intel 64 and IA-32 Processor Brand Strings\r\nBrand Index Brand String\r\n00H This processor does not support the brand identification feature\r\n01H Intel(R) Celeron(R) processor1\r\n02H Intel(R) Pentium(R) III processor1\r\n03H Intel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) \r\nprocessor\r\n04H Intel(R) Pentium(R) III processor\r\n06H Mobile Intel(R) Pentium(R) III processor-M\r\n07H Mobile Intel(R) Celeron(R) processor1\r\n08H Intel(R) Pentium(R) 4 processor\r\n09H Intel(R) Pentium(R) 4 processor\r\n0AH Intel(R) Celeron(R) processor1\r\n0BH Intel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP\r\n0CH Intel(R) Xeon(R) processor MP\r\n0EH Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor\r\n0FH Mobile Intel(R) Celeron(R) processor1\r\n11H Mobile Genuine Intel(R) processor\r\n12H Intel(R) Celeron(R) M processor\r\n13H Mobile Intel(R) Celeron(R) processor1\r\n14H Intel(R) Celeron(R) processor\r\n15H Mobile Genuine Intel(R) processor\r\n16H Intel(R) Pentium(R) M processor\r\n17H Mobile Intel(R) Celeron(R) processor1\r\n18H – 0FFH RESERVED\r\nNOTES:\r\n1.Indicates versions of these processors that were introduced after the Pentium III ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/a9907105-9d55-4b94-80be-c436e97058f9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=db353755f556272466e8f8e0d7ef370bad231c13afe67a1b56cfcab813f58b6e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 268
      },
      {
        "segments": [
          {
            "segment_id": "ad26cf8e-a0b3-422c-9582-d7f13011d384",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 54,
            "page_width": 612,
            "page_height": 792,
            "content": "1-42 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEAX[7:4] ← Model; \r\nEAX[11:8] ← Family; \r\nEAX[13:12] ← Processor type; \r\nEAX[15:14] ← Reserved;\r\nEAX[19:16] ← Extended Model;\r\nEAX[27:20] ← Extended Family;\r\nEAX[31:28] ← Reserved;\r\nEBX[7:0] ← Brand Index; (* Reserved if the value is zero. *)\r\nEBX[15:8] ← CLFLUSH Line Size;\r\nEBX[16:23] ← Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)\r\nEBX[24:31] ← Initial APIC ID;\r\nECX ← Feature flags; (* See Figure 1-4. *)\r\nEDX ← Feature flags; (* See Figure 1-5. *)\r\nBREAK;\r\nEAX = 2H:\r\nEAX ← Cache and TLB information; \r\n EBX ← Cache and TLB information; \r\n ECX ← Cache and TLB information; \r\nEDX ← Cache and TLB information; \r\nBREAK;\r\nEAX = 3H:\r\nEAX ← Reserved; \r\n EBX ← Reserved; \r\n ECX ← ProcessorSerialNumber[31:0]; \r\n(* Pentium III processors only, otherwise reserved. *)\r\nEDX ← ProcessorSerialNumber[63:32]; \r\n(* Pentium III processors only, otherwise reserved. *\r\nBREAK\r\nEAX = 4H:\r\nEAX ← Deterministic Cache Parameters Leaf; (* See Table 1-5. *)\r\nEBX ← Deterministic Cache Parameters Leaf; \r\n ECX ← Deterministic Cache Parameters Leaf; \r\nEDX ← Deterministic Cache Parameters Leaf; \r\nBREAK;\r\nEAX = 5H:\r\nEAX ← MONITOR/MWAIT Leaf; (* See Table 1-5. *)\r\n EBX ← MONITOR/MWAIT Leaf; \r\n ECX ← MONITOR/MWAIT Leaf; \r\nEDX ← MONITOR/MWAIT Leaf; \r\nBREAK;\r\nEAX = 6H:\r\nEAX ← Thermal and Power Management Leaf; (* See Table 1-5. *)\r\n EBX ← Thermal and Power Management Leaf; \r\n ECX ← Thermal and Power Management Leaf; \r\nEDX ← Thermal and Power Management Leaf; \r\nBREAK;\r\nEAX = 7H:\r\nEAX ← Structured Extended Feature Leaf; (* See Table 1-5. *);\r\n EBX ← Structured Extended Feature Leaf; \r\n ECX ← Structured Extended Feature Leaf; \r\nEDX ← Structured Extended Feature Leaf; \r\nBREAK;\r\nEAX = 8H:\r\nEAX ← Reserved = 0;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ad26cf8e-a0b3-422c-9582-d7f13011d384.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=32338c001bc2b79f8541b2860f621b0f3c663a9de5ebe04f4cc72705ca12122e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 288
      },
      {
        "segments": [
          {
            "segment_id": "4c3f239d-2221-43b3-a6c7-4716881ebd34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 55,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-43\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 9H:\r\nEAX ← Direct Cache Access Information Leaf; (* See Table 1-5. *)\r\n EBX ← Direct Cache Access Information Leaf; \r\n ECX ← Direct Cache Access Information Leaf; \r\nEDX ← Direct Cache Access Information Leaf; \r\nBREAK;\r\nEAX = AH:\r\nEAX ← Architectural Performance Monitoring Leaf; (* See Table 1-5. *)\r\n EBX ← Architectural Performance Monitoring Leaf; \r\n ECX ← Architectural Performance Monitoring Leaf; \r\nEDX ← Architectural Performance Monitoring Leaf; \r\nBREAK\r\nEAX = BH:\r\nEAX ← Extended Topology Enumeration Leaf; (* See Table 1-5. *)\r\nEBX ← Extended Topology Enumeration Leaf; \r\n ECX ← Extended Topology Enumeration Leaf; \r\nEDX ← Extended Topology Enumeration Leaf; \r\nBREAK;\r\nEAX = CH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = DH:\r\nEAX ← Processor Extended State Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Processor Extended State Enumeration Leaf; \r\n ECX ← Processor Extended State Enumeration Leaf; \r\nEDX ← Processor Extended State Enumeration Leaf; \r\nBREAK;\r\nEAX = EH:\r\nEAX ← Reserved = 0;\r\n EBX ← Reserved = 0; \r\n ECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = FH:\r\nEAX ← Platform Quality of Service Monitoring Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\n ECX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nEDX ← Platform Quality of Service Monitoring Enumeration Leaf; \r\nBREAK;\r\nEAX = 10H:\r\nEAX ← Platform Quality of Service Enforcement Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\n ECX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nEDX ← Platform Quality of Service Enforcement Enumeration Leaf; \r\nBREAK;\r\nEAX = 12H:\r\nEAX ← Intel SGX Enumeration Leaf; (* See Table 1-5. *)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4c3f239d-2221-43b3-a6c7-4716881ebd34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4873519e9ea812a5b3edaaabc6e9311265318c35d802988ac360d282c3622c0e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 319
      },
      {
        "segments": [
          {
            "segment_id": "6cbd4a0c-0fb3-4c30-baac-8fbfe7962241",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 56,
            "page_width": 612,
            "page_height": 792,
            "content": "1-44 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n EBX ← Intel SGX Enumeration Leaf; \r\n ECX ← Intel SGX Enumeration Leaf; \r\nEDX ← Intel SGX Enumeration Leaf; \r\nBREAK;\r\nEAX = 14H:\r\nEAX ← Intel Processor Trace Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Intel Processor Trace Enumeration Leaf; \r\n ECX ← Intel Processor Trace Enumeration Leaf; \r\nEDX ← Intel Processor Trace Enumeration Leaf; \r\nBREAK;\r\nEAX = 15H:\r\nEAX ← Time Stamp Counter and Core Crystal Clock Information Leaf; (* See Table 1-5. *)\r\n EBX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\n ECX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nEDX ← Time Stamp Counter and Core Crystal Clock Information Leaf; \r\nBREAK;\r\nEAX = 16H:\r\nEAX ← Processor Frequency Information Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Processor Frequency Information Enumeration Leaf; \r\n ECX ← Processor Frequency Information Enumeration Leaf; \r\nEDX ← Processor Frequency Information Enumeration Leaf; \r\nBREAK;\r\nEAX = 17H:\r\nEAX ← System-On-Chip Vendor Attribute Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\n ECX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nEDX ← System-On-Chip Vendor Attribute Enumeration Leaf; \r\nBREAK;\r\nEAX = 18H:\r\nEAX ← Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\n ECX ←Deterministic Address Translation Parameters Enumeration Leaf; \r\nEDX ← Deterministic Address Translation Parameters Enumeration Leaf; \r\nBREAK;\r\nEAX = 1BH:\r\nEAX ← PCONFIG Information Enumeration Leaf; (* See Table 1-5. *)\r\n EBX ← PCONFIG Information Enumeration Leaf; \r\n ECX ←PCONFIG Information Enumeration Leaf; \r\nEDX ← PCONFIG Information Enumeration Leaf; \r\nBREAK;\r\nEAX = 1FH:\r\nEAX ← V2 Extended Topology Enumeration Leaf; (* See Table 1-5. *)\r\nEBX ← V2 Extended Topology Enumeration Leaf; \r\n ECX ← V2 Extended Topology Enumeration Leaf; \r\nEDX ← V2 Extended Topology Enumeration Leaf; \r\nBREAK;\r\nEAX = 80000000H:\r\nEAX ← Highest extended function input value understood by CPUID;\r\nEBX ← Reserved; \r\nECX ← Reserved; \r\nEDX ← Reserved; \r\nBREAK;\r\nEAX = 80000001H:\r\nEAX ← Reserved; ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/6cbd4a0c-0fb3-4c30-baac-8fbfe7962241.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=56a05feff284693be524e60bfd51b471e753d616bccb17290779e585ad887eaa",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 332
      },
      {
        "segments": [
          {
            "segment_id": "6a49c33f-49b3-4ba0-b197-2a6700c1bdaf",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 57,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-45\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nEBX ← Reserved; \r\nECX ← Extended Feature Bits (* See Table 1-5.*); \r\nEDX ← Extended Feature Bits (* See Table 1-5. *); \r\nBREAK;\r\nEAX = 80000002H:\r\nEAX ← Processor Brand String; \r\nEBX ← Processor Brand String, continued;\r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000003H:\r\nEAX ← Processor Brand String, continued; \r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued; \r\nBREAK;\r\nEAX = 80000004H:\r\nEAX ← Processor Brand String, continued; \r\nEBX ← Processor Brand String, continued; \r\nECX ← Processor Brand String, continued; \r\nEDX ← Processor Brand String, continued;\r\nBREAK;\r\nEAX = 80000005H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000006H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Cache information; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000007H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nEAX = 80000008H:\r\nEAX ← Reserved = 0; \r\nEBX ← Reserved = 0; \r\nECX ← Reserved = 0; \r\nEDX ← Reserved = 0; \r\nBREAK;\r\nDEFAULT: (* EAX = Value outside of recognized range for CPUID. *)\r\n(* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)\r\nEAX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEBX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nECX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nEDX ← Reserved; (* Information returned for highest basic information leaf. *)\r\nBREAK;\r\nESAC;",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/6a49c33f-49b3-4ba0-b197-2a6700c1bdaf.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=07f21ac183c1285131dea1fd72e55768ed09944a013e5583d4e0605077f8f689",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8432d8cd-f9ae-4260-85d9-fc0f70e449f2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 58,
            "page_width": 612,
            "page_height": 792,
            "content": "1-46 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\nFlags Affected\r\nNone.\r\nExceptions (All Operating Modes)\r\n#UD If the LOCK prefix is used.\r\nIn earlier IA-32 processors that do not support the CPUID instruction, execution of the instruction results in an \r\ninvalid opcode (#UD) exception being generated.§",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/8432d8cd-f9ae-4260-85d9-fc0f70e449f2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f65d08d6a25035ef52e2dc6becf4ad30fcb80a0e9015a0346c4cb6b8d1de856e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 339
      },
      {
        "segments": [
          {
            "segment_id": "328859cf-b609-4fdd-bf74-939921750355",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-47\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.8 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 1-13 and Table 1-14 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 1-13 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword. \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 1-14. Table 1-14 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 1-14. Instruc\u0002tion classified in Table 1-14 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype will be referenced in the instruction operand encoding table in the reference page of each instruction, \r\nproviding the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 1-13. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nFull Mem N/A N/A 16 32 64 Load/store or subDword full vector\r\nTuple1 Scalar\r\n8bit N/A 1 1 1\r\n1Tuple\r\n16bit N/A 2 2 2\r\n32bit 0 4 4 4\r\n64bit 1 8 8 8\r\nTuple1 Fixed\r\n32bit N/A 4 4 4 1 Tuple, memsize not affected by \r\n64bit N/A 8 8 8 EVEX.W\r\nTuple1_4X 32bit 0 161 N/A 16 4FMA(PS)\r\nTuple2\r\n32bit 0 8 8 8\r\nBroadcast (2 elements) 64bit 1 NA 16 16\r\nTuple4\r\n32bit 0 NA 16 16\r\nBroadcast (4 elements) 64bit 1 NA NA 32\r\nTuple8 32bit 0 NA NA 32 Broadcast (8 elements) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/328859cf-b609-4fdd-bf74-939921750355.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=af8b4c66a23a06e5cb66884520246355c45288bc1dc14e863d2886402faf673c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 517
      },
      {
        "segments": [
          {
            "segment_id": "328859cf-b609-4fdd-bf74-939921750355",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 59,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 1-47\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.8 COMPRESSED DISPLACEMENT (DISP8*N) SUPPORT IN EVEX\r\nFor memory addressing using disp8 form, EVEX-encoded instructions always use a compressed displacement \r\nscheme by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, \r\nthe value of EVEX.b bit (embedded broadcast) and the input element size of the instruction. In general, the factor \r\nN corresponds to the number of bytes characterizing the internal memory operation of the input operand (e.g., 64 \r\nwhen the accessing a full 512-bit memory vector). The scale factor N is listed in Table 1-13 and Table 1-14 below, \r\nwhere EVEX encoded instructions are classified using the tupletype attribute. The scale factor N of each tupletype \r\nis listed based on the vector length (VL) and other factors affecting it.\r\nTable 1-13 covers EVEX-encoded instructions which has a load semantic in conjunction with additional computa\u0002tional or data element movement operation, operating either on the full vector or half vector (due to conversion of \r\nnumerical precision from a wider format to narrower format). EVEX.b is supported for such instructions for data \r\nelement sizes which are either dword or qword. \r\nEVEX-encoded instruction that are pure load/store, and “Load+op” instruction semantic that operate on data \r\nelement size less then dword do not support broadcasting using EVEX.b. These are listed in Table 1-14. Table 1-14 \r\nalso includes many broadcast instructions which perform broadcast using a subset of data elements without using \r\nEVEX.b. These instructions and a few data element size conversion instruction are covered in Table 1-14. Instruc\u0002tion classified in Table 1-14 do not use EVEX.b and EVEX.b must be 0, otherwise #UD will occur.\r\nThe tupletype will be referenced in the instruction operand encoding table in the reference page of each instruction, \r\nproviding the cross reference for the scaling factor N to encoding memory addressing operand. \r\nNote that the disp8*N rules still apply when using 16b addressing.\r\nTable 1-13. Compressed Displacement (DISP8*N) Affected by Embedded Broadcast\r\nTupleType EVEX.b InputSize EVEX.W Broadcast N (VL=128) N (VL=256) N (VL= 512) Comment\r\nFull\r\n0 32bit 0 none 16 32 64\r\nLoad+Op (Full Vector \r\nDword/Qword)\r\n1 32bit 0 {1tox} 4 4 4\r\n0 64bit 1 none 16 32 64\r\n1 64bit 1 {1tox} 8 8 8\r\nHalf\r\n0 32bit 0 none 8 16 32\r\nLoad+Op (Half Vector) 1 32bit 0 {1tox} 4 4 4\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nFull Mem N/A N/A 16 32 64 Load/store or subDword full vector\r\nTuple1 Scalar\r\n8bit N/A 1 1 1\r\n1Tuple\r\n16bit N/A 2 2 2\r\n32bit 0 4 4 4\r\n64bit 1 8 8 8\r\nTuple1 Fixed\r\n32bit N/A 4 4 4 1 Tuple, memsize not affected by \r\n64bit N/A 8 8 8 EVEX.W\r\nTuple1_4X 32bit 0 161 N/A 16 4FMA(PS)\r\nTuple2\r\n32bit 0 8 8 8\r\nBroadcast (2 elements) 64bit 1 NA 16 16\r\nTuple4\r\n32bit 0 NA 16 16\r\nBroadcast (4 elements) 64bit 1 NA NA 32\r\nTuple8 32bit 0 NA NA 32 Broadcast (8 elements) ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/328859cf-b609-4fdd-bf74-939921750355.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=af8b4c66a23a06e5cb66884520246355c45288bc1dc14e863d2886402faf673c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 517
      },
      {
        "segments": [
          {
            "segment_id": "b76e9a20-e431-4b23-8b8c-ca36203da55b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 60,
            "page_width": 612,
            "page_height": 792,
            "content": "1-48 Ref. # 319433-037\r\nFUTURE INTEL® ARCHITECTURE INSTRUCTION EXTENSIONS AND FEATURES\r\n1.9 BFLOAT16 FLOATING-POINT FORMAT\r\nIntel® Deep Learning Boost (Intel® DL Boost) uses bfloat16 format (BF16). Figure 1-8 illustrates \r\nBF16 versus FP16 and FP32.\r\nBF16 has several advantages over FP16:\r\n• It can be seen as a short version of FP32, skipping the least significant 16 bits of mantissa.\r\n• There is no need to support denormals; FP32, and therefore also BF16, offer more than enough range \r\nfor deep learning training tasks.\r\n• FP32 accumulation after the multiply is essential to achieve sufficient numerical behavior on an \r\napplication level.\r\n• Hardware exception handling is not needed as this is a performance optimization; industry is designing \r\nalgorithms around checking inf/NaN.\r\nHalf Mem N/A N/A 8 16 32 SubQword Conversion\r\nQuarter Mem N/A N/A 4 8 16 SubDword Conversion\r\nEighth Mem N/A N/A 2 4 8 SubWord Conversion\r\nMem128 N/A N/A 16 16 16 Shift count from memory\r\nMOVDDUP N/A N/A 8 32 64 VMOVDDUP\r\nNOTES:\r\n1. Scalar\r\nFigure 1-8. Comparison of BF16 to FP16 and FP32\r\nTable 1-14. EVEX DISP8*N for Instructions Not Affected by Embedded Broadcast(Continued)\r\nTupleType InputSize EVEX.W N (VL= 128) N (VL= 256) N (VL= 512) Comment\r\nBFP10001\r\nFP32\r\ns 5 bit exp 10 bit mantissa\r\ns 8 bit exp 23 bit mantissa\r\nFP16\r\nBF16 s 8 bit exp 7 bit mantissa",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b76e9a20-e431-4b23-8b8c-ca36203da55b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=118d6299795c64517d377495d4290acf768fc6e66485968e0906ed9c593accff",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c3703a18-d91a-46e3-8811-a0a89c1b2d57",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 61,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-1\r\nINSTRUCTION SET REFERENCE, A-Z\r\nCHAPTER 2\r\nINSTRUCTION SET REFERENCE, A-Z\r\nInstructions described in this document follow the general documentation convention established in Intel 64 and \r\nIA-32 Architectures Software Developer’s Manual Volume 2A. \r\n2.1 INSTRUCTION SET REFERENCE",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/c3703a18-d91a-46e3-8811-a0a89c1b2d57.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6db37fa8b18ae212815405391b6f601d8d093a701ab9bfd85d2c40fbd9f550d6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 264
      },
      {
        "segments": [
          {
            "segment_id": "e8a60980-e26f-4c38-943d-c09b4261c4c5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 62,
            "page_width": 612,
            "page_height": 792,
            "content": "2-2 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nENQCMD — Enqueue Command\r\nInstruction Operand Encoding\r\nDescription\r\nThe ENQCMD instruction allows software to write commands to enqueue registers, which are special device \r\nregisters accessed using memory-mapped I/O (MMIO).\r\nEnqueue registers expect writes to have the following format:\r\nBits 19:0 conveys the process address space identifier (PASID), a value which system software may assign to indi\u0002vidual software threads. Bit 31 contains privilege identification (0 = user; 1 = supervisor). Devices implementing \r\nenqueue registers may use these two values along with a device-specific command in the upper 60 bytes. Chapter \r\n3 provides more details regarding how ENQCMD uses PASIDs.\r\nThe ENQCMD instruction begins by reading 64 bytes of command data from its source memory operand. (The \r\nsource operand is a normal memory operand; ModR/M.mod ≠ 11b.) This is an ordinary load with cacheability and \r\nmemory ordering implied normally by the memory type. The source operand need not be aligned, and there is no \r\nguarantee that all 64 bytes are loaded atomically.\r\nThe instruction then formats those 64 bytes into command data with a format consistent with that given in \r\nFigure 2-1:\r\n• Command[19:0] get IA32_PASID[19:0].1\r\n• Command[30:20] are zero.\r\n• Command[31] is 0 (indicating user).\r\n• Command[511:32] get bits 511:32 of the source operand that was read from memory.\r\n(The instruction ignores bits 31:0 of the source operand.)\r\nThe ENQCMD instruction uses an enqueue store (defined below) to write these command data to the destination \r\noperand. The address of the destination operand is specified in a general purpose register as an offset into the ES \r\nsegment (the segment cannot be overridden).2 The destination linear address must be 64-byte aligned. The oper\u0002ation of an enqueue store disregards the memory type of the destination memory address.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nF2 0F 38 F8 /r\r\nENQCMD r32/64, m512\r\nA V/V ENQCMD Atomically enqueue 64-byte user command \r\nwith PASID from source memory operand to \r\ndestination offset in ES segment specified in \r\nregister operand as offset in ES segment.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) ModRM:r/m (r) NA NA\r\nFigure 2-1. 64-Byte Data Written to Enqueue Registers\r\n1. It is expected that system software will load the IA32_PASID MSR so that bits 19:0 contain the PASID of the current soft\u0002ware thread. The MSR’s valid bit, IA32_PASID[31], must be 1. The PASID MSR is discussed in more detail in Section 3.1.\r\n2. In 64-bit mode, the width of the register operand is 64 bits (32 bits with a 67H prefix). Outside 64-bit mode when CS.D = \r\n1, the width is 32 bits (16 bits with a 67H prefix). Outside 64-bit mode when CS.D=0, the width is 16 bits (32 bits with a \r\n67H prefix).\r\nPRIV RESERVED\r\n0 511 32 31 30 20 19\r\nDEVICE SPECIFIC COMMAND PASID",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e8a60980-e26f-4c38-943d-c09b4261c4c5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=029dcdedfd25a59821cab18875b9e2805b9d342d9814e955ddd65c9a8de30796",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 475
      },
      {
        "segments": [
          {
            "segment_id": "4ca78620-c0d9-46fe-b10d-b9a1755ad77b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 63,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-3\r\nINSTRUCTION SET REFERENCE, A-Z\r\nAn enqueue store is not ordered relative to older stores to WB or WC memory (including non-temporal stores) or \r\nto executions of the CLFLUSHOPT or CLWB (when applied to addresses other than that of the enqueue store). Soft\u0002ware can enforce such ordering by executing a fencing instruction such as SFENCE or MFENCE before the enqueue \r\nstore.\r\nAn enqueue store does not write the data into the cache hierarchy, nor does it fetch any data into the cache hier\u0002archy. An enqueue store’s command data is never combined with that of any other store to the same address.\r\nUnlike other stores, an enqueue store returns a status, which the ENQCMD instruction loads into the ZF flag in the \r\nRFLAGS register:\r\n• ZF = 0 (success) reports that the 64-byte command data was written atomically to a device’s enqueue register \r\nand has been accepted by the device. (It does not guarantee that the device has acted on the command; it may \r\nhave queued it for later execution.)\r\n• ZF = 1 (retry) reports that the command data was not accepted. This status is returned if the destination \r\naddress is an enqueue register but the command was not accepted due to capacity or other temporal reasons. \r\nThis status is also returned if the destination address was not an enqueue register (including the case of a \r\nmemory address); in these cases, the store is dropped and is written neither to MMIO nor to memory.\r\nAvailability of the ENQCMD instruction is indicated by the presence of the CPUID feature flag ENQCMD (bit 29 of the \r\nECX register, see “CPUID Instruction” in Chapter 1).\r\nOperation\r\nIF IA32_PASID[31] = 0\r\nTHEN #GP;\r\nELSE\r\nCOMMAND ← (SRC & ~FFFFFFFFH) | (IA32_PASID & FFFFFH);\r\nDEST ← COMMAND;\r\nFI;\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nENQCMD int_enqcmd(void *dst, const void *src)\r\nFlags Affected\r\nThe ZF flag is set if the enqueue-store completion returns the retry status; otherwise it is cleared. All other flags \r\nare cleared.\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nProtected Mode Exceptions\r\n#GP(0) For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\nIf the PASID Valid field (bit 31) is 0 in IA32_PASID MSR.\r\n#SS(0) For an illegal address in the SS segment.\r\n#PF(fault-code) For a page fault.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29] = 0.\r\nIf the LOCK prefix is used.\r\nReal-Address Mode Exceptions\r\n#GP If any part of the operand lies outside the effective address space from 0 to FFFFH.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\nIf the PASID Valid field (bit 31) is 0 in IA32_PASID MSR.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29] = 0.\r\nIf the LOCK prefix is used.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4ca78620-c0d9-46fe-b10d-b9a1755ad77b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=1d6deac57c43009c006ad256c9fdafa35fb2c396d835534dc567d0f32d76ce79",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 459
      },
      {
        "segments": [
          {
            "segment_id": "0edd7c14-39cb-48c2-8cc1-b8f7dbc7f39f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 64,
            "page_width": 612,
            "page_height": 792,
            "content": "2-4 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVirtual-8086 Mode Exceptions\r\nSame exceptions as in real address mode. Additionally:\r\n#PF(fault-code) For a page fault.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\n#SS(0) If a memory address referencing the SS segment is in non-canonical form.\r\n#GP(0) If the memory address is in non-canonical form.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\nIf the PASID Valid field (bit 31) is 0 in IA32_PASID MSR.\r\n#PF(fault-code) For a page fault.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29].\r\nIf the LOCK prefix is used.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/0edd7c14-39cb-48c2-8cc1-b8f7dbc7f39f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6fc45bfe365b37431081fb38343cecdf9e55b28219c3b759b25c5cf13ccf56be",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 96
      },
      {
        "segments": [
          {
            "segment_id": "5b6cfcce-0ad8-4183-822b-37efa27375c9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-5\r\nINSTRUCTION SET REFERENCE, A-Z\r\nENQCMDS — Enqueue Command Supervisor\r\nInstruction Operand Encoding\r\nDescription\r\nThe ENQCMDS instruction allows system software to write commands to enqueue registers, which are special \r\ndevice registers accessed using memory-mapped I/O (MMIO).\r\nEnqueue registers expect writes to have the format given in Figure 2-1 and explained in the section on “ENQCMD \r\n— Enqueue Command.”\r\nThe ENQCMDS instruction begins by reading 64 bytes of command data from its source memory operand. (The \r\nsource operand is a normal memory operand; ModR/M.mod ≠ 11b.) This is an ordinary load with cacheability and \r\nmemory ordering implied normally by the memory type. The source operand need not be aligned, and there is no \r\nguarantee that all 64 bytes are loaded atomically.\r\nENQCMDS formats its source data differently from ENQCMD. Specifically, it formats them into command data as \r\nfollows:\r\n• Command[19:0] get bits 19:0 of the source operand that was read from memory. These 20 bits communicate \r\na process address-space identifier (PASID). Chapter 3 provides more details regarding how ENQCMDS uses \r\nPASIDs.\r\n• Command[30:20] are zero.\r\n• Command[511:31] get bits 511:31 of the source operand that was read from memory. Bit 31 communicates a \r\nprivilege identification (0 = user; 1 = supervisor)\r\n(The instruction ignores bits 30:20 of the source operand.)\r\nThe ENQCMDS instruction then uses an enqueue store (defined below) to write these command data to the desti\u0002nation operand. The address of the destination operand is specified in a general purpose register as an offset into \r\nthe ES segment (the segment cannot be overridden).1 The destination linear address must be 64-byte aligned. The \r\noperation of an enqueue store disregards the memory type of the destination memory address.\r\nAn enqueue store is not ordered relative to older stores to WB or WC memory (including non-temporal stores) or \r\nto executions of the CLFLUSHOPT or CLWB (when applied to addresses other than that of the enqueue store). Soft\u0002ware can enforce such ordering by executing a fencing instruction such as SFENCE or MFENCE before the enqueue \r\nstore.\r\nAn enqueue store does not write the data into the cache hierarchy, nor does it fetch any data into the cache hier\u0002archy. An enqueue store’s command data is never combined with that of any other store to the same address.\r\nUnlike other stores, an enqueue store returns a status, which the ENQCMDS instruction loads into the ZF flag in the \r\nRFLAGS register:\r\n• ZF = 0 (success) reports that the 64-byte command data was written atomically to a device’s enqueue register \r\nand has been accepted by the device. (It does not guarantee that the device has acted on the command; it may \r\nhave queued it for later execution.)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nF3 0F 38 F8 /r\r\nENQCMDS r32/64, m512\r\nA V/V ENQCMD Atomically enqueue 64-byte command from \r\nsource memory operand to destination offset \r\nin ES segment specified in register operand as \r\noffset in ES segment.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) ModRM:r/m (r) NA NA\r\n1. In 64-bit mode, the width of the register operand is 64 bits (32 bits with a 67H prefix). Outside 64-bit mode when CS.D = \r\n1, the width is 32 bits (16 bits with a 67H prefix). Outside 64-bit mode when CS.D=0, the width is 16 bits (32 bits with a \r\n67H prefix).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/5b6cfcce-0ad8-4183-822b-37efa27375c9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3081274b91a51cd7931afedb8f397d168f42153947d1c0490bd0476181b28098",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 560
      },
      {
        "segments": [
          {
            "segment_id": "5b6cfcce-0ad8-4183-822b-37efa27375c9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 65,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-5\r\nINSTRUCTION SET REFERENCE, A-Z\r\nENQCMDS — Enqueue Command Supervisor\r\nInstruction Operand Encoding\r\nDescription\r\nThe ENQCMDS instruction allows system software to write commands to enqueue registers, which are special \r\ndevice registers accessed using memory-mapped I/O (MMIO).\r\nEnqueue registers expect writes to have the format given in Figure 2-1 and explained in the section on “ENQCMD \r\n— Enqueue Command.”\r\nThe ENQCMDS instruction begins by reading 64 bytes of command data from its source memory operand. (The \r\nsource operand is a normal memory operand; ModR/M.mod ≠ 11b.) This is an ordinary load with cacheability and \r\nmemory ordering implied normally by the memory type. The source operand need not be aligned, and there is no \r\nguarantee that all 64 bytes are loaded atomically.\r\nENQCMDS formats its source data differently from ENQCMD. Specifically, it formats them into command data as \r\nfollows:\r\n• Command[19:0] get bits 19:0 of the source operand that was read from memory. These 20 bits communicate \r\na process address-space identifier (PASID). Chapter 3 provides more details regarding how ENQCMDS uses \r\nPASIDs.\r\n• Command[30:20] are zero.\r\n• Command[511:31] get bits 511:31 of the source operand that was read from memory. Bit 31 communicates a \r\nprivilege identification (0 = user; 1 = supervisor)\r\n(The instruction ignores bits 30:20 of the source operand.)\r\nThe ENQCMDS instruction then uses an enqueue store (defined below) to write these command data to the desti\u0002nation operand. The address of the destination operand is specified in a general purpose register as an offset into \r\nthe ES segment (the segment cannot be overridden).1 The destination linear address must be 64-byte aligned. The \r\noperation of an enqueue store disregards the memory type of the destination memory address.\r\nAn enqueue store is not ordered relative to older stores to WB or WC memory (including non-temporal stores) or \r\nto executions of the CLFLUSHOPT or CLWB (when applied to addresses other than that of the enqueue store). Soft\u0002ware can enforce such ordering by executing a fencing instruction such as SFENCE or MFENCE before the enqueue \r\nstore.\r\nAn enqueue store does not write the data into the cache hierarchy, nor does it fetch any data into the cache hier\u0002archy. An enqueue store’s command data is never combined with that of any other store to the same address.\r\nUnlike other stores, an enqueue store returns a status, which the ENQCMDS instruction loads into the ZF flag in the \r\nRFLAGS register:\r\n• ZF = 0 (success) reports that the 64-byte command data was written atomically to a device’s enqueue register \r\nand has been accepted by the device. (It does not guarantee that the device has acted on the command; it may \r\nhave queued it for later execution.)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nF3 0F 38 F8 /r\r\nENQCMDS r32/64, m512\r\nA V/V ENQCMD Atomically enqueue 64-byte command from \r\nsource memory operand to destination offset \r\nin ES segment specified in register operand as \r\noffset in ES segment.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) ModRM:r/m (r) NA NA\r\n1. In 64-bit mode, the width of the register operand is 64 bits (32 bits with a 67H prefix). Outside 64-bit mode when CS.D = \r\n1, the width is 32 bits (16 bits with a 67H prefix). Outside 64-bit mode when CS.D=0, the width is 16 bits (32 bits with a \r\n67H prefix).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/5b6cfcce-0ad8-4183-822b-37efa27375c9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3081274b91a51cd7931afedb8f397d168f42153947d1c0490bd0476181b28098",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 560
      },
      {
        "segments": [
          {
            "segment_id": "ddcd3e3f-08ff-4238-8953-fed9cd0c8cf6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 66,
            "page_width": 612,
            "page_height": 792,
            "content": "2-6 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\n• ZF = 1 (retry) reports that the command data was not accepted. This status is returned if the destination \r\naddress is an enqueue register but the command was not accepted due to capacity or other temporal reasons. \r\nThis status is also returned if the destination address was not an enqueue register (including the case of a \r\nmemory address); in these cases, the store is dropped and is written neither to MMIO nor to memory.\r\nThe ENQCMDS instruction may be executed only if CPL = 0. Availability of the ENQCMDS instruction is indicated by \r\nthe presence of the CPUID feature flag ENQCMD (bit 29 of the ECX register, see “CPUID Instruction” in Chapter 1).\r\nOperation\r\nDEST ← SRC & ~7FF00000H; // clear bits 30:20\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nENQCMDS int_enqcmds(void *dst, const void *src)\r\nFlags Affected\r\nThe ZF flag is set if the enqueue-store completion returns the retry status; otherwise it is cleared. All other flags \r\nare cleared.\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nProtected Mode Exceptions\r\n#GP(0) For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\nIf the current privilege level is not 0.\r\n#SS(0) For an illegal address in the SS segment.\r\n#PF(fault-code) For a page fault.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29] = 0.\r\nIf the LOCK prefix is used.\r\nReal-Address Mode Exceptions\r\n#GP If any part of the operand lies outside the effective address space from 0 to FFFFH.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29] = 0.\r\nIf the LOCK prefix is used.\r\nVirtual-8086 Mode Exceptions\r\n#GP(0) The ENQCMDS instruction is not recognized in virtual-8086 mode.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\n#SS(0) If a memory address referencing the SS segment is in non-canonical form.\r\n#GP(0) If the memory address is in non-canonical form.\r\nIf destination linear address is not aligned to a 64-byte boundary.\r\nIf the current privilege level is not 0.\r\n#PF(fault-code) For a page fault.\r\n#UD If CPUID.07H.0H:ECX.ENQCMD[bit 29].\r\nIf the LOCK prefix is used.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ddcd3e3f-08ff-4238-8953-fed9cd0c8cf6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b02e327c96435ffafab6be04efc7acb33e96d034cdc0670f9c21cf15bd468f63",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 360
      },
      {
        "segments": [
          {
            "segment_id": "99191309-11a2-4e2b-9d7c-67c3f799f393",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 67,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-7\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse\r\nInstruction Operand Encoding\r\nDescription\r\nThe AFFINEINVB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine \r\ntransformation is defined by A * inv(x) + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. The \r\ninverse of the bytes in x is defined with respect to the reduction polynomial x8 + x4 + x3 + x + 1.\r\nOne SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register \r\nor memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” \r\nvalues in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of \r\nthe instruction require 16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F3A CF /r /ib\r\nGF2P8AFFINEINVQB xmm1, \r\nxmm2/m128, imm8\r\nA V/V GFNI Computes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nVEX.128.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nVEX.256.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.128.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB xmm1{k1}{z}, \r\nxmm2, xmm3/m128/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.256.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB ymm1{k1}{z}, \r\nymm2, ymm3/m256/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nEVEX.512.66.0F3A.W1 CF /r /ib\r\nVGF2P8AFFINEINVQB zmm1{k1}{z}, \r\nzmm2, zmm3/m512/m64bcst, imm8\r\nC V/V AVX512F\r\nGFNI\r\nComputes inverse affine transformation in the \r\nfinite field GF(2^8).\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) imm8 (r) NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nC Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/99191309-11a2-4e2b-9d7c-67c3f799f393.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=81596b78215a2835ed1e87dcbfbb769f15b66e699ba7b0e0ada7c1ce806f32fe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 355
      },
      {
        "segments": [
          {
            "segment_id": "c045e058-ea6a-4c76-9152-0f0b2869caba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 68,
            "page_width": 612,
            "page_height": 792,
            "content": "2-8 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nThe inverse of each byte is given by the following table. The upper nibble is on the vertical axis and the lower nibble \r\nis on the horizontal axis. For example, the inverse of 0x95 is 0x8A.\r\nOperation\r\ndefine affine_inverse_byte(tsrc2qw, src1byte, imm):\r\nFOR i ← 0 to 7:\r\n* parity(x) = 1 if x has an odd number of 1s in it, and 0 otherwise.*\r\n* inverse(x) is defined in the table above *\r\nretbyte.bit[i] ← parity(tsrc2qw.byte[7-i] AND inverse(src1byte)) XOR imm8.bit[i]\r\nreturn retbyte\r\nVGF2P8AFFINEINVQB dest, src1, src2, imm8 (EVEX encoded version)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC2 is memory and EVEX.b==1:\r\ntsrc2 ← SRC2.qword[0]\r\nELSE:\r\ntsrc2 ← SRC2.qword[j]\r\nFOR b ← 0 to 7:\r\nIF k1[j*8+b] OR *no writemask*:\r\nFOR i ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_inverse_byte(tsrc2, SRC1.qword[j].byte[b], imm8)\r\nELSE IF *zeroing*:\r\nDEST.qword[j].byte[b] ← 0\r\n*ELSE DEST.qword[j].byte[b] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nTable 2-1. Inverse Byte Listings\r\n- 0123456789ABCDEF\r\n0 0 1 8D F6 CB 52 7B D1 E8 4F 29 C0 B0 E1 E5 C7\r\n1 74 B4 AA 4B 99 2B 60 5F 58 3F FD CC FF 40 EE B2\r\n2 3A 6E 5A F1 55 4D A8 C9 C1 A 98 15 30 44 A2 C2\r\n3 2C 45 92 6C F3 39 66 42 F2 35 20 6F 77 BB 59 19\r\n4 1D FE 37 67 2D 31 F5 69 A7 64 AB 13 54 25 E9 9\r\n5 ED 5C 5 CA 4C 24 87 BF 18 3E 22 F0 51 EC 61 17\r\n6 16 5E AF D3 49 A6 36 43 F4 47 91 DF 33 93 21 3B\r\n7 79 B7 97 85 10 B5 BA 3C B6 70 D0 6 A1 FA 81 82\r\n8 83 7E 7F 80 96 73 BE 56 9B 9E 95 D9 F7 2 B9 A4\r\n9 DE 6A 32 6D D8 8A 84 72 2A 14 9F 88 F9 DC 89 9A\r\nA FB 7C 2E C3 8F B8 65 48 26 C8 12 4A CE E7 D2 62\r\nB C E0 1F EF 11 75 78 71 A5 8E 76 3D BD BC 86 57\r\nC B 28 2F A3 DA D4 E4 F A9 27 53 4 1B FC AC E6\r\nD 7A 7 AE 63 C5 DB E2 EA 94 8B C4 D5 9D F8 90 6B\r\nE B1 D D6 EB C6 E CF AD 8 4E D7 E3 5D 50 1E B3\r\nF 5B 23 38 34 68 46 3 8C DD 9C 7D A0 CD 1A 41 1C",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/c045e058-ea6a-4c76-9152-0f0b2869caba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=263905e3f8d4258abf34d5bc8c54c93cdaccca5fff503f7c396dbb6e497e80d0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 440
      },
      {
        "segments": [
          {
            "segment_id": "bb070dfc-95ba-406f-93ed-cef920152269",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 69,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-9\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVGF2P8AFFINEINVQB dest, src1, src2, imm8 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (2, 128), (4, 256)\r\nFOR j ← 0 TO KL-1:\r\nFOR b ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_inverse_byte(SRC2.qword[j], SRC1.qword[j].byte[b], imm8)\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8AFFINEINVQB srcdest, src1, imm8 (128b SSE encoded version)\r\nFOR j ← 0 TO 1:\r\nFOR b ← 0 to 7:\r\nSRCDEST.qword[j].byte[b] ← affine_inverse_byte(SRC1.qword[j], SRCDEST.qword[j].byte[b], imm8)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nGF2P8AFFINEINVQB __m128i _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m128i _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m128i _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m256i _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);\r\nGF2P8AFFINEINVQB __m512i _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/bb070dfc-95ba-406f-93ed-cef920152269.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a2994e7fa1d991290714da64d6cf369b5005331a26791338c671d3f95324e206",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b41ffa11-abeb-43d0-9e55-3993add2abd8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 70,
            "page_width": 612,
            "page_height": 792,
            "content": "2-10 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8AFFINEQB — Galois Field Affine Transformation\r\nInstruction Operand Encoding\r\nDescription\r\nThe AFFINEB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine \r\ntransformation is defined by A * x + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. One SIMD \r\nregister (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory \r\noperand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the \r\nfirst register. The “b” vector is constant for all calculations and contained in the immediate byte.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression. The SSE encoded forms of \r\nthe instruction require16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F3A CE /r /ib\r\nGF2P8AFFINEQB xmm1, \r\nxmm2/m128, imm8\r\nA V/V GFNI Computes affine transformation in the finite \r\nfield GF(2^8).\r\nVEX.128.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nVEX.256.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.128.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB xmm1{k1}{z}, \r\nxmm2, xmm3/m128/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.256.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB ymm1{k1}{z}, \r\nymm2, ymm3/m256/m64bcst, imm8\r\nC V/V AVX512VL\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nEVEX.512.66.0F3A.W1 CE /r /ib\r\nVGF2P8AFFINEQB zmm1{k1}{z}, \r\nzmm2, zmm3/m512/m64bcst, imm8\r\nC V/V AVX512F\r\nGFNI\r\nComputes affine transformation in the finite \r\nfield GF(2^8).\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) imm8 (r) NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nC Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b41ffa11-abeb-43d0-9e55-3993add2abd8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=63bc75af6b0422b7fb17a6d1a12c359985ffb393622b7e784937361b8e6ade87",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 470
      },
      {
        "segments": [
          {
            "segment_id": "e00e54d0-9ab7-4cdd-a179-565760f559c6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 71,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-11\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\ndefine parity(x):\r\nt ← 0 // single bit\r\nFOR i ← 0 to 7:\r\nt = t xor x.bit[i]\r\nreturn t\r\ndefine affine_byte(tsrc2qw, src1byte, imm):\r\nFOR i ← 0 to 7:\r\n* parity(x) = 1 if x has an odd number of 1s in it, and 0 otherwise.*\r\nretbyte.bit[i] ← parity(tsrc2qw.byte[7-i] AND src1byte) XOR imm8.bit[i]\r\nreturn retbyte\r\nVGF2P8AFFINEQB dest, src1, src2, imm8 (EVEX encoded version)\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC2 is memory and EVEX.b==1:\r\ntsrc2 ← SRC2.qword[0]\r\nELSE:\r\ntsrc2 ← SRC2.qword[j]\r\nFOR b ← 0 to 7:\r\nIF k1[j*8+b] OR *no writemask*:\r\nDEST.qword[j].byte[b] ← affine_byte(tsrc2, SRC1.qword[j].byte[b], imm8)\r\nELSE IF *zeroing*:\r\nDEST.qword[j].byte[b] ← 0\r\n*ELSE DEST.qword[j].byte[b] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVGF2P8AFFINEQB dest, src1, src2, imm8 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (2, 128), (4, 256)\r\nFOR j ← 0 TO KL-1:\r\nFOR b ← 0 to 7:\r\nDEST.qword[j].byte[b] ← affine_byte(SRC2.qword[j], SRC1.qword[j].byte[b], imm8)\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8AFFINEQB srcdest, src1, imm8 (128b SSE encoded version)\r\nFOR j ← 0 TO 1:\r\nFOR b ← 0 to 7:\r\nSRCDEST.qword[j].byte[b] ← affine_byte(SRC1.qword[j], SRCDEST.qword[j].byte[b], imm8)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nGF2P8AFFINEQB __m128i _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);\r\nGF2P8AFFINEQB __m128i _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEQB __m128i _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);\r\nGF2P8AFFINEQB __m256i _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);\r\nGF2P8AFFINEQB __m256i _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEQB __m256i _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);\r\nGF2P8AFFINEQB __m512i _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);\r\nGF2P8AFFINEQB __m512i _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);\r\nGF2P8AFFINEQB __m512i _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e00e54d0-9ab7-4cdd-a179-565760f559c6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=dff52aa9a4d5892c8b2a497d06c37548719c4c9ccb32b5902ab9cd04792c5b17",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "648879bb-26c2-4a34-bfb5-585dd6f88640",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 72,
            "page_width": 612,
            "page_height": 792,
            "content": "2-12 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/648879bb-26c2-4a34-bfb5-585dd6f88640.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=55629a7130f6a73ff2626c608e4bde8ed9305980dbbda750cea5f2cb17d4adb3",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 278
      },
      {
        "segments": [
          {
            "segment_id": "bce5b6f1-4714-4641-8651-5414f1a5c95d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 73,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-13\r\nINSTRUCTION SET REFERENCE, A-Z\r\nGF2P8MULB — Galois Field Multiply Bytes\r\nInstruction Operand Encoding\r\nDescription\r\nThe instruction multiplies elements in the finite field GF(28), operating on a byte (field element) in the first source \r\noperand and the corresponding byte in a second source operand. The field GF(28) is represented in polynomial \r\nrepresentation with the reduction polynomial x8 + x4 + x3 + x + 1.\r\nThis instruction does not support broadcasting.\r\nThe EVEX encoded form of this instruction supports memory fault suppression. The SSE encoded forms of the \r\ninstruction require16B alignment on their memory operations.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\n66 0F38 CF /r\r\nGF2P8MULB xmm1, xmm2/m128\r\nA V/V GFNI Multiplies elements in the finite field GF(2^8). \r\nVEX.128.66.0F38.W0 CF /r\r\nVGF2P8MULB xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nVEX.256.66.0F38.W0 CF /r\r\nVGF2P8MULB ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.128.66.0F38.W0 CF /r\r\nVGF2P8MULB xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nC V/V AVX512VL\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.256.66.0F38.W0 CF /r\r\nVGF2P8MULB ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nC V/V AVX512VL\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nEVEX.512.66.0F38.W0 CF /r\r\nVGF2P8MULB zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nC V/V AVX512F\r\nGFNI\r\nMultiplies elements in the finite field GF(2^8). \r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (r, w) ModRM:r/m (r) NA NA\r\nB NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nC Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/bce5b6f1-4714-4641-8651-5414f1a5c95d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=30db2765172a3c77c9aad6f336c19341dc9091723d268ad6803301c34376bd6c",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "cf85bd11-43f1-4aad-b26e-ef35904d80a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 74,
            "page_width": 612,
            "page_height": 792,
            "content": "2-14 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\ndefine gf2p8mul_byte(src1byte, src2byte):\r\ntword ← 0\r\nFOR i ← 0 to 7:\r\nIF src2byte.bit[i]:\r\ntword ← tword XOR (src1byte<< i)\r\n* carry out polynomial reduction by the characteristic polynomial p*\r\nFOR i ← 14 downto 8:\r\np ← 0x11B << (i-8) *0x11B = 0000_0001_0001_1011 in binary*\r\nIF tword.bit[i]:\r\ntword ← tword XOR p\r\nreturn tword.byte[0]\r\nVGF2P8MULB dest, src1, src2 (EVEX encoded version)\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[j] ← gf2p8mul_byte(SRC1.byte[j], SRC2.byte[j])\r\nELSE iF *zeroing*:\r\nDEST.byte[j] ← 0\r\n* ELSE DEST.byte[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVGF2P8MULB dest, src1, src2 (128b and 256b VEX encoded versions)\r\n(KL, VL) = (16, 128), (32, 256)\r\nFOR j ← 0 TO KL-1:\r\nDEST.byte[j] ← gf2p8mul_byte(SRC1.byte[j], SRC2.byte[j])\r\nDEST[MAX_VL-1:VL] ← 0\r\nGF2P8MULB srcdest, src1 (128b SSE encoded version)\r\nFOR j ← 0 TO 15:\r\nSRCDEST.byte[j] ← gf2p8mul_byte(SRCDEST.byte[j], SRC1.byte[j])\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVGF2P8MULB __m128i _mm_gf2p8mul_epi8(__m128i, __m128i);\r\nVGF2P8MULB __m128i _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);\r\nVGF2P8MULB __m128i _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);\r\nVGF2P8MULB __m256i _mm256_gf2p8mul_epi8(__m256i, __m256i);\r\nVGF2P8MULB __m256i _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);\r\nVGF2P8MULB __m256i _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);\r\nVGF2P8MULB __m512i _mm512_gf2p8mul_epi8(__m512i, __m512i);\r\nVGF2P8MULB __m512i _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);\r\nVGF2P8MULB __m512i _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nLegacy-encoded and VEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/cf85bd11-43f1-4aad-b26e-ef35904d80a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f0bc2463e5206c2e02e52f2004c237ef79523791424278e3ffc4dce6d8ee889d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 478
      },
      {
        "segments": [
          {
            "segment_id": "7043a548-8dca-4255-aabc-ea8cde447064",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 75,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-15\r\nINSTRUCTION SET REFERENCE, A-Z\r\nPCONFIG — Platform Configuration\r\nInstruction Operand Encoding\r\nDescription\r\nPCONFIG allows software to configure certain platform features. PCONFIG supports multiple leaf functions, with a \r\nleaf function identified by the value in EAX. The registers RBX, RCX, and RDX have leaf-specific purposes.\r\nEach PCONFIG leaf function applies to a specific hardware block called a PCONFIG target, and each PCONFIG target \r\nis associated with a numerical identifier. The identifiers of the PCONFIG targets supported by the CPU (which imply \r\nthe supported leaf functions) are enumerated in the sub-leaves of the PCONFIG-information leaf of CPUID (EAX = \r\n1BH). An attempt to execute an undefined leaf function results in a general-protection exception (#GP).\r\nAddresses and operands are 32 bits outside 64-bit mode (IA32_EFER.LMA = 0 || CS.L = 0) and are 64 bits in 64-\r\nbit mode (IA32_EFER.LMA = 1 && CS.L = 1). The value of CS.D has no effect on address calculation.\r\nTable 2-2 shows the leaf encodings for PCONFIG.\r\nThe MKTME_KEY_PROGRAM leaf of PCONFIG pertains to the MKTME target, which has target identifier 1. It is used \r\nby software to manage the key associated with a KeyID. The leaf function is invoked by setting the leaf value of 0 \r\nin EAX and the address of MKTME_KEY_PROGRAM_STRUCT in RBX. Successful execution of the leaf clears RAX (set \r\nto zero) and ZF, CF, PF, AF, OF, and SF are cleared. In case of failure, the failure reason is indicated in RAX with ZF \r\nset to 1 and CF, PF, AF, OF, and SF are cleared. The MKTME_KEY_PROGRAM leaf uses the \r\nMKTME_KEY_PROGRAM_STRUCT in memory shown in Table 2-3.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nNP 0F 01 C5\r\nPCONFIG \r\nA V/V PCONFIG This instruction is used to execute functions \r\nfor configuring platform features.\r\nEAX: Leaf function to be invoked.\r\nRBX/RCX/RDX: Leaf-specific purpose.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA NA NA NA NA\r\nTable 2-2. PCONFIG Leaf Encodings\r\nLeaf Encoding Description\r\nMKTME_KEY_PROGRAM 00000000H This leaf is used to program the key and encryption mode associated \r\nwith a KeyID.\r\nRESERVED 00000001H - FFFFFFFFH Reserved for future use (#GP(0) if used).\r\nTable 2-3. MKTME_KEY_PROGRAM_STRUCT Format\r\nField Offset (bytes) Size (bytes) Comments\r\nKEYID 0 2 Key Identifier.\r\nKEYID_CTRL 2 4 KeyID control:\r\n• Bits [7:0]: COMMAND.\r\n• Bits [23:8]: ENC_ALG.\r\n• Bits [31:24]: Reserved, must be zero.\r\nRESERVED 6 58 Reserved, must be zero.\r\nKEY_FIELD_1 64 64 Software supplied KeyID data key or entropy for KeyID data key.\r\nKEY_FIELD_2 128 64 Software supplied KeyID tweak key or entropy for KeyID tweak key.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/7043a548-8dca-4255-aabc-ea8cde447064.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e2ad28813c63877415e0ea545fb883b8953d9036ae93b7cbe941254f0601e11e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 433
      },
      {
        "segments": [
          {
            "segment_id": "19050ca3-e37c-4616-ab3f-30f88f055e77",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "2-16 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nA description of each of the fields in MKTME_KEY_PROGRAM_STRUCT is provided below:\r\n• KEYID: Key Identifier being programmed to the MKTME engine.\r\n• KEYID_CTRL: The KEYID_CTRL field carries two sub-fields used by software to control the behavior of a \r\nKeyID: Command and KeyID encryption algorithm. \r\nThe command used controls the encryption mode for a KeyID. Table 2-4 provides a summary of the \r\ncommands supported.\r\nThe encryption algorithm field (ENC_ALG) allows software to select one of the activated encryption algorithms \r\nfor the KeyID. The BIOS can activate a set of algorithms to allow for use when programming keys using the \r\nIA32_TME_ACTIVATE MSR (does not apply to KeyID 0 which uses TME policy). The ISA checks to ensure that \r\nthe algorithm selected by software is one of the algorithms that has been activated by the BIOS.\r\n• KEY_FIELD_1: This field carries the software supplied data key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom data key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\n• KEY_FIELD_2: This field carries the software supplied tweak key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom tweak key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\nAll KeyIDs use the TME key on MKTME activation. Software can at any point decide to change the key for a \r\nKeyID using the PCONFIG instruction. Change of keys for a KeyID does NOT change the state of the TLB \r\ncaches or memory pipeline. It is software's responsibility to take appropriate actions to ensure correct \r\nbehavior.\r\nTable 2-5 shows the return values associated with the MKTME_KEY_PROGRAM leaf of PCONFIG. On \r\ninstruction execution, RAX is populated with the return value.\r\nTable 2-4. Supported Key Programming Commands\r\nCommand Encoding Description\r\nKEYID_SET_KEY_DIRECT 0 Software uses this mode to directly program a key for use with KeyID.\r\nKEYID_SET_KEY_RANDOM 1 CPU generates and assigns an ephemeral key for use with a KeyID. Each time the \r\ninstruction is executed, the CPU generates a new key using a hardware random \r\nnumber generator and the keys are discarded on reset.\r\nKEYID_CLEAR_KEY 2 Clear the (software programmed) key associated with the KeyID. On execution of this \r\ncommand, the KeyID gets TME behavior (encrypt with platform TME key).\r\nKEYID_NO_ENCRYPT 3 Do not encrypt memory when this KeyID is in use.\r\nTable 2-5. Supported Key Programming Commands\r\nReturn Value Encoding Description\r\nPROG_SUCCESS 0 KeyID was successfully programmed.\r\nINVALID_PROG_CMD 1 Invalid KeyID programming command.\r\nENTROPY_ERROR 2 Insufficient entropy.\r\nINVALID_KEYID 3 KeyID not valid.\r\nINVALID_ENC_ALG 4 Invalid encryption algorithm chosen (not supported).\r\nDEVICE_BUSY 5 Failure to access key table.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/19050ca3-e37c-4616-ab3f-30f88f055e77.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=68cf751698aaffd33715ccf029327364fc86c8967e91497e834695283c82c16e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 604
      },
      {
        "segments": [
          {
            "segment_id": "19050ca3-e37c-4616-ab3f-30f88f055e77",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 76,
            "page_width": 612,
            "page_height": 792,
            "content": "2-16 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nA description of each of the fields in MKTME_KEY_PROGRAM_STRUCT is provided below:\r\n• KEYID: Key Identifier being programmed to the MKTME engine.\r\n• KEYID_CTRL: The KEYID_CTRL field carries two sub-fields used by software to control the behavior of a \r\nKeyID: Command and KeyID encryption algorithm. \r\nThe command used controls the encryption mode for a KeyID. Table 2-4 provides a summary of the \r\ncommands supported.\r\nThe encryption algorithm field (ENC_ALG) allows software to select one of the activated encryption algorithms \r\nfor the KeyID. The BIOS can activate a set of algorithms to allow for use when programming keys using the \r\nIA32_TME_ACTIVATE MSR (does not apply to KeyID 0 which uses TME policy). The ISA checks to ensure that \r\nthe algorithm selected by software is one of the algorithms that has been activated by the BIOS.\r\n• KEY_FIELD_1: This field carries the software supplied data key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom data key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\n• KEY_FIELD_2: This field carries the software supplied tweak key to be used for the KeyID if the direct key \r\nprogramming option is used (KEYID_SET_KEY_DIRECT). When the random key programming option is used \r\n(KEYID_SET_KEY_RANDOM), this field carries the software supplied entropy to be mixed in the CPU generated \r\nrandom tweak key. It is software's responsibility to ensure that the key supplied for the direct programming \r\noption or the entropy supplied for the random programming option does not result in weak keys. There are no \r\nexplicit checks in the instruction to detect or prevent weak keys. When AES XTS-128 is used, the upper 48B are \r\ntreated as reserved and must be zeroed out by software before executing the instruction.\r\nAll KeyIDs use the TME key on MKTME activation. Software can at any point decide to change the key for a \r\nKeyID using the PCONFIG instruction. Change of keys for a KeyID does NOT change the state of the TLB \r\ncaches or memory pipeline. It is software's responsibility to take appropriate actions to ensure correct \r\nbehavior.\r\nTable 2-5 shows the return values associated with the MKTME_KEY_PROGRAM leaf of PCONFIG. On \r\ninstruction execution, RAX is populated with the return value.\r\nTable 2-4. Supported Key Programming Commands\r\nCommand Encoding Description\r\nKEYID_SET_KEY_DIRECT 0 Software uses this mode to directly program a key for use with KeyID.\r\nKEYID_SET_KEY_RANDOM 1 CPU generates and assigns an ephemeral key for use with a KeyID. Each time the \r\ninstruction is executed, the CPU generates a new key using a hardware random \r\nnumber generator and the keys are discarded on reset.\r\nKEYID_CLEAR_KEY 2 Clear the (software programmed) key associated with the KeyID. On execution of this \r\ncommand, the KeyID gets TME behavior (encrypt with platform TME key).\r\nKEYID_NO_ENCRYPT 3 Do not encrypt memory when this KeyID is in use.\r\nTable 2-5. Supported Key Programming Commands\r\nReturn Value Encoding Description\r\nPROG_SUCCESS 0 KeyID was successfully programmed.\r\nINVALID_PROG_CMD 1 Invalid KeyID programming command.\r\nENTROPY_ERROR 2 Insufficient entropy.\r\nINVALID_KEYID 3 KeyID not valid.\r\nINVALID_ENC_ALG 4 Invalid encryption algorithm chosen (not supported).\r\nDEVICE_BUSY 5 Failure to access key table.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/19050ca3-e37c-4616-ab3f-30f88f055e77.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=68cf751698aaffd33715ccf029327364fc86c8967e91497e834695283c82c16e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 604
      },
      {
        "segments": [
          {
            "segment_id": "501b884b-3ebd-463c-8740-51083999bc3d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 77,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-17\r\nINSTRUCTION SET REFERENCE, A-Z\r\nPCONFIG Virtualization\r\nSoftware in VMX root mode can control the execution of PCONFIG in VMX non-root mode using the following execu\u0002tion controls introduced for PCONFIG:\r\n• PCONFIG_ENABLE: This control is a single bit control and enables the PCONFIG instruction in VMX non-root \r\nmode. If 0, the execution of PCONFIG in VMX non-root mode causes #UD. Otherwise, execution of PCONFIG \r\nworks according to PCONFIG_EXITING.\r\n• PCONFIG_EXITING: This is a 64b control and allows VMX root mode to cause a VM-exit for various leaf \r\nfunctions of PCONFIG. This control does not have any effect if the PCONFIG_ENABLE control is clear.\r\nPCONFIG Concurrency\r\nIn a scenario, where the MKTME_KEY_PROGRAM leaf of PCONFIG is executed concurrently on multiple logical \r\nprocessors, only one logical processor will succeed in updating the key table. PCONFIG execution will return with \r\nan error code (DEVICE_BUSY) on other logical processors and software must retry. In cases where the instruction \r\nexecution fails with a DEVICE_BUSY error code, the key table is not updated, thereby ensuring that either the key \r\ntable is updated in its entirety with the information for a KeyID, or it is not updated at all. In order to accomplish \r\nthis, the MKTME_KEY_PROGRAM leaf of PCONFIG maintains a writer lock for updating the key table. This lock is \r\nreferred to as the Key table lock and denoted in the instruction flows as KEY_TABLE_LOCK. The lock can either be \r\nunlocked, when no logical processor is holding the lock (also the initial state of the lock) or be in an exclusive state \r\nwhere a logical processor is trying to update the key table. There can be only one logical processor holding the lock \r\nin exclusive state. The lock, being exclusive, can only be acquired when the lock is in unlocked state.\r\nPCONFIG uses the following syntax to acquire KEY_TABLE_LOCK in exclusive mode and release the lock:\r\n• KEY_TABLE_LOCK.ACQUIRE(WRITE)\r\n• KEY_TABLE_LOCK.RELEASE()\r\nOperation\r\n(* #UD if PCONFIG is not enumerated or CPL>0 *)\r\nif (CPUID.7.0:EDX[18] == 0 OR CPL > 0) #UD;\r\nif (in VMX non-root mode)\r\n{\r\nif (VMCS.PCONFIG_ENABLE == 1)\r\n{\r\nif ((EAX > 62 AND VMCS.PCONFIG_EXITING[63] ==1) OR \r\n (EAX < 63 AND VMCS.PCONFIG_EXITING[EAX] == 1))\r\n{\r\nSet VMCS.EXIT_REASON = PCONFIG; //No Exit qualification\r\nDeliver VMEXIT;\r\n}\r\n}\r\nelse\r\n{ \r\n#UD\r\nTable 2-6. PCONFIG Operation Variables\r\nVariable Name Type Size \r\n(Bytes)\r\nDescription\r\nTMP_KEY_PROGRAM_STRUCT MKTME_KEY_PROGRAM_STRUCT 192 Structure holding the key programming structure.\r\nTMP_RND_DATA_KEY UINT128 16 Random data key generated for random key \r\nprogramming option.\r\nTMP_RND_TWEAK_KEY UINT128 16 Random tweak key generated for random key \r\nprogramming option.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/501b884b-3ebd-463c-8740-51083999bc3d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9fc23819312c534b8ec8dff42b5ffa77f189f46312ac88f5f84ef16b3d52ec8c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 422
      },
      {
        "segments": [
          {
            "segment_id": "c8e96c66-1d59-425a-b544-1b21aeb9bb2f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 78,
            "page_width": 612,
            "page_height": 792,
            "content": "2-18 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\n}\r\n}\r\n(* #GP(0) for an unsupported leaf *)\r\nif(EAX != 0) #GP(0)\r\n(* KEY_PROGRAM leaf flow *)\r\nif (EAX == 0)\r\n{\r\n(* #GP(0) if TME_ACTIVATE MSR is not locked or does not enable TME or multiple keys are not enabled *)\r\nif (IA32_TME_ACTIVATE.LOCK != 1 OR IA32_TME_ACTIVATE.ENABLE != 1 OR IA32_TME_ACTIVATE.MK_TME_KEYID_BITS == 0) \r\n#GP(0)\r\n(* Check MKTME_KEY_PROGRAM_STRUCT is 256B aligned *)\r\nif(DS:RBX is not 256B aligned) #GP(0);\r\n(* Check that MKTME_KEY_PROGRAM_STRUCT is read accessible *)\r\n<<DS: RBX should be read accessible>>\r\n(* Copy MKTME_KEY_PROGRAM_STRUCT to a temporary variable *)\r\nTMP_KEY_PROGRAM_STRUCT = DS:RBX.*;\r\n(* RSVD field check *)\r\nif(TMP_KEY_PROGRAM_STRUCT.RSVD != 0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.RSVD !=0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1.BYTES[63:16] != 0) #GP(0);\r\nif(TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2.BYTES[63:16] != 0) #GP(0);\r\n(* Check for a valid command *)\r\nif(TMP_KEY_PROGRAM_STRUCT. KEYID_CTRL.COMMAND is not a valid command)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_PROG_CMD;\r\ngoto EXIT;\r\n}\r\n(* Check that the KEYID being operated upon is a valid KEYID *)\r\nif(TMP_KEY_PROGRAM_STRUCT.KEYID > \r\n2^IA32_TME_ACTIVATE.MK_TME_KEYID_BITS - 1\r\nOR TMP_KEY_PROGRAM_STRUCT.KEYID > \r\nIA32_TME_CAPABILITY.MK_TME_MAX_KEYS \r\nOR TMP_KEY_PROGRAM_STRUCT.KEYID == 0) \r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_KEYID;\r\ngoto EXIT;\r\n}\r\n(* Check that only one algorithm is requested for the KeyID and it is one of the activated algorithms *)\r\nif(NUM_BITS(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG) != 1 || \r\n(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.ENC_ALG & \r\nIA32_TME_ACTIVATE. MK_TME_CRYPTO_ALGS == 0))",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/c8e96c66-1d59-425a-b544-1b21aeb9bb2f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7d7615c06cd3850806ba74aa232b0df49185aa959a8907c5f362a781dbee0db6",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "34a1255c-1dc3-48ba-a07b-846b11eab0c4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 79,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-19\r\nINSTRUCTION SET REFERENCE, A-Z\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = INVALID_ENC_ALG;\r\ngoto EXIT;\r\n}\r\n(* Try to acquire exclusive lock *)\r\nif (NOT KEY_TABLE_LOCK.ACQUIRE(WRITE))\r\n{\r\n//PCONFIG failure\r\nRFLAGS.ZF = 1;\r\nRAX = DEVICE_BUSY;\r\ngoto EXIT;\r\n}\r\n(* Lock is acquired and key table will be updated as per the command \r\nBefore this point no changes to the key table are made *)\r\nswitch(TMP_KEY_PROGRAM_STRUCT.KEYID_CTRL.COMMAND)\r\n{\r\ncase KEYID_SET_KEY_DIRECT:\r\n<<Write \r\nDATA_KEY=TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1,\r\nTWEAK_KEY=TMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2,\r\nENCRYPTION_MODE=ENCRYPT_WITH_KEYID_KEY,\r\nto MKTME Key table at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\ncase KEYID_SET_KEY_RANDOM:\r\nTMP_RND_DATA_KEY = <<Generate a random key using hardware RNG>>\r\nif (NOT ENOUGH ENTROPY)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = ENTROPY_ERROR;\r\ngoto EXIT;\r\n}\r\nTMP_RND_TWEAK_KEY = <<Generate a random key using hardware RNG>>\r\nif (NOT ENOUGH ENTROPY)\r\n{\r\nRFLAGS.ZF = 1;\r\nRAX = ENTROPY_ERROR;\r\ngoto EXIT;\r\n}\r\n(* Mix user supplied entropy to the data key and tweak key *)\r\nTMP_RND_DATA_KEY = TMP_RND_KEY XOR \r\nTMP_KEY_PROGRAM_STRUCT.KEY_FIELD_1.BYTES[15:0];\r\nTMP_RND_TWEAK_KEY = TMP_RND_TWEAK_KEY XOR \r\nTMP_KEY_PROGRAM_STRUCT.KEY_FIELD_2.BYTES[15:0];\r\n<<Write \r\nDATA_KEY=TMP_RND_DATA_KEY, \r\nTWEAK_KEY=TMP_RND_TWEAK_KEY,\r\nENCRYPTION_MODE=ENCRYPT_WITH_KEYID_KEY,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/34a1255c-1dc3-48ba-a07b-846b11eab0c4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=133bc6c95c2e2281e2ee939042ee728a5667364f8dcfa90618ed67f44ab4b148",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 375
      },
      {
        "segments": [
          {
            "segment_id": "f4fd657b-97f4-4684-a815-2e71a6c8e895",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 80,
            "page_width": 612,
            "page_height": 792,
            "content": "2-20 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\n>>\r\nbreak;\r\ncase KEYID_CLEAR_KEY:\r\n<<Write\r\nDATA_KEY='0,\r\nTWEAK_KEY='0,\r\nENCRYPTION_MODE = ENCRYPT_WITH_TME_KEY,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\ncase KD_NO_ENCRYPT:\r\n<<Write \r\nENCRYPTION_MODE=NO_ENCRYPTION,\r\nto MKTME_KEY_TABLE at index TMP_KEY_PROGRAM_STRUCT.KEYID\r\n>>\r\nbreak;\r\n}\r\nRAX = 0;\r\nRFLAGS.ZF = 0;\r\n//Release Lock\r\nKEY_TABLE_LOCK(RELEASE);\r\nEXIT:\r\nRFLAGS.CF=0;\r\nRFLAGS.PF=0;\r\nRFLAGS.AF=0;\r\nRFLAGS.OF=0;\r\nRFLAGS.SF=0;\r\n}\r\nend_of_flow\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nTBD\r\nProtected Mode Exceptions\r\n#GP(0) If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability are not enabled in IA32_TME_ACTIVATE MSR.\r\nIf the memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\nIf a memory operand effective address is outside the DS segment limit.\r\n#PF(fault-code) If a page fault occurs in accessing memory operands.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf current privilege level is not 0.\r\nIf CPUID.7.0:EDX[bit 18] = 0\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/f4fd657b-97f4-4684-a815-2e71a6c8e895.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=85bd2331a6cc8ab8eb1aa0774c49c2e6d7081dd6bb62237cc1ce38221b5b53d0",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ca407ca4-2616-479e-a92d-e80f5372df78",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 81,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-21\r\nINSTRUCTION SET REFERENCE, A-Z\r\nReal Address Mode Exceptions\r\n#GP If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability is not enabled in IA32_TME_ACTIVATE MSR.\r\nIf a memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf current privilege level is not 0.\r\nIf CPUID.7.0:EDX.PCONFIG[bit 18] = 0\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.\r\nVirtual 8086 Mode Exceptions\r\n#UD PCONFIG instruction is not recognized in virtual-8086 mode.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\n#GP(0) If input value in EAX encodes an unsupported leaf.\r\nIf IA32_TME_ACTIVATE MSR is not locked.\r\nIf TME and MKTME capability is not enabled in IA32_TME_ACTIVATE MSR.\r\nIf a memory operand is not 256B aligned.\r\nIf any of the reserved bits in MKTME_KEY_PROGRAM_STRUCT are set.\r\nIf a memory operand is non-canonical form.\r\n#PF(fault-code) If a page fault occurs in accessing memory operands.\r\n#UD If any of the LOCK/REP/OSIZE/VEX prefixes are used.\r\nIf the current privilege level is not 0.\r\nIf CPUID.7.0:EDX.PCONFIG[bit 18] = 0.\r\nIf in VMX non-root mode and VMCS.PCONFIG_ENABLE = 0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ca407ca4-2616-479e-a92d-e80f5372df78.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bd346987fba0bd22fc31a6f2f2a54f875636cfd1b6ac68058093689f93247e1a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 365
      },
      {
        "segments": [
          {
            "segment_id": "80b639fb-6c0a-41a3-8d27-0130b5047ead",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 82,
            "page_width": 612,
            "page_height": 792,
            "content": "2-22 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDEC — Perform One Round of an AES Decryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the \r\nround key from the second source operand, operating on a 128-bit data (state) from the first source operand, and \r\nstore the result in the destination operand.\r\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDEC\u0002CLAST instruction.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESDEC\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.256.66.0F38.WIG DE /r \r\nVAESDEC ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from ymm2 with a \r\n128-bit round key from ymm3/m256; store the \r\nresult in ymm1.\r\nEVEX.128.66.0F38.WIG DE /r\r\nVAESDEC xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from xmm2 with a \r\n128-bit round key from xmm3/m128; store the \r\nresult in xmm1.\r\nEVEX.256.66.0F38.WIG DE /r\r\nVAESDEC ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from ymm2 with a \r\n128-bit round key from ymm3/m256; store the \r\nresult in ymm1.\r\nEVEX.512.66.0F38.WIG DE /r\r\nVAESDEC zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform one round of an AES decryption flow, \r\nusing the Equivalent Inverse Cipher, operating \r\non a 128-bit data (state) from zmm2 with a \r\n128-bit round key from zmm3/m512; store the \r\nresult in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/80b639fb-6c0a-41a3-8d27-0130b5047ead.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=686da642f056dd8fefa56886bd41385246508e732790a96b65e5cec0775a186a",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "4d84db40-4407-4b69-b961-484ef949a24a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 83,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-23\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDEC (128b and 256b VEX encoded versions)\r\n(KL,V) = (1,128), (2,256)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESDEC (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nSTATE ← InvMixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESDEC __m256i _mm256_aesdec_epi128(__m256i, __m256i);\r\nVAESDEC __m512i _mm512_aesdec_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4d84db40-4407-4b69-b961-484ef949a24a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5f4bde60fda85ae58bc9ecbf2a5799182800f3d51b2fc64ee59fd62791b0d322",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 509
      },
      {
        "segments": [
          {
            "segment_id": "ff48acfd-acaa-4fac-8183-e576546d2fea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 84,
            "page_width": 612,
            "page_height": 792,
            "content": "2-24 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDECLAST — Perform Last Round of an AES Decryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the \r\nround key from the second source operand, operating on a 128-bit data (state) from the first source operand, and \r\nstore the result in the destination operand.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESDECLAST\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.256.66.0F38.WIG DF /r \r\nVAESDECLAST ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from ymm3/m256; \r\nstore the result in ymm1.\r\nEVEX.128.66.0F38.WIG DF /r\r\nVAESDECLAST xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, oper\u0002ating on a 128-bit data (state) from xmm2 with \r\na 128-bit round key from xmm3/m128; store \r\nthe result in xmm1.\r\nEVEX.256.66.0F38.WIG DF /r\r\nVAESDECLAST ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from ymm3/m256; \r\nstore the result in ymm1.\r\nEVEX.512.66.0F38.WIG DF /r\r\nVAESDECLAST zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform the last round of an AES decryption \r\nflow, using the Equivalent Inverse Cipher, \r\noperating on a 128-bit data (state) from zmm2 \r\nwith a 128-bit round key from zmm3/m512; \r\nstore the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ff48acfd-acaa-4fac-8183-e576546d2fea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bfce04c007c97f3194fe4026c342edad5a327c41754d11441c00597ee4b7cb67",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ddef2639-db9d-4475-8e21-050aeab18735",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 85,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-25\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESDECLAST (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESDECLAST (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← InvShiftRows( STATE )\r\nSTATE ← InvSubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESDECLAST __m256i _mm256_aesdeclast_epi128(__m256i, __m256i);\r\nVAESDECLAST __m512i _mm512_aesdeclast_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ddef2639-db9d-4475-8e21-050aeab18735.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5bdc712118530eca201250092e4ed760daf75cfec04f61cd485f8d6a42854df9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 478
      },
      {
        "segments": [
          {
            "segment_id": "ae415ea0-0bcb-43b2-8ded-73f25d68f8ed",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 86,
            "page_width": 612,
            "page_height": 792,
            "content": "2-26 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENC — Perform One Round of an AES Encryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs a single round of an AES encryption flow using a round key from the second source \r\noperand, operating on 128-bit data (state) from the first source operand, and store the result in the destination \r\noperand.\r\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC\u0002CLAST instruction.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESENC\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.256.66.0F38.WIG DC /r \r\nVAESENC ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from the \r\nymm3/m256; store the result in ymm1.\r\nEVEX.128.66.0F38.WIG DC /r\r\nVAESENC xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from xmm2 \r\nwith a 128-bit round key from the \r\nxmm3/m128; store the result in xmm1.\r\nEVEX.256.66.0F38.WIG DC /r\r\nVAESENC ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from ymm2 \r\nwith a 128-bit round key from the \r\nymm3/m256; store the result in ymm1.\r\nEVEX.512.66.0F38.WIG DC /r\r\nVAESENC zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform one round of an AES encryption flow, \r\noperating on a 128-bit data (state) from zmm2 \r\nwith a 128-bit round key from the \r\nzmm3/m512; store the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ae415ea0-0bcb-43b2-8ded-73f25d68f8ed.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b16127960ae1c0b11658f55e3ff03dc934efd8566365065ec39a71cb63b380ad",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d68f4b3e-9787-4e24-b636-35a81e8510ba",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 87,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-27\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENC (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR I ← 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESENC (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i ← 0 to KL-1:\r\nSTATE ← SRC1.xmm[i] // xmm[i] is the i’th xmm word in the SIMD register\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nSTATE ← MixColumns( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESENC __m256i _mm256_aesenc_epi128(__m256i, __m256i);\r\nVAESENC __m512i _mm512_aesenc_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/d68f4b3e-9787-4e24-b636-35a81e8510ba.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=118f8452163dea6522f153560246831d549ecf8d9786f61a3d539a4021afdf19",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 498
      },
      {
        "segments": [
          {
            "segment_id": "cbd12822-3655-4a21-9214-54b3efc647e3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 88,
            "page_width": 612,
            "page_height": 792,
            "content": "2-28 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENCLAST — Perform Last Round of an AES Encryption Flow\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs the last round of an AES encryption flow using a round key from the second source \r\noperand, operating on 128-bit data (state) from the first source operand, and store the result in the destination \r\noperand.\r\nVEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy \r\nencoded versions of the instruction require that the first source operand and the destination operand are the same \r\nand must be an XMM register.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nOperation\r\nAESENCLAST\r\nSTATE ← SRC1\r\nRoundKey ← SRC2\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST[127:0] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:128] (Unmodified)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.256.66.0F38.WIG DD /r \r\nVAESENCLAST ymm1, ymm2, \r\nymm3/m256\r\nA V/V VAES Perform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nymm2 with a 128 bit round key from \r\nymm3/m256; store the result in ymm1.\r\nEVEX.128.66.0F38.WIG DD /r\r\nVAESENCLAST xmm1, xmm2, \r\nxmm3/m128\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nxmm2 with a 128 bit round key from \r\nxmm3/m128; store the result in xmm1.\r\nEVEX.256.66.0F38.WIG DD /r\r\nVAESENCLAST ymm1, ymm2, \r\nymm3/m256\r\nB V/V AVX512VL\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nymm2 with a 128 bit round key from \r\nymm3/m256; store the result in ymm1.\r\nEVEX.512.66.0F38.WIG DD /r\r\nVAESENCLAST zmm1, zmm2, \r\nzmm3/m512\r\nB V/V AVX512F\r\nVAES\r\nPerform the last round of an AES encryption \r\nflow, operating on a 128-bit data (state) from \r\nzmm2 with a 128 bit round key from \r\nzmm3/m512; store the result in zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/cbd12822-3655-4a21-9214-54b3efc647e3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3d52ace22290918eb45807c583d02e482752e61b792a3deae0d8eb45e9883b09",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "8d35da91-8317-485d-81e8-7c2f2b1b057f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 89,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-29\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVAESENCLAST (128b and 256b VEX encoded versions)\r\n(KL, VL) = (1,128), (2,256)\r\nFOR I=0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST.xmm[i]← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nVAESENCLAST (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nSTATE ← SRC1.xmm[i]\r\nRoundKey ← SRC2.xmm[i]\r\nSTATE ← ShiftRows( STATE )\r\nSTATE ← SubBytes( STATE )\r\nDEST.xmm[i] ← STATE XOR RoundKey\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVAESENCLAST __m256i _mm256_aesenclast_epi128(__m256i, __m256i);\r\nVAESENCLAST __m512i _mm512_aesenclast_epi128(__m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/8d35da91-8317-485d-81e8-7c2f2b1b057f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=37bb107b72b03e6b7d05bdf8e251b1137b6716d4f9787c56b6dfdb75b3efceba",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 454
      },
      {
        "segments": [
          {
            "segment_id": "96a2dec2-9f26-4145-8e19-c99796c0bf58",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 90,
            "page_width": 612,
            "page_height": 792,
            "content": "2-30 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVCVTNE2PS2BF16 — Convert Two Packed Single Data to One Packed BF16 Data\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction converts two SIMD registers of packed single data into a single register of packed BF16 data.\r\nThis instruction does not support memory fault suppression.\r\n“Round to nearest even” rounding mode is used. Output denormals are always flushed to zero and input denormals \r\nare always treated as zero. MXCSR is not consulted nor updated. \r\nOperation\r\nVCVTNE2PS2BF16 dest, src1, src2\r\nVL = (128, 256, 512)\r\nKL = VL/16\r\norigdest ← dest\r\nFOR i ← 0 to KL-1:\r\nIF k1[ i ] or *no writemask*:\r\nIF src is memory and evex.b == 1:\r\nt ← src2.fp32[0]\r\nELSE if i < k1/2:\r\nt ← src2.fp32[ i ]\r\nELSE:\r\nt ← src1.fp32[ i-KL/2]\r\n// see for definition of convert helper function \r\ndest.word[i] ← convert_fp32_to_bfloat16(t)\r\nELSE IF *zeroing*:\r\ndest.word[ i ] ← 0\r\nELSE: // merge masking, dest element unchanged\r\ndest.word[ i ] ← origdest.word[ i ]\r\nDEST[MAXVL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.F2.0F38.W0 72 /r\r\nVCVTNE2PS2BF16 xmm1{k1}{z}, \r\nxmm2, xmm3/m128/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nConvert packed single data from xmm2 and \r\nxmm3/m128/m32bcst to packed BF16 data in \r\nxmm1 with writemask k1.\r\nEVEX.256.F2.0F38.W0 72 /r\r\nVCVTNE2PS2BF16 ymm1{k1}{z}, \r\nymm2, ymm3/m256/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nConvert packed single data from ymm2 and \r\nymm3/m256/m32bcst to packed BF16 data in \r\nymm1 with writemask k1.\r\nEVEX.512.F2.0F38.W0 72 /r\r\nVCVTNE2PS2BF16 zmm1{k1}{z}, \r\nzmm2, zmm3/m512/m32bcst\r\nA V/V AVX512F\r\nAVX512_BF16\r\nConvert packed single data from zmm2 and \r\nzmm3/m512/m32bcst to packed BF16 data in \r\nzmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/96a2dec2-9f26-4145-8e19-c99796c0bf58.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=72aa16c0a27e9528516fdef6ace0aae3a55c641d600bd895fd9b2044a35435ff",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "72dd3fa8-a82f-434f-bf6a-ce32ed839cd9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 91,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-31\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVCVTNE2PS2BF16 __m128bh _mm_cvtne2ps_pbh (__m128, __m128);\r\nVCVTNE2PS2BF16 __m128bh _mm_mask_cvtne2ps_pbh (__m128bh, __mmask8, __m128, __m128);\r\nVCVTNE2PS2BF16 __m128bh _mm_maskz_cvtne2ps_pbh (__mmask8, __m128, __m128);\r\nVCVTNE2PS2BF16 __m256bh _mm256_cvtne2ps_pbh (__m256, __m256);\r\nVCVTNE2PS2BF16 __m256bh _mm256_mask_cvtne2ps_pbh (__m256bh, __mmask16, __m256, __m256);\r\nVCVTNE2PS2BF16 __m256bh _mm256_maskz_cvtne2ps_ pbh (__mmask16, __m256, __m256);\r\nVCVTNE2PS2BF16 __m512bh _mm512_cvtne2ps_pbh (__m512, __m512);\r\nVCVTNE2PS2BF16 __m512bh _mm512_mask_cvtne2ps_pbh (__m512bh, __mmask32, __m512, __m512);\r\nVCVTNE2PS2BF16 __m512bh _mm512_maskz_cvtne2ps_pbh (__mmask32, __m512, __m512);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/72dd3fa8-a82f-434f-bf6a-ce32ed839cd9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a5fdf4c7735310fe26c9e5e2db4588fe2dfefb3f28ff6f633a173858ae7c9c4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 363
      },
      {
        "segments": [
          {
            "segment_id": "74723072-e782-4fbb-81e5-8ec4267faa7f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 92,
            "page_width": 612,
            "page_height": 792,
            "content": "2-32 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVCVTNEPS2BF16 — Convert Packed Single Data to Packed BF16 Data\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction converts one SIMD register of packed single data into a single register of packed BF16 data.\r\n“Round to nearest even” rounding mode is used. Output denormals are always flushed to zero and input denormals \r\nare always treated as zero. MXCSR is not consulted nor updated. \r\nAs the instruction operand encoding table shows, the EVEX.vvvv field is not used for encoding an operand. \r\nEVEX.vvvv is reserved and must be 0b1111 otherwise instructions will #UD.\r\nOperation\r\nDefine convert_fp32_to_bfloat16(x):\r\nIF x is zero or denormal:\r\ndest[15] ← x[31] // sign preserving zero (denormal go to zero)\r\ndest[14:0] ← 0\r\nELSE IF x is infinity:\r\ndest[15:0] ← x[31:16]\r\nELSE IF x is NAN:\r\ndest[15:0] ← x[31:16] // truncate and set MSB of the mantisa force QNAN\r\ndest[6] ← 1\r\nELSE // normal number\r\nLSB ← x[16]\r\nrounding_bias ← 0x00007FFF + LSB\r\ntemp[31:0] ← x[31:0] + rounding_bias // integer add\r\ndest[15:0] ← temp[31:16]\r\nRETURN dest\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.F3.0F38.W0 72 /r\r\nVCVTNEPS2BF16 xmm1{k1}{z}, \r\nxmm2/m128/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nConvert packed single data from xmm2/m128 \r\nto packed BF16 data in xmm1 with writemask \r\nk1.\r\nEVEX.256.F3.0F38.W0 72 /r\r\nVCVTNEPS2BF16 xmm1{k1}{z}, \r\nymm2/m256/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nConvert packed single data from ymm2/m256 \r\nto packed BF16 data in xmm1 with writemask \r\nk1.\r\nEVEX.512.F3.0F38.W0 72 /r\r\nVCVTNEPS2BF16 ymm1{k1}{z}, \r\nzmm2/m512/m32bcst\r\nA V/V AVX512F\r\nAVX512_BF16\r\nConvert packed single data from zmm2/m512 \r\nto packed BF16 data in ymm1 with writemask \r\nk1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/74723072-e782-4fbb-81e5-8ec4267faa7f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=05d6dc1c5adbef0a15a210919144e10b2d10d55895d934e9e8146033407a4c95",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "84e29aae-c7a3-403f-8d01-4cf2a3f4576e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 93,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-33\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVCVTNEPS2BF16 dest, src\r\nVL = (128, 256, 512)\r\nKL = VL/16\r\norigdest ← dest\r\nFOR i ← 0 to KL/2-1:\r\nIF k1[ i ] or *no writemask*:\r\nIF src is memory and evex.b == 1:\r\nt ← src.fp32[0]\r\nELSE:\r\nt ← src.fp32[ i ]\r\ndest.word[i] ← convert_fp32_to_bfloat16(t)\r\nELSE IF *zeroing*:\r\ndest.word[ i ] ← 0\r\nELSE: // merge masking, dest element unchanged\r\ndest.word[ i ] ← origdest.word[ i ]\r\nDEST[MAXVL-1:VL/2] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVCVTNEPS2BF16 __m128bh _mm_cvtneps_pbh (__m128);\r\nVCVTNEPS2BF16 __m128bh _mm_mask_cvtneps_pbh (__m128bh, __mmask8, __m128);\r\nVCVTNEPS2BF16 __m128bh _mm_maskz_cvtneps_pbh (__mmask8, __m128);\r\nVCVTNEPS2BF16 __m128bh _mm256_cvtneps_pbh (__m256);\r\nVCVTNEPS2BF16 __m128bh _mm256_mask_cvtneps_pbh (__m128bh, __mmask8, __m256);\r\nVCVTNEPS2BF16 __m128bh _mm256_maskz_cvtneps_pbh (__mmask8, __m256);\r\nVCVTNEPS2BF16 __m256bh _mm512_cvtneps_pbh (__m512);\r\nVCVTNEPS2BF16 __m256bh _mm512_mask_cvtneps_pbh (__m256bh, __mmask16, __m512);\r\nVCVTNEPS2BF16 __m256bh _mm512_maskz_cvtneps_pbh (__mmask16, __m512);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/84e29aae-c7a3-403f-8d01-4cf2a3f4576e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=0a72ecd665db03f0e634bfe05c43957f7f5949941873452ab477b36a55abbbcc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 419
      },
      {
        "segments": [
          {
            "segment_id": "edc0a7d8-e324-4a18-ab58-fd4a4b4e2631",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 94,
            "page_width": 612,
            "page_height": 792,
            "content": "2-34 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVDPBF16PS — Dot Product of BF16 Pairs Accumulated into Packed Single Precision\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction performs a SIMD dot-product of two BF16 pairs and accumulates into a packed single precision \r\nregister.\r\n“Round to nearest even” rounding mode is used. Output denormals are always flushed to zero and input denormals \r\nare always treated as zero. MXCSR is not consulted nor updated. \r\nOperation\r\nDefine make_fp32(x):\r\n// The x parameter is bfloat16. Pack it in to upper 16b of a dword. The bit pattern is a legal fp32 value. Return that bit pattern.\r\ndword ← 0\r\ndword[31:16] ← x\r\nRETURN dword\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.F3.0F38.W0 52 /r\r\nVDPBF16PS xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nMultiply BF16 pairs from xmm2 and \r\nxmm3/m128, and accumulate the resulting \r\npacked single precision results in xmm1 with \r\nwritemask k1.\r\nEVEX.256.F3.0F38.W0 52 /r\r\nVDPBF16PS ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512VL\r\nAVX512_BF16\r\nMultiply BF16 pairs from ymm2 and \r\nymm3/m256, and accumulate the resulting \r\npacked single precision results in ymm1 with \r\nwritemask k1.\r\nEVEX.512.F3.0F38.W0 52 /r\r\nVDPBF16PS zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512F\r\nAVX512_BF16\r\nMultiply BF16 pairs from zmm2 and \r\nzmm3/m512, and accumulate the resulting \r\npacked single precision results in zmm1 with \r\nwritemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/edc0a7d8-e324-4a18-ab58-fd4a4b4e2631.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e5676a3f45446c5ae67688e8b895a9d92326f9d6065c54c62ef93ababc0f2146",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "d58a4b74-23aa-4d3a-97e0-8664f3605a34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 95,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-35\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVDPBF16PS srcdest, src1, src2\r\nVL = (128, 256, 512)\r\nKL = VL/32\r\norigdest ← srcdest\r\nFOR i ← 0 to KL-1:\r\nIF k1[ i ] or *no writemask*:\r\nIF src2 is memory and evex.b == 1:\r\nt ← src2.dword[0]\r\nELSE:\r\nt ← src2.dword[ i ]\r\n// FP32 FMA with daz in, ftz out and RNE rounding. MXCSR neither consulted nor updated.\r\nsrcdest.fp32[ i ] += make_fp32(src1.bfloat16[2*i+1]) * make_fp32(t.bfloat[1])\r\nsrcdest.fp32[ i ] += make_fp32(src1.bfloat16[2*i+0]) * make_fp32(t.bfloat[0])\r\nELSE IF *zeroing*:\r\nsrcdest.dword[ i ] ← 0\r\nELSE: // merge masking, dest element unchanged\r\nsrcdest.dword[ i ] ← origdest.dword[ i ]\r\nsrcdest[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVDPBF16PS __m128 _mm_dpbf16_ps(__m128, __m128bh, __m128bh);\r\nVDPBF16PS __m128 _mm_mask_dpbf16_ps( __m128, __mmask8, __m128bh, __m128bh);\r\nVDPBF16PS __m128 _mm_maskz_dpbf16_ps(__mmask8, __m128, __m128bh, __m128bh);\r\nVDPBF16PS __m256 _mm256_dpbf16_ps(__m256, __m256bh, __m256bh);\r\nVDPBF16PS __m256 _mm256_mask_dpbf16_ps(__m256, __mmask8, __m256bh, __m256bh);\r\nVDPBF16PS __m256 _mm256_maskz_dpbf16_ps(__mmask8, __m256, __m256bh, __m256bh);\r\nVDPBF16PS __m512 _mm512_dpbf16_ps(__m512, __m512bh, __m512bh);\r\nVDPBF16PS __m512 _mm512_mask_dpbf16_ps(__m512, __mmask16, __m512bh, __m512bh);\r\nVDPBF16PS __m512 _mm512_maskz_dpbf16_ps(__mmask16, __m512, __m512bh, __m512bh);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/d58a4b74-23aa-4d3a-97e0-8664f3605a34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b9930e587ae046e8e8667fc5209f8e1f7145fe7dfaf3e1b69e86bf8d754ec184",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      },
      {
        "segments": [
          {
            "segment_id": "385a8e6c-205e-4931-b808-4ab5cc9d9520",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 96,
            "page_width": 612,
            "page_height": 792,
            "content": "2-36 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVP2INTERSECTD/VP2INTERSECTQ — Compute Intersection Between DWORDS/QUADWORDS to \r\na Pair of Mask Registers \r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction writes an even/odd pair of mask registers. The mask register destination indicated in the \r\nMODRM.REG field is used to form the basis of the register pair. The low bit of that field is masked off (set to zero) \r\nto create the first register of the pair.\r\nEVEX.aaa and EVEX.z must be zero.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature Flag Description\r\nEVEX.NDS.128.F2.0F38.W0 68 /r \r\nVP2INTERSECTD k1+1, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512VL\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between dwords in \r\nxmm3/m128/m32bcst and xmm2.\r\nEVEX.NDS.256.F2.0F38.W0 68 /r\r\nVP2INTERSECTD k1+1, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512VL\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between dwords in \r\nymm3/m256/m32bcst and ymm2.\r\nEVEX.NDS.512.F2.0F38.W0 68 /r\r\nVP2INTERSECTD k1+1, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512F\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between dwords in \r\nzmm3/m512/m32bcst and zmm2.\r\nEVEX.NDS.128.F2.0F38.W1 68 /r\r\nVP2INTERSECTQ k1+1, xmm2, \r\nxmm3/m128/m64bcst\r\nA V/V AVX512VL\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between quadwords in \r\nxmm3/m128/m64bcst and xmm2.\r\nEVEX.NDS.256.F2.0F38.W1 68 /r\r\nVP2INTERSECTQ k1+1, ymm2, \r\nymm3/m256/m64bcst\r\nA V/V AVX512VL\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between quadwords in \r\nymm3/m256/m64bcst and ymm2.\r\nEVEX.NDS.512.F2.0F38.W1 68 /r\r\nVP2INTERSECTQ k1+1, zmm2, \r\nzmm3/m512/m64bcst\r\nA V/V AVX512F\r\nAVX512_VP2INTERSECT\r\nStore, in an even/odd pair of mask registers, \r\nthe indicators of the locations of value \r\nmatches between quadwords in \r\nzmm3/m512/m64bcst and zmm2.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/385a8e6c-205e-4931-b808-4ab5cc9d9520.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=050c4711767af5c5ab1832e15bf15dd1e4f9f752292c9efa549ac3d5b85c6ddd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 307
      },
      {
        "segments": [
          {
            "segment_id": "40d7656a-8c1b-4953-9a36-17f2b4296d10",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 97,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-37\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVP2INTERSECTD destmask, src1, src2\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\n// dest_mask_reg_id is the register id specified in the instruction for destmask\r\ndest_base ← dest_mask_reg_id & ~1\r\n// maskregs[ ] is an array representing the mask registers\r\nmaskregs[dest_base+0][MAX_KL-1:0] ← 0\r\nmaskregs[dest_base+1][MAX_KL-1:0] ← 0\r\nFOR i ← 0 to KL-1:\r\nFOR j ← 0 to KL-1:\r\nmatch ← (src1.dword[i] == src2.dword[j])\r\nmaskregs[dest_base+0].bit[i] |= match\r\nmaskregs[dest_base+1].bit[j] |= match\r\nVP2INTERSECTQ destmask, src1, src2\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\n// dest_mask_reg_id is the register id specified in the instruction for destmask\r\ndest_base ← dest_mask_reg_id & ~1\r\n// maskregs[ ] is an array representing the mask registers\r\nmaskregs[dest_base+0][MAX_KL-1:0] ← 0\r\nmaskregs[dest_base+1][MAX_KL-1:0] ← 0\r\nFOR i = 0 to KL-1:\r\nFOR j = 0 to KL-1:\r\nmatch ← (src1.qword[i] == src2.qword[j])\r\nmaskregs[dest_base+0].bit[i] |= match\r\nmaskregs[dest_base+1].bit[j] |= match\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVP2INTERSECTD void _mm_2intersect_epi32(__m128i, __m128i, __mmask8 *, __mmask8 *);\r\nVP2INTERSECTD void _mm256_2intersect_epi32(__m256i, __m256i, __mmask8 *, __mmask8 *);\r\nVP2INTERSECTD void _mm512_2intersect_epi32(__m512i, __m512i, __mmask16 *, __mmask16 *);\r\nVP2INTERSECTQ void _mm_2intersect_epi64(__m128i, __m128i, __mmask8 *, __mmask8 *);\r\nVP2INTERSECTQ void _mm256_2intersect_epi64(__m256i, __m256i, __mmask8 *, __mmask8 *);\r\nVP2INTERSECTQ void _mm512_2intersect_epi64(__m512i, __m512i, __mmask8 *, __mmask8 *);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/40d7656a-8c1b-4953-9a36-17f2b4296d10.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ae3a627a6dc398e484f970586101eb7fac8cbf766ffcf7d88b172954b446344",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 210
      },
      {
        "segments": [
          {
            "segment_id": "d7b1fc78-16d8-4f53-b280-4f32bcf3d8d5",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 98,
            "page_width": 612,
            "page_height": 792,
            "content": "2-38 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCLMULQDQ — Carry-Less Multiplication Quadword\r\nInstruction Operand Encoding\r\nDescription\r\nPerforms a carry-less multiplication of two quadwords, selected from the first source and second source operand \r\naccording to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to \r\nuse according to the table below, other bits of the immediate byte are ignored.\r\nThe EVEX encoded form of this instruction does not support memory fault suppression.\r\nNOTES:\r\nSRC2 denotes the second source operand, which can be a register or memory; SRC1 denotes the first source and \r\ndestination operand.\r\nThe first source operand and the destination operand are the same and must be a ZMM/YMM/XMM register. The \r\nsecond source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. Bits (VL_MAX\u00021:128) of the corresponding YMM destination register remain unchanged.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nVEX.256.66.0F3A.WIG 44 /r /ib \r\nVPCLMULQDQ ymm1, ymm2, \r\nymm3/m256, imm8\r\nA V/V VPCLMULQDQ Carry-less multiplication of one quadword of \r\nymm2 by one quadword of ymm3/m256, stores \r\nthe 128-bit result in ymm1. The immediate is \r\nused to determine which quadwords of ymm2 \r\nand ymm3/m256 should be used.\r\nEVEX.128.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ xmm1, xmm2, \r\nxmm3/m128, imm8\r\nB V/V AVX512VL\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nxmm2 by one quadword of xmm3/m128, stores \r\nthe 128-bit result in xmm1. The immediate is \r\nused to determine which quadwords of xmm2 \r\nand xmm3/m128 should be used.\r\nEVEX.256.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ ymm1, ymm2, \r\nymm3/m256, imm8\r\nB V/V AVX512VL\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nymm2 by one quadword of ymm3/m256, stores \r\nthe 128-bit result in ymm1. The immediate is \r\nused to determine which quadwords of ymm2 \r\nand ymm3/m256 should be used.\r\nEVEX.512.66.0F3A.WIG 44 /r /ib\r\nVPCLMULQDQ zmm1, zmm2, \r\nzmm3/m512, imm8\r\nB V/V AVX512F\r\nVPCLMULQDQ\r\nCarry-less multiplication of one quadword of \r\nzmm2 by one quadword of zmm3/m512, stores \r\nthe 128-bit result in zmm1. The immediate is \r\nused to determine which quadwords of zmm2 \r\nand zmm3/m512 should be used.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nB Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) imm8 (r)\r\nTable 2-7. PCLMULQDQ Quadword Selection of Immediate Byte\r\nimm[4] imm[0] PCLMULQDQ Operation\r\n0 0 CL_MUL( SRC2[63:0], SRC1[63:0] )\r\n0 1 CL_MUL( SRC2[63:0], SRC1[127:64] )\r\n1 0 CL_MUL( SRC2[127:64], SRC1[63:0] )\r\n1 1 CL_MUL( SRC2[127:64], SRC1[127:64] )",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/d7b1fc78-16d8-4f53-b280-4f32bcf3d8d5.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ae3b9dbc423c6787f38f3bb169e97bb2c446bc1235a68c51a60052ee71ad086d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      },
      {
        "segments": [
          {
            "segment_id": "27be6cfe-0670-4da9-83ba-fc38fbd881e9",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 99,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-39\r\nINSTRUCTION SET REFERENCE, A-Z\r\nCompilers and assemblers may implement the following pseudo-op syntax to simply programming and emit the \r\nrequired encoding for imm8.\r\nOperation\r\ndefine PCLMUL128(X,Y): // helper function\r\nFOR i ← 0 to 63:\r\nTMP [ i ] ← X[ 0 ] and Y[ i ]\r\nFOR j ← 1 to i:\r\nTMP [ i ] ← TMP [ i ] xor (X[ j ] and Y[ i - j ])\r\nDEST[ i ] ← TMP[ i ]\r\nFOR i ← 64 to 126:\r\nTMP [ i ] ← 0\r\nFOR j ← i - 63 to 63:\r\nTMP [ i ] ← TMP [ i ] xor (X[ j ] and Y[ i - j ])\r\nDEST[ i ] ← TMP[ i ]\r\nDEST[127] ← 0;\r\nRETURN DEST // 128b vector\r\nPCLMULQDQ (SSE version)\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.qword[1]\r\nDEST[127:0] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:128] (Unmodified)\r\nVPCLMULQDQ (128b and 256b VEX encoded versions)\r\n(KL,VL) = (1,128), (2,256)\r\nFOR i= 0 to KL-1:\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.xmm[i].qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.xmm[i].qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.xmm[i].qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.xmm[i].qword[1]\r\nDEST.xmm[i] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:VL] ← 0\r\nTable 2-8. Pseudo-Op and PCLMULQDQ Implementation\r\nPseudo-Op Imm8 Encoding\r\nPCLMULLQLQDQ xmm1, xmm2 0000_0000B\r\nPCLMULHQLQDQ xmm1, xmm2 0000_0001B\r\nPCLMULLQHQDQ xmm1, xmm2 0001_0000B\r\nPCLMULHQHQDQ xmm1, xmm2 0001_0001B",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/27be6cfe-0670-4da9-83ba-fc38fbd881e9.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7202644270adb96df134745057363fc5e9bb995811d1a8f597968c163f342d0b",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "f93f9bbc-8b95-4942-81fe-5aa4adf2cb1c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 100,
            "page_width": 612,
            "page_height": 792,
            "content": "2-40 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCLMULQDQ (EVEX encoded version)\r\n(KL,VL) = (1,128), (2,256), (4,512)\r\nFOR i = 0 to KL-1:\r\nIF Imm8[0] = 0:\r\nTEMP1 ← SRC1.xmm[i].qword[0]\r\nELSE:\r\nTEMP1 ← SRC1.xmm[i].qword[1]\r\nIF Imm8[4] = 0:\r\nTEMP2 ← SRC2.xmm[i].qword[0]\r\nELSE:\r\nTEMP2 ← SRC2.xmm[i].qword[1]\r\nDEST.xmm[i] ← PCLMUL128(TEMP1, TEMP2)\r\nDEST[MAXVL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPCLMULQDQ __m256i _mm256_clmulepi64_epi128(__m256i, __m256i, const int);\r\nVPCLMULQDQ __m512i _mm512_clmulepi64_epi128(__m512i, __m512i, const int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nVEX-encoded: Exceptions Type 4.\r\nEVEX-encoded: See Exceptions Type E4NF.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/f93f9bbc-8b95-4942-81fe-5aa4adf2cb1c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3f7915c952c53276b573dd21358005212c6fe3f828ac95372d69cf947fe0fea6",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 322
      },
      {
        "segments": [
          {
            "segment_id": "5d777d3d-e664-440d-bfe3-a9171d87ff8f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-41\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register\r\nInstruction Operand Encoding\r\nDescription\r\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the desti\u0002nation operand (first operand), based on the active elements determined by the writemask operand. Note: \r\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nMoves up to 512 bits of packed byte values from the source operand (second operand) to the destination operand \r\n(first operand). This instruction is used to store partial contents of a vector register into a byte vector or single \r\nmemory location using the active elements in operand writemask.\r\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z \r\nmust be zero.\r\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the \r\nsource operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper \r\nbits are zeroed.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:r/m (w) ModRM:reg (r) NA NA\r\nB NA ModRM:r/m (w) ModRM:reg (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/5d777d3d-e664-440d-bfe3-a9171d87ff8f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ac216a764ef02df9800fec3ad7dc8191200d96700ccd9acebf5d42aae5e76b6c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 555
      },
      {
        "segments": [
          {
            "segment_id": "5d777d3d-e664-440d-bfe3-a9171d87ff8f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 101,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-41\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPCOMPRESS — Store Sparse Packed Byte/Word Integer Values into Dense Memory/Register\r\nInstruction Operand Encoding\r\nDescription\r\nCompress (stores) up to 64 byte values or 32 word values from the source operand (second operand) to the desti\u0002nation operand (first operand), based on the active elements determined by the writemask operand. Note: \r\nEVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nMoves up to 512 bits of packed byte values from the source operand (second operand) to the destination operand \r\n(first operand). This instruction is used to store partial contents of a vector register into a byte vector or single \r\nmemory location using the active elements in operand writemask.\r\nMemory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z \r\nmust be zero.\r\nRegister destination version: If the vector length of the contiguous vector is less than that of the input vector in the \r\nsource operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper \r\nbits are zeroed.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W0 63 /r\r\nVPCOMPRESSB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W0 63 /r\r\nVPCOMPRESSB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W0 63 /r\r\nVPCOMPRESSB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW m128{k1}, xmm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm1 to m128 with writemask k1.\r\nEVEX.128.66.0F38.W1 63 /r\r\nVPCOMPRESSW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW m256{k1}, ymm1\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm1 to m256 with writemask k1.\r\nEVEX.256.66.0F38.W1 63 /r\r\nVPCOMPRESSW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nCompress up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW m512{k1}, zmm1\r\nA V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm1 to m512 with writemask k1.\r\nEVEX.512.66.0F38.W1 63 /r\r\nVPCOMPRESSW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Compress up to 512 bits of packed word values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:r/m (w) ModRM:reg (r) NA NA\r\nB NA ModRM:r/m (w) ModRM:reg (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/5d777d3d-e664-440d-bfe3-a9171d87ff8f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ac216a764ef02df9800fec3ad7dc8191200d96700ccd9acebf5d42aae5e76b6c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 555
      },
      {
        "segments": [
          {
            "segment_id": "3b74587f-db35-4409-80b9-0ff615b20b09",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 102,
            "page_width": 612,
            "page_height": 792,
            "content": "2-42 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPCOMPRESSB store form\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[k] ← SRC.byte[j]\r\nk ← k +1\r\nVPCOMPRESSB reg-reg form\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[k] ← SRC.byte[j]\r\nk ← k + 1\r\nIF *merging-masking*:\r\n*DEST[VL-1:k*8] remains unchanged*\r\nELSE DEST[VL-1:k*8] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPCOMPRESSW store form\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[k] ← SRC.word[j]\r\nk ← k + 1\r\nVPCOMPRESSW reg-reg form\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[k] ← SRC.word[j]\r\nk ← k + 1\r\nIF *merging-masking*:\r\n*DEST[VL-1:k*16] remains unchanged*\r\nELSE DEST[VL-1:k*16] ← 0\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/3b74587f-db35-4409-80b9-0ff615b20b09.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c8d8fcc528d72f565964eaf1178eb4eb35f11792a91f0d8d29a368bac3c9d098",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "831cd55e-1067-478c-b5ab-e21ab47d1e6b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 103,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-43\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPCOMPRESSB __m128i _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);\r\nVPCOMPRESSB __m128i _mm_maskz_compress_epi8(__mmask16, __m128i);\r\nVPCOMPRESSB __m256i _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);\r\nVPCOMPRESSB __m256i _mm256_maskz_compress_epi8(__mmask32, __m256i);\r\nVPCOMPRESSB __m512i _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);\r\nVPCOMPRESSB __m512i _mm512_maskz_compress_epi8(__mmask64, __m512i);\r\nVPCOMPRESSB void _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);\r\nVPCOMPRESSB void _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);\r\nVPCOMPRESSB void _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);\r\nVPCOMPRESSW __m128i _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);\r\nVPCOMPRESSW __m128i _mm_maskz_compress_epi16(__mmask8, __m128i); \r\nVPCOMPRESSW __m256i _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);\r\nVPCOMPRESSW __m256i _mm256_maskz_compress_epi16(__mmask16, __m256i);\r\nVPCOMPRESSW __m512i _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);\r\nVPCOMPRESSW __m512i _mm512_maskz_compress_epi16(__mmask32, __m512i);\r\nVPCOMPRESSW void _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);\r\nVPCOMPRESSW void _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);\r\nVPCOMPRESSW void _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/831cd55e-1067-478c-b5ab-e21ab47d1e6b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b737852c0c6d74f2d0df40f3862285311f5a47aec3e11980b4cd92ba621e1cf0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 275
      },
      {
        "segments": [
          {
            "segment_id": "7b219a5d-4c00-45fa-baf6-0e810ee8387f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 104,
            "page_width": 612,
            "page_height": 792,
            "content": "2-44 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPBUSD — Multiply and Add Unsigned and Signed Bytes\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second \r\nsource operand, producing intermediate signed word results. The word results are then summed and accumulated \r\nin the destination dword element size operand.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPBUSD dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\n// Byte elements of SRC1 are zero-extended to 16b and\r\n// byte elements of SRC2 are sign extended to 16b before multiplication.\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1word ← ZERO_EXTEND(SRC1.byte[4*i]) * SIGN_EXTEND(t.byte[0])\r\np2word ← ZERO_EXTEND(SRC1.byte[4*i+1]) * SIGN_EXTEND(t.byte[1])\r\np3word ← ZERO_EXTEND(SRC1.byte[4*i+2]) * SIGN_EXTEND(t.byte[2])\r\np4word ← ZERO_EXTEND(SRC1.byte[4*i+3]) * SIGN_EXTEND(t.byte[3])\r\nDEST.dword[i] ← ORIGDEST.dword[i] + p1word + p2word + p3word + p4word\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 50 /r\r\nVPDPBUSD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs of signed bytes in \r\nxmm3/m128/m32bcst with corresponding \r\nunsigned bytes of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1 under writemask k1.\r\nEVEX.256.66.0F38.W0 50 /r\r\nVPDPBUSD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs of signed bytes in \r\nymm3/m256/m32bcst with corresponding \r\nunsigned bytes of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1 under writemask k1.\r\nEVEX.512.66.0F38.W0 50 /r\r\nVPDPBUSD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 4 pairs of signed bytes in \r\nzmm3/m512/m32bcst with corresponding \r\nunsigned bytes of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1 under writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/7b219a5d-4c00-45fa-baf6-0e810ee8387f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=15f970305103703b51df86ec512a34a10a483e53130a20119bf1b4a100206c1d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "11e20800-b6c8-4b84-8ee1-0e8e231ae33b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 105,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-45\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPBUSD __m128i _mm_dpbusd_epi32(__m128i, __m128i, __m128i);\r\nVPDPBUSD __m128i _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPBUSD __m128i _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPBUSD __m256i _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);\r\nVPDPBUSD __m256i _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPBUSD __m256i _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPBUSD __m512i _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);\r\nVPDPBUSD __m512i _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPBUSD __m512i _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/11e20800-b6c8-4b84-8ee1-0e8e231ae33b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4c194a643fe0ed12e27ba065f67bf203bcea3c04715f85b39cbda4fd959b9563",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 404
      },
      {
        "segments": [
          {
            "segment_id": "8eaa65fa-db1b-4159-a53d-fad804853682",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 106,
            "page_width": 612,
            "page_height": 792,
            "content": "2-46 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPBUSDS — Multiply and Add Unsigned and Signed Bytes with Saturation\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual unsigned bytes of the first source operand by the corresponding signed bytes of the second \r\nsource operand, producing intermediate signed word results. The word results are then summed and accumulated \r\nin the destination dword element size operand. If the intermediate sum overflows a 32b signed number the result \r\nis saturated to either 0x7FFF_FFFF for positive numbers of 0x8000_0000 for negative numbers.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPBUSDS dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\n// Byte elements of SRC1 are zero-extended to 16b and\r\n// byte elements of SRC2 are sign extended to 16b before multiplication.\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1word ← ZERO_EXTEND(SRC1.byte[4*i]) * SIGN_EXTEND(t.byte[0])\r\np2word ← ZERO_EXTEND(SRC1.byte[4*i+1]) * SIGN_EXTEND(t.byte[1])\r\np3word ← ZERO_EXTEND(SRC1.byte[4*i+2]) * SIGN_EXTEND(t.byte[2])\r\np4word ← ZERO_EXTEND(SRC1.byte[4*i+3]) *SIGN_EXTEND(t.byte[3])\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(ORIGDEST.dword[i] + p1word + p2word + p3word + p4word)\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 51 /r\r\nVPDPBUSDS xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs signed bytes in \r\nxmm3/m128/m32bcst with corresponding \r\nunsigned bytes of xmm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in xmm1, under \r\nwritemask k1.\r\nEVEX.256.66.0F38.W0 51 /r\r\nVPDPBUSDS ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 4 pairs signed bytes in \r\nymm3/m256/m32bcst with corresponding \r\nunsigned bytes of ymm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in ymm1, under \r\nwritemask k1.\r\nEVEX.512.66.0F38.W0 51 /r\r\nVPDPBUSDS zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 4 pairs signed bytes in \r\nzmm3/m512/m32bcst with corresponding \r\nunsigned bytes of zmm2, summing those \r\nproducts and adding them to doubleword \r\nresult, with signed saturation in zmm1, under \r\nwritemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/8eaa65fa-db1b-4159-a53d-fad804853682.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=45a5fc439e7acfc55b38e48e30b1df36902a3192bbc2904cdeca399f964538a5",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7a12547d-4b17-4ffe-9615-cc86d5043a7c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 107,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-47\r\nINSTRUCTION SET REFERENCE, A-Z\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPBUSDS __m128i _mm_dpbusds_epi32(__m128i, __m128i, __m128i);\r\nVPDPBUSDS __m128i _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPBUSDS __m128i _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPBUSDS __m256i _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);\r\nVPDPBUSDS __m256i _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPBUSDS __m256i _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPBUSDS __m512i _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);\r\nVPDPBUSDS __m512i _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPBUSDS __m512i _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/7a12547d-4b17-4ffe-9615-cc86d5043a7c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3ca482c20840b376098e78aaba475c4585562021a97b4a284c85869fc77213fe",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 435
      },
      {
        "segments": [
          {
            "segment_id": "3d661012-295e-40c9-8839-79265a38d544",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 108,
            "page_width": 612,
            "page_height": 792,
            "content": "2-48 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPWSSD — Multiply and Add Signed Word Integers\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second \r\nsource operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then \r\nsummed and accumulated in the destination operand.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPWSSD dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1dword ← SRC1.word[2*i] * t.word[0]\r\np2dword ← SRC1.word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← ORIGDEST.dword[i] + p1dword + p2dword\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 52 /r\r\nVPDPWSSD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs signed words in \r\nxmm3/m128/m32bcst with corresponding \r\nsigned words of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1, under writemask k1.\r\nEVEX.256.66.0F38.W0 52 /r\r\nVPDPWSSD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs signed words in \r\nymm3/m256/m32bcst with corresponding \r\nsigned words of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1, under writemask k1.\r\nEVEX.512.66.0F38.W0 52 /r\r\nVPDPWSSD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 2 pairs signed words in \r\nzmm3/m512/m32bcst with corresponding \r\nsigned words of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1, under writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/3d661012-295e-40c9-8839-79265a38d544.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=724b8d87e80256ace1955d23b0b1db9bb638b0eec3b93f17d6145c695640a3f8",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ceaab1bb-6c8b-418c-8883-84d9ea426bed",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 109,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-49\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPWSSD __m128i _mm_dpwssd_epi32(__m128i, __m128i, __m128i);\r\nVPDPWSSD __m128i _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPWSSD __m128i _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPWSSD __m256i _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);\r\nVPDPWSSD __m256i _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPWSSD __m256i _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPWSSD __m512i _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);\r\nVPDPWSSD __m512i _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPWSSD __m512i _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ceaab1bb-6c8b-418c-8883-84d9ea426bed.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f113c14cce28ddff75f1ff5f3ce5a7196c82e89845aaff8c4e4b5eed7aabf33f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "5740ad98-6cb1-4ff7-948e-4cde3c96d772",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 110,
            "page_width": 612,
            "page_height": 792,
            "content": "2-50 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPDPWSSDS — Multiply and Add Signed Word Integers with Saturation\r\nInstruction Operand Encoding\r\nDescription\r\nMultiplies the individual signed words of the first source operand by the corresponding signed words of the second \r\nsource operand, producing intermediate signed, doubleword results. The adjacent doubleword results are then \r\nsummed and accumulated in the destination operand. If the intermediate sum overflows a 32b signed number, the \r\nresult is saturated to either 0x7FFF_FFFF for positive numbers of 0x8000_0000 for negative numbers.\r\nThis instruction supports memory fault suppression.\r\nOperation\r\nVPDPWSSDS dest, src1, src2\r\n(KL,VL)=(4,128), (8,256), (16,512)\r\nORIGDEST ← DEST\r\nFOR i ← 0 TO KL-1:\r\nIF k1[i] or *no writemask*:\r\nIF SRC2 is memory and EVEX.b == 1:\r\nt ← SRC2.dword[0]\r\nELSE:\r\nt ← SRC2.dword[i]\r\np1dword ← SRC1.word[2*i] * t.word[0]\r\np2dword ← SRC1.word[2*i+1] * t.word[1]\r\nDEST.dword[i] ← SIGNED_DWORD_SATURATE(ORIGDEST.dword[i] + p1dword + p2dword)\r\nELSE IF *zeroing*:\r\nDEST.dword[i] ← 0\r\nELSE: // Merge masking, dest element unchanged\r\nDEST.dword[i] ← ORIGDEST.dword[i]\r\nDEST[MAX_VL-1:VL] ← 0\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 53 /r\r\nVPDPWSSDS xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs of signed words in \r\nxmm3/m128/m32bcst with corresponding \r\nsigned words of xmm2, summing those \r\nproducts and adding them to doubleword result \r\nin xmm1, with signed saturation, under \r\nwritemask k1.\r\nEVEX.256.66.0F38.W0 53 /r\r\nVPDPWSSDS ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nA V/V AVX512_VNNI\r\nAVX512VL\r\nMultiply groups of 2 pairs of signed words in \r\nymm3/m256/m32bcst with corresponding \r\nsigned words of ymm2, summing those \r\nproducts and adding them to doubleword result \r\nin ymm1, with signed saturation, under \r\nwritemask k1.\r\nEVEX.512.66.0F38.W0 53 /r\r\nVPDPWSSDS zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nA V/V AVX512_VNNI Multiply groups of 2 pairs of signed words in \r\nzmm3/m512/m32bcst with corresponding \r\nsigned words of zmm2, summing those \r\nproducts and adding them to doubleword result \r\nin zmm1, with signed saturation, under \r\nwritemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/5740ad98-6cb1-4ff7-948e-4cde3c96d772.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4fe8df63e325cfd520ea312aea31233584e64338a6140524a21940534ad18529",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "28981b25-120f-4d12-8ae8-e925c16235ce",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 111,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-51\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPDPWSSDS __m128i _mm_dpwssds_epi32(__m128i, __m128i, __m128i);\r\nVPDPWSSDS __m128i _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPDPWSSDS __m128i _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPDPWSSDS __m256i _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);\r\nVPDPWSSDS __m256i _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPDPWSSDS __m256i _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPDPWSSDS __m512i _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);\r\nVPDPWSSDS __m512i _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPDPWSSDS __m512i _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/28981b25-120f-4d12-8ae8-e925c16235ce.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=24255e869cce2bbfcdba10c914fc4176dfead925beef3b95df0769319e16e9d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 399
      },
      {
        "segments": [
          {
            "segment_id": "b4f46977-96be-4f75-8787-2d2cb92ee15d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 112,
            "page_width": 612,
            "page_height": 792,
            "content": "2-52 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPEXPAND — Expand Byte/Word Values\r\nInstruction Operand Encoding\r\nDescription\r\nExpands (loads) up to 64 byte integer values or 32 word integer values from the source operand (memory operand) \r\nto the destination operand (register operand), based on the active elements determined by the writemask operand.\r\nNote: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 62 /r\r\nVPEXPANDB xmm1{k1}{z}, m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed byte values \r\nfrom m128 to xmm1 with writemask k1.\r\nEVEX.128.66.0F38.W0 62 /r\r\nVPEXPANDB xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed byte values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 62 /r\r\nVPEXPANDB ymm1{k1}{z}, m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed byte values \r\nfrom m256 to ymm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 62 /r\r\nVPEXPANDB ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed byte values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 62 /r\r\nVPEXPANDB zmm1{k1}{z}, m512\r\nA V/V AVX512_VBMI2 Expands up to 512 bits of packed byte values \r\nfrom m512 to zmm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 62 /r\r\nVPEXPANDB zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Expands up to 512 bits of packed byte values \r\nfrom zmm2 to zmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 62 /r\r\nVPEXPANDW xmm1{k1}{z}, m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed word values \r\nfrom m128 to xmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 62 /r\r\nVPEXPANDW xmm1{k1}{z}, xmm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 128 bits of packed word values \r\nfrom xmm2 to xmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 62 /r\r\nVPEXPANDW ymm1{k1}{z}, m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed word values \r\nfrom m256 to ymm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 62 /r\r\nVPEXPANDW ymm1{k1}{z}, ymm2\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nExpands up to 256 bits of packed word values \r\nfrom ymm2 to ymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 62 /r\r\nVPEXPANDW zmm1{k1}{z}, m512\r\nA V/V AVX512_VBMI2 Expands up to 512 bits of packed word values \r\nfrom m512 to zmm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 62 /r\r\nVPEXPANDW zmm1{k1}{z}, zmm2\r\nB V/V AVX512_VBMI2 Expands up to 512 bits of packed byte integer \r\nvalues from zmm2 to zmm1 with writemask \r\nk1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Tuple1 Scalar ModRM:reg (w) ModRM:r/m (r) NA NA\r\nB NA ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b4f46977-96be-4f75-8787-2d2cb92ee15d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=45109506503adda220961cb606e87a840b1f42788073bd8cc5cf2dda15297f8c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 412
      },
      {
        "segments": [
          {
            "segment_id": "13e264e5-7d26-41aa-b99e-bb9ceb83f780",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 113,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-53\r\nINSTRUCTION SET REFERENCE, A-Z\r\nMoves 128, 256 or 512 bits of packed byte integer values from the source operand (memory operand) to the desti\u0002nation operand (register operand). This instruction is used to load from an int8 vector register or memory location \r\nwhile inserting the data into sparse elements of destination vector register using the active elements pointed out \r\nby the operand writemask.\r\nThis instruction supports memory fault suppression.\r\nNote that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element \r\ninstead of the size of the full vector.\r\nOperation\r\nVPEXPANDB\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.byte[j] ← SRC.byte[k];\r\nk ← k + 1\r\nELSE:\r\nIF *merging-masking*:\r\n*DEST.byte[j] remains unchanged*\r\nELSE: ; zeroing-masking\r\nDEST.byte[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPEXPANDW\r\n(KL, VL) = (8,128), (16,256), (32, 512)\r\nk ← 0\r\nFOR j ← 0 TO KL-1:\r\nIF k1[j] OR *no writemask*:\r\nDEST.word[j] ← SRC.word[k];\r\nk ← k + 1\r\nELSE:\r\nIF *merging-masking*:\r\n*DEST.word[j] remains unchanged*\r\nELSE: ; zeroing-masking\r\nDEST.word[j] ← 0\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/13e264e5-7d26-41aa-b99e-bb9ceb83f780.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3e9dada8e321aab93893824c27512564730a93f3f986eb8b60b927f78b24c608",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b6bf40d4-ba15-41d3-b57e-c2f386041063",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 114,
            "page_width": 612,
            "page_height": 792,
            "content": "2-54 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPEXPAND __m128i _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);\r\nVPEXPAND __m128i _mm_maskz_expand_epi8(__mmask16, __m128i);\r\nVPEXPAND __m128i _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);\r\nVPEXPAND __m128i _mm_maskz_expandloadu_epi8(__mmask16, const void*);\r\nVPEXPAND __m256i _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);\r\nVPEXPAND __m256i _mm256_maskz_expand_epi8(__mmask32, __m256i);\r\nVPEXPAND __m256i _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);\r\nVPEXPAND __m256i _mm256_maskz_expandloadu_epi8(__mmask32, const void*);\r\nVPEXPAND __m512i _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);\r\nVPEXPAND __m512i _mm512_maskz_expand_epi8(__mmask64, __m512i);\r\nVPEXPAND __m512i _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);\r\nVPEXPAND __m512i _mm512_maskz_expandloadu_epi8(__mmask64, const void*);\r\nVPEXPANDW __m128i _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);\r\nVPEXPANDW __m128i _mm_maskz_expand_epi16(__mmask8, __m128i);\r\nVPEXPANDW __m128i _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);\r\nVPEXPANDW __m128i _mm_maskz_expandloadu_epi16(__mmask8, const void *);\r\nVPEXPANDW __m256i _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);\r\nVPEXPANDW __m256i _mm256_maskz_expand_epi16(__mmask16, __m256i);\r\nVPEXPANDW __m256i _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);\r\nVPEXPANDW __m256i _mm256_maskz_expandloadu_epi16(__mmask16, const void*);\r\nVPEXPANDW __m512i _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);\r\nVPEXPANDW __m512i _mm512_maskz_expand_epi16(__mmask32, __m512i);\r\nVPEXPANDW __m512i _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);\r\nVPEXPANDW __m512i _mm512_maskz_expandloadu_epi16(__mmask32, const void*);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Exceptions Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b6bf40d4-ba15-41d3-b57e-c2f386041063.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=6054619933b2ce92079b44df6f93d3e5275466d149d6562865bfa4a0ee1abb3e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 334
      },
      {
        "segments": [
          {
            "segment_id": "4cc7aa0a-677d-442e-90b8-cfca24d733a3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 115,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-55\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPOPCNT — Return the Count of Number of Bits Set to 1 in BYTE/WORD/DWORD/QWORD\r\nInstruction Operand Encoding\r\nDescription\r\nThis instruction counts the number of bits set to one in each byte, word, dword or qword element of its source (e.g., \r\nzmm2 or memory) and places the results in the destination register (zmm1). This instruction supports memory \r\nfault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature Flag Description\r\nEVEX.128.66.0F38.W0 54 /r\r\nVPOPCNTB xmm1{k1}{z}, \r\nxmm2/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128 and puts the result in xmm1 with \r\nwritemask k1.\r\nEVEX.256.66.0F38.W0 54 /r\r\nVPOPCNTB ymm1{k1}{z}, \r\nymm2/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256 and puts the result in ymm1 with \r\nwritemask k1.\r\nEVEX.512.66.0F38.W0 54 /r\r\nVPOPCNTB zmm1{k1}{z}, \r\nzmm2/m512\r\nA V/V AVX512_BITALG Counts the number of bits set to one in \r\nzmm2/m512 and puts the result in zmm1 with \r\nwritemask k1.\r\nEVEX.128.66.0F38.W1 54 /r\r\nVPOPCNTW xmm1{k1}{z}, \r\nxmm2/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128 and puts the result in xmm1 with \r\nwritemask k1.\r\nEVEX.256.66.0F38.W1 54 /r\r\nVPOPCNTW ymm1{k1}{z}, \r\nymm2/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256 and puts the result in ymm1 with \r\nwritemask k1.\r\nEVEX.512.66.0F38.W1 54 /r\r\nVPOPCNTW zmm1{k1}{z}, \r\nzmm2/m512\r\nA V/V AVX512_BITALG Counts the number of bits set to one in \r\nzmm2/m512 and puts the result in zmm1 with \r\nwritemask k1.\r\nEVEX.128.66.0F38.W0 55 /r\r\nVPOPCNTD xmm1{k1}{z}, \r\nxmm2/m128/m32bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128/m32bcst and puts the result in \r\nxmm1 with writemask k1.\r\nEVEX.256.66.0F38.W0 55 /r\r\nVPOPCNTD ymm1{k1}{z}, \r\nymm2/m256/m32bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256/m32bcst and puts the result in \r\nymm1 with writemask k1.\r\nEVEX.512.66.0F38.W0 55 /r\r\nVPOPCNTD zmm1{k1}{z}, \r\nzmm2/m512/m32bcst\r\nB V/V AVX512_VPOPCNTDQ Counts the number of bits set to one in \r\nzmm2/m512/m32bcst and puts the result in \r\nzmm1 with writemask k1.\r\nEVEX.128.66.0F38.W1 55 /r\r\nVPOPCNTQ xmm1{k1}{z}, \r\nxmm2/m128/m64bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nxmm2/m128/m32bcst and puts the result in \r\nxmm1 with writemask k1.\r\nEVEX.256.66.0F38.W1 55 /r\r\nVPOPCNTQ ymm1{k1}{z}, \r\nymm2/m256/m64bcst\r\nB V/V AVX512_VPOPCNTDQ\r\nAVX512VL\r\nCounts the number of bits set to one in \r\nymm2/m256/m32bcst and puts the result in \r\nymm1 with writemask k1.\r\nEVEX.512.66.0F38.W1 55 /r\r\nVPOPCNTQ zmm1{k1}{z}, \r\nzmm2/m512/m64bcst\r\nB V/V AVX512_VPOPCNTDQ Counts the number of bits set to one in \r\nzmm2/m512/m64bcst and puts the result in \r\nzmm1 with writemask k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) ModRM:r/m (r) NA NA\r\nB Full ModRM:reg (w) ModRM:r/m (r) NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4cc7aa0a-677d-442e-90b8-cfca24d733a3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9df67bad6f26cf04b4a966bafac8dc111c45632e71da1c8cda1aaa625ad31f06",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 449
      },
      {
        "segments": [
          {
            "segment_id": "84b67b83-1b05-4daf-9b0e-3258207ef821",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 116,
            "page_width": 612,
            "page_height": 792,
            "content": "2-56 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPOPCNTB\r\n(KL, VL) = (16, 128), (32, 256), (64, 512)\r\nFOR j \r\n← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.byte[j] \r\n← POPCNT(SRC.byte[j])\r\nELSE IF *merging-masking*:\r\n*DEST.byte[j] remains unchanged*\r\nELSE:\r\nDEST.byte[j] \r\n← 0\r\nDEST[MAX_VL-1:VL] \r\n← 0\r\nVPOPCNTW\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j \r\n← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] \r\n← POPCNT(SRC.word[j])\r\nELSE IF *merging-masking*:\r\n*DEST.word[j] remains unchanged*\r\nELSE:\r\nDEST.word[j] \r\n← 0\r\nDEST[MAX_VL-1:VL] \r\n← 0\r\nVPOPCNTD\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j \r\n← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nIF SRC is broadcast memop:\r\nt \r\n← SRC.dword[0]\r\nELSE:\r\nt \r\n← SRC.dword[j]\r\nDEST.dword[j] \r\n← POPCNT(t)\r\nELSE IF *merging-masking*:\r\n*DEST..dword[j] remains unchanged*\r\nELSE:\r\nDEST..dword[j] \r\n← 0\r\nDEST[MAX_VL-1:VL] \r\n← 0\r\nVPOPCNTQ\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j \r\n← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nIF SRC is broadcast memop:\r\nt \r\n← SRC.qword[0]\r\nELSE:\r\nt \r\n← SRC.qword[j]\r\nDEST.qword[j] \r\n← POPCNT(t)\r\nELSE IF *merging-masking*:\r\n*DEST..qword[j] remains unchanged*\r\nELSE:\r\nDEST..qword[j] \r\n← 0\r\nDEST[MAX_VL-1:VL] \r\n← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/84b67b83-1b05-4daf-9b0e-3258207ef821.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a68942fea55e52d8a8c5a90c1e9bb6d4800aa5bc68575e57985882c8c3aae81d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "591a80a1-c112-481b-9858-a0ea69bc790a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 117,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-57\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPOPCNTW __m128i _mm_popcnt_epi16(__m128i);\r\nVPOPCNTW __m128i _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);\r\nVPOPCNTW __m128i _mm_maskz_popcnt_epi16(__mmask8, __m128i);\r\nVPOPCNTW __m256i _mm256_popcnt_epi16(__m256i);\r\nVPOPCNTW __m256i _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);\r\nVPOPCNTW __m256i _mm256_maskz_popcnt_epi16(__mmask16, __m256i);\r\nVPOPCNTW __m512i _mm512_popcnt_epi16(__m512i);\r\nVPOPCNTW __m512i _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);\r\nVPOPCNTW __m512i _mm512_maskz_popcnt_epi16(__mmask32, __m512i);\r\nVPOPCNTQ __m128i _mm_popcnt_epi64(__m128i);\r\nVPOPCNTQ __m128i _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);\r\nVPOPCNTQ __m128i _mm_maskz_popcnt_epi64(__mmask8, __m128i);\r\nVPOPCNTQ __m256i _mm256_popcnt_epi64(__m256i);\r\nVPOPCNTQ __m256i _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);\r\nVPOPCNTQ __m256i _mm256_maskz_popcnt_epi64(__mmask8, __m256i);\r\nVPOPCNTQ __m512i _mm512_popcnt_epi64(__m512i);\r\nVPOPCNTQ __m512i _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);\r\nVPOPCNTQ __m512i _mm512_maskz_popcnt_epi64(__mmask8, __m512i);\r\nVPOPCNTD __m128i _mm_popcnt_epi32(__m128i);\r\nVPOPCNTD __m128i _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);\r\nVPOPCNTD __m128i _mm_maskz_popcnt_epi32(__mmask8, __m128i);\r\nVPOPCNTD __m256i _mm256_popcnt_epi32(__m256i);\r\nVPOPCNTD __m256i _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);\r\nVPOPCNTD __m256i _mm256_maskz_popcnt_epi32(__mmask8, __m256i);\r\nVPOPCNTD __m512i _mm512_popcnt_epi32(__m512i);\r\nVPOPCNTD __m512i _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);\r\nVPOPCNTD __m512i _mm512_maskz_popcnt_epi32(__mmask16, __m512i);\r\nVPOPCNTB __m128i _mm_popcnt_epi8(__m128i);\r\nVPOPCNTB __m128i _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);\r\nVPOPCNTB __m128i _mm_maskz_popcnt_epi8(__mmask16, __m128i);\r\nVPOPCNTB __m256i _mm256_popcnt_epi8(__m256i);\r\nVPOPCNTB __m256i _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);\r\nVPOPCNTB __m256i _mm256_maskz_popcnt_epi8(__mmask32, __m256i);\r\nVPOPCNTB __m512i _mm512_popcnt_epi8(__m512i);\r\nVPOPCNTB __m512i _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);\r\nVPOPCNTB __m512i _mm512_maskz_popcnt_epi8(__mmask64, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/591a80a1-c112-481b-9858-a0ea69bc790a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d0c54d53b3aacb3771aa7e11345c2b414c33742a438a12542523c1c65d61dbc0",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 347
      },
      {
        "segments": [
          {
            "segment_id": "97dad2b5-f8af-463e-81e7-1dd0adc90f89",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 118,
            "page_width": 612,
            "page_height": 792,
            "content": "2-58 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLD — Concatenate and Shift Packed Data Left Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the left by constant value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F3A.W1 70 /r /ib\r\nVPSHLDW xmm1{k1}{z}, xmm2, \r\nxmm3/m128, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W1 70 /r /ib\r\nVPSHLDW ymm1{k1}{z}, ymm2, \r\nymm3/m256, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W1 70 /r /ib\r\nVPSHLDW zmm1{k1}{z}, zmm2, \r\nzmm3/m512, imm8\r\nA V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.128.66.0F3A.W0 71 /r /ib\r\nVPSHLDD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W0 71 /r /ib\r\nVPSHLDD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W0 71 /r /ib\r\nVPSHLDD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.128.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W1 71 /r /ib\r\nVPSHLDQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the left by constant \r\nvalue in imm8 into zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)\r\nB Full ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/97dad2b5-f8af-463e-81e7-1dd0adc90f89.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2877fb3570e6959621cfcd64cf4e22eee4e2f3f4ef775c3ff84d677c9caae6c5",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "47c8afa8-c194-4dbc-8686-e0ad4f29ccac",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 119,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-59\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHLDW DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.word[j], SRC3.word[j]) << (imm8 & 15)\r\nDEST.word[j] ← tmp.word[1]\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDD DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.dword[j], tsrc3) << (imm8 & 31)\r\nDEST.dword[j] ← tmp.dword[1]\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDQ DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(SRC2.qword[j], tsrc3) << (imm8 & 63)\r\nDEST.qword[j] ← tmp.qword[1]\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/47c8afa8-c194-4dbc-8686-e0ad4f29ccac.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f22ed333151e4aa47f76f4e6d6a05c940d7dcc7e38e01688b803f7ec6d3e8270",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "ef4e67d0-da37-4868-8af9-da4b0213262d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 120,
            "page_width": 612,
            "page_height": 792,
            "content": "2-60 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHLDD __m128i _mm_shldi_epi32(__m128i, __m128i, int);\r\nVPSHLDD __m128i _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDD __m128i _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);\r\nVPSHLDD __m256i _mm256_shldi_epi32(__m256i, __m256i, int);\r\nVPSHLDD __m256i _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHLDD __m256i _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);\r\nVPSHLDD __m512i _mm512_shldi_epi32(__m512i, __m512i, int);\r\nVPSHLDD __m512i _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);\r\nVPSHLDD __m512i _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);\r\nVPSHLDQ __m128i _mm_shldi_epi64(__m128i, __m128i, int);\r\nVPSHLDQ __m128i _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDQ __m128i _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);\r\nVPSHLDQ __m256i _mm256_shldi_epi64(__m256i, __m256i, int);\r\nVPSHLDQ __m256i _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHLDQ __m256i _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);\r\nVPSHLDQ __m512i _mm512_shldi_epi64(__m512i, __m512i, int);\r\nVPSHLDQ __m512i _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);\r\nVPSHLDQ __m512i _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);\r\nVPSHLDW __m128i _mm_shldi_epi16(__m128i, __m128i, int);\r\nVPSHLDW __m128i _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHLDW __m128i _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);\r\nVPSHLDW __m256i _mm256_shldi_epi16(__m256i, __m256i, int);\r\nVPSHLDW __m256i _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);\r\nVPSHLDW __m256i _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);\r\nVPSHLDW __m512i _mm512_shldi_epi16(__m512i, __m512i, int);\r\nVPSHLDW __m512i _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);\r\nVPSHLDW __m512i _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/ef4e67d0-da37-4868-8af9-da4b0213262d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=653b5cc48359d3d3408ccdaa955b215b38e9db262561c50f8a067171c25e4661",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 364
      },
      {
        "segments": [
          {
            "segment_id": "a8b7d808-8b0f-4b0e-9c5f-63db48b86584",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 121,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-61\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLDV — Concatenate and Variable Shift Packed Data Left Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the left by variable value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W1 70 /r\r\nVPSHLDVW xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.256.66.0F38.W1 70 /r\r\nVPSHLDVW ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.512.66.0F38.W1 70 /r\r\nVPSHLDVW zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nEVEX.128.66.0F38.W0 71 /r\r\nVPSHLDVD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.256.66.0F38.W0 71 /r\r\nVPSHLDVD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.512.66.0F38.W0 71 /r\r\nVPSHLDVD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nEVEX.128.66.0F38.W1 71 /r\r\nVPSHLDVQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the left by value in xmm3/m128 into \r\nxmm1.\r\nEVEX.256.66.0F38.W1 71 /r\r\nVPSHLDVQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the left by value in xmm3/m256 into \r\nymm1.\r\nEVEX.512.66.0F38.W1 71 /r\r\nVPSHLDVQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the left by value in zmm3/m512 into \r\nzmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA\r\nB Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/a8b7d808-8b0f-4b0e-9c5f-63db48b86584.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b485601317f9252fd17f5c8ee4976f6d570bfce2b5a4f9743ee2abaad6da5522",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e37e525a-f428-43f1-8e30-b3d3cd06114d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 122,
            "page_width": 612,
            "page_height": 792,
            "content": "2-62 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nFUNCTION concat(a,b):\r\nIF words:\r\nd.word[1] ← a\r\nd.word[0] ← b\r\nreturn d\r\nELSE IF dwords:\r\nq.dword[1] ← a\r\nq.dword[0] ← b\r\nreturn q\r\nELSE IF qwords:\r\no.qword[1] ← a\r\no.qword[0] ← b\r\nreturn o\r\nVPSHLDVW DEST, SRC2, SRC3\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.word[j], SRC2.word[j]) << (SRC3.word[j] & 15)\r\nDEST.word[j] ← tmp.word[1]\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHLDVD DEST, SRC2, SRC3\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.dword[j], SRC2.dword[j]) << (tsrc3 & 31)\r\nDEST.dword[j] ← tmp.dword[1]\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/e37e525a-f428-43f1-8e30-b3d3cd06114d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b35a82e5391ff9ef8722098cc803d1bf42a7bc528291b754b8cbd9f9691164cc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 472
      },
      {
        "segments": [
          {
            "segment_id": "c326def5-4abf-45f7-b606-2fa41e30e9ac",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 123,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-63\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHLDVQ DEST, SRC2, SRC3\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\ntmp ← concat(DEST.qword[j], SRC2.qword[j]) << (tsrc3 & 63)\r\nDEST.qword[j] ← tmp.qword[1]\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHLDVW __m128i _mm_shldv_epi16(__m128i, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVW __m256i _mm256_shldv_epi16(__m256i, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHLDVQ __m512i _mm512_shldv_epi64(__m512i, __m512i, __m512i);\r\nVPSHLDVQ __m512i _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);\r\nVPSHLDVQ __m512i _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);\r\nVPSHLDVW __m128i _mm_shldv_epi16(__m128i, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVW __m128i _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVW __m256i _mm256_shldv_epi16(__m256i, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHLDVW __m256i _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHLDVW __m512i _mm512_shldv_epi16(__m512i, __m512i, __m512i);\r\nVPSHLDVW __m512i _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);\r\nVPSHLDVW __m512i _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);\r\nVPSHLDVD __m128i _mm_shldv_epi32(__m128i, __m128i, __m128i);\r\nVPSHLDVD __m128i _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHLDVD __m128i _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHLDVD __m256i _mm256_shldv_epi32(__m256i, __m256i, __m256i);\r\nVPSHLDVD __m256i _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHLDVD __m256i _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHLDVD __m512i _mm512_shldv_epi32(__m512i, __m512i, __m512i);\r\nVPSHLDVD __m512i _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPSHLDVD __m512i _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/c326def5-4abf-45f7-b606-2fa41e30e9ac.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4eda3208cfa062786b9227751a31fc47a3a08e143316a9316522c0f38a159f4b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 235
      },
      {
        "segments": [
          {
            "segment_id": "4433d8e6-bf29-4a96-bd4a-f5e00812aeca",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 124,
            "page_width": 612,
            "page_height": 792,
            "content": "2-64 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHRD — Concatenate and Shift Packed Data Right Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the right by constant value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F3A.W1 72 /r /ib\r\nVPSHRDW xmm1{k1}{z}, xmm2, \r\nxmm3/m128, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W1 72 /r /ib\r\nVPSHRDW ymm1{k1}{z}, ymm2, \r\nymm3/m256, imm8\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W1 72 /r /ib\r\nVPSHRDW zmm1{k1}{z}, zmm2, \r\nzmm3/m512, imm8\r\nA V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.128.66.0F3A.W0 73 /r /ib\r\nVPSHRDD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W0 73 /r /ib\r\nVPSHRDD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W0 73 /r /ib\r\nVPSHRDD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nEVEX.128.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into xmm1.\r\nEVEX.256.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst, imm8\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into ymm1.\r\nEVEX.512.66.0F3A.W1 73 /r /ib\r\nVPSHRDQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst, imm8\r\nB V/V AVX512_VBMI2 Concatenate destination and source operands, \r\nextract result shifted to the right by constant \r\nvalue in imm8 into zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)\r\nB Full ModRM:reg (w) EVEX.vvvv ModRM:r/m (r) imm8 (r)",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/4433d8e6-bf29-4a96-bd4a-f5e00812aeca.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e658a9935921e9b093266714fc7ddb6b8a20dba2996aff0eebe1e827d0332d0f",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 356
      },
      {
        "segments": [
          {
            "segment_id": "b0e5adae-6db7-4515-a69f-9ba41e49f80d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 125,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-65\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHRDW DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] ← concat(SRC3.word[j], SRC2.word[j]) >> (imm8 & 15)\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDD DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.dword[j] ← concat(tsrc3, SRC2.dword[j]) >> (imm8 & 31)\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDQ DEST, SRC2, SRC3, imm8\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.qword[j] ← concat(tsrc3, SRC2.qword[j]) >> (imm8 & 63)\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b0e5adae-6db7-4515-a69f-9ba41e49f80d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5810e0bb3760721a6207a9aca979c0a02fcd24aabed5e53f20d29800c05f2dcd",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "b7fa5434-a6eb-40cd-99f3-a19f52c358fd",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 126,
            "page_width": 612,
            "page_height": 792,
            "content": "2-66 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHRDQ __m128i _mm_shrdi_epi64(__m128i, __m128i, int);\r\nVPSHRDQ __m128i _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDQ __m128i _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);\r\nVPSHRDQ __m256i _mm256_shrdi_epi64(__m256i, __m256i, int);\r\nVPSHRDQ __m256i _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHRDQ __m256i _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);\r\nVPSHRDQ __m512i _mm512_shrdi_epi64(__m512i, __m512i, int);\r\nVPSHRDQ __m512i _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);\r\nVPSHRDQ __m512i _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);\r\nVPSHRDD __m128i _mm_shrdi_epi32(__m128i, __m128i, int);\r\nVPSHRDD __m128i _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDD __m128i _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);\r\nVPSHRDD __m256i _mm256_shrdi_epi32(__m256i, __m256i, int);\r\nVPSHRDD __m256i _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);\r\nVPSHRDD __m256i _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);\r\nVPSHRDD __m512i _mm512_shrdi_epi32(__m512i, __m512i, int);\r\nVPSHRDD __m512i _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);\r\nVPSHRDD __m512i _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);\r\nVPSHRDW __m128i _mm_shrdi_epi16(__m128i, __m128i, int);\r\nVPSHRDW __m128i _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);\r\nVPSHRDW __m128i _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);\r\nVPSHRDW __m256i _mm256_shrdi_epi16(__m256i, __m256i, int);\r\nVPSHRDW __m256i _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);\r\nVPSHRDW __m256i _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);\r\nVPSHRDW __m512i _mm512_shrdi_epi16(__m512i, __m512i, int);\r\nVPSHRDW __m512i _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);\r\nVPSHRDW __m512i _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b7fa5434-a6eb-40cd-99f3-a19f52c358fd.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d6b936ab440f65182b80136e2899cc0111100584003b4c37d6525be31581674d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 355
      },
      {
        "segments": [
          {
            "segment_id": "0d30f907-eab3-4c2c-9deb-9b917638bf3a",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 127,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-67\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHRDV — Concatenate and Variable Shift Packed Data Right Logical\r\nInstruction Operand Encoding\r\nDescription\r\nConcatenate packed data, extract result shifted to the right by variable value.\r\nThis instruction supports memory fault suppression.\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W1 72 /r\r\nVPSHRDVW xmm1{k1}{z}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.256.66.0F38.W1 72 /r\r\nVPSHRDVW ymm1{k1}{z}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.512.66.0F38.W1 72 /r\r\nVPSHRDVW zmm1{k1}{z}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nEVEX.128.66.0F38.W0 73 /r\r\nVPSHRDVD xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.256.66.0F38.W0 73 /r\r\nVPSHRDVD ymm1{k1}{z}, ymm2, \r\nymm3/m256/m32bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.512.66.0F38.W0 73 /r\r\nVPSHRDVD zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m32bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nEVEX.128.66.0F38.W1 73 /r\r\nVPSHRDVQ xmm1{k1}{z}, xmm2, \r\nxmm3/m128/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate xmm1 and xmm2, extract result \r\nshifted to the right by value in xmm3/m128 \r\ninto xmm1.\r\nEVEX.256.66.0F38.W1 73 /r\r\nVPSHRDVQ ymm1{k1}{z}, ymm2, \r\nymm3/m256/m64bcst\r\nB V/V AVX512_VBMI2\r\nAVX512VL\r\nConcatenate ymm1 and ymm2, extract result \r\nshifted to the right by value in xmm3/m256 \r\ninto ymm1.\r\nEVEX.512.66.0F38.W1 73 /r\r\nVPSHRDVQ zmm1{k1}{z}, zmm2, \r\nzmm3/m512/m64bcst\r\nB V/V AVX512_VBMI2 Concatenate zmm1 and zmm2, extract result \r\nshifted to the right by value in zmm3/m512 \r\ninto zmm1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA\r\nB Full ModRM:reg (r, w) EVEX.vvvv ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/0d30f907-eab3-4c2c-9deb-9b917638bf3a.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d81f5eb74db915e7a78df16fe308c94e1a8a9c24d26ed0c03020b91ec45355b4",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "7ae4821a-1314-48d5-b481-e2b1d430c532",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 128,
            "page_width": 612,
            "page_height": 792,
            "content": "2-68 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nOperation\r\nVPSHRDVW DEST, SRC2, SRC3\r\n(KL, VL) = (8, 128), (16, 256), (32, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.word[j] ← concat(SRC2.word[j], DEST.word[j]) >> (SRC3.word[j] & 15)\r\nELSE IF *zeroing*:\r\nDEST.word[j] ← 0\r\n*ELSE DEST.word[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDVD DEST, SRC2, SRC3\r\n(KL, VL) = (4, 128), (8, 256), (16, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.dword[0]\r\nELSE:\r\ntsrc3 ← SRC3.dword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.dword[j] ← concat(SRC2.dword[j], DEST.dword[j]) >> (tsrc3 & 31)\r\nELSE IF *zeroing*:\r\nDEST.dword[j] ← 0\r\n*ELSE DEST.dword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0\r\nVPSHRDVQ DEST, SRC2, SRC3\r\n(KL, VL) = (2, 128), (4, 256), (8, 512)\r\nFOR j ← 0 TO KL-1:\r\nIF SRC3 is broadcast memop:\r\ntsrc3 ← SRC3.qword[0]\r\nELSE:\r\ntsrc3 ← SRC3.qword[j]\r\nIF MaskBit(j) OR *no writemask*:\r\nDEST.qword[j] ← concat(SRC2.qword[j], DEST.qword[j]) >> (tsrc3 & 63)\r\nELSE IF *zeroing*:\r\nDEST.qword[j] ← 0\r\n*ELSE DEST.qword[j] remains unchanged*\r\nDEST[MAX_VL-1:VL] ← 0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/7ae4821a-1314-48d5-b481-e2b1d430c532.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=568a6159f3e04b72f636823f4b48866900aaa5faec0f91408225c97aab32ae7d",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 489
      },
      {
        "segments": [
          {
            "segment_id": "c86fd7bd-b3af-4190-8f31-55aadb96c56d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 129,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-69\r\nINSTRUCTION SET REFERENCE, A-Z\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHRDVQ __m128i _mm_shrdv_epi64(__m128i, __m128i, __m128i);\r\nVPSHRDVQ __m128i _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVQ __m128i _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVQ __m256i _mm256_shrdv_epi64(__m256i, __m256i, __m256i);\r\nVPSHRDVQ __m256i _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHRDVQ __m256i _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHRDVQ __m512i _mm512_shrdv_epi64(__m512i, __m512i, __m512i);\r\nVPSHRDVQ __m512i _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);\r\nVPSHRDVQ __m512i _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);\r\nVPSHRDVD __m128i _mm_shrdv_epi32(__m128i, __m128i, __m128i);\r\nVPSHRDVD __m128i _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVD __m128i _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVD __m256i _mm256_shrdv_epi32(__m256i, __m256i, __m256i);\r\nVPSHRDVD __m256i _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);\r\nVPSHRDVD __m256i _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);\r\nVPSHRDVD __m512i _mm512_shrdv_epi32(__m512i, __m512i, __m512i);\r\nVPSHRDVD __m512i _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);\r\nVPSHRDVD __m512i _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);\r\nVPSHRDVW __m128i _mm_shrdv_epi16(__m128i, __m128i, __m128i);\r\nVPSHRDVW __m128i _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);\r\nVPSHRDVW __m128i _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);\r\nVPSHRDVW __m256i _mm256_shrdv_epi16(__m256i, __m256i, __m256i);\r\nVPSHRDVW __m256i _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);\r\nVPSHRDVW __m256i _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);\r\nVPSHRDVW __m512i _mm512_shrdv_epi16(__m512i, __m512i, __m512i);\r\nVPSHRDVW __m512i _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);\r\nVPSHRDVW __m512i _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);\r\nSIMD Floating-Point Exceptions\r\nNone.\r\nOther Exceptions\r\nSee Type E4.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/c86fd7bd-b3af-4190-8f31-55aadb96c56d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9ffb4740b13edea3fd9a601d56c4dccdca16fa7b1e8d0e484605ec3b7526e7dd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 175
      },
      {
        "segments": [
          {
            "segment_id": "27b2c792-947f-4826-8daf-018c2422c774",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 130,
            "page_width": 612,
            "page_height": 792,
            "content": "2-70 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVPSHUFBITQMB — Shuffle Bits from Quadword Elements Using Byte Indexes into Mask\r\nInstruction Operand Encoding\r\nDescription\r\nThe VPSHUFBITQMB instruction performs a bit gather select using second source as control and first source as \r\ndata. Each bit uses 6 control bits (2nd source operand) to select which data bit is going to be gathered (first source \r\noperand). A given bit can only access 64 different bits of data (first 64 destination bits can access first 64 data bits, \r\nsecond 64 destination bits can access second 64 data bits, etc.).\r\nControl data for each output bit is stored in 8 bit elements of SRC2, but only the 6 least significant bits of each \r\nelement are used.\r\nThis instruction uses write masking (zeroing only). This instruction supports memory fault suppression.\r\nThe first source operand is a ZMM register. The second source operand is a ZMM register or a memory location. The \r\ndestination operand is a mask register.\r\nOperation\r\nVPSHUFBITQMB DEST, SRC1, SRC2\r\n(KL, VL) = (16,128), (32,256), (64, 512)\r\nFOR i ← 0 TO KL/8-1: //Qword\r\nFOR j ← 0 to 7: // Byte\r\nIF k2[i*8+j] or *no writemask*:\r\nm ← SRC2.qword[i].byte[j] & 0x3F\r\nk1[i*8+j] ← SRC1.qword[i].bit[m]\r\nELSE:\r\nk1[i*8+j] ← 0\r\nk1[MAX_KL-1:KL] ← 0\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nVPSHUFBITQMB __mmask16 _mm_bitshuffle_epi64_mask(__m128i, __m128i);\r\nVPSHUFBITQMB __mmask16 _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);\r\nVPSHUFBITQMB __mmask32 _mm256_bitshuffle_epi64_mask(__m256i, __m256i);\r\nVPSHUFBITQMB __mmask32 _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);\r\nVPSHUFBITQMB __mmask64 _mm512_bitshuffle_epi64_mask(__m512i, __m512i);\r\nVPSHUFBITQMB __mmask64 _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);\r\nOpcode/\r\nInstruction\r\nOp/\r\nEn\r\n64/32 \r\nbit Mode \r\nSupport\r\nCPUID Feature \r\nFlag\r\nDescription\r\nEVEX.128.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, xmm2, \r\nxmm3/m128\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nExtract values in xmm2 using control bits of \r\nxmm3/m128 with writemask k2 and leave the \r\nresult in mask register k1.\r\nEVEX.256.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, ymm2, \r\nymm3/m256\r\nA V/V AVX512_BITALG\r\nAVX512VL\r\nExtract values in ymm2 using control bits of \r\nymm3/m256 with writemask k2 and leave the \r\nresult in mask register k1.\r\nEVEX.512.66.0F38.W0 8F /r\r\nVPSHUFBITQMB k1{k2}, zmm2, \r\nzmm3/m512\r\nA V/V AVX512_BITALG Extract values in zmm2 using control bits of \r\nzmm3/m512 with writemask k2 and leave the \r\nresult in mask register k1.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA Full Mem ModRM:reg (w) EVEX.vvvv (r) ModRM:r/m (r) NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/27b2c792-947f-4826-8daf-018c2422c774.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a52405558687990f6193066cc82e67c289dd7c3cda71f176b927f6ec2c83b327",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 365
      },
      {
        "segments": [
          {
            "segment_id": "79ef3076-c101-47bf-83c4-0f2980dcab96",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 131,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 2-71\r\nINSTRUCTION SET REFERENCE, A-Z\r\nWBNOINVD—Write Back and Do Not Invalidate Cache\r\nInstruction Operand Encoding\r\nDescription\r\nThe WBNOINVD instruction writes back all modified cache lines in the processor’s internal cache to main memory \r\nbut does not invalidate (flush) the internal caches.\r\nAfter executing this instruction, the processor does not wait for the external caches to complete their write-back \r\noperation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache \r\nwrite-back signal. The amount of time or cycles for WBNOINVD to complete will vary due to size and other factors \r\nof different cache hierarchies. As a consequence, the use of the WBNOINVD instruction can have an impact on \r\nlogical processor interrupt/event response time. \r\nThe WBNOINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of \r\na program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see \r\n“Serializing Instructions” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \r\nVolume 3A).\r\nIn situations where cache coherency with main memory is not a concern, software can use the INVD instruction. \r\nThis instruction’s operation is the same in non-64-bit modes and 64-bit mode.\r\nIA-32 Architecture Compatibility\r\nThe WBNOINVD instruction is implementation dependent, and its function may be implemented differently on \r\nfuture Intel 64 and IA-32 processors.\r\nOperation\r\nWriteBack(InternalCaches);\r\nContinue; (* Continue execution *)\r\nIntel C/C++ Compiler Intrinsic Equivalent\r\nWBNOINVD void _wbnoinvd(void);\r\nFlags Affected\r\nNone.\r\nProtected Mode Exceptions\r\n#GP(0) If the current privilege level is not 0.\r\n#UD If the LOCK prefix is used.\r\nReal-Address Mode Exceptions\r\n#UD If the LOCK prefix is used.\r\nOpcode /\r\nInstruction\r\nOp/ \r\nEn\r\n64/32 bit \r\nMode \r\nSupport\r\nCPUID \r\nFeature \r\nFlag\r\nDescription\r\nF3 0F 09\r\nWBNOINVD\r\nA V/V WBNOINVD Write back and do not flush internal caches; \r\ninitiate writing-back without flushing of external \r\ncaches.\r\nOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\r\nA NA NA NA NA NA",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/79ef3076-c101-47bf-83c4-0f2980dcab96.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ca0685864709af68205f6fc48474a06ecdc1876d512dd0e11b7c504c7c1bea95",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "59fc1a82-1b33-4cc6-84b6-caea9faf564b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 132,
            "page_width": 612,
            "page_height": 792,
            "content": "2-72 Ref. # 319433-037\r\nINSTRUCTION SET REFERENCE, A-Z\r\nVirtual-8086 Mode Exceptions\r\n#GP(0) WBNOINVD cannot be executed at the virtual-8086 mode.\r\nCompatibility Mode Exceptions\r\nSame exceptions as in protected mode.\r\n64-Bit Mode Exceptions\r\nSame exceptions as in protected mode.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/59fc1a82-1b33-4cc6-84b6-caea9faf564b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=141009460be1181e72aea6f9025f82d916132c46486d4830422425cf0d85cc56",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 364
      },
      {
        "segments": [
          {
            "segment_id": "b8827022-f06e-482d-9945-6a89de8781e6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 133,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 3-1\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\nCHAPTER 3\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS\r\n(PASIDS)\r\nChapter 2 described the ENQCMD and ENQCMDS instructions. These instructions perform enqueue stores, which \r\nwrite command data to special device registers called enqueue registers.\r\nBits 19:0 of the 64-byte command data written by an enqueue store conveys the process address space identifier \r\n(PASID) associated with the command. Software can use PASIDs to identify individual software threads. Devices \r\nsupporting enqueue registers may use these PASIDs in responding to commands submitted through those regis\u0002ters.\r\nAs explained in Chapter 2, an execution of ENQCMD formats the command data with the PASID specified in \r\nbits 19:0 of the IA32_PASID MSR. It is expected that system software will configure that MSR to contain the PASID \r\nassociated with the software thread that is executing.\r\nENQCMDS can be executed only by system software operating with CPL > 0. It is the responsibility of system soft\u0002ware executing ENQCMDS to configure the command data with the appropriate PASID.\r\nSection 3.1 provides details of the IA32_PASID MSR. Section 3.2 describes how the XSAVE feature set supports \r\nthat MSR. Section 3.3 presents PASID virtualization, a virtualization feature that allows a virtual-machine monitor \r\nto control the PASID values produced by enqueue stores executed by software in a virtual machine.\r\n3.1 THE IA32_PASID MSR\r\nThis section describes the IA32_PASID MSR used by the ENQCMD instruction. The MSR can be read and written \r\nwith the RDMSR and WRMSR instructions, using MSR index D93H. The MSR has format given in Table 3-1.\r\nAn execution of WRMSR causes a general-protection exception (#GP) in response to an attempt to set any bit in \r\nthe ranges 30:20 or 63:32. Executions of RDMSR always return zero for those bits.\r\nBecause system software may associate a PASID with a software thread, it may choose to update the IA32_PASID \r\nMSR on context switches. To facilitate such a usage, the XSAVE feature set is extended to manage the IA32_PASID \r\nMSR. These extensions are detailed in Section 3.2.\r\n3.2 THE PASID STATE COMPONENT FOR THE XSAVE FEATURE SET\r\nAs noted in Section 3.1, system software may choose to update the IA32_PASID MSR on context switches. This \r\nusage is supported by extensions to the XSAVE feature set.\r\nThe XSAVE feature set supports the saving and restoring of state components. These state components are orga\u0002nized using state-component bitmaps (each bit in such a bitmap corresponds to a state component).\r\nA new state component is introduced called PASID state. PASID state comprises the IA32_PASID MSR. It is \r\ndefined to be state component 10, so PASID state is associated with bit 10 in state component bitmaps. It is a \r\nTable 3-1. IA32_PASID MSR\r\nBit Offset Description\r\n19:0 Process address space identifier (PASID). Specifies the PASID of the currently running software thread.\r\n30:20 Reserved\r\n31 Valid. Execution of ENQCMD causes a #GP if this bit is clear.\r\n63:32 Reserved",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/b8827022-f06e-482d-9945-6a89de8781e6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd85c25c7016017cde30c5ebda2863e3ab86e641e112520d4a0a874c04490cfd",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 483
      },
      {
        "segments": [
          {
            "segment_id": "6da10e77-4074-44f0-a9df-87917ec614e8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 134,
            "page_width": 612,
            "page_height": 792,
            "content": "3-2 Ref. # 319433-037\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\nsupervisor state component, meaning that it can be managed only by the XSAVES and XRSTORS instructions. \r\nSystem software can enable those instructions to manage PASID state by setting bit 10 in the IA32_XSS MSR.\r\nProcessor support for this management of PASID state is enumerated by the CPUID instruction as follows:\r\n• CPUID function 0DH, sub-function 1, enumerates in EDX:ECX a bitmap of the supervisor state components. \r\nECX[10] will be enumerated as 1 to indicate that PASID state is supported.\r\n• If PASID state is supported, CPUID function 0DH, sub-function 10 enumerates details for state component as \r\nfollows:\r\n— EAX enumerates 8 as the size (in bytes) required for PASID state. (The state component comprises only the \r\none MSR.)\r\n— EBX enumerates value 0, as is the case for supervisor state components.\r\n— ECX[0] enumerates 1, indicating that PASID state is a supervisor state component.\r\n— ECX[1] enumerates 0, indicating that state component 10 is located immediately following the preceding \r\nstate component when the compacted format of the extended region of an XSAVE area is used.\r\n— ECX[31:2] and EDX enumerate 0, as is the case for all state components.\r\nLike WRMSR, XRSTORS causes a general-protection exception (#GP) in response to an attempt to set any bit in the \r\nIA32_PASID MSR in the ranges 30:20 or 63:32. Like RDMSR, XSAVES always saves zero for those bits.\r\n3.3 PASID TRANSLATION\r\nAs noted earlier, an operating system (OS) may use PASIDs to identify individual software threads that are allowed \r\nto access devices supporting enqueue registers.\r\nIntel® Scalable I/O Virtualization (Scalable IOV) defines an approach to hardware-assisted I/O virtualization, \r\nextending it to support seamless addition of resources and dynamic provisioning of containers.1 With Scalable IOV, \r\na virtual-machine monitor (VMM) needs to control the PASIDs that are used by different virtual machines just as \r\nthe guest OS controls the PASIDs used by software threads.\r\nTo allow a VMM to control the PASIDs used by enqueue stores while still allowing efficient use by a guest OS, a new \r\nvirtualization feature is introduced, called PASID translation. PASID translation, if enabled, applies to any \r\nenqueue store performed by software in a virtual machine: the 20-bit PASID value specified by the guest operating \r\nsystem (guest PASID) for ENQCMD or ENQCMDS is translated into a 20-bit value (host PASID) that is used in the \r\nresulting enqueue store.\r\n3.3.1 PASID Translation Structures\r\nPASID translation is implemented by two hierarchies of data structures (PASID-translation hierarchies) config\u0002ured by a VMM. Guest PASIDs 00000H to 7FFFFH are translated through the low PASID-translation hierarchy, while \r\nguest PASIDs 80000 to FFFFFH are translated through the high PASID-translation hierarchy.\r\nEach PASID-translation hierarchy includes a 4-KByte PASID directory. A PASID directory comprises 512 8-byte \r\nentries, each of which has the following format:\r\n• Bit 0 is the entry’s present bit. The entry is used only if this bit is 1.\r\n• Bits 11:1 are reserved and must be 0.\r\n• Bits M–1:12 specify the 4-KByte aligned address of a PASID table (see below), where M is the physical-address \r\nwidth supported by the processor.\r\n• Bits 63:M are reserved and must be 0.\r\nA PASID-translation hierarchy also includes up to 512 4-KByte PASID tables; these are referenced by PASID \r\ndirectory entries (see above). A PASID table comprises 1024 4-byte entries, each of which has the following \r\nformat:\r\n• Bits 19:0 are the host PASID specified by the entry.\r\n1. See the Intel® Scalable I/O Virtualization Technical Specification for more details.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/6da10e77-4074-44f0-a9df-87917ec614e8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c5e7a7d1c15322416530ba5bf52c66e8005d8f4bb2c23293e9f3d7375a9d44d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "6da10e77-4074-44f0-a9df-87917ec614e8",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 134,
            "page_width": 612,
            "page_height": 792,
            "content": "3-2 Ref. # 319433-037\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\nsupervisor state component, meaning that it can be managed only by the XSAVES and XRSTORS instructions. \r\nSystem software can enable those instructions to manage PASID state by setting bit 10 in the IA32_XSS MSR.\r\nProcessor support for this management of PASID state is enumerated by the CPUID instruction as follows:\r\n• CPUID function 0DH, sub-function 1, enumerates in EDX:ECX a bitmap of the supervisor state components. \r\nECX[10] will be enumerated as 1 to indicate that PASID state is supported.\r\n• If PASID state is supported, CPUID function 0DH, sub-function 10 enumerates details for state component as \r\nfollows:\r\n— EAX enumerates 8 as the size (in bytes) required for PASID state. (The state component comprises only the \r\none MSR.)\r\n— EBX enumerates value 0, as is the case for supervisor state components.\r\n— ECX[0] enumerates 1, indicating that PASID state is a supervisor state component.\r\n— ECX[1] enumerates 0, indicating that state component 10 is located immediately following the preceding \r\nstate component when the compacted format of the extended region of an XSAVE area is used.\r\n— ECX[31:2] and EDX enumerate 0, as is the case for all state components.\r\nLike WRMSR, XRSTORS causes a general-protection exception (#GP) in response to an attempt to set any bit in the \r\nIA32_PASID MSR in the ranges 30:20 or 63:32. Like RDMSR, XSAVES always saves zero for those bits.\r\n3.3 PASID TRANSLATION\r\nAs noted earlier, an operating system (OS) may use PASIDs to identify individual software threads that are allowed \r\nto access devices supporting enqueue registers.\r\nIntel® Scalable I/O Virtualization (Scalable IOV) defines an approach to hardware-assisted I/O virtualization, \r\nextending it to support seamless addition of resources and dynamic provisioning of containers.1 With Scalable IOV, \r\na virtual-machine monitor (VMM) needs to control the PASIDs that are used by different virtual machines just as \r\nthe guest OS controls the PASIDs used by software threads.\r\nTo allow a VMM to control the PASIDs used by enqueue stores while still allowing efficient use by a guest OS, a new \r\nvirtualization feature is introduced, called PASID translation. PASID translation, if enabled, applies to any \r\nenqueue store performed by software in a virtual machine: the 20-bit PASID value specified by the guest operating \r\nsystem (guest PASID) for ENQCMD or ENQCMDS is translated into a 20-bit value (host PASID) that is used in the \r\nresulting enqueue store.\r\n3.3.1 PASID Translation Structures\r\nPASID translation is implemented by two hierarchies of data structures (PASID-translation hierarchies) config\u0002ured by a VMM. Guest PASIDs 00000H to 7FFFFH are translated through the low PASID-translation hierarchy, while \r\nguest PASIDs 80000 to FFFFFH are translated through the high PASID-translation hierarchy.\r\nEach PASID-translation hierarchy includes a 4-KByte PASID directory. A PASID directory comprises 512 8-byte \r\nentries, each of which has the following format:\r\n• Bit 0 is the entry’s present bit. The entry is used only if this bit is 1.\r\n• Bits 11:1 are reserved and must be 0.\r\n• Bits M–1:12 specify the 4-KByte aligned address of a PASID table (see below), where M is the physical-address \r\nwidth supported by the processor.\r\n• Bits 63:M are reserved and must be 0.\r\nA PASID-translation hierarchy also includes up to 512 4-KByte PASID tables; these are referenced by PASID \r\ndirectory entries (see above). A PASID table comprises 1024 4-byte entries, each of which has the following \r\nformat:\r\n• Bits 19:0 are the host PASID specified by the entry.\r\n1. See the Intel® Scalable I/O Virtualization Technical Specification for more details.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/6da10e77-4074-44f0-a9df-87917ec614e8.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c5e7a7d1c15322416530ba5bf52c66e8005d8f4bb2c23293e9f3d7375a9d44d4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 583
      },
      {
        "segments": [
          {
            "segment_id": "3eafc28a-4ff2-4449-9841-f1b205c0bd82",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 135,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 3-3\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\n• Bits 30:20 are reserved and must be 0.\r\n• Bits 31 is the entry’s valid bit. The entry is used only if this bit is 1.\r\nSection 3.3.2 explains how the PASID-translation hierarchies are used to translate the PASIDs used for enqueue \r\nstores.\r\n3.3.2 The PASID Translation Process\r\nEach execution of ENQCMD or ENQCMDS results in an enqueue store with a PASID value. (ENQCMD obtains the \r\nPASID from the IA32_PASID MSR; ENQCMDS obtains it from the instruction's source operand.) When PASID trans\u0002lation is enabled, this PASID value is interpreted as a guest PASID. The guest PASID is converted to a host PASID; \r\nthe enqueue store uses the host PASID for bits 19:0 of the command data that it writes.\r\nThe PASID translation process is illustrated in Figure 3-1.\r\nThe process operates as follows:\r\n• If bit 19 of guest PASID is clear, the low PASID directory is used; otherwise, the high PASID directory is used.\r\n• Bits 18:10 of the guest PASID select an entry from the PASID directory. A VM exit occurs if the entry’s valid bit \r\nis clear or if any reserved bit is set. Otherwise, bits M:0 of the entry (with bit 0 cleared) contain the physical \r\naddress of a PASID table, where M is the physical-address width supported by the processor..\r\n• Bits 9:0 of the guest PASID select an entry from the PASID table. A VM exit occurs if the entry’s present bit is \r\nclear or if any reserved bit is set. Otherwise, bits 19:0 of the entry are the host PASID.\r\nFigure 3-1. PASID Translation Process\r\n19 18 10 9 0\r\nGuest PASID\r\n Host PASID Rsvd\r\n31 30 19 0\r\nPASID Table\r\n Rsvd PASID Table Pointer Rsvd\r\nM (M–1) 11 10 0\r\nHigh PASID Directory\r\nEntry Index = Guest PASID [9:0]\r\nV\r\n Host PASID Rsvd\r\n31 30 19 0\r\nPASID Table\r\nV\r\nP\r\nEntry Index = 63 1\r\nGuest PASID [18:10]\r\n Rsvd PASID Table Pointer Rsvd\r\nM (M–1) 11 10 0\r\nLow PASID Directory\r\nP\r\n63 1\r\nHigh PASID Directory \r\nPointer in VMCS\r\nLow PASID Directory \r\nPointer in VMCS\r\nVMCS Fields\r\n1\r\n0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/3eafc28a-4ff2-4449-9841-f1b205c0bd82.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8b30b695cab753f6aeb2f5dbde8cad7f11a671ea55e7bf40a93d5c1d28771bcb",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 362
      },
      {
        "segments": [
          {
            "segment_id": "2b578273-5e7d-4c4d-ab93-914610ba7d71",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 136,
            "page_width": 612,
            "page_height": 792,
            "content": "3-4 Ref. # 319433-037\r\nENQUEUE STORES AND PROCESS ADDRESS SPACE IDENTIFIERS (PASIDS)\r\nAn execution of ENQCMD or ENQCMDS performs PASID translation only after checking for conditions that may \r\nresult in general-protection exception (the check of IA32_PASID.Valid for ENQCMD; the check of CPL for \r\nENQCMDS) and after loading the instruction's source operand from memory. PASID translation occurs before the \r\nactual enqueue store and thus before any faults or VM exits that it may cause (e.g., page faults or EPT violations).\r\n3.3.3 VMX Support\r\nA VMM enables PASID translation by setting secondary processor-based VM-execution control 21. A processor \r\nenumerates support for the 1-setting of this control in the normal way (by setting bit 53 of the \r\nIA32_VMX_PROCBASED_CTLS2 MSR). It is expected that any processor that supports the ENQCMD and ENQCMDS \r\ninstructions will also support PASID virtualization and vice versa.\r\nPASID translation uses two new 64-bit VM-execution control fields in the VMCS: the low PASID directory \r\naddress and the high PASID directory address. These are the physical addresses of the low PASID directory \r\nand the high PASID directory, respectively. Software can access these new VMCS fields using the encoding pairs \r\n00002038H/00002039H and 0000203AH/0000203BH, respectively.\r\nIf the “PASID translation” VM-execution control is 1, VM entry fails if either PASID directory address sets any bit in \r\nthe ranges 11:0 or 63:M, where M is the physical-address width supported by the processor.\r\nSection 3.3.2 identified situations that may cause a VM exit during PASID translation. Such a VM exit uses basic \r\nexit reason 72 (for ENQCMD PASID translation failure) or 73 (ENQCMDS PASID translation failure). The exit quali\u0002fication is determined as follows:\r\n• For ENQCMD, it is IA32_PASID & 7FFFFH (bits 63:20 are cleared).\r\n• For ENQCMD, it is SRC & FFFFFFFFH, where SRC is the instruction’s source operand (only bits 31:0 may be set).",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/2b578273-5e7d-4c4d-ab93-914610ba7d71.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=82ed1fd1c988e13a74dca3404d26ddd9ef7bb423d88c91a4f719962e6b091a5b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 299
      },
      {
        "segments": [
          {
            "segment_id": "aac29e65-9cde-4008-93e1-5293cef6ab34",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 137,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 4-1\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS\r\nCHAPTER 4\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS\r\n4.1 HARDWARE FEEDBACK INTERFACE\r\nHardware provides guidance to the Operating System (OS) scheduler to perform optimal workload scheduling \r\nthrough a hardware feedback interface structure in memory. This structure has a global header that is 16 byte in \r\nsize. Following this global header, there is one 8 byte entry per logical processor in the socket. The structure is \r\ndesigned as follows.\r\nThe global header is structured as follows.\r\nThe per logical processor scheduler feedback entry is structured as follows.\r\nTable 4-1. Hardware Feedback Interface Structure\r\nByte Offset Size (Bytes) Description\r\n0 16 Global Header\r\n16 8 LP0 Capability Values\r\n24 8 LP1 Capability Values\r\n... ... ...\r\n16 + n*8 8 LPn Capability Values\r\nTable 4-2. Hardware Feedback Interface Global Header Structure\r\nByte Offset Size (Bytes) Field Name Description\r\n0 8 Timestamp Timestamp of when the table was last updated by hardware. This is a \r\ntimestamp in crystal clock units.\r\nInitialized by OS to 0.\r\n8 1 Performance \r\nCapability Changed\r\nIf set to 1, indicates the performance capability field for one or more logical \r\nprocessors was updated in the table.\r\nInitialized by OS to 0.\r\n9 1 Energy Efficiency \r\nCapability Changed\r\nIf set to 1, indicates the energy efficiency capability field for one or more \r\nlogical processors was updated in the table.\r\nInitialized by OS to 0.\r\n10 6 Reserved Initialized by OS to 0.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/aac29e65-9cde-4008-93e1-5293cef6ab34.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=536b389ecfdfcb4702fd0ffd988951beebdf6558d8e7bfaf8512979f9f2b7fc7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 240
      },
      {
        "segments": [
          {
            "segment_id": "cca2902b-3b49-41b1-a5a0-98c9a5956936",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 138,
            "page_width": 612,
            "page_height": 792,
            "content": "4-2 Ref. # 319433-037\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS\r\n4.1.1 Hardware Feedback Interface Pointer\r\nThe physical address of the hardware feedback interface structure is programmed by the OS into a package scoped \r\nMSR named IA32_HW_FEEDBACK_PTR. The MSR is structured as follows:\r\n• Bits 63:MAXPHYADDR1 - Reserved. \r\n• Bits MAXPHYADDR-1:12 - ADDR. This is the physical address of the page frame of the first page of this \r\nstructure.\r\n• Bits 11:1 - Reserved. \r\n• Bit 0 - Valid. When set to 1, indicates a valid pointer is programmed into the MSR.\r\nThe address of this MSR is 17D0H.\r\nSee Section 4.1.4 for details on how the OS detects the size of memory to allocate for this structure. This MSR is \r\ncleared on reset to its default value of 0. The MSR retains its state on INIT.\r\n4.1.2 Hardware Feedback Interface Configuration\r\nThe operating system enables the hardware feedback interface using a package scoped MSR named IA32_HW_-\r\nFEEDBACK_CONFIG (address 17D1H).\r\nThe MSR is structured as follows:\r\n• Bits 63:1 - Reserved. \r\n• Bit 0 - Enable. When set to 1, enables the hardware feedback interface.\r\nThis MSR is cleared on reset to its default value of 0. The MSR retains its state on INIT.\r\nWhen the Enable bit transitions from 1 to 0, hardware sets the IA32_PACKAGE_THERM_STATUS bit 26 to 1 to \r\nacknowledge disabling of the interface. The OS should wait for this bit to be set to 1 after disabling the interface \r\nbefore reclaiming the memory allocated for this structure. When this bit is set to 1, it is safe to reclaim the memory \r\nas it is guaranteed that there are no writes in progress to this structure by hardware.\r\nSENTER clears the enable bit to 0 on all sockets.\r\n4.1.3 Hardware Feedback Interface Notifications\r\nThe IA32_PACKAGE_THERM_STATUS MSR is extended with a new bit, hardware feedback interface structure \r\nchange status (bit 26, R/WC0), to indicate that the hardware has updated the hardware feedback interface struc\u0002ture. This is a sticky bit and once set, indicates that the OS should read the structure to determine the change and \r\nadjust its scheduling decisions. Once set, the hardware will not generate any further updates to this structure until \r\nTable 4-3. Hardware Feedback Interface Logical Processor Entry Structure\r\nByte Offset Size (Bytes) Field Name Description\r\n0 1 Performance \r\nCapability\r\nPerformance capability is an 8-bit value (0 ... 255) specifying the relative \r\nperformance level of a logical processor. Higher values indicate higher \r\nperformance; the lowest performance level of 0 indicates a recommendation to \r\nthe OS to not schedule any software threads on it for performance reasons.\r\nInitialized by OS to 0.\r\n1 1 Energy \r\nEfficiency \r\nCapability\r\nEnergy Efficiency capability is an 8-bit value (0 ... 255) specifying the relative \r\nenergy efficiency level of a logical processor. Higher values indicate higher energy \r\nefficiency; the lowest energy efficiency capability of 0 indicates a recommendation \r\nto the OS to not schedule any software threads on it for efficiency reasons.\r\nInitialized by OS to 0.\r\n2 6 Reserved Initialized by OS to 0.\r\n1. MAXPHYADDR is reported in CPUID.80000008H:EAX[7:0].",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/cca2902b-3b49-41b1-a5a0-98c9a5956936.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e94dbd55fcc42b5bce3c9411c34c9bffd8247c8999569d8be5819faf4a28fc3c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 508
      },
      {
        "segments": [
          {
            "segment_id": "93b11c7c-c2f5-4686-8c8f-a3aae3d448f1",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 139,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 4-3\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS\r\nthe OS clears this bit by writing 0. The hardware guarantees that all writes to the hardware feedback interface \r\nstructure are globally observed.\r\nThe OS can enable interrupt-based notifications when the structure is updated by hardware through a new enable \r\nbit, hardware feedback interrupt enable (bit 25, R/W), in the IA32_PACKAGE_THERM_INTERRUPT MSR. When this \r\nbit is set to 1, it enables the generation of an interrupt when the hardware feedback interface structure is updated \r\nby hardware.\r\n4.1.4 Hardware Feedback Interface Enumeration\r\nCPUID.06H.0H:EAX.HW_FEEDBACK[bit 19] enumerates support for this feature. When this bit is enumerated to 1, \r\nthe following MSR (or bits in the MSR) are supported by the hardware:\r\n• IA32_HW_FEEDBACK_PTR (address 17D0H)\r\n• IA32_HW_FEEDBACK_CONFIG (address 17D1H)\r\n• IA32_PACKAGE_THERM_STATUS bit 26\r\n• IA32_PACKAGE_THERM_INTERRUPT bit 25\r\nWhen CPUID.06H.0H:EAX.HW_FEEDBACK[bit 19] = 1, then CPUID.06H.0H:EDX reports the following:\r\n• EDX[7:0] - Bitmap of supported hardware feedback interface capabilities. \r\nBit 0: When set to 1, indicates support for performance capability reporting.\r\nBit 1: When set to 1, indicates support for energy efficiency capability reporting.\r\nBits 0 and 1 will always be set together. Other bits are reserved.\r\n• EDX[11:8] - Enumerates the size of the hardware feedback interface structure in number of 4 KB pages using \r\nminus-one notation. \r\n• EDX[31:16] - Index (starting at 0) of this logical processor’s row in the hardware feedback interface structure. \r\nNote that the index may be same for multiple logical processors on some parts. On some parts the indices may \r\nnot be contiguous, i.e., there may be unused rows in the table.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/93b11c7c-c2f5-4686-8c8f-a3aae3d448f1.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=52727f7ce291a98421528f2871d4dfc78fab5a18d870336387fdf262f75f5d80",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "887338ee-f59f-4f0a-abe5-c6e28d4f51c2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 140,
            "page_width": 612,
            "page_height": 792,
            "content": "4-4 Ref. # 319433-037\r\nHARDWARE FEEDBACK INTERFACE ISA EXTENSIONS",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/887338ee-f59f-4f0a-abe5-c6e28d4f51c2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d06a095ada6d59f68c90f74928ce42798d815a80400982d2da9ddca7126cf96a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 271
      },
      {
        "segments": [
          {
            "segment_id": "549f0880-6dc5-4bd1-afe2-47b492e2b76b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 141,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 I\r\nINDEX\r\nB\r\nBrand information 1-38\r\nprocessor brand index 1-40\r\nprocessor brand string 1-38\r\nC\r\nCache and TLB information 1-33\r\nCache Inclusiveness 1-10\r\nCLFLUSH instruction\r\nCPUID flag 1-32\r\nCMOVcc flag 1-32\r\nCMOVcc instructions\r\nCPUID flag 1-32\r\nCMPXCHG16B instruction\r\nCPUID bit 1-30\r\nCMPXCHG8B instruction\r\nCPUID flag 1-32\r\nCPUID instruction 1-8, 1-32\r\n36-bit page size extension 1-32\r\nAPIC on-chip 1-32\r\nbasic CPUID information 1-9\r\ncache and TLB characteristics 1-9, 1-33\r\nCLFLUSH flag 1-32\r\nCLFLUSH instruction cache line size 1-29\r\nCMPXCHG16B flag 1-30\r\nCMPXCHG8B flag 1-32\r\nCPL qualified debug store 1-30\r\ndebug extensions, CR4.DE 1-31\r\ndebug store supported 1-32\r\ndeterministic cache parameters leaf 1-9, 1-12, 1-14, 1-15, 1-16, 1-17, 1-18, 1-19, 1-20, 1-24\r\nextended function information 1-24\r\nfeature information 1-31\r\nFPU on-chip 1-31\r\nFSAVE flag 1-33\r\nFXRSTOR flag 1-33\r\nIA-32e mode available 1-25\r\ninput limits for EAX 1-26\r\nL1 Context ID 1-30\r\nlocal APIC physical ID 1-29\r\nmachine check architecture 1-32\r\nmachine check exception 1-32\r\nmemory type range registers 1-32\r\nMONITOR feature information 1-36\r\nMONITOR/MWAIT flag 1-30\r\nMONITOR/MWAIT leaf 1-10, 1-11, 1-12, 1-14, 1-15, 1-21, 1-24\r\nMWAIT feature information 1-36\r\npage attribute table 1-32\r\npage size extension 1-32\r\nperformance monitoring features 1-36\r\nphysical address bits 1-26\r\nphysical address extension 1-32\r\npower management 1-36, 1-37, 1-38\r\nprocessor brand index 1-28, 1-38\r\nprocessor brand string 1-25, 1-38\r\nprocessor serial number 1-32\r\nprocessor type field 1-28\r\nRDMSR flag 1-32\r\nreturned in EBX 1-28\r\nreturned in ECX & EDX 1-29\r\nself snoop 1-33\r\nSpeedStep technology 1-30\r\nSS2 extensions flag 1-33",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/549f0880-6dc5-4bd1-afe2-47b492e2b76b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5a429b455b1e4b2c1099769dd965ee9aac9a359e66d782dd6a0eea757fa1ef86",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "15589aee-1e69-483c-8c52-cc4e0f365a5c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 142,
            "page_width": 612,
            "page_height": 792,
            "content": "II Ref. # 319433-037\r\nSSE extensions flag 1-33\r\nSSE3 extensions flag 1-30\r\nSSSE3 extensions flag 1-30\r\nSYSENTER flag 1-32\r\nSYSEXIT flag 1-32\r\nthermal management 1-36, 1-37, 1-38\r\nthermal monitor 1-30, 1-33\r\ntime stamp counter 1-32\r\nusing CPUID 1-8\r\nvendor ID string 1-26\r\nversion information 1-9, 1-36\r\nvirtual 8086 Mode flag 1-31\r\nvirtual address bits 1-26\r\nWRMSR flag 1-32\r\nF\r\nFeature information, processor 1-8\r\nFXRSTOR instruction\r\nCPUID flag 1-33\r\nFXSAVE instruction\r\nCPUID flag 1-33\r\nI\r\nIA-32e mode\r\nCPUID flag 1-25\r\nInstruction set\r\ngrouped by processor 1-1\r\nL\r\nL1 Context ID 1-30 M\r\nMachine check architecture\r\nCPUID flag 1-32\r\ndescription 1-32\r\nMMX instructions\r\nCPUID flag for technology 1-33\r\nModel & family information 1-36\r\nMONITOR instruction\r\nCPUID flag 1-30\r\nfeature data 1-36\r\nMWAIT instruction\r\nCPUID flag 1-30\r\nfeature data 1-36\r\nP\r\nPending break enable 1-33\r\nPerformance-monitoring counters\r\nCPUID inquiry for 1-36\r\nR\r\nRDMSR instruction\r\nCPUID flag 1-32\r\nS\r\nSelf Snoop 1-33\r\nSpeedStep technology 1-30\r\nSSE extensions\r\nCPUID flag 1-33\r\nSSE2 extensions\r\nCPUID flag 1-33\r\nSSE3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/15589aee-1e69-483c-8c52-cc4e0f365a5c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7a55fe98d15016f9c0755998e9cffd23921023d80759547c27b3a447c2d69024",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "dab3dab4-098d-4ce2-ab90-4bc24ec90f65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 143,
            "page_width": 612,
            "page_height": 792,
            "content": "Ref. # 319433-037 III\r\nCPUID flag 1-30\r\nSSE3 extensions\r\nCPUID flag 1-30\r\nSSSE3 extensions\r\nCPUID flag 1-30\r\nStepping information 1-36\r\nSYSENTER instruction\r\nCPUID flag 1-32\r\nSYSEXIT instruction\r\nCPUID flag 1-32\r\nT\r\nThermal Monitor\r\nCPUID flag 1-33\r\nThermal Monitor 2 1-30\r\nCPUID flag 1-30\r\nTime Stamp Counter 1-32\r\nV\r\nVersion information, processor 1-8\r\nVPMULTISHIFTQB – Select Packed Unaligned Bytes from Quadword Source 2-46\r\nW\r\nWBINVD instruction 2-71\r\nWBINVD/INVD bit 1-10\r\nWRMSR instruction\r\nCPUID flag 1-32\r\nX\r\nXFEATURE_ENALBED_MASK 1-4\r\nXRSTOR 1-4, 1-37\r\nXSAVE 1-4, 1-30, 1-37",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/900764ae-e7ad-4c7c-b731-36d3664b9562/images/dab3dab4-098d-4ce2-ab90-4bc24ec90f65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T042628Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c54b2dad3321ec261443563b9fcf3c728c07da71d3c38da4310223b75e08d969",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 492
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\n \"title\": \"Intel® Architecture Instruction Set Extensions and Future Features Programming Reference\"\n}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "```json\n{\"author\": \"Intel Corporation\"}\n```"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No response"
        }
      ]
    }
  }
}