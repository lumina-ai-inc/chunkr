{
  "file_name": "Intel - _vectorcall and __regcall Demystified.pdf",
  "task_id": "8f7d455e-5d32-495a-a5d1-7a208a414d06",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "a5f160b2-d63c-4b8b-8818-09ea5cf4be1d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "_vectorcall and __regcall Demystified\r\nThe motivation to have the new vectorcall calling convention is to make use of as many registers as \r\npossible to pass function arguments rather than pushing the function arguments to stack and reading \r\nthem from stack inside the function. Targeting this calling convention on performance critical functions \r\ncan increase the performance since now most of the interaction is happening with registers (as\r\ndemonstrated below with a code sample). For more information on vectorcall calling convention, please \r\nrefer to the following URLs:\r\n1. http://msdn.microsoft.com/en-us/library/dn375768.aspx\r\n2. http://blogs.msdn.com/b/vcblog/archive/2013/07/12/introducing-vector-calling\u0002convention.aspx\r\nIntel® C++ Compiler 14.0 Update 1 doesn’t support _vectorcall calling convention. Instead users can use \r\n__regcall calling convention which is a workaround for _vectorcall (demonstrated in this article).\r\nCode Snippet:\r\n#include<intrin.h>\r\n#include<iostream>\r\nusing namespace std;\r\nstruct Point{\r\n__m128 x, y;\r\n};\r\n__declspec(noinline) Point add(Point p1, Point p2){\r\nPoint p3;\r\np3.x = _mm_add_ps(p1.x, p2.x);\r\np3.y = _mm_add_ps(p1.y, p2.y);\r\nreturn p3;\r\n}\r\nint main(int argc, char *argv[]){\r\nPoint a[16], b[16], c[16], sum;\r\nmemset(&sum, 0, 32);\r\nfor (int i = 0; i < 16; i++)\r\nc[i] = add(a[i], b[i]);\r\nfor (int i = 0; i < 16; i++)\r\n{\r\nsum.x = _mm_add_ps(sum.x, c[i].x);\r\nsum.y = _mm_add_ps(sum.y, c[i].y);\r\n}\r\nreturn 0;\r\n}\r\nWhen this code is compiled with __cdecl calling convention for Win32 using VS2013 Compiler, it errors \r\nout as shown below:\r\nC:\\Users\\amadhuso\\Documents\\Visual Studio 2013\\Projects\\Elemvector\\Elemvector>cl.exe \r\nElemvector.cpp /arch:AVX",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/a5f160b2-d63c-4b8b-8818-09ea5cf4be1d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20819adc21ae9821fe46fb88f4809244c2989b73d623c9da15c42e9481b7c69d",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "292e9912-fc2b-45ac-89b2-a01f6921a7f4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Microsoft (R) C/C++ Optimizing Compiler Version 18.00.21005.1 for x86\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\nElemvector.cpp\r\nYou are using an Intel supplied intrinsic header file with a third-party compiler.\r\nC:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\xlocale(337) : warning C4530: C++ \r\nexception handler used, but unwind semantics are not enabled. Specify /EHsc\r\nElemvector.cpp(7) : error C2719: 'p1': formal parameter with __declspec(align('16')) won't be aligned\r\nElemvector.cpp(7) : error C2719: 'p2': formal parameter with __declspec(align('16')) won't be aligned\r\nIntel® C++ Compiler doesn’t encounter this problem. We handle this case well.\r\nThis article is intended to analyze the code generated by VS2013 compiler and ICL 14.0 Update 1 (x64 \r\nbuild). Analyzing the ASM will give you good insight as to how each calling convention passes the \r\nfunction arguments / return value.\r\nASM generated by VS2013 compiler (_cdecl calling convention):\r\n>cl.exe /O2 /arch:AVX /FAs Elemvector.cpp /EHsc\r\nMicrosoft (R) C/C++ Optimizing Compiler Version 18.00.21005.1 for x64\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\nElemvector.cpp\r\nYou are using an Intel supplied intrinsic header file with a third-party compiler.\r\nMicrosoft (R) Incremental Linker Version 12.00.21005.1\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n/out:Elemvector.exe\r\nElemvector.obj\r\n$LL6@main:\r\n; 17 : c[i] = add(a[i], b[i]);\r\nvmovups ymm0, YMMWORD PTR b$[rsp+r9]\r\nlea r8, QWORD PTR $T2[rsp]\r\nlea rdx, QWORD PTR $T1[rsp]\r\nlea rcx, QWORD PTR $T3[rsp]\r\nvmovups YMMWORD PTR $T2[rsp], ymm0\r\nvmovups YMMWORD PTR $T1[rsp], ymm0\r\nvzeroupper\r\ncall ?add@@YA?AUPoint@@U1@0@Z ; add\r\nadd r9, 32 ; 00000020H\r\nvmovups ymm0, YMMWORD PTR [rax]\r\nvmovups YMMWORD PTR c$[rsp+r9-32], ymm0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/292e9912-fc2b-45ac-89b2-a01f6921a7f4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a2f20bf8c94cef1e3827e1af91b743964ab6d9cd8ce7f8492e6dcaaafde5ad37",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 466
      },
      {
        "segments": [
          {
            "segment_id": "4bc559a2-0a5e-4dda-951a-1003ac9e9cb0",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "cmp r9, 512 ; 00000200H\r\njl SHORT $LL6@main\r\n; COMDAT ?add@@YA?AUPoint@@U1@0@Z\r\n_TEXT SEGMENT\r\n$T1 = 8\r\np1$ = 16\r\np2$ = 24\r\n?add@@YA?AUPoint@@U1@0@Z PROC ; add, COMDAT\r\n; 8 : Point p3;\r\n; 9 : p3.x = _mm_add_ps(p1.x, p2.x);\r\nvmovups ymm1, YMMWORD PTR [rdx]\r\n; 10 : p3.y = _mm_add_ps(p1.y, p2.y);\r\n; 11 : return p3;\r\nmov rax, rcx\r\nvaddps ymm1, ymm1, YMMWORD PTR [r8]\r\nvmovups YMMWORD PTR [rcx], ymm1\r\n; 12 : }\r\nret 0\r\n?add@@YA?AUPoint@@U1@0@Z ENDP ; add\r\nFrom the generated ASM, it is clear that function arguments/return value is passed in stack and not in \r\nregisters though the actual computation happens in registers. The move instructions in blue font \r\ndemonstrate this.\r\nASM generated by ICC 14.0 Update 1 (_cdecl calling convention):\r\n>icl.exe /O2 /QxAVX /FAs Elemvector.cpp /EHsc\r\nIntel(R) C++ Intel(R) 64 Compiler XE for applications running on Intel(R) 64, Version 14.0.1.139 Build \r\n20131008\r\nCopyright (C) 1985-2013 Intel Corporation. All rights reserved.\r\nElemvector.cpp\r\nMicrosoft (R) Incremental Linker Version 12.00.21005.1\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n-out:Elemvector.exe\r\nElemvector.obj\r\n.B1.3:: ; Preds .B1.10 .B1.2\r\n;;; c[i] = add(a[i], b[i]);\r\n lea rcx, QWORD PTR [1664+rsp] ;17.20\r\n vmovups xmm0, XMMWORD PTR [48+rsp+rdi] ;17.20",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/4bc559a2-0a5e-4dda-951a-1003ac9e9cb0.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a556b0cf7fb9fc0a7cc96598d411f7f73160d63618e1340ba1979cb7537b9942",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "9c999c85-b7cd-466f-b83a-2b7cae8b302c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": " mov rdx, rsi ;17.20\r\n vmovups xmm1, XMMWORD PTR [32+rsp+rdi] ;17.20\r\n mov r8, rbx ;17.20\r\n vmovups XMMWORD PTR [16+rsi], xmm0 ;17.20\r\n vmovups XMMWORD PTR [rsi], xmm1 ;17.20\r\n vmovups xmm2, XMMWORD PTR [560+rsp+rdi] ;17.20\r\n vmovups xmm3, XMMWORD PTR [544+rsp+rdi] ;17.20\r\n vmovups XMMWORD PTR [16+rbx], xmm2 ;17.20\r\n vmovups XMMWORD PTR [rbx], xmm3 ;17.20\r\n call ?add@@YA?AUPoint@@U1@0@Z ;17.20\r\n.B1.10:: ; Preds .B1.3\r\n vmovups xmm0, XMMWORD PTR [1664+rsp] ;17.20\r\n inc r12b ;16.26\r\n vmovups xmm1, XMMWORD PTR [1680+rsp] ;17.20\r\n vmovups XMMWORD PTR [1056+rsp+rdi], xmm0 ;17.3\r\n vmovups XMMWORD PTR [1072+rsp+rdi], xmm1 ;17.3\r\n add rdi, 32 ;16.26\r\n cmp r12b, 16 ;16.22\r\n jl .B1.3 ; Prob 93% ;16.22\r\n?add@@YA?AUPoint@@U1@0@Z PROC \r\n; parameter 1: [rdx]\r\n; parameter 2: [r8]\r\n.B2.1:: ; Preds .B2.0\r\n mov rax, rcx ;11.10\r\n vmovups xmm0, XMMWORD PTR [rdx] ;9.21\r\n vmovups xmm1, XMMWORD PTR [16+rdx] ;10.21\r\n vaddps xmm3, xmm0, XMMWORD PTR [r8] ;9.10\r\n vaddps xmm2, xmm1, XMMWORD PTR [16+r8] ;10.10\r\n vmovups XMMWORD PTR [16+rcx], xmm2 ;11.10\r\n vmovups XMMWORD PTR [rcx], xmm3 ;11.10\r\n ret ;11.10\r\nEven Intel® C++ Compiler does similar transfer of function arguments (obviously because __cdecl calling \r\nconvention defines this). As shown above XMM0 is mapped to a[i].x, XMM1 is mapped to a[i].y, XMM2\r\nis mapped to b[i].x and XMM3 is mapped to b[i].y. ASM clearly shows that first the values of the array \r\nare fetched from memory to a Intel® XMM register and then before the add() function call, those values \r\nare copied to stack. Inside the function, the values are taken from stack into Intel® XMM register and \r\nafter the computation, the result is pushed back to stack from the register.\r\nASM generated by VS2013 compiler (_vectorcall calling convention):",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/9c999c85-b7cd-466f-b83a-2b7cae8b302c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b324048ddd6b7878e67a49cadfffd25918025a84f853b9aa8f3fac92b86409e7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 456
      },
      {
        "segments": [
          {
            "segment_id": "90b9c987-dcef-461d-b0d9-15347e41e80e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "The only code change is as shown below:\r\nFrom:\r\n__declspec(noinline) Point add(Point p1, Point p2){\r\nPoint p3;\r\np3.x = _mm_add_ps(p1.x, p2.x);\r\np3.y = _mm_add_ps(p1.y, p2.y);\r\nreturn p3;\r\n}\r\nTo\r\n__declspec(noinline) Point _vectorcall add(Point p1, Point p2){\r\nPoint p3;\r\np3.x = _mm_add_ps(p1.x, p2.x);\r\np3.y = _mm_add_ps(p1.y, p2.y);\r\nreturn p3;\r\n}\r\n>cl.exe /O2 /arch:AVX /FAs Elemvector.cpp /EHsc\r\nMicrosoft (R) C/C++ Optimizing Compiler Version 18.00.21005.1 for x64\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\nElemvector.cpp\r\nYou are using an Intel supplied intrinsic header file with a third-party compiler.\r\nMicrosoft (R) Incremental Linker Version 12.00.21005.1\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n/out:Elemvector.exe\r\nElemvector.obj\r\nBelow is the corresponding ASM\r\n$LL6@main:\r\nvmovups xmm2, XMMWORD PTR b$[rsp+rdi]\r\nvmovups xmm3, XMMWORD PTR b$[rsp+rdi+16]\r\nvmovups xmm0, xmm2\r\nvmovups xmm1, xmm3\r\nvzeroupper\r\ncall ?add@@YQ?AUPoint@@U1@0@Z ; add\r\nlea rsi, QWORD PTR [rsi+32]\r\nlea rdi, QWORD PTR [rdi+32]\r\nvmovups XMMWORD PTR $T1[rsp+16], xmm1\r\nvmovups XMMWORD PTR $T1[rsp], xmm0\r\nvmovups ymm0, YMMWORD PTR $T1[rsp]\r\nvmovups YMMWORD PTR [rsi-32], ymm0",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/90b9c987-dcef-461d-b0d9-15347e41e80e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=efebb9334697bf6df273603433c0d4be58504ce603677004c073808fa59dfac4",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "2431b8d3-fe9b-4905-bbfe-75faa0544073",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "dec rbp\r\njne SHORT $LL6@main\r\n?add@@YQ?AUPoint@@U1@0@Z PROC ; add, COMDAT\r\nsub rsp, 24\r\nvmovaps XMMWORD PTR [rsp], xmm6\r\nvmovaps xmm6, XMMWORD PTR [rsp]\r\nvaddps xmm0, xmm0, xmm2\r\nvaddps xmm1, xmm1, xmm3\r\nadd rsp, 24\r\nret 0\r\nUnlike the first case, the values of the array are passed in Intel® XMM registers this time rather through \r\nthe stack. \r\nIntel® C++ Compiler 14.0 Update 1 doesn’t support _vectorcall calling convention. Instead you can \r\nrequest the compiler to use as many as registers as possible during function call by specifying _regcall \r\ncalling convention. Below is the demonstration of the same. The only code change is as follows:\r\nFrom:\r\n__declspec(noinline) Point _vectorcall add(Point p1, Point p2){\r\nPoint p3;\r\np3.x = _mm_add_ps(p1.x, p2.x);\r\np3.y = _mm_add_ps(p1.y, p2.y);\r\nreturn p3;\r\n}\r\nTo:\r\n__declspec(noinline) Point __regcall add(Point p1, Point p2){\r\nPoint p3;\r\np3.x = _mm_add_ps(p1.x, p2.x);\r\np3.y = _mm_add_ps(p1.y, p2.y);\r\nreturn p3;\r\n}\r\nASM generated by ICL 14.0 Update 1 Compiler (__regcall calling convention):\r\n>icl.exe /O2 /QxAVX /FAs Elemvector.cpp /EHsc /Qregcall\r\nIntel(R) C++ Intel(R) 64 Compiler XE for applications running on Intel(R) 64, Version 14.0.1.139 Build \r\n20131008\r\nCopyright (C) 1985-2013 Intel Corporation. All rights reserved.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/2431b8d3-fe9b-4905-bbfe-75faa0544073.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5eeb9416eacba8e5ad65e548bf39feabfecbe7230dfedaa6c54ac6ad2b1ba76f",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "e554a1ec-f834-45a7-bd68-94f1102485b4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Elemvector.cpp\r\nMicrosoft (R) Incremental Linker Version 12.00.21005.1\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n-out:Elemvector.exe\r\nElemvector.obj\r\n.B1.3:: ; Preds .B1.10 .B1.2\r\n vmovdqu xmm0, XMMWORD PTR [64+rsp+rbp] ;17.20\r\n vmovdqu xmm1, XMMWORD PTR [80+rsp+rbp] ;17.20\r\n vmovdqu xmm2, XMMWORD PTR [576+rsp+rbp] ;17.20\r\n vmovdqu xmm3, XMMWORD PTR [592+rsp+rbp] ;17.20\r\n call ?__regcall2__add@@YE?AUPoint@@U1@0@Z ;17.20\r\n.B1.10:: ; Preds .B1.3\r\n inc r15b ;16.26\r\n vmovups XMMWORD PTR [1088+rsp+rbp], xmm0 ;17.3\r\n vmovups XMMWORD PTR [1104+rsp+rbp], xmm1 ;17.3\r\n add rbp, 32 ;16.26\r\n cmp r15b, 16 ;16.22\r\n jl .B1.3 ; Prob 93% ;16.22\r\n?__regcall2__add@@YE?AUPoint@@U1@0@Z PROC \r\n; parameter 1: xmm0 xmm1\r\n; parameter 2: xmm2 xmm3\r\n.B2.1:: ; Preds .B2.0\r\n vaddps xmm0, xmm2, xmm0 ;9.10\r\n vaddps xmm1, xmm3, xmm1 ;10.10\r\n ret \r\nBy using __regcall calling convention, the function arguments and return value are passed using Intel® \r\nXMM registers rather than through stack. _vectorcall calling convention will introduced in a future \r\nversion of the Intel® C++ Compiler.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/8f7d455e-5d32-495a-a5d1-7a208a414d06/images/e554a1ec-f834-45a7-bd68-94f1102485b4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041454Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=3c52c37182c5dfd1942773085a0d1e99bbf7c33d97262e28f16d712f7467beea",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 488
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "_vectorcall and __regcall Demystified\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "author: Intel Corporation\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "```json\n{\n  \"date_published\": null\n}\n```"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "Several locations are mentioned in the provided assembly code snippets.  These include registers like `rdx`, `rsi`, `r8`, `rbx`, `rcx`, `rax`, `xmm0`, `xmm1`, `xmm2`, `xmm3`, stack offsets like `[32+rsp+rdi]`, `[16+rsi]`, `[560+rsp+rdi]`, `[1664+rsp]`, `[1056+rsp+rdi]`, and symbolic memory references like `b$[rsp+rdi]`, `$T1[rsp+16]`. Also, the code discusses passing arguments via the stack and registers.\n"
        }
      ]
    }
  }
}