{
  "file_name": "MARX - Uncovering Class Hierarchies in C++ Programs - (NDSS 2017).pdf",
  "task_id": "e0edbb48-7741-4158-90db-348d799f97dd",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "fb785734-4cd5-4bf2-a82a-cad7b74a3325",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "MARX: Uncovering Class Hierarchies\r\nin C++ Programs\r\nAndre Pawlowski∗, Moritz Contag∗, Victor van der Veen†, Chris Ouwehand†,\r\nThorsten Holz∗, Herbert Bos†, Elias Athanasopoulos‡, and Cristiano Giuffrida†\r\n∗ Horst Gortz Institut for IT-Security (HGI) ¨\r\nRuhr-Universitat Bochum, Germany ¨\r\n{andre.pawlowski, moritz.contag, thorsten.holz}@rub.de\r\n† Computer Science Institute\r\nVrije Universiteit Amsterdam,\r\n{vvdveen, herbertb, giuffrida}@cs.vu.nl,\r\n{chris.ouwehand}@vu.nl\r\n‡ Computer Science Department\r\nUniversity of Cyprus, Cyprus\r\neliasathan@cs.ucy.ac.cy\r\nAbstract—Reverse engineering of binary executables is a\r\ndifficult task which gets more involved by the way compilers\r\ntranslate high-level concepts used in paradigms such as object\u0002oriented programming into native code, as it is the case for C++.\r\nSuch code is harder to grasp than, e. g., traditional procedural\r\ncode, since it is generally more verbose and adds complexity\r\nthrough features such as polymorphism or inheritance. Hence, a\r\ndeep understanding of interactions between instantiated objects,\r\ntheir corresponding classes, and the connection between classes\r\nwould vastly reduce the time it takes an analyst to understand\r\nthe application. The growth in complexity in contemporary C++\r\napplications only amplifies the effect.\r\nIn this paper, we introduce Marx, an analysis framework\r\nto reconstruct class hierarchies of C++ programs and resolve\r\nvirtual callsites. We have evaluated the results on a diverse set\r\nof large, real-world applications. Our experimental results show\r\nthat our approach achieves a high precision (93.2% of the hier\u0002archies reconstructed accurately for Node.js, 88.4% for MySQL\r\nServer) while keeping analysis times practical. Furthermore, we\r\nshow that, despite any imprecision in the analysis, the derived\r\ninformation can be reliably used in classic software security\r\nhardening applications without breaking programs. We showcase\r\nthis property for two applications built on top of the output of\r\nour framework: vtable protection and type-safe object reuse. This\r\ndemonstrates that, in addition to traditional reverse engineering\r\napplications, Marx can aid in implementing concrete, valuable\r\ntools e. g., in the domain of exploit mitigations.\r\nI. INTRODUCTION\r\nSoftware exploitation has significantly increased in com\u0002plexity and sophistication in recent years. Despite many at\u0002tempts to harden applications, exploitation of vulnerabilities\r\nis still possible, especially for large and complex C/C++\r\nprograms, where attackers can leverage a rich environment of\r\ndynamically computed jumps. The targets of these branches\r\nare resolved only at runtime, and therefore they can be influ\u0002enced for introducing new malicious control flows by taking\r\nadvantage of software vulnerabilities. In contrast to C, C++, the\r\nchoice for implementing a huge industrial software base [25],\r\ncontains an additional source of indirect branches. While C\r\nprograms need to resolve the target of a branch when, say, a\r\nfunction returns or a function pointer is used, C++ programs\r\nalso need to support dynamic dispatching of virtual calls.\r\nSince virtual objects support several methods from different\r\nclasses in their hierarchy, most compilers implement dynamic\r\ndispatching of virtual calls using indirect branches. In practice,\r\nC++ programs are thus full of indirect calls, and most of these\r\ncan be influenced not just by overflow-type vulnerabilities, but\r\nalso by temporal bugs (i. e., use-after-free vulnerabilities).\r\nThis plethora of indirect calls makes analyzing C++ bina\u0002ries very important, since many exploits target exclusively C++\r\nprograms, but also significantly hard. For instance, according\r\nto a recent study [29], most libraries linked to Firefox contain\r\nalmost 7% of indirect calls over direct calls and about 40% of\r\nthem are virtual calls. Such indirect control-flow transfers rank\r\namong the greatest challenges for even the most basic analysis\r\nsteps, such as the recovery of the control flow graph (CFG) [9],\r\n[24]. Resolving the targets of indirect calls and jumps in\r\na binary is difficult. At the binary level, we have no way\r\nto directly learn class hierarchy information in the program.\r\nWhile we know that every virtual function call indexes a\r\nvirtual function table (so called vtable), we neither know the\r\nvtables’ exact locations, nor their relationships to each other.\r\nReverse engineering such code from a given binary executable\r\nis therefore a very challenging task in practice.\r\nAlbeit challenging, vtable reconstruction directly from\r\nbinaries can be useful in several domains. First, the class\r\nhierarchy helps the analysis of C++ legacy or closed code.\r\nSecond, since vtables are commonly abused by exploits, secu\u0002rity analysts can explore incidents affecting C++ applications\r\nwhen source code is not available. Finally, many defenses\r\nthat harden C++ binaries can leverage the class hierarchy\r\ninformation for delivering sound protection of programs in the\r\nabsence of source code. Current state-of-the-art binary-only\r\nprotection approaches use weaker characteristics typical for\r\nC++ applications to protect virtual callsites, such as allowing\r\nall existing classes at a virtual callsite [21], or enforcing that\r\nthe pointer to the vtable resides in read-only memory [13].\r\nThis stems from a lack of precision and scalability of current\r\nclass hierarchy reconstruction approaches [12], [17], [18].\r\nPermission to freely reproduce all or part of this paper for noncommercial\r\npurposes is granted provided that copies bear this notice and the full citation\r\non the first page. Reproduction for commercial purposes is strictly prohibited\r\nwithout the prior written consent of the Internet Society, the first-named author\r\n(for reproduction of an entire paper only), and the author’s employer if the\r\npaper was prepared within the scope of employment.\r\nNDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA\r\nCopyright 2017 Internet Society, ISBN 1-1891562-46-0\r\nhttp://dx.doi.org/10.14722/ndss.2017.23096",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/fb785734-4cd5-4bf2-a82a-cad7b74a3325.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e07ba047559a3a4304253fa0dd4b6b6c3267fffdc09a9b8f59f700392ecfd897",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 859
      },
      {
        "segments": [
          {
            "segment_id": "fb785734-4cd5-4bf2-a82a-cad7b74a3325",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "MARX: Uncovering Class Hierarchies\r\nin C++ Programs\r\nAndre Pawlowski∗, Moritz Contag∗, Victor van der Veen†, Chris Ouwehand†,\r\nThorsten Holz∗, Herbert Bos†, Elias Athanasopoulos‡, and Cristiano Giuffrida†\r\n∗ Horst Gortz Institut for IT-Security (HGI) ¨\r\nRuhr-Universitat Bochum, Germany ¨\r\n{andre.pawlowski, moritz.contag, thorsten.holz}@rub.de\r\n† Computer Science Institute\r\nVrije Universiteit Amsterdam,\r\n{vvdveen, herbertb, giuffrida}@cs.vu.nl,\r\n{chris.ouwehand}@vu.nl\r\n‡ Computer Science Department\r\nUniversity of Cyprus, Cyprus\r\neliasathan@cs.ucy.ac.cy\r\nAbstract—Reverse engineering of binary executables is a\r\ndifficult task which gets more involved by the way compilers\r\ntranslate high-level concepts used in paradigms such as object\u0002oriented programming into native code, as it is the case for C++.\r\nSuch code is harder to grasp than, e. g., traditional procedural\r\ncode, since it is generally more verbose and adds complexity\r\nthrough features such as polymorphism or inheritance. Hence, a\r\ndeep understanding of interactions between instantiated objects,\r\ntheir corresponding classes, and the connection between classes\r\nwould vastly reduce the time it takes an analyst to understand\r\nthe application. The growth in complexity in contemporary C++\r\napplications only amplifies the effect.\r\nIn this paper, we introduce Marx, an analysis framework\r\nto reconstruct class hierarchies of C++ programs and resolve\r\nvirtual callsites. We have evaluated the results on a diverse set\r\nof large, real-world applications. Our experimental results show\r\nthat our approach achieves a high precision (93.2% of the hier\u0002archies reconstructed accurately for Node.js, 88.4% for MySQL\r\nServer) while keeping analysis times practical. Furthermore, we\r\nshow that, despite any imprecision in the analysis, the derived\r\ninformation can be reliably used in classic software security\r\nhardening applications without breaking programs. We showcase\r\nthis property for two applications built on top of the output of\r\nour framework: vtable protection and type-safe object reuse. This\r\ndemonstrates that, in addition to traditional reverse engineering\r\napplications, Marx can aid in implementing concrete, valuable\r\ntools e. g., in the domain of exploit mitigations.\r\nI. INTRODUCTION\r\nSoftware exploitation has significantly increased in com\u0002plexity and sophistication in recent years. Despite many at\u0002tempts to harden applications, exploitation of vulnerabilities\r\nis still possible, especially for large and complex C/C++\r\nprograms, where attackers can leverage a rich environment of\r\ndynamically computed jumps. The targets of these branches\r\nare resolved only at runtime, and therefore they can be influ\u0002enced for introducing new malicious control flows by taking\r\nadvantage of software vulnerabilities. In contrast to C, C++, the\r\nchoice for implementing a huge industrial software base [25],\r\ncontains an additional source of indirect branches. While C\r\nprograms need to resolve the target of a branch when, say, a\r\nfunction returns or a function pointer is used, C++ programs\r\nalso need to support dynamic dispatching of virtual calls.\r\nSince virtual objects support several methods from different\r\nclasses in their hierarchy, most compilers implement dynamic\r\ndispatching of virtual calls using indirect branches. In practice,\r\nC++ programs are thus full of indirect calls, and most of these\r\ncan be influenced not just by overflow-type vulnerabilities, but\r\nalso by temporal bugs (i. e., use-after-free vulnerabilities).\r\nThis plethora of indirect calls makes analyzing C++ bina\u0002ries very important, since many exploits target exclusively C++\r\nprograms, but also significantly hard. For instance, according\r\nto a recent study [29], most libraries linked to Firefox contain\r\nalmost 7% of indirect calls over direct calls and about 40% of\r\nthem are virtual calls. Such indirect control-flow transfers rank\r\namong the greatest challenges for even the most basic analysis\r\nsteps, such as the recovery of the control flow graph (CFG) [9],\r\n[24]. Resolving the targets of indirect calls and jumps in\r\na binary is difficult. At the binary level, we have no way\r\nto directly learn class hierarchy information in the program.\r\nWhile we know that every virtual function call indexes a\r\nvirtual function table (so called vtable), we neither know the\r\nvtables’ exact locations, nor their relationships to each other.\r\nReverse engineering such code from a given binary executable\r\nis therefore a very challenging task in practice.\r\nAlbeit challenging, vtable reconstruction directly from\r\nbinaries can be useful in several domains. First, the class\r\nhierarchy helps the analysis of C++ legacy or closed code.\r\nSecond, since vtables are commonly abused by exploits, secu\u0002rity analysts can explore incidents affecting C++ applications\r\nwhen source code is not available. Finally, many defenses\r\nthat harden C++ binaries can leverage the class hierarchy\r\ninformation for delivering sound protection of programs in the\r\nabsence of source code. Current state-of-the-art binary-only\r\nprotection approaches use weaker characteristics typical for\r\nC++ applications to protect virtual callsites, such as allowing\r\nall existing classes at a virtual callsite [21], or enforcing that\r\nthe pointer to the vtable resides in read-only memory [13].\r\nThis stems from a lack of precision and scalability of current\r\nclass hierarchy reconstruction approaches [12], [17], [18].\r\nPermission to freely reproduce all or part of this paper for noncommercial\r\npurposes is granted provided that copies bear this notice and the full citation\r\non the first page. Reproduction for commercial purposes is strictly prohibited\r\nwithout the prior written consent of the Internet Society, the first-named author\r\n(for reproduction of an entire paper only), and the author’s employer if the\r\npaper was prepared within the scope of employment.\r\nNDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA\r\nCopyright 2017 Internet Society, ISBN 1-1891562-46-0\r\nhttp://dx.doi.org/10.14722/ndss.2017.23096",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/fb785734-4cd5-4bf2-a82a-cad7b74a3325.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e07ba047559a3a4304253fa0dd4b6b6c3267fffdc09a9b8f59f700392ecfd897",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 859
      },
      {
        "segments": [
          {
            "segment_id": "0bf15c54-1e08-4370-8f87-930aeb4c2602",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "This means that, if we can successfully recover the class hi\u0002erarchy from a binary, we can improve state-of-the-art binary\u0002level defenses that can benefit from such information. For in\u0002stance, we can ensure that virtual function calls conform to the\r\nclass hierarchy, and therefore provide strong guarantees against\r\nattempts to hijack the control flow of the program (so called\r\nvtable hijacking attacks). Another example is to ensure that\r\nobjects of different type classes are allocated from different\r\nmemory pools to prevent the reuse of memory in a type-unsafe\r\nmanner—a common source of use-after-free exploits. For both\r\nthese example applications, extracting the class hierarchy of\r\nthe binary program is important. Notice that this is only a\r\nset of mitigations that rely on C++ semantics, although an\r\nimportant one given that prior work argued that C++ binary\u0002level defenses have trouble stopping control-flow hijacking\r\nattacks due to the lack of class hierarchy information [23].\r\nIn this paper, we consider the problem of reconstructing\r\nclass relations directly from binaries. Our approach does not\r\nrely on embedded RTTI information (metadata emitted by\r\nthe compiler for resolving class information at runtime, often\r\nstripped), does not rely on particular compiler flags, and works\r\non industrial software. Since reconstructing class relations\r\nis a hard problem by itself and information concerning the\r\ndirection of the relation is not available in binaries, we only\r\nfocus on reconstructing class hierarchies as a set and ignore\r\nthe direction of inheritance. Our system, Marx, can accurately\r\nreconstruct 93.2% of the hierarchies for Node.js and 88.4% of\r\nthe hierarchies for MySQL Server. Overall, we have success\u0002fully applied Marx to more than 80 MiB of binary code to\r\ndemonstrate the practicality of our implementation.\r\nMarx is a valuable framework for the reverse engineering\r\ncommunity, however, as we have already mentioned, secu\u0002rity applications can leverage class relations for protecting\r\nbinaries. The information provided by the analysis allows us\r\nto implement stronger binary-level defenses using type-based\r\ninvariants. To showcase the practicality of Marx, we develop\r\ntwo binary-level defenses on top of it. The first application is\r\na vtable protection system to prevent virtual calls to methods\r\nthat do not belong to the class hierarchy and mitigate vtable\r\nhijacking attacks. The second application is a custom heap\r\nallocator to support type-safe object reuse, by placing newly\r\nallocated objects in memory pools based on their type.\r\nBoth security applications use the class hierarchy recovered\r\nfrom a binary. We demonstrate that, even when the extracted\r\nclass hierarchy is imperfect, our defenses can improve security\r\nat reasonable performance and without breaking programs. To\r\ncompensate for the imprecision of the analysis, our vtable\r\nprotection solution treats invariant violations as anomalies and\r\ntriggers more heavyweight checks on a slow path (trading\r\noff on performance). Our type-safe object reuse solution, in\r\nturn, can gracefully tolerate type-to-pool mapping mismatches\r\n(trading off on security). In short, we show that it is possible\r\nto build fully conservative binary-level defense solutions on\r\ntop of imprecise information, exposing new interesting and\r\npreviously unexplored tradeoffs.\r\nContributions. In summary, the contributions of this paper\r\nare as follows:\r\n1) We design and implement Marx, a framework for\r\nreconstructing class hierarchies directly from binary\r\nexecutables that do not embed RTTI information,\r\nand are produced with arbitrary compiler flags. Marx\r\nis freely available at https://github.com/RUB-SysSec/\r\nMarx.\r\n2) We evaluate Marx with more than 80 MiB of binary\r\ncode and we show that vtables can be reconstructed\r\nfrom binaries with high precision. As an example,\r\nMarx can accurately reconstruct 93.2% of the hier\u0002archies for Node.js and 88.4% of the hierarchies for\r\nMySQL Server.\r\n3) We develop two security applications for binaries\r\nbased on class hierarchies exported by Marx: vtable\r\nprotection and type-safe object reuse. Our applica\u0002tions show it is possible to tolerate imprecise in\u0002formation when building sound binary-level defense\r\nsolutions by trading off on performance and security.\r\nII. TECHNICAL BACKGROUND\r\nGiven that Marx is applied to C++ binaries for extracting\r\nthe class hierarchy, some basic knowledge of C++ internals\r\nis required for understanding the mechanics of our analysis.\r\nTherefore, we discuss in this section some fundamental C++\r\nconcepts and how they are implemented in modern compilers.\r\nA. Object-oriented Programming\r\nC++ is an object-oriented programming (OOP) language\r\nwhich compiles to native code. In OOP, classes are data types\r\nused to instantiate concrete objects. On the latter, one can\r\ncall functions (also called member functions or methods) as\r\ndefined by the class an object was instantiated from. Apart\r\nfrom functions, classes can also define attributes and hence\r\ncouple code (via functions) and data (via attributes) together.\r\nOOP allows classes to inherit functions and attributes from\r\nother classes. This defines a relation. The class providing\r\nfunctions and attributes to another class is commonly called\r\nthe base class in that relation, whereas the class inheriting\r\nthese is called the derived class. This concept leads to what is\r\ncalled a class hierarchy: Every class is related to either zero or\r\nmultiple bases as well as zero or multiple derived classes. Class\r\nhierarchies can be depicted as a directed graph in which the\r\ninheritance relation is given by the direction (base or derived\r\nclass). If a class inherits from multiple base classes, this is\r\nreferred to as multiple inheritance; otherwise, it is called single\r\ninheritance.\r\nClasses may add several modifiers to their functions. One\r\nof the most important throughout this paper is the virtual\r\nmodifier. If this modifier is used on a function, a derived\r\nclass is free to override said function and provide its own\r\nimplementation. This concept is called polymorphism, where\r\na single function invocation may behave differently, depending\r\non the context in which it is called. More concretely, the\r\nprogrammer can call a virtual function on either an object\r\nof the base or any derived classes. Depending on the type\r\nof the object, the appropriate implementation of the function\r\nis called. This, in turn, allows programmers to work on the\r\nmost general class and vastly simplify their code. In cases\r\nwhere the compiler cannot determine statically on which object\r\nthe function is to be invoked, the selection of the appropriate\r\nimplementation is made at runtime. Furthermore, abstract\r\n2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/0bf15c54-1e08-4370-8f87-930aeb4c2602.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bc3a4cb219d8f7948370c9f2aa57d8b0688b6a35f0068f0cb48edb03c5064d46",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1008
      },
      {
        "segments": [
          {
            "segment_id": "0bf15c54-1e08-4370-8f87-930aeb4c2602",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "This means that, if we can successfully recover the class hi\u0002erarchy from a binary, we can improve state-of-the-art binary\u0002level defenses that can benefit from such information. For in\u0002stance, we can ensure that virtual function calls conform to the\r\nclass hierarchy, and therefore provide strong guarantees against\r\nattempts to hijack the control flow of the program (so called\r\nvtable hijacking attacks). Another example is to ensure that\r\nobjects of different type classes are allocated from different\r\nmemory pools to prevent the reuse of memory in a type-unsafe\r\nmanner—a common source of use-after-free exploits. For both\r\nthese example applications, extracting the class hierarchy of\r\nthe binary program is important. Notice that this is only a\r\nset of mitigations that rely on C++ semantics, although an\r\nimportant one given that prior work argued that C++ binary\u0002level defenses have trouble stopping control-flow hijacking\r\nattacks due to the lack of class hierarchy information [23].\r\nIn this paper, we consider the problem of reconstructing\r\nclass relations directly from binaries. Our approach does not\r\nrely on embedded RTTI information (metadata emitted by\r\nthe compiler for resolving class information at runtime, often\r\nstripped), does not rely on particular compiler flags, and works\r\non industrial software. Since reconstructing class relations\r\nis a hard problem by itself and information concerning the\r\ndirection of the relation is not available in binaries, we only\r\nfocus on reconstructing class hierarchies as a set and ignore\r\nthe direction of inheritance. Our system, Marx, can accurately\r\nreconstruct 93.2% of the hierarchies for Node.js and 88.4% of\r\nthe hierarchies for MySQL Server. Overall, we have success\u0002fully applied Marx to more than 80 MiB of binary code to\r\ndemonstrate the practicality of our implementation.\r\nMarx is a valuable framework for the reverse engineering\r\ncommunity, however, as we have already mentioned, secu\u0002rity applications can leverage class relations for protecting\r\nbinaries. The information provided by the analysis allows us\r\nto implement stronger binary-level defenses using type-based\r\ninvariants. To showcase the practicality of Marx, we develop\r\ntwo binary-level defenses on top of it. The first application is\r\na vtable protection system to prevent virtual calls to methods\r\nthat do not belong to the class hierarchy and mitigate vtable\r\nhijacking attacks. The second application is a custom heap\r\nallocator to support type-safe object reuse, by placing newly\r\nallocated objects in memory pools based on their type.\r\nBoth security applications use the class hierarchy recovered\r\nfrom a binary. We demonstrate that, even when the extracted\r\nclass hierarchy is imperfect, our defenses can improve security\r\nat reasonable performance and without breaking programs. To\r\ncompensate for the imprecision of the analysis, our vtable\r\nprotection solution treats invariant violations as anomalies and\r\ntriggers more heavyweight checks on a slow path (trading\r\noff on performance). Our type-safe object reuse solution, in\r\nturn, can gracefully tolerate type-to-pool mapping mismatches\r\n(trading off on security). In short, we show that it is possible\r\nto build fully conservative binary-level defense solutions on\r\ntop of imprecise information, exposing new interesting and\r\npreviously unexplored tradeoffs.\r\nContributions. In summary, the contributions of this paper\r\nare as follows:\r\n1) We design and implement Marx, a framework for\r\nreconstructing class hierarchies directly from binary\r\nexecutables that do not embed RTTI information,\r\nand are produced with arbitrary compiler flags. Marx\r\nis freely available at https://github.com/RUB-SysSec/\r\nMarx.\r\n2) We evaluate Marx with more than 80 MiB of binary\r\ncode and we show that vtables can be reconstructed\r\nfrom binaries with high precision. As an example,\r\nMarx can accurately reconstruct 93.2% of the hier\u0002archies for Node.js and 88.4% of the hierarchies for\r\nMySQL Server.\r\n3) We develop two security applications for binaries\r\nbased on class hierarchies exported by Marx: vtable\r\nprotection and type-safe object reuse. Our applica\u0002tions show it is possible to tolerate imprecise in\u0002formation when building sound binary-level defense\r\nsolutions by trading off on performance and security.\r\nII. TECHNICAL BACKGROUND\r\nGiven that Marx is applied to C++ binaries for extracting\r\nthe class hierarchy, some basic knowledge of C++ internals\r\nis required for understanding the mechanics of our analysis.\r\nTherefore, we discuss in this section some fundamental C++\r\nconcepts and how they are implemented in modern compilers.\r\nA. Object-oriented Programming\r\nC++ is an object-oriented programming (OOP) language\r\nwhich compiles to native code. In OOP, classes are data types\r\nused to instantiate concrete objects. On the latter, one can\r\ncall functions (also called member functions or methods) as\r\ndefined by the class an object was instantiated from. Apart\r\nfrom functions, classes can also define attributes and hence\r\ncouple code (via functions) and data (via attributes) together.\r\nOOP allows classes to inherit functions and attributes from\r\nother classes. This defines a relation. The class providing\r\nfunctions and attributes to another class is commonly called\r\nthe base class in that relation, whereas the class inheriting\r\nthese is called the derived class. This concept leads to what is\r\ncalled a class hierarchy: Every class is related to either zero or\r\nmultiple bases as well as zero or multiple derived classes. Class\r\nhierarchies can be depicted as a directed graph in which the\r\ninheritance relation is given by the direction (base or derived\r\nclass). If a class inherits from multiple base classes, this is\r\nreferred to as multiple inheritance; otherwise, it is called single\r\ninheritance.\r\nClasses may add several modifiers to their functions. One\r\nof the most important throughout this paper is the virtual\r\nmodifier. If this modifier is used on a function, a derived\r\nclass is free to override said function and provide its own\r\nimplementation. This concept is called polymorphism, where\r\na single function invocation may behave differently, depending\r\non the context in which it is called. More concretely, the\r\nprogrammer can call a virtual function on either an object\r\nof the base or any derived classes. Depending on the type\r\nof the object, the appropriate implementation of the function\r\nis called. This, in turn, allows programmers to work on the\r\nmost general class and vastly simplify their code. In cases\r\nwhere the compiler cannot determine statically on which object\r\nthe function is to be invoked, the selection of the appropriate\r\nimplementation is made at runtime. Furthermore, abstract\r\n2",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/0bf15c54-1e08-4370-8f87-930aeb4c2602.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=bc3a4cb219d8f7948370c9f2aa57d8b0688b6a35f0068f0cb48edb03c5064d46",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1008
      },
      {
        "segments": [
          {
            "segment_id": "f798d259-e43a-42c7-901f-5fed288e412b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Fig. 1. Example hierarchy layout shown at a high-level in a) and b) shows its layout in native code. Class C inherits attributes and functions of both class A\r\nand B. Further, class C overrides funcA2 and funcB1 and provides its own implementation, C::funcA2 and C::funcB1.\r\nbase classes represent an edge case: They provide several\r\nvirtual functions, but no implementation on their own (pure\r\nvirtual functions). This forces the deriving class to implement\r\nfunctions conforming to the declaration the base class provides.\r\nFigure 1 a) depicts an exemplary relation of three classes\r\nA, B, and C. Class C inherits the functions from classes A\r\nand B, i. e., one may call the functions funcA1, funcA2,\r\nfuncB1, funcB2 on an object of class C, in addition to\r\nthe functions class C provides itself. The same is true for the\r\nattributes; hence, class C allocates space for attributes varA,\r\nvarB, and varC. Further, C overrides funcA2 and funcB1,\r\ni. e., it specifies a more fitting implementation for its class.\r\nIn order to create an object of a specific class, the operator\r\nnew can be used, amongst others. It allocates space for the\r\nobject (whose size is mostly determined by its attributes) and\r\ncalls a designated initialization function that initializes the\r\nobject’s attributes with meaningful values. This function is\r\ncalled a constructor. Similarly, a destructor releases further\r\nresources the constructor requested previously, and is usually\r\ninvoked through the operator delete.\r\nIn the following, we explain how the aforementioned\r\nconcepts are implemented on the binary level.\r\nB. Virtual Function Tables\r\nOn the binary level, polymorphism is implemented with\r\nthe help of what is called a virtual function table (vtable for\r\nshort). It contains the addresses of all virtual functions a class\r\nprovides. Each object of such a class contains a pointer to the\r\ncorresponding vtable. In the following, we refer to this pointer\r\nas vtblptr.\r\nIn the Itanium C++ ABI [3], two metadata fields in the\r\nvtable are specified: Runtime Type Identification (RTTI) and\r\nOffset-to-Top. The RTTI field holds a pointer to a data structure\r\nin which metadata about the class resides, i. e., the name of\r\nthe class and its base classes. Even though this information\r\nis useful for type reconstruction, it may not be available\r\nin compiled binaries. It only has to be included if, e. g.,\r\ndynamic_cast or type_info is used, which requires\r\nprecise type information at runtime. The Offset-to-Top field\r\nholds an offset that is required when implementing multiple\r\ninheritance. To this end, it is used to adjust an object pointer,\r\nas discussed in a later section.\r\nC. Virtual Function Dispatch\r\nAs opposed to regular functions (which are implemented\r\nusing direct calls), virtual function calls require a specific type\r\nof callsite (virtual callsite, or vcall). They handle the selection\r\nof the proper virtual function depending on the object on which\r\nthe function is invoked using the object’s vtable.\r\nConsider a virtual callsite invoking funcA2 on an object\r\nof either class A or C. Independent of the class the object\r\nat the callsite is instantiated from, in this case, one merely\r\nhas to call whatever function is referenced at offset 0x08 in\r\nthe object’s vtable. As seen in Figure 1 b), this offset either\r\npoints to A::funcA2 or C::funcA2 and always calls the\r\ncorrect implementation for the given object. Note that this\r\noffset has to be the same across all related vtables. In this case,\r\nthis constraint applies for vtable A and C, as classes A and\r\nC are the only candidates when invoking function funcA2.\r\nThis mechanism effectively implements polymorphism at the\r\nbinary level. In the following, we will refer to the pointer to\r\nthe current object as thisptr.\r\nThe compiler emits code that directly implements this\r\nmechanism. At each vcall, the thisptr to the object is also set as\r\nan implicit argument (meaning the argument is not specifically\r\nset in the source code). Depending on the calling convention,\r\nthe thisptr is either stored in a specific register or on the stack.\r\nIn the Itanium C++ ABI on x86-64, a vcall always has the\r\nfollowing structure:\r\nmov RDI, thisptr\r\ncall [vtblptr + x]\r\nThe thisptr is stored in the RDI register as the first\r\nargument and the vtblptr is used to select the correct virtual\r\ntable. The value x denotes the offset into the selected vtable\r\nin order to branch to the correct function. Note that it may be\r\nzero or omitted if the first function of the vtable is targeted.\r\nD. Multiple Inheritance\r\nIn addition to single inheritance, C++ supports multiple\r\ninheritance. This allows a class to have multiple base classes\r\nfrom which it inherits functions and attributes. In the example\r\ngiven in Figure 1, class C uses multiple inheritance and derives\r\nfrom class A and B.\r\nConsidering the way virtual calls are dispatched, it becomes\r\napparent that vtables are inherited as well. Given that the\r\n3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/f798d259-e43a-42c7-901f-5fed288e412b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ed847e8b98ade41c7ee8e6a35f52cecfcb87e577e1b924225d666feed4c74cc9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 808
      },
      {
        "segments": [
          {
            "segment_id": "f798d259-e43a-42c7-901f-5fed288e412b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "Fig. 1. Example hierarchy layout shown at a high-level in a) and b) shows its layout in native code. Class C inherits attributes and functions of both class A\r\nand B. Further, class C overrides funcA2 and funcB1 and provides its own implementation, C::funcA2 and C::funcB1.\r\nbase classes represent an edge case: They provide several\r\nvirtual functions, but no implementation on their own (pure\r\nvirtual functions). This forces the deriving class to implement\r\nfunctions conforming to the declaration the base class provides.\r\nFigure 1 a) depicts an exemplary relation of three classes\r\nA, B, and C. Class C inherits the functions from classes A\r\nand B, i. e., one may call the functions funcA1, funcA2,\r\nfuncB1, funcB2 on an object of class C, in addition to\r\nthe functions class C provides itself. The same is true for the\r\nattributes; hence, class C allocates space for attributes varA,\r\nvarB, and varC. Further, C overrides funcA2 and funcB1,\r\ni. e., it specifies a more fitting implementation for its class.\r\nIn order to create an object of a specific class, the operator\r\nnew can be used, amongst others. It allocates space for the\r\nobject (whose size is mostly determined by its attributes) and\r\ncalls a designated initialization function that initializes the\r\nobject’s attributes with meaningful values. This function is\r\ncalled a constructor. Similarly, a destructor releases further\r\nresources the constructor requested previously, and is usually\r\ninvoked through the operator delete.\r\nIn the following, we explain how the aforementioned\r\nconcepts are implemented on the binary level.\r\nB. Virtual Function Tables\r\nOn the binary level, polymorphism is implemented with\r\nthe help of what is called a virtual function table (vtable for\r\nshort). It contains the addresses of all virtual functions a class\r\nprovides. Each object of such a class contains a pointer to the\r\ncorresponding vtable. In the following, we refer to this pointer\r\nas vtblptr.\r\nIn the Itanium C++ ABI [3], two metadata fields in the\r\nvtable are specified: Runtime Type Identification (RTTI) and\r\nOffset-to-Top. The RTTI field holds a pointer to a data structure\r\nin which metadata about the class resides, i. e., the name of\r\nthe class and its base classes. Even though this information\r\nis useful for type reconstruction, it may not be available\r\nin compiled binaries. It only has to be included if, e. g.,\r\ndynamic_cast or type_info is used, which requires\r\nprecise type information at runtime. The Offset-to-Top field\r\nholds an offset that is required when implementing multiple\r\ninheritance. To this end, it is used to adjust an object pointer,\r\nas discussed in a later section.\r\nC. Virtual Function Dispatch\r\nAs opposed to regular functions (which are implemented\r\nusing direct calls), virtual function calls require a specific type\r\nof callsite (virtual callsite, or vcall). They handle the selection\r\nof the proper virtual function depending on the object on which\r\nthe function is invoked using the object’s vtable.\r\nConsider a virtual callsite invoking funcA2 on an object\r\nof either class A or C. Independent of the class the object\r\nat the callsite is instantiated from, in this case, one merely\r\nhas to call whatever function is referenced at offset 0x08 in\r\nthe object’s vtable. As seen in Figure 1 b), this offset either\r\npoints to A::funcA2 or C::funcA2 and always calls the\r\ncorrect implementation for the given object. Note that this\r\noffset has to be the same across all related vtables. In this case,\r\nthis constraint applies for vtable A and C, as classes A and\r\nC are the only candidates when invoking function funcA2.\r\nThis mechanism effectively implements polymorphism at the\r\nbinary level. In the following, we will refer to the pointer to\r\nthe current object as thisptr.\r\nThe compiler emits code that directly implements this\r\nmechanism. At each vcall, the thisptr to the object is also set as\r\nan implicit argument (meaning the argument is not specifically\r\nset in the source code). Depending on the calling convention,\r\nthe thisptr is either stored in a specific register or on the stack.\r\nIn the Itanium C++ ABI on x86-64, a vcall always has the\r\nfollowing structure:\r\nmov RDI, thisptr\r\ncall [vtblptr + x]\r\nThe thisptr is stored in the RDI register as the first\r\nargument and the vtblptr is used to select the correct virtual\r\ntable. The value x denotes the offset into the selected vtable\r\nin order to branch to the correct function. Note that it may be\r\nzero or omitted if the first function of the vtable is targeted.\r\nD. Multiple Inheritance\r\nIn addition to single inheritance, C++ supports multiple\r\ninheritance. This allows a class to have multiple base classes\r\nfrom which it inherits functions and attributes. In the example\r\ngiven in Figure 1, class C uses multiple inheritance and derives\r\nfrom class A and B.\r\nConsidering the way virtual calls are dispatched, it becomes\r\napparent that vtables are inherited as well. Given that the\r\n3",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/f798d259-e43a-42c7-901f-5fed288e412b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=ed847e8b98ade41c7ee8e6a35f52cecfcb87e577e1b924225d666feed4c74cc9",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 808
      },
      {
        "segments": [
          {
            "segment_id": "40653ac1-ca34-459b-b8f3-165158848f97",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "dispatching mechanism targets certain offsets in the vtable,\r\nthe order of the functions must be preserved throughout the\r\nhierarchy. Conceptually, for multiple base classes, multiple\r\nvtables have to be inherited.\r\nIn the given example, class C has a copy of the vtable of\r\nclass A with a modified entry (pointer to function C::funcA2\r\ninstead of A::funcA2) and appends pointers to its own\r\nimplementations of virtual functions to it. Further, a modified\r\ncopy of the vtable of class B is added as a sub-vtable\r\nof class C. In this sub-vtable, only the function entries of\r\noverridden virtual functions have changed. These entries have\r\nbeen replaced by a pointer to special functions called thunks.\r\nIf a class derives from only one base class, both vtables can\r\nbe merged without conflicts – the current class simply uses\r\nhigher offsets when accessing its part of the vtable. In case\r\nof multiple inheritance, however, sub-vtables have to be used.\r\nWhen accessing an object of class C as an instance of class\r\nB, the thisptr has to be increased by 0x10. Hence, the layout\r\nmatches the one expected by vcalls of class B. Thunks are\r\nused to call back into virtual functions belonging to class C.\r\nIn the given example, funcB1 was overwritten by class\r\nC. At the position of the entry of funcB1 in the sub-vtable,\r\nthe pointer to the thunk, thunk to C::funcB1, has been\r\nwritten. When executing this thunk, the thisptr is modified to\r\npoint to the beginning of the object C and invokes funcB1 of\r\nclass C. This ensures that the function uses the correct offsets\r\ninto the object, i. e., the thisptr points to the start of object C.\r\nThe Offset-to-Top field of the sub-vtables holds the value\r\nthat has to be added to the thisptr to reach the beginning\r\nof the object. In our example, the Offset-to-Top holds the\r\nvalue -0x10. When the sub-vtable of object C is used, the\r\nthisptr points to offset 0x10 of the object (the vtblptr of\r\nthe sub-vtable). When adding the value of the Offset-to-Top\r\nfield, the thisptr points to the beginning of object C. More\r\ndetails on multiple inheritance can be found in the C++ ABI\r\ndocumentation [3].\r\nE. Object Creation and Destruction\r\nAs mentioned in Section II-A, constructors are used for\r\ninitializing the memory area previously allocated to hold a\r\nspecific object. Additionally to any initialization performed\r\nby the programmer (such as setting default values for object\r\nattributes), the compiler adds statements to set an object’s\r\nvtable pointer(s). In case of inheritance, constructors are called\r\ntop-down, i. e., the base class constructor is executed prior to\r\nthe constructor of the derived class.\r\nAnalogous principles apply to the destructor of a class.\r\nHowever, destructors are invoked in reverse order (bottom-up,\r\ninvoking the most specific destructor first).\r\nIII. ANALYSIS APPROACH\r\nGiven a binary executable, we aim at extracting the C++\r\nclass hierarchies as accurately as possible. To this end, we\r\nextract distinct properties that result from the way a C++\r\ncompiler implements the aforementioned high-level concepts\r\non the binary level. In the following, we describe the design\r\nof our approach that is implemented in a tool called Marx.\r\nGenerally speaking, our analysis is divided into two steps:\r\nFig. 2. Structure of an Itanium C++ ABI vtable. The vtable pointer referenced\r\nin the code points to offset 0, where the table of function pointers starts. The\r\ntwo metadata fields (RTTI and Offset-to-Top) precede said table.\r\n1) Vtable Extraction. Distinct patterns that are typical\r\nfor vtables in the code are searched and information\r\nabout the vtables is extracted.\r\n2) Static Analysis. Given that these heuristics might lead\r\nto an overestimation, a static analysis of the code is\r\nconducted which searches for usages of the vtables\r\nfound in the previous step.\r\nIn the following, we focus on the Itanium C++ ABI [3].\r\nHowever, we stress that the presented methodology is applica\u0002ble to other ABIs as well, such as the ARM [6] or the Microsoft\r\nC++ ABI [14].\r\nA. Vtable Extraction\r\nVirtual function tables in a binary are the key element\r\nto our analysis. By extracting usages of vtables, one easily\r\nfinds points in the program where objects are either created\r\n(constructors) or destroyed (destructors). This, in turn, yields\r\nvaluable information about the relation of different classes.\r\nHence, one can view vtables as roughly analogous to a certain\r\nclass and relation of vtables as corresponding to certain class\r\nhierarchies.\r\nOur analysis applies multiple heuristics in order to locate\r\nvtables in a binary (H-1 to H-6), as we discuss in the\r\nfollowing. A rough, albeit simple, estimate can be used to\r\nrestrict the search space to specific sections: As vtables are\r\nfully specified at compile time, they can be placed in read-only\r\nsections (heuristic H-1). Therefore, only those sections that\r\ntypically hold vtables, such as .rodata, .data.rel.ro,\r\nand .data.rel.ro.local, are analyzed.\r\nFigure 2 shows the typical structure of an Itanium C++\r\nABI vtable. A vtable consists of three different parts: the\r\nOffset-to-Top field, the RTTI pointer, and multiple function\r\nentries. Each type has different properties which can be used\r\nto distinguish between them. Also, their order is fixed, which\r\nmakes it possible to search for a series of consecutive patterns\r\nin a memory range, e. g., a specific section.\r\nAs seen in the figure, the vtblptr references the beginning\r\nof the function entries. Usually, this reference will be used in\r\na constructor or destructor. However, we note that the other\r\nfields are usually not referenced at all (heuristic H-2).\r\nOffset-to-Top is used to implement multiple inheritance for\r\nobjects and encodes the offset from the sub-object to the base\r\nobject. It is a mandatory field and always contains 0 if multiple\r\ninheritance is unused. Our approach checks the sanity of this\r\nentry by only allowing values in the range from -0xFFFFFF\r\nto 0xFFFFFF as proposed by Prakash et al. [21]. In addition,\r\n4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/40653ac1-ca34-459b-b8f3-165158848f97.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=73be5e7f4fb29d815410e8b76246471a8a52d5f145cf48d6a4acad37eb739231",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 972
      },
      {
        "segments": [
          {
            "segment_id": "40653ac1-ca34-459b-b8f3-165158848f97",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "dispatching mechanism targets certain offsets in the vtable,\r\nthe order of the functions must be preserved throughout the\r\nhierarchy. Conceptually, for multiple base classes, multiple\r\nvtables have to be inherited.\r\nIn the given example, class C has a copy of the vtable of\r\nclass A with a modified entry (pointer to function C::funcA2\r\ninstead of A::funcA2) and appends pointers to its own\r\nimplementations of virtual functions to it. Further, a modified\r\ncopy of the vtable of class B is added as a sub-vtable\r\nof class C. In this sub-vtable, only the function entries of\r\noverridden virtual functions have changed. These entries have\r\nbeen replaced by a pointer to special functions called thunks.\r\nIf a class derives from only one base class, both vtables can\r\nbe merged without conflicts – the current class simply uses\r\nhigher offsets when accessing its part of the vtable. In case\r\nof multiple inheritance, however, sub-vtables have to be used.\r\nWhen accessing an object of class C as an instance of class\r\nB, the thisptr has to be increased by 0x10. Hence, the layout\r\nmatches the one expected by vcalls of class B. Thunks are\r\nused to call back into virtual functions belonging to class C.\r\nIn the given example, funcB1 was overwritten by class\r\nC. At the position of the entry of funcB1 in the sub-vtable,\r\nthe pointer to the thunk, thunk to C::funcB1, has been\r\nwritten. When executing this thunk, the thisptr is modified to\r\npoint to the beginning of the object C and invokes funcB1 of\r\nclass C. This ensures that the function uses the correct offsets\r\ninto the object, i. e., the thisptr points to the start of object C.\r\nThe Offset-to-Top field of the sub-vtables holds the value\r\nthat has to be added to the thisptr to reach the beginning\r\nof the object. In our example, the Offset-to-Top holds the\r\nvalue -0x10. When the sub-vtable of object C is used, the\r\nthisptr points to offset 0x10 of the object (the vtblptr of\r\nthe sub-vtable). When adding the value of the Offset-to-Top\r\nfield, the thisptr points to the beginning of object C. More\r\ndetails on multiple inheritance can be found in the C++ ABI\r\ndocumentation [3].\r\nE. Object Creation and Destruction\r\nAs mentioned in Section II-A, constructors are used for\r\ninitializing the memory area previously allocated to hold a\r\nspecific object. Additionally to any initialization performed\r\nby the programmer (such as setting default values for object\r\nattributes), the compiler adds statements to set an object’s\r\nvtable pointer(s). In case of inheritance, constructors are called\r\ntop-down, i. e., the base class constructor is executed prior to\r\nthe constructor of the derived class.\r\nAnalogous principles apply to the destructor of a class.\r\nHowever, destructors are invoked in reverse order (bottom-up,\r\ninvoking the most specific destructor first).\r\nIII. ANALYSIS APPROACH\r\nGiven a binary executable, we aim at extracting the C++\r\nclass hierarchies as accurately as possible. To this end, we\r\nextract distinct properties that result from the way a C++\r\ncompiler implements the aforementioned high-level concepts\r\non the binary level. In the following, we describe the design\r\nof our approach that is implemented in a tool called Marx.\r\nGenerally speaking, our analysis is divided into two steps:\r\nFig. 2. Structure of an Itanium C++ ABI vtable. The vtable pointer referenced\r\nin the code points to offset 0, where the table of function pointers starts. The\r\ntwo metadata fields (RTTI and Offset-to-Top) precede said table.\r\n1) Vtable Extraction. Distinct patterns that are typical\r\nfor vtables in the code are searched and information\r\nabout the vtables is extracted.\r\n2) Static Analysis. Given that these heuristics might lead\r\nto an overestimation, a static analysis of the code is\r\nconducted which searches for usages of the vtables\r\nfound in the previous step.\r\nIn the following, we focus on the Itanium C++ ABI [3].\r\nHowever, we stress that the presented methodology is applica\u0002ble to other ABIs as well, such as the ARM [6] or the Microsoft\r\nC++ ABI [14].\r\nA. Vtable Extraction\r\nVirtual function tables in a binary are the key element\r\nto our analysis. By extracting usages of vtables, one easily\r\nfinds points in the program where objects are either created\r\n(constructors) or destroyed (destructors). This, in turn, yields\r\nvaluable information about the relation of different classes.\r\nHence, one can view vtables as roughly analogous to a certain\r\nclass and relation of vtables as corresponding to certain class\r\nhierarchies.\r\nOur analysis applies multiple heuristics in order to locate\r\nvtables in a binary (H-1 to H-6), as we discuss in the\r\nfollowing. A rough, albeit simple, estimate can be used to\r\nrestrict the search space to specific sections: As vtables are\r\nfully specified at compile time, they can be placed in read-only\r\nsections (heuristic H-1). Therefore, only those sections that\r\ntypically hold vtables, such as .rodata, .data.rel.ro,\r\nand .data.rel.ro.local, are analyzed.\r\nFigure 2 shows the typical structure of an Itanium C++\r\nABI vtable. A vtable consists of three different parts: the\r\nOffset-to-Top field, the RTTI pointer, and multiple function\r\nentries. Each type has different properties which can be used\r\nto distinguish between them. Also, their order is fixed, which\r\nmakes it possible to search for a series of consecutive patterns\r\nin a memory range, e. g., a specific section.\r\nAs seen in the figure, the vtblptr references the beginning\r\nof the function entries. Usually, this reference will be used in\r\na constructor or destructor. However, we note that the other\r\nfields are usually not referenced at all (heuristic H-2).\r\nOffset-to-Top is used to implement multiple inheritance for\r\nobjects and encodes the offset from the sub-object to the base\r\nobject. It is a mandatory field and always contains 0 if multiple\r\ninheritance is unused. Our approach checks the sanity of this\r\nentry by only allowing values in the range from -0xFFFFFF\r\nto 0xFFFFFF as proposed by Prakash et al. [21]. In addition,\r\n4",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/40653ac1-ca34-459b-b8f3-165158848f97.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=73be5e7f4fb29d815410e8b76246471a8a52d5f145cf48d6a4acad37eb739231",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 972
      },
      {
        "segments": [
          {
            "segment_id": "e7dded1f-e733-4dbb-a361-04be43ea9f65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "the value cannot be a relocation entry and these checks\r\nconstitute heuristic H-3.\r\nRTTI holds a pointer to further type information for the\r\nclass. Since this field is optional, the entry is either a pointer\r\nor 0. If the entry is, in fact, a pointer to data, it has to point to\r\nnon-executable memory (heuristic H-4). Since the vtable can\r\nbe part of a shared library, this entry can also be a relocation\r\nentry.\r\nFunction entries hold a pointer to the virtual functions the\r\nclass provides. Hence, an entry either points to the .text,\r\n.plt, or the .extern section of the binary, or it is a\r\nrelocation entry. One of these properties has to be satisfied\r\nsuch that the analysis deems the function pointer to be valid\r\n(heuristic H-5).\r\nIn rare cases, the compiler sets the first few function entries\r\nof the vtable to 0. This can happen for multiple inheritance\r\nconstructs inheriting from abstract classes. To cope with these\r\nedge cases, our approach allows the first two function entries\r\nof the vtable to be 0. This number was empirically found to\r\nbe sufficient (relaxing heuristic H-6).\r\nFinally, we can determine the beginning of a vtable by\r\nsearching three consecutive words in memory that fulfill the\r\nproperties outlined above. Further, the length of the vtable can\r\nbe estimated by checking the subsequent function entries for\r\nvalidity.\r\nTo sum up, the heuristics we employ are:\r\nH-1 Vtables have to lie in read-only sections.\r\nH-2 In a candidate vtable, only the beginning of the\r\nfunction entries is referenced from the code.\r\nH-3 Offset-to-Top lies within a well-defined range and it\r\nis no relocation entry.\r\nH-4 RTTI either points into a data section or is 0.\r\nH-5 A function entry points into a code section or is a\r\nrelocation entry.\r\nH-6 (relaxing) The first two function entries may be 0.\r\nNote that the heuristics to find these patterns can lead\r\nto an overestimation of extracted vtables. Nevertheless, this\r\ndoes not impact the subsequent analysis notably since only\r\nexisting vtables are referenced in the code (cf. heuristic H-2).\r\nWe note that only in rare cases an overestimated vtable can\r\nresult in an overestimated hierarchy. On the other hand, only\r\nan underestimation of vtables would lower the precision of the\r\nanalysis, which is unlikely for the presented approach.\r\nB. Static Analysis\r\nNow that we obtained a possibly overestimated set of\r\nvtable candidates, the second phase of our approach statically\r\nanalyzes their relation based on indicators found in the binary\r\ncode. Eventually, it yields distinct sets of vtables that are part\r\nof a class hierarchy. In the following, we discuss the various\r\nindicators the approach uses.\r\n1) Overwrite Analysis: In Section II-E, we discussed how\r\nduring object creation, the constructor writes the vtblptr into\r\nthe object. Further, when class C inherits from class A, as\r\ndepicted in Figure 1, the constructor of class A is executed\r\nbefore the constructor of class C (top-down approach). This\r\nensures that the inherited attributes of class A are initialized\r\nbefore the constructor of class C accesses them. Consequently,\r\nthe vtblptr of the base class A is written into the new objects\r\nbefore the derived constructor writes the vtblptr of class C as\r\nshown in Figure 3. This also holds for multiple inheritance.\r\nIn the given example, class C also inherits from class B.\r\nHence, the constructor of class B is also executed before the\r\nconstructor of class C. In this case, however, the vtblptr of\r\nclass B is overwritten by the vtblptr to the sub-vtable of class\r\nC.\r\nIn contrast, during object deletion, the destructor of class\r\nC is executed before the destructor of class A, i. e., invocation\r\nfollows a bottom-up approach. Therefore, the vtblptr of class\r\nC is overwritten by the vtblptr of class A. This also holds in\r\nthe case of multiple inheritance for the sub-vtable of class C\r\nand vtblptr of class B, analogously. We can leverage this and\r\ndetect the dependency of two classes by tracking if one vtblptr\r\nin an object is overwritten by another vtblptr. Remember that\r\nclasses are roughly analogous to their vtable for our approach.\r\nNaturally, this also means that we have to track the creation\r\nof a potential object by monitoring the new operators of\r\nthe memory allocator. By correctly identifying constructors\r\nand destructors, our approach would also be able to make a\r\nstatement about the direction of the inheritance, i. e., detect\r\nwhich class is the base and which the deriving class. In its\r\ncurrent implementation, however, our approach reconstructs\r\nthe class hierarchy as a plain set.\r\nDue to compiler optimizations, constructors are often in\u0002lined next to the memory allocation of the object in the\r\nsame function. The same concept is applied to destructors,\r\nanalogously. While our approach does not identify constructors\r\nand destructors directly, it detects the characteristic pattern\r\nof vtblptr overwrites. As a result, we are able to detect\r\noverwrites for which a concrete classification as constructor\r\nor destructor is more involved. More precisely, our overwrite\r\nanalysis is performed on statically calculated paths through\r\nmultiple functions, as discussed in Section IV. Thus, we avoid\r\nhaving problems with function inlining as opposed to other\r\napproaches such as the one presented by Jin et al. [17].\r\n2) Vtable Function Entries: Classes in the same hierarchy\r\nshare attributes and a subset of virtual functions. Also, a class\r\nthat inherits virtual functions from another class does not have\r\nto overwrite it. As a result, the vtables of both classes, base and\r\nderived, may contain multiple entries that point to the same\r\nfunction as in the other classes’ vtable. In order to work in\r\npolymorphic constructs, this function entry has to be at the\r\nsame position in the vtables.\r\nHence, we can employ a heuristic that checks if multiple\r\nvtables share the same function entry at the same position.\r\nIf they do, we consider them as related. Obviously, specific\r\nentries like a 0 entry or the pure virtual function have to\r\nbe excluded from this heuristic. Note that, similar to the\r\noverwrite analysis in its current form, no direction information\r\nis included. Naturally, if the compiler places the same function\r\nentry at the same position in unrelated vtables due to optimiza\u0002tion passes, our analysis would find them to be related. This\r\nwould lead to an overestimation of the found class hierarchy.\r\nHowever, the evaluation results in Section VI-A show that this\r\ncase can be neglected in practice.\r\n5",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/e7dded1f-e733-4dbb-a361-04be43ea9f65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4338463e74a09a2bf5e7e99e67ffeff18be76ca1b6b490a1d3da7fa35717ad43",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1066
      },
      {
        "segments": [
          {
            "segment_id": "e7dded1f-e733-4dbb-a361-04be43ea9f65",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "the value cannot be a relocation entry and these checks\r\nconstitute heuristic H-3.\r\nRTTI holds a pointer to further type information for the\r\nclass. Since this field is optional, the entry is either a pointer\r\nor 0. If the entry is, in fact, a pointer to data, it has to point to\r\nnon-executable memory (heuristic H-4). Since the vtable can\r\nbe part of a shared library, this entry can also be a relocation\r\nentry.\r\nFunction entries hold a pointer to the virtual functions the\r\nclass provides. Hence, an entry either points to the .text,\r\n.plt, or the .extern section of the binary, or it is a\r\nrelocation entry. One of these properties has to be satisfied\r\nsuch that the analysis deems the function pointer to be valid\r\n(heuristic H-5).\r\nIn rare cases, the compiler sets the first few function entries\r\nof the vtable to 0. This can happen for multiple inheritance\r\nconstructs inheriting from abstract classes. To cope with these\r\nedge cases, our approach allows the first two function entries\r\nof the vtable to be 0. This number was empirically found to\r\nbe sufficient (relaxing heuristic H-6).\r\nFinally, we can determine the beginning of a vtable by\r\nsearching three consecutive words in memory that fulfill the\r\nproperties outlined above. Further, the length of the vtable can\r\nbe estimated by checking the subsequent function entries for\r\nvalidity.\r\nTo sum up, the heuristics we employ are:\r\nH-1 Vtables have to lie in read-only sections.\r\nH-2 In a candidate vtable, only the beginning of the\r\nfunction entries is referenced from the code.\r\nH-3 Offset-to-Top lies within a well-defined range and it\r\nis no relocation entry.\r\nH-4 RTTI either points into a data section or is 0.\r\nH-5 A function entry points into a code section or is a\r\nrelocation entry.\r\nH-6 (relaxing) The first two function entries may be 0.\r\nNote that the heuristics to find these patterns can lead\r\nto an overestimation of extracted vtables. Nevertheless, this\r\ndoes not impact the subsequent analysis notably since only\r\nexisting vtables are referenced in the code (cf. heuristic H-2).\r\nWe note that only in rare cases an overestimated vtable can\r\nresult in an overestimated hierarchy. On the other hand, only\r\nan underestimation of vtables would lower the precision of the\r\nanalysis, which is unlikely for the presented approach.\r\nB. Static Analysis\r\nNow that we obtained a possibly overestimated set of\r\nvtable candidates, the second phase of our approach statically\r\nanalyzes their relation based on indicators found in the binary\r\ncode. Eventually, it yields distinct sets of vtables that are part\r\nof a class hierarchy. In the following, we discuss the various\r\nindicators the approach uses.\r\n1) Overwrite Analysis: In Section II-E, we discussed how\r\nduring object creation, the constructor writes the vtblptr into\r\nthe object. Further, when class C inherits from class A, as\r\ndepicted in Figure 1, the constructor of class A is executed\r\nbefore the constructor of class C (top-down approach). This\r\nensures that the inherited attributes of class A are initialized\r\nbefore the constructor of class C accesses them. Consequently,\r\nthe vtblptr of the base class A is written into the new objects\r\nbefore the derived constructor writes the vtblptr of class C as\r\nshown in Figure 3. This also holds for multiple inheritance.\r\nIn the given example, class C also inherits from class B.\r\nHence, the constructor of class B is also executed before the\r\nconstructor of class C. In this case, however, the vtblptr of\r\nclass B is overwritten by the vtblptr to the sub-vtable of class\r\nC.\r\nIn contrast, during object deletion, the destructor of class\r\nC is executed before the destructor of class A, i. e., invocation\r\nfollows a bottom-up approach. Therefore, the vtblptr of class\r\nC is overwritten by the vtblptr of class A. This also holds in\r\nthe case of multiple inheritance for the sub-vtable of class C\r\nand vtblptr of class B, analogously. We can leverage this and\r\ndetect the dependency of two classes by tracking if one vtblptr\r\nin an object is overwritten by another vtblptr. Remember that\r\nclasses are roughly analogous to their vtable for our approach.\r\nNaturally, this also means that we have to track the creation\r\nof a potential object by monitoring the new operators of\r\nthe memory allocator. By correctly identifying constructors\r\nand destructors, our approach would also be able to make a\r\nstatement about the direction of the inheritance, i. e., detect\r\nwhich class is the base and which the deriving class. In its\r\ncurrent implementation, however, our approach reconstructs\r\nthe class hierarchy as a plain set.\r\nDue to compiler optimizations, constructors are often in\u0002lined next to the memory allocation of the object in the\r\nsame function. The same concept is applied to destructors,\r\nanalogously. While our approach does not identify constructors\r\nand destructors directly, it detects the characteristic pattern\r\nof vtblptr overwrites. As a result, we are able to detect\r\noverwrites for which a concrete classification as constructor\r\nor destructor is more involved. More precisely, our overwrite\r\nanalysis is performed on statically calculated paths through\r\nmultiple functions, as discussed in Section IV. Thus, we avoid\r\nhaving problems with function inlining as opposed to other\r\napproaches such as the one presented by Jin et al. [17].\r\n2) Vtable Function Entries: Classes in the same hierarchy\r\nshare attributes and a subset of virtual functions. Also, a class\r\nthat inherits virtual functions from another class does not have\r\nto overwrite it. As a result, the vtables of both classes, base and\r\nderived, may contain multiple entries that point to the same\r\nfunction as in the other classes’ vtable. In order to work in\r\npolymorphic constructs, this function entry has to be at the\r\nsame position in the vtables.\r\nHence, we can employ a heuristic that checks if multiple\r\nvtables share the same function entry at the same position.\r\nIf they do, we consider them as related. Obviously, specific\r\nentries like a 0 entry or the pure virtual function have to\r\nbe excluded from this heuristic. Note that, similar to the\r\noverwrite analysis in its current form, no direction information\r\nis included. Naturally, if the compiler places the same function\r\nentry at the same position in unrelated vtables due to optimiza\u0002tion passes, our analysis would find them to be related. This\r\nwould lead to an overestimation of the found class hierarchy.\r\nHowever, the evaluation results in Section VI-A show that this\r\ncase can be neglected in practice.\r\n5",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/e7dded1f-e733-4dbb-a361-04be43ea9f65.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4338463e74a09a2bf5e7e99e67ffeff18be76ca1b6b490a1d3da7fa35717ad43",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1066
      },
      {
        "segments": [
          {
            "segment_id": "ea548365-c44b-4ecf-9426-b1662770b54c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "Fig. 3. Order of vtblptr overwrites during the creation of an object of class C. The control flow of the execution of Constructor C is depicted as dotted\r\nlines.\r\n3) Inter-Procedural Data Flow: We perform our analysis\r\non paths through multiple functions. Even if analysis within a\r\nfunction is well defined, special attention has to be paid to the\r\npoint where function boundaries are traversed.\r\na) Forward Edge: Virtual functions are usually only\r\ncalled via an indirect call instruction. As these are dispatched\r\ndynamically based on a concrete object, the list of potential\r\ncall targets is not easily retrieved statically. As the overwrite\r\nanalysis analyzes paths through multiple functions, indirect\r\ncallsites pose a roadblock and may prevent the analysis from\r\nfollowing the call target. Consequently, vtable relations that are\r\nestablished beyond this point will be missed by the analysis.\r\nWe say it lacks context, as no potential object at the callsite\r\nis known with which the callsite could be resolved.\r\nIn order to tackle this problem, the static analysis tries to\r\nresolve the indirect call instruction with the help of the context\r\n(essential a memory state) it built up on the current path. If\r\nthe argument of an indirect call instruction is known, i. e., it\r\ndereferences a known vtblptr, we resolve the target function\r\nand continue the analysis in the newly discovered function on\r\nthe path while keeping the current context.\r\nAs an additional side effect of resolving the branch targets\r\nat a vcall in the current analysis run, we know which vtable is\r\nused for it. Since in polymorphic constructs only classes within\r\nthe same hierarchy are allowed, a vcall can only be used by\r\nobjects of dependent classes. Hence, if during the analysis the\r\nsame vcall is used by objects containing different vtables, these\r\nvtables are related (i. e., the objects are from the same class\r\nhierarchy). However, no information about the direction of the\r\ninheritance of the classes is obtained.\r\nb) Backward Edge: In addition to passing known con\u0002text on to the beginning of a more deeply nested function, the\r\nanalysis also has to take return values of a callee back to its\r\ncaller into account. Since different paths through the callee can\r\nresult in multiple different return values, we generalize them\r\ninto a set of return values, which is effectively the union of\r\nthe individual return values on each path. Then, if the return\r\nvalue is used in a point where more context is required, such\r\nas a vcall, the information provided all possible return values\r\ncan be used to, e. g., resolve an indirect callsite.\r\nConsider the example given in Figure 4, which was en\u0002countered in the FileZilla FTP client. This function returns a\r\ndifferent object depending on the given argument. The classes\r\nthat are used to create the object (namely, X, Y, and Z) are\r\npart of the same hierarchy. Without tracking the possible\r\nreturn values of this function into a vcall of the caller, it is\r\nFig. 4. A simplified version of the function GetSortComparisonObject\r\nfrom the FileZilla FTP client. Depending on the given argument, it creates\r\na new object of different classes and returns it. Without considering the\r\nbackward edge, no statement about the classes referenced in this function\r\ncan be made.\r\nFig. 5. A class hierarchy that is connected via a shared library. Classes G\r\nand J both inherit from classes belonging to the same hierarchy in a different\r\nmodule. This fact is only observable when taking module boundaries into\r\naccount.\r\nnot possible to find the relation of these classes based on\r\ninformation of the forward edge alone.\r\n4) Inter-Modular Data Flow: Applications are commonly\r\ndivided into multiple modules (also known as libraries), where\r\neach module performs a specific task. On Linux, these modules\r\nare implemented using shared objects, which already include\r\nthe notion that common functionality can be reused by dif\u0002ferent applications. Obviously, modules can depend on each\r\nother. Specifically, in C++, it is possible to interact with classes\r\nexported by a shared object. Such relations would be hidden\r\nfrom our analysis when analyzing single modules only due\r\nto missing context. To counter this, we support inter-modular\r\nanalyses.\r\n6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/ea548365-c44b-4ecf-9426-b1662770b54c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f5d5eb20bbcf96f04d4b18dd43e65e224b3b2b1f098e3dc6616725d50ba68d73",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 690
      },
      {
        "segments": [
          {
            "segment_id": "ea548365-c44b-4ecf-9426-b1662770b54c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": "Fig. 3. Order of vtblptr overwrites during the creation of an object of class C. The control flow of the execution of Constructor C is depicted as dotted\r\nlines.\r\n3) Inter-Procedural Data Flow: We perform our analysis\r\non paths through multiple functions. Even if analysis within a\r\nfunction is well defined, special attention has to be paid to the\r\npoint where function boundaries are traversed.\r\na) Forward Edge: Virtual functions are usually only\r\ncalled via an indirect call instruction. As these are dispatched\r\ndynamically based on a concrete object, the list of potential\r\ncall targets is not easily retrieved statically. As the overwrite\r\nanalysis analyzes paths through multiple functions, indirect\r\ncallsites pose a roadblock and may prevent the analysis from\r\nfollowing the call target. Consequently, vtable relations that are\r\nestablished beyond this point will be missed by the analysis.\r\nWe say it lacks context, as no potential object at the callsite\r\nis known with which the callsite could be resolved.\r\nIn order to tackle this problem, the static analysis tries to\r\nresolve the indirect call instruction with the help of the context\r\n(essential a memory state) it built up on the current path. If\r\nthe argument of an indirect call instruction is known, i. e., it\r\ndereferences a known vtblptr, we resolve the target function\r\nand continue the analysis in the newly discovered function on\r\nthe path while keeping the current context.\r\nAs an additional side effect of resolving the branch targets\r\nat a vcall in the current analysis run, we know which vtable is\r\nused for it. Since in polymorphic constructs only classes within\r\nthe same hierarchy are allowed, a vcall can only be used by\r\nobjects of dependent classes. Hence, if during the analysis the\r\nsame vcall is used by objects containing different vtables, these\r\nvtables are related (i. e., the objects are from the same class\r\nhierarchy). However, no information about the direction of the\r\ninheritance of the classes is obtained.\r\nb) Backward Edge: In addition to passing known con\u0002text on to the beginning of a more deeply nested function, the\r\nanalysis also has to take return values of a callee back to its\r\ncaller into account. Since different paths through the callee can\r\nresult in multiple different return values, we generalize them\r\ninto a set of return values, which is effectively the union of\r\nthe individual return values on each path. Then, if the return\r\nvalue is used in a point where more context is required, such\r\nas a vcall, the information provided all possible return values\r\ncan be used to, e. g., resolve an indirect callsite.\r\nConsider the example given in Figure 4, which was en\u0002countered in the FileZilla FTP client. This function returns a\r\ndifferent object depending on the given argument. The classes\r\nthat are used to create the object (namely, X, Y, and Z) are\r\npart of the same hierarchy. Without tracking the possible\r\nreturn values of this function into a vcall of the caller, it is\r\nFig. 4. A simplified version of the function GetSortComparisonObject\r\nfrom the FileZilla FTP client. Depending on the given argument, it creates\r\na new object of different classes and returns it. Without considering the\r\nbackward edge, no statement about the classes referenced in this function\r\ncan be made.\r\nFig. 5. A class hierarchy that is connected via a shared library. Classes G\r\nand J both inherit from classes belonging to the same hierarchy in a different\r\nmodule. This fact is only observable when taking module boundaries into\r\naccount.\r\nnot possible to find the relation of these classes based on\r\ninformation of the forward edge alone.\r\n4) Inter-Modular Data Flow: Applications are commonly\r\ndivided into multiple modules (also known as libraries), where\r\neach module performs a specific task. On Linux, these modules\r\nare implemented using shared objects, which already include\r\nthe notion that common functionality can be reused by dif\u0002ferent applications. Obviously, modules can depend on each\r\nother. Specifically, in C++, it is possible to interact with classes\r\nexported by a shared object. Such relations would be hidden\r\nfrom our analysis when analyzing single modules only due\r\nto missing context. To counter this, we support inter-modular\r\nanalyses.\r\n6",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/ea548365-c44b-4ecf-9426-b1662770b54c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=f5d5eb20bbcf96f04d4b18dd43e65e224b3b2b1f098e3dc6616725d50ba68d73",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 690
      },
      {
        "segments": [
          {
            "segment_id": "0f49769c-f304-4c36-b839-58c4fc0e9812",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Consider the example depicted in Figure 5. The application\r\nitself contains two class hierarchies that appear to be unrelated\r\nwhen looking at the main module. However, when taking the\r\napplication’s shared library into account, it becomes apparent\r\nthat the two hierarchies are, indeed, related. Both hierarchies\r\nin the main module derive from a class of the very same hier\u0002archy in the shared library. Isolated analysis of the individual\r\nmodules would not have yielded the same result.\r\nOur approach analyzes shared libraries first and creates data\r\nflow summaries of the return values and vtblptr overwrites\r\nin their respective modules. If a function in a shared library\r\nis called during the analysis phase, the aforementioned sum\u0002maries are added to the current context accordingly. This way,\r\nwe can also consider all class hierarchy connections that are\r\noutside of the currently analyzed module.\r\nIV. IMPLEMENTATION\r\nBased on the concepts presented in Section III, we im\u0002plemented an analysis framework called Marx in C++ for\r\nLinux x86-64 binaries. Note that even though only Linux\r\nx86-64 binaries are supported as of now, the implementation\r\ncan be easily extended to support more architectures. This is\r\nsupported by the fact that we use VEX-IR from the Valgrind\r\nproject [5] as our intermediate language.\r\nIn the following, we describe the implementation of Marx,\r\ndiscuss challenges we encountered, and explain how we solved\r\nthem. To foster research on this topic, the source code of Marx\r\nis freely available at https://github.com/RUB-SysSec/Marx.\r\nThe first step of our analysis, vtable extraction, is per\u0002formed on an IDA database using scripting facilities provided\r\nby IDAPython [2]. In addition to the candidate vtables identi\u0002fied via the heuristics H1 – H6 described in Section III-A, the\r\ncontrol-flow graph (CFG) of all known functions is extracted\r\nas well, which is used in the subsequent static analysis step.\r\nThe static analysis is mostly driven by a data tracking\r\nengine which updates the context collected upon a path through\r\nthe binary, as discussed in Section III-B. Said context is\r\nused to track assignments of vtables to new objects and their\r\noverwrites in constructors and destructors. In its current state,\r\nthe engine implements basic 64-bit VEX instructions, as this\r\nis already sufficient for our needs. The constructs we want to\r\nidentify hardly involve any complex calculations and with our\r\nfocus on real-world applicability, we have to weigh up Marx’\r\nprecision against its performance.\r\nA. Starting Points and Context Sensitivity\r\nMarx starts its analysis for each function in the target\r\nprogram separately, i. e., each function serves as starting point\r\nfor at least one path. In order to obtain reasonable results for\r\na specific path, however, enough context has to be known in\r\nwhich the function is executed. Otherwise, relations may be\r\nmissed and the current traversal would not add to the overall\r\nresults of the analysis.\r\nThere are multiple ways to ensure that the analysis visits\r\na function g with a reasonable amount of context. For one, if\r\ng lies deeper within a path, it is reasonable that its caller f\r\nalready adds vital information to the context. By starting an\r\nanalysis path at f, the context added by it is available when\r\narriving at g. If f constructs an object and g overwrites its\r\nvtable, this information would be missed by analyzing g out\r\nof context. This aspect is discussed further below.\r\nOn the other hand, it helps to consider the context a\r\nfunction inherently lies in. For example, g may be a virtual\r\nfunction. This, in turn, means that it belongs to (at least)\r\none vtable. Hence, our analysis can be provided with some\r\ninitial context: a thisptr exists and the object’s vtblptr can be\r\ninitialized to point to the vtable g lies in. For example, for the\r\nx86-64 Itanium C++ ABI, any occurrence of [rdi + 0] is\r\nthen known to resolve to the current vtblptr.\r\nThis enables the analysis to handle operations on the object\r\nitself now that the target object is known (vtblptr overwrites or\r\nvcalls). Further, if g belongs to multiple vtables, g is analyzed\r\nin just as many contexts.\r\nB. Path Creation and Convergence\r\nThe previous section already hinted on where possible\r\npaths through the binary start—at any known function. How\u0002ever, care has to be taken that a path ends at a point where\r\nall relations have been picked up by our analysis and no\r\nsuperfluous calculations are performed by further following\r\nthe path. A na¨ıve approach would be to simply analyze all\r\npossible paths at the given starting point. Yet, this leads to\r\nwhat is called the path explosion problem, as the number of\r\npaths easily exceeds a feasible amount for non-trivial CFGs.\r\nMarx decides which paths through a function are worth\r\nanalyzing by following a heuristic: on each basic block in the\r\nCFG, a predicate is run which decides whether the block is\r\nconsidered interesting. We consider those blocks as interesting\r\nthat contain one or more of the following cases: (i) an indirect\r\ncall (i.e., a possible vcall), (ii) a (direct) call to a new operator,\r\nor (iii) an instruction operating on a vtblptr. With this heuristic,\r\nwe attempt to visit only those blocks that add to the overall\r\ncontext we are interested in.\r\nWe then compute paths that try to visit as many interesting\r\nbasic blocks as possible before reaching an exit block. In order\r\nto avoid a high computational complexity, a threshold t is\r\nintroduced. If a function contains more than t interesting basic\r\nblocks, paths are generated that guarantee to visit at least one\r\ninteresting block, but no attempts are made to maximize this\r\nnumber. Empirically, we found a threshold of 20 interesting\r\nbasic blocks to be sufficient for our purposes. By trying to visit\r\nmultiple interesting basic blocks on a path within a function,\r\noverwrites in the very same function are more likely to be\r\ndetected. This is, for example, the case for inlined constructors:\r\none block may allocate memory, whereas another writes the\r\nobject’s vtable.\r\nLoops are only traversed once, i. e., paths are guaranteed\r\nto visit every basic block at most once. Empirically, we did\r\nnot encounter cases where loop unrolling would have yielded\r\nbetter results in terms of object creation coverage.\r\nUp to now, we only considered paths within a certain\r\nfunction. However, such a path may contain calls to other\r\nfunctions. As already stated in the previous section, the call\r\ndepth of a path impacts the amount of context available to our\r\nanalysis, which, in turn, strongly impacts its results. Still, it is\r\nalso an important factor to ensure that the analysis terminates\r\n7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/0f49769c-f304-4c36-b839-58c4fc0e9812.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7aad7004ce18c7a13dcf80b2b9501e3cef7bc34bde23ffaccfa440cbc2e2df37",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1089
      },
      {
        "segments": [
          {
            "segment_id": "0f49769c-f304-4c36-b839-58c4fc0e9812",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "Consider the example depicted in Figure 5. The application\r\nitself contains two class hierarchies that appear to be unrelated\r\nwhen looking at the main module. However, when taking the\r\napplication’s shared library into account, it becomes apparent\r\nthat the two hierarchies are, indeed, related. Both hierarchies\r\nin the main module derive from a class of the very same hier\u0002archy in the shared library. Isolated analysis of the individual\r\nmodules would not have yielded the same result.\r\nOur approach analyzes shared libraries first and creates data\r\nflow summaries of the return values and vtblptr overwrites\r\nin their respective modules. If a function in a shared library\r\nis called during the analysis phase, the aforementioned sum\u0002maries are added to the current context accordingly. This way,\r\nwe can also consider all class hierarchy connections that are\r\noutside of the currently analyzed module.\r\nIV. IMPLEMENTATION\r\nBased on the concepts presented in Section III, we im\u0002plemented an analysis framework called Marx in C++ for\r\nLinux x86-64 binaries. Note that even though only Linux\r\nx86-64 binaries are supported as of now, the implementation\r\ncan be easily extended to support more architectures. This is\r\nsupported by the fact that we use VEX-IR from the Valgrind\r\nproject [5] as our intermediate language.\r\nIn the following, we describe the implementation of Marx,\r\ndiscuss challenges we encountered, and explain how we solved\r\nthem. To foster research on this topic, the source code of Marx\r\nis freely available at https://github.com/RUB-SysSec/Marx.\r\nThe first step of our analysis, vtable extraction, is per\u0002formed on an IDA database using scripting facilities provided\r\nby IDAPython [2]. In addition to the candidate vtables identi\u0002fied via the heuristics H1 – H6 described in Section III-A, the\r\ncontrol-flow graph (CFG) of all known functions is extracted\r\nas well, which is used in the subsequent static analysis step.\r\nThe static analysis is mostly driven by a data tracking\r\nengine which updates the context collected upon a path through\r\nthe binary, as discussed in Section III-B. Said context is\r\nused to track assignments of vtables to new objects and their\r\noverwrites in constructors and destructors. In its current state,\r\nthe engine implements basic 64-bit VEX instructions, as this\r\nis already sufficient for our needs. The constructs we want to\r\nidentify hardly involve any complex calculations and with our\r\nfocus on real-world applicability, we have to weigh up Marx’\r\nprecision against its performance.\r\nA. Starting Points and Context Sensitivity\r\nMarx starts its analysis for each function in the target\r\nprogram separately, i. e., each function serves as starting point\r\nfor at least one path. In order to obtain reasonable results for\r\na specific path, however, enough context has to be known in\r\nwhich the function is executed. Otherwise, relations may be\r\nmissed and the current traversal would not add to the overall\r\nresults of the analysis.\r\nThere are multiple ways to ensure that the analysis visits\r\na function g with a reasonable amount of context. For one, if\r\ng lies deeper within a path, it is reasonable that its caller f\r\nalready adds vital information to the context. By starting an\r\nanalysis path at f, the context added by it is available when\r\narriving at g. If f constructs an object and g overwrites its\r\nvtable, this information would be missed by analyzing g out\r\nof context. This aspect is discussed further below.\r\nOn the other hand, it helps to consider the context a\r\nfunction inherently lies in. For example, g may be a virtual\r\nfunction. This, in turn, means that it belongs to (at least)\r\none vtable. Hence, our analysis can be provided with some\r\ninitial context: a thisptr exists and the object’s vtblptr can be\r\ninitialized to point to the vtable g lies in. For example, for the\r\nx86-64 Itanium C++ ABI, any occurrence of [rdi + 0] is\r\nthen known to resolve to the current vtblptr.\r\nThis enables the analysis to handle operations on the object\r\nitself now that the target object is known (vtblptr overwrites or\r\nvcalls). Further, if g belongs to multiple vtables, g is analyzed\r\nin just as many contexts.\r\nB. Path Creation and Convergence\r\nThe previous section already hinted on where possible\r\npaths through the binary start—at any known function. How\u0002ever, care has to be taken that a path ends at a point where\r\nall relations have been picked up by our analysis and no\r\nsuperfluous calculations are performed by further following\r\nthe path. A na¨ıve approach would be to simply analyze all\r\npossible paths at the given starting point. Yet, this leads to\r\nwhat is called the path explosion problem, as the number of\r\npaths easily exceeds a feasible amount for non-trivial CFGs.\r\nMarx decides which paths through a function are worth\r\nanalyzing by following a heuristic: on each basic block in the\r\nCFG, a predicate is run which decides whether the block is\r\nconsidered interesting. We consider those blocks as interesting\r\nthat contain one or more of the following cases: (i) an indirect\r\ncall (i.e., a possible vcall), (ii) a (direct) call to a new operator,\r\nor (iii) an instruction operating on a vtblptr. With this heuristic,\r\nwe attempt to visit only those blocks that add to the overall\r\ncontext we are interested in.\r\nWe then compute paths that try to visit as many interesting\r\nbasic blocks as possible before reaching an exit block. In order\r\nto avoid a high computational complexity, a threshold t is\r\nintroduced. If a function contains more than t interesting basic\r\nblocks, paths are generated that guarantee to visit at least one\r\ninteresting block, but no attempts are made to maximize this\r\nnumber. Empirically, we found a threshold of 20 interesting\r\nbasic blocks to be sufficient for our purposes. By trying to visit\r\nmultiple interesting basic blocks on a path within a function,\r\noverwrites in the very same function are more likely to be\r\ndetected. This is, for example, the case for inlined constructors:\r\none block may allocate memory, whereas another writes the\r\nobject’s vtable.\r\nLoops are only traversed once, i. e., paths are guaranteed\r\nto visit every basic block at most once. Empirically, we did\r\nnot encounter cases where loop unrolling would have yielded\r\nbetter results in terms of object creation coverage.\r\nUp to now, we only considered paths within a certain\r\nfunction. However, such a path may contain calls to other\r\nfunctions. As already stated in the previous section, the call\r\ndepth of a path impacts the amount of context available to our\r\nanalysis, which, in turn, strongly impacts its results. Still, it is\r\nalso an important factor to ensure that the analysis terminates\r\n7",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/0f49769c-f304-4c36-b839-58c4fc0e9812.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=7aad7004ce18c7a13dcf80b2b9501e3cef7bc34bde23ffaccfa440cbc2e2df37",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1089
      },
      {
        "segments": [
          {
            "segment_id": "2edc489d-1aba-463e-9c45-c2d0d5624534",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "in a reasonable amount of time and, once again, illustrates how\r\none has to weigh up performance and accuracy. Empirically,\r\nwe determined that a maximum call depth of 2 is sufficient for\r\nanalyzing large real-world applications. Note that, depending\r\non time and resources available to an analyst, higher precision\r\ncan be achieved by increasing this number.\r\nC. Virtual Callsite Identification\r\nEven though the information collected in these steps is\r\nalready helpful for an analyst, we further refine the result and\r\ntry to distinguish vcalls from other indirect call constructs and\r\nonly resolve target sets for the former. To detect a vcall, Marx\r\nsearches for the virtual function dispatch structure described\r\nin Section II-C. As this structure applies to both vcalls and\r\nother types of indirect calls (e. g., function pointers), we\r\nimplemented two modes to resolve the targets: conservative\r\nand non-conservative mode.\r\nIn conservative mode, an indirect call is only identified\r\nas vcall if the thisptr holds a known object and a vtable is\r\ninvolved when computing the target address. This ensures that\r\nthe analysis has an exact state for the thisptr.\r\nIn non-conservative mode, an indirect call is considered to\r\nbe a vcall simply if the vtable is involved in the computation of\r\nthe target address, i. e., we drop the requirement that the thisptr\r\nhas to be valid. Due to missing context during the analysis\r\n(i. e., call depth is depleted), memory locations might not be\r\nidentified as objects and therefore the thisptr check can fail.\r\nThe non-conservative mode allows the analysis to resolve more\r\nvcalls since requirements are relaxed. However, overestimation\r\ncan lead to a higher false positive rate. The difference between\r\nboth modes is further evaluated in Section VI-B.\r\nV. APPLICATIONS\r\nBeyond applications in the area of reverse engineering, the\r\nresults of the reconstructed class hierarchies can also be used\r\nto significantly improve defenses that mitigate attacks against\r\nC++ applications. In this section, we present two protection\r\napproaches build on top of the analysis results provided by\r\nMarx: vtable protection and type-safe object reuse. In practice,\r\na C++ application can be analyzed by Marx before deployment\r\nand then set up with the wanted protection.\r\nA. VTable Protection for Binaries\r\nVTable protection and, more generally, Control-Flow In\u0002tegrity (CFI) [7] is a promising way to stop advanced code\u0002reuse attacks. In its ideal form, it limits an attacker by\r\nenforcing that each indirect branch can only target valid—\r\nas intended by the programmer—code paths. Unfortunately,\r\npractical CFI implementations suffer from precision loss when\r\ndetermining the set of valid targets for each branch [11], [19],\r\n[23]. Naturally, this also goes for CFI implementations that\r\nonly protect virtual callsites [15]. Since it is even harder to\r\nrecover class hierarchies of an application without access to\r\nits source code, current state-of-the-art binary-level defenses\r\nrely on weak characteristics to narrow down the set of call\r\ntargets [23]. Examples include looking only at argument count\r\ninformation [28], enforcing that the vtblptr has to point to\r\nread-only memory [13], or allowing all existing vtables at a\r\nvcall [21]. Despite drastically reducing the set of valid targets,\r\nthese approaches may still leave enough wiggle room for\r\nattackers to launch devastating attacks [11], [19], [23].\r\nWith the reconstructed class hierarchies, we can extend\r\nexisting binary-level CFI solutions with a vtable protection.\r\nOur goal is to increase CFI guarantees for C++ applications\r\nby expanding state-of-the-art defenses with a mechanism to\r\nenforce correct class hierarchies for indirect branches. On\r\nthat account, we extract the index into the vtable for each\r\nidentified vcall that is used to determine the function entry\r\n(as explained in Section II-C). With the help of the class\r\nhierarchy, we are then able to generate a function type for\r\nall virtual functions at this position in the class hierarchy.\r\nIn our example shown in Figure 1, functions A::funcA1,\r\nB::funcB1, and thunk to C::funcB1 would get the\r\nsame function type. Obviously, targeting A::funcA1 is not\r\nallowed at vcalls that are used to branch to B::funcB1\r\nand thunk to C::funcB1, indicating an overestimation\r\nof our approach. However, the achieved precision of the call\r\ntarget set is a vast improvement in comparison to existing\r\nbinary-only vtable protection approaches and it remains to be\r\nshown that this small overestimation can be exploited by an\r\nadversary [29].\r\nIdeally, the vtable protection would merely insert a label\r\ncheck before each vcall that verifies whether the target is\r\nof the same function type as the virtual callsite. Since our\r\nstatic analysis is in certain cases not able to precisely assign\r\na hierarchy to each vcall, however, we apply two additional\r\ntechniques:\r\n• Dynamic Analysis. To increase coverage, we run the\r\nbinary in a controlled environment with trusted input\r\n(e. g., by running unit tests). During dynamic analysis,\r\nwe inspect whether (i) executed indirect calls exhibit\r\ncharacteristics of a vcall, (ii) hierarchies used at the\r\nsame vcall are merged together, and (iii) detected\r\nvcalls are in fact vcalls.\r\n• Slow Path. Since our analysis may still miss key\r\ninformation about callsites (e.g., class hierarchy re\u0002lations, leading to false positives), our extension can\r\nenter a slow path when a function type check failed\r\n(treating the failure as an anomaly rather than breaking\r\nthe program). This slow path can be used to further\r\ninvestigate the branch and to decide if it is allowed or\r\nnot.\r\nMoreover, as we are only interested in protecting C++\r\nsemantics, our static analysis filters callsites that are definitely\r\nnot vcalls.\r\nWe implemented a binary-only vtable protection on Linux\r\nfor x86-64, using a similar binary run-time instrumentation\r\nmodel as proposed by Van der Veen et al. [28]: we use\r\nDyninst [10] to move all functions to a protected shadow code\r\nregion and prepend them with a two-byte function type value,\r\nas obtained from our static analysis. Next, we instrument each\r\nvcall with a short sequence of instructions. These instructions\r\ncheck whether the target’s function type matches that of the\r\nvcall. If not, it enters our slow path, which we implemented\r\nby using the PathArmor open source CFI framework [27].\r\nNote that we did not implement our own user-space JIT\r\nverifier, but rather let the kernel module sleep for 10 ms\r\n8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/2edc489d-1aba-463e-9c45-c2d0d5624534.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a84e5b3bccbfcf327e9f498154b6dcd6b17bd370287c1237ff8d97c5d84fc962",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1019
      },
      {
        "segments": [
          {
            "segment_id": "2edc489d-1aba-463e-9c45-c2d0d5624534",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "in a reasonable amount of time and, once again, illustrates how\r\none has to weigh up performance and accuracy. Empirically,\r\nwe determined that a maximum call depth of 2 is sufficient for\r\nanalyzing large real-world applications. Note that, depending\r\non time and resources available to an analyst, higher precision\r\ncan be achieved by increasing this number.\r\nC. Virtual Callsite Identification\r\nEven though the information collected in these steps is\r\nalready helpful for an analyst, we further refine the result and\r\ntry to distinguish vcalls from other indirect call constructs and\r\nonly resolve target sets for the former. To detect a vcall, Marx\r\nsearches for the virtual function dispatch structure described\r\nin Section II-C. As this structure applies to both vcalls and\r\nother types of indirect calls (e. g., function pointers), we\r\nimplemented two modes to resolve the targets: conservative\r\nand non-conservative mode.\r\nIn conservative mode, an indirect call is only identified\r\nas vcall if the thisptr holds a known object and a vtable is\r\ninvolved when computing the target address. This ensures that\r\nthe analysis has an exact state for the thisptr.\r\nIn non-conservative mode, an indirect call is considered to\r\nbe a vcall simply if the vtable is involved in the computation of\r\nthe target address, i. e., we drop the requirement that the thisptr\r\nhas to be valid. Due to missing context during the analysis\r\n(i. e., call depth is depleted), memory locations might not be\r\nidentified as objects and therefore the thisptr check can fail.\r\nThe non-conservative mode allows the analysis to resolve more\r\nvcalls since requirements are relaxed. However, overestimation\r\ncan lead to a higher false positive rate. The difference between\r\nboth modes is further evaluated in Section VI-B.\r\nV. APPLICATIONS\r\nBeyond applications in the area of reverse engineering, the\r\nresults of the reconstructed class hierarchies can also be used\r\nto significantly improve defenses that mitigate attacks against\r\nC++ applications. In this section, we present two protection\r\napproaches build on top of the analysis results provided by\r\nMarx: vtable protection and type-safe object reuse. In practice,\r\na C++ application can be analyzed by Marx before deployment\r\nand then set up with the wanted protection.\r\nA. VTable Protection for Binaries\r\nVTable protection and, more generally, Control-Flow In\u0002tegrity (CFI) [7] is a promising way to stop advanced code\u0002reuse attacks. In its ideal form, it limits an attacker by\r\nenforcing that each indirect branch can only target valid—\r\nas intended by the programmer—code paths. Unfortunately,\r\npractical CFI implementations suffer from precision loss when\r\ndetermining the set of valid targets for each branch [11], [19],\r\n[23]. Naturally, this also goes for CFI implementations that\r\nonly protect virtual callsites [15]. Since it is even harder to\r\nrecover class hierarchies of an application without access to\r\nits source code, current state-of-the-art binary-level defenses\r\nrely on weak characteristics to narrow down the set of call\r\ntargets [23]. Examples include looking only at argument count\r\ninformation [28], enforcing that the vtblptr has to point to\r\nread-only memory [13], or allowing all existing vtables at a\r\nvcall [21]. Despite drastically reducing the set of valid targets,\r\nthese approaches may still leave enough wiggle room for\r\nattackers to launch devastating attacks [11], [19], [23].\r\nWith the reconstructed class hierarchies, we can extend\r\nexisting binary-level CFI solutions with a vtable protection.\r\nOur goal is to increase CFI guarantees for C++ applications\r\nby expanding state-of-the-art defenses with a mechanism to\r\nenforce correct class hierarchies for indirect branches. On\r\nthat account, we extract the index into the vtable for each\r\nidentified vcall that is used to determine the function entry\r\n(as explained in Section II-C). With the help of the class\r\nhierarchy, we are then able to generate a function type for\r\nall virtual functions at this position in the class hierarchy.\r\nIn our example shown in Figure 1, functions A::funcA1,\r\nB::funcB1, and thunk to C::funcB1 would get the\r\nsame function type. Obviously, targeting A::funcA1 is not\r\nallowed at vcalls that are used to branch to B::funcB1\r\nand thunk to C::funcB1, indicating an overestimation\r\nof our approach. However, the achieved precision of the call\r\ntarget set is a vast improvement in comparison to existing\r\nbinary-only vtable protection approaches and it remains to be\r\nshown that this small overestimation can be exploited by an\r\nadversary [29].\r\nIdeally, the vtable protection would merely insert a label\r\ncheck before each vcall that verifies whether the target is\r\nof the same function type as the virtual callsite. Since our\r\nstatic analysis is in certain cases not able to precisely assign\r\na hierarchy to each vcall, however, we apply two additional\r\ntechniques:\r\n• Dynamic Analysis. To increase coverage, we run the\r\nbinary in a controlled environment with trusted input\r\n(e. g., by running unit tests). During dynamic analysis,\r\nwe inspect whether (i) executed indirect calls exhibit\r\ncharacteristics of a vcall, (ii) hierarchies used at the\r\nsame vcall are merged together, and (iii) detected\r\nvcalls are in fact vcalls.\r\n• Slow Path. Since our analysis may still miss key\r\ninformation about callsites (e.g., class hierarchy re\u0002lations, leading to false positives), our extension can\r\nenter a slow path when a function type check failed\r\n(treating the failure as an anomaly rather than breaking\r\nthe program). This slow path can be used to further\r\ninvestigate the branch and to decide if it is allowed or\r\nnot.\r\nMoreover, as we are only interested in protecting C++\r\nsemantics, our static analysis filters callsites that are definitely\r\nnot vcalls.\r\nWe implemented a binary-only vtable protection on Linux\r\nfor x86-64, using a similar binary run-time instrumentation\r\nmodel as proposed by Van der Veen et al. [28]: we use\r\nDyninst [10] to move all functions to a protected shadow code\r\nregion and prepend them with a two-byte function type value,\r\nas obtained from our static analysis. Next, we instrument each\r\nvcall with a short sequence of instructions. These instructions\r\ncheck whether the target’s function type matches that of the\r\nvcall. If not, it enters our slow path, which we implemented\r\nby using the PathArmor open source CFI framework [27].\r\nNote that we did not implement our own user-space JIT\r\nverifier, but rather let the kernel module sleep for 10 ms\r\n8",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/2edc489d-1aba-463e-9c45-c2d0d5624534.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a84e5b3bccbfcf327e9f498154b6dcd6b17bd370287c1237ff8d97c5d84fc962",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1019
      },
      {
        "segments": [
          {
            "segment_id": "56d53d82-fe53-48d2-a514-c3fba40d6337",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "whenever a new path is found. This is to carefully mimic\r\nthe behavior of the original PathArmor’s implementation with\r\nan over-approximation of the average values (Table 3 from\r\nthe PathArmor paper [27]). We also remark that we adopted\r\nPathArmor’s context-sensitive CFI approach to demonstrate\r\nthe feasibility of our protection strategy similar to other\r\nefforts [20], but our system can incorporate any other solution\r\nto operate heavyweight security checks on the slow path.\r\nB. Type-safe Object Reuse\r\nTypically a process reuses freed memory for new alloca\u0002tions blindly. Attackers can abuse this mechanism by exploit\u0002ing use-after-free vulnerabilities, where a malicious object is\r\ncarefully placed in memory that was previously occupied and\r\n(dangling) pointers still point to it. Type-safe memory alloca\u0002tors such as Cling [8] aim at reducing this risk by preventing\r\nmemory chunks of different types from being allocated in the\r\nsame location. Essentially, type-safe memory (and in our case\r\nobject) reuse maintains pools (i. e., memory regions) that are\r\nused for allocating only a particular type of object. Newly\r\nallocated objects are placed only in their own typed pool, and\r\nobjects with different types cannot share a common memory\r\nlocation in the lifetime of the process. Assuming the class\r\nhierarchy of a C++ program is known, types can be defined\r\nbased on class relations. As a result, we can reduce the attack\r\nsurface by forcing pointers of similar typed objects to overlap.\r\nUnlike Cling [8], we focus only on type-safe C++ object reuse,\r\nwith object types derived from the recovered class hierarchy.\r\nOn the other hand, Cling is C++ agnostic in principle and\r\nthe class hierarchy as reconstructed by Marx can significantly\r\nimprove it in handling C++ allocations. The benefit is to reduce\r\nthe number of typed pools (and memory usage) and also avoid\r\nexpensive instrumentation to derive the run-time type (Cling\r\nrelies on callstack hashes rather than offline type information).\r\nTo demonstrate this concept, we built a type-safe object\r\nreuse system based on the class hierarchy exported by Marx.\r\nOur system consists of two parts: an allocator with type\u0002safe object reuse support and a library to instrument object\r\nallocations. The allocator enhances tcmalloc with functions\r\nthat leverage type information to place new objects in type\u0002based pools.\r\nSpecifically, in tcmalloc, pools are subdivided in align\u0002ment pools. For performance reasons, tcmalloc keeps track\r\nof thread-local pools and one central pool. When a thread\u0002local pool reaches a predefined limit of free pages, it transfers\r\nsome of the free pages to the central pool. Merging pools can\r\nbe an issue for typed allocations since different types can end\r\nup in the same pool. Notice that new typed allocations must\r\nbe aligned with past ones. When the allocation size does not\r\ndivide the page size, it is possible that an object overlaps two\r\npages. If this is the case and at least one of the two pages\r\nwith the overlapping object are given back to the central pool,\r\nwe can not guarantee that following allocations are correctly\r\naligned. Therefore, we do not give any memory back from\r\ntyped pools if the alignment size class does not divide the size\r\nof a page.\r\nFinally, our type-safe object reuse application contains a\r\nshared library that instruments all allocations at runtime. The\r\nshared library is preloaded with the protected binary to trigger\r\ntype-based allocations when virtual objects are instantiated and\r\nto resolve the actual allocation type based on the available class\r\nhierarchy. The type resolution works as follows. We start by\r\npreprocessing the analysis of Marx to construct triples of the\r\nform (location, size, type). Here, location is\r\nthe address of the call-site of new, size the size given to new,\r\nand type is a unique identifier. Moreover, the type identifier\r\n(or type tag) is generated by assigning a distinct value to each\r\nunique class hierarchy found by Marx. At runtime, we load the\r\nfile containing these triples and store them in a hashtable. This\r\nhashtable uses the tuple (location, size) as key and\r\nthe type as value. The shared library overrides the new and\r\nnew[] operators, so we can infer the type information before\r\ndispatching to our typed allocation function in tcmalloc.\r\nNote that some allocations may be missed. We stress here that\r\nour intention is to showcase a prototype based on the exported\r\nclass hierarchy and not a mature defense. In a real setting, the\r\nbinary should be rewritten [10] by adding the resolution code\r\nto all callsites that construct virtual objects—eliminating the\r\nneed for any run-time type inference instrumentation.\r\nFor each occurring allocation, the size of the allocation is\r\nused as the key and the location is computed using the return\r\naddress. With this information, the type tag is retrieved from\r\nthe hashtable and passed to the modified allocator function,\r\nwhich maintains a pool per allocated type. When no type exists\r\nfor the particular location and size combination, a value of zero\r\nis returned. The allocator uses this value to choose a fast path,\r\nwhere no typed memory pools are used.\r\nVI. EVALUATION\r\nIn this section, we evaluate Marx and its applications in\r\nterms of performance and accuracy. Unless stated otherwise,\r\nall test cases are compiled using GCC 4.8.5. Our test cases in\u0002clude a variety of real-world applications and shared libraries.\r\nConsequently, no alterations to the compiler options specified\r\nby a test case have been made, i. e., each program is compiled\r\nwith the compiler flags intended by the authors. We evaluated\r\nour class hierarchy reconstruction and virtual callsite target\r\nresolution on Ubuntu 14.04 LTS running on an Intel Core i7-\r\n2600 CPU with 16 GB of RAM.\r\nThe evaluation testbed for our binary vtable protection\r\nand type-safe object reuse implementations is a system with\r\nan Intel Core i7-6700K CPU @ 4.00GHz and 16 GB of\r\nRAM, running Ubuntu 14.04 LTS with Linux kernel 4.2.0 and\r\ntransparent huge paging disabled.\r\nA. Class Hierarchy Reconstruction\r\nThe main goal of our framework is to provide an analyst\r\nwith accurate information about the class hierarchies. Hence,\r\nwe evaluated the precision of Marx by comparing the analysis\r\nresults with the class hierarchies of the application as reported\r\nby the compiler. More specifically, the ground truth is obtained\r\nby parsing the RTTI of the target application. Remember\r\nthat our analysis reconstructs an individual class hierarchy as\r\na set and does not contain information about the direction\r\nof inheritance. Hence, the ground truth is also extracted as\r\na set. Table I shows the accuracy of our class hierarchy\r\nreconstruction for various real-world applications and shared\r\nlibraries. Sizes in the table are given in MiB and are taken\r\nfrom the stripped binaries without debug information.\r\n9",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/56d53d82-fe53-48d2-a514-c3fba40d6337.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19dccb214458d65aa3f9adcef81e3758154f59f217a07c7f2af54eb0e3d9f63a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1094
      },
      {
        "segments": [
          {
            "segment_id": "56d53d82-fe53-48d2-a514-c3fba40d6337",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "whenever a new path is found. This is to carefully mimic\r\nthe behavior of the original PathArmor’s implementation with\r\nan over-approximation of the average values (Table 3 from\r\nthe PathArmor paper [27]). We also remark that we adopted\r\nPathArmor’s context-sensitive CFI approach to demonstrate\r\nthe feasibility of our protection strategy similar to other\r\nefforts [20], but our system can incorporate any other solution\r\nto operate heavyweight security checks on the slow path.\r\nB. Type-safe Object Reuse\r\nTypically a process reuses freed memory for new alloca\u0002tions blindly. Attackers can abuse this mechanism by exploit\u0002ing use-after-free vulnerabilities, where a malicious object is\r\ncarefully placed in memory that was previously occupied and\r\n(dangling) pointers still point to it. Type-safe memory alloca\u0002tors such as Cling [8] aim at reducing this risk by preventing\r\nmemory chunks of different types from being allocated in the\r\nsame location. Essentially, type-safe memory (and in our case\r\nobject) reuse maintains pools (i. e., memory regions) that are\r\nused for allocating only a particular type of object. Newly\r\nallocated objects are placed only in their own typed pool, and\r\nobjects with different types cannot share a common memory\r\nlocation in the lifetime of the process. Assuming the class\r\nhierarchy of a C++ program is known, types can be defined\r\nbased on class relations. As a result, we can reduce the attack\r\nsurface by forcing pointers of similar typed objects to overlap.\r\nUnlike Cling [8], we focus only on type-safe C++ object reuse,\r\nwith object types derived from the recovered class hierarchy.\r\nOn the other hand, Cling is C++ agnostic in principle and\r\nthe class hierarchy as reconstructed by Marx can significantly\r\nimprove it in handling C++ allocations. The benefit is to reduce\r\nthe number of typed pools (and memory usage) and also avoid\r\nexpensive instrumentation to derive the run-time type (Cling\r\nrelies on callstack hashes rather than offline type information).\r\nTo demonstrate this concept, we built a type-safe object\r\nreuse system based on the class hierarchy exported by Marx.\r\nOur system consists of two parts: an allocator with type\u0002safe object reuse support and a library to instrument object\r\nallocations. The allocator enhances tcmalloc with functions\r\nthat leverage type information to place new objects in type\u0002based pools.\r\nSpecifically, in tcmalloc, pools are subdivided in align\u0002ment pools. For performance reasons, tcmalloc keeps track\r\nof thread-local pools and one central pool. When a thread\u0002local pool reaches a predefined limit of free pages, it transfers\r\nsome of the free pages to the central pool. Merging pools can\r\nbe an issue for typed allocations since different types can end\r\nup in the same pool. Notice that new typed allocations must\r\nbe aligned with past ones. When the allocation size does not\r\ndivide the page size, it is possible that an object overlaps two\r\npages. If this is the case and at least one of the two pages\r\nwith the overlapping object are given back to the central pool,\r\nwe can not guarantee that following allocations are correctly\r\naligned. Therefore, we do not give any memory back from\r\ntyped pools if the alignment size class does not divide the size\r\nof a page.\r\nFinally, our type-safe object reuse application contains a\r\nshared library that instruments all allocations at runtime. The\r\nshared library is preloaded with the protected binary to trigger\r\ntype-based allocations when virtual objects are instantiated and\r\nto resolve the actual allocation type based on the available class\r\nhierarchy. The type resolution works as follows. We start by\r\npreprocessing the analysis of Marx to construct triples of the\r\nform (location, size, type). Here, location is\r\nthe address of the call-site of new, size the size given to new,\r\nand type is a unique identifier. Moreover, the type identifier\r\n(or type tag) is generated by assigning a distinct value to each\r\nunique class hierarchy found by Marx. At runtime, we load the\r\nfile containing these triples and store them in a hashtable. This\r\nhashtable uses the tuple (location, size) as key and\r\nthe type as value. The shared library overrides the new and\r\nnew[] operators, so we can infer the type information before\r\ndispatching to our typed allocation function in tcmalloc.\r\nNote that some allocations may be missed. We stress here that\r\nour intention is to showcase a prototype based on the exported\r\nclass hierarchy and not a mature defense. In a real setting, the\r\nbinary should be rewritten [10] by adding the resolution code\r\nto all callsites that construct virtual objects—eliminating the\r\nneed for any run-time type inference instrumentation.\r\nFor each occurring allocation, the size of the allocation is\r\nused as the key and the location is computed using the return\r\naddress. With this information, the type tag is retrieved from\r\nthe hashtable and passed to the modified allocator function,\r\nwhich maintains a pool per allocated type. When no type exists\r\nfor the particular location and size combination, a value of zero\r\nis returned. The allocator uses this value to choose a fast path,\r\nwhere no typed memory pools are used.\r\nVI. EVALUATION\r\nIn this section, we evaluate Marx and its applications in\r\nterms of performance and accuracy. Unless stated otherwise,\r\nall test cases are compiled using GCC 4.8.5. Our test cases in\u0002clude a variety of real-world applications and shared libraries.\r\nConsequently, no alterations to the compiler options specified\r\nby a test case have been made, i. e., each program is compiled\r\nwith the compiler flags intended by the authors. We evaluated\r\nour class hierarchy reconstruction and virtual callsite target\r\nresolution on Ubuntu 14.04 LTS running on an Intel Core i7-\r\n2600 CPU with 16 GB of RAM.\r\nThe evaluation testbed for our binary vtable protection\r\nand type-safe object reuse implementations is a system with\r\nan Intel Core i7-6700K CPU @ 4.00GHz and 16 GB of\r\nRAM, running Ubuntu 14.04 LTS with Linux kernel 4.2.0 and\r\ntransparent huge paging disabled.\r\nA. Class Hierarchy Reconstruction\r\nThe main goal of our framework is to provide an analyst\r\nwith accurate information about the class hierarchies. Hence,\r\nwe evaluated the precision of Marx by comparing the analysis\r\nresults with the class hierarchies of the application as reported\r\nby the compiler. More specifically, the ground truth is obtained\r\nby parsing the RTTI of the target application. Remember\r\nthat our analysis reconstructs an individual class hierarchy as\r\na set and does not contain information about the direction\r\nof inheritance. Hence, the ground truth is also extracted as\r\na set. Table I shows the accuracy of our class hierarchy\r\nreconstruction for various real-world applications and shared\r\nlibraries. Sizes in the table are given in MiB and are taken\r\nfrom the stripped binaries without debug information.\r\n9",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/56d53d82-fe53-48d2-a514-c3fba40d6337.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=19dccb214458d65aa3f9adcef81e3758154f59f217a07c7f2af54eb0e3d9f63a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1094
      },
      {
        "segments": [
          {
            "segment_id": "6ee4e53a-3d02-4c07-9750-d0f76ff3b58b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE I. RESULTS OF THE CLASS HIERARCHY RECONSTRUCTION ANALYSIS. size GIVES THE SIZE OF THE STRIPPED BINARY IN MIB. # GT AND #\r\nanalysis GIVE THE NUMBER OF HIERARCHIES IN THE GROUND TRUTH AND FOUND DURING THE ANALYSIS, RESPECTIVELY. # matching GIVES THE NUMBER\r\nOF HIERARCHIES THAT ARE CORRECTLY RECONSTRUCTED. # overestimated AND # underestimated GIVE THE NUMBER OF RECONSTRUCTED HIERARCHIES\r\nTHAT ARE OVERESTIMATED AND UNDERESTIMATED, RESPECTIVELY. # not found GIVES THE NUMBER OF HIERARCHIES THAT WERE NOT FOUND DURING\r\nTHE ANALYSIS. # not existing GIVES THE NUMBER OF HIERARCHIES THAT WERE FOUND DURING THE ANALYSIS BUT DO NOT EXIST IN THE GROUND TRUTH.\r\ntime needed GIVES THE TIME THAT THE STATIC ANALYSIS NEEDS TO COMPLETE.\r\nProgram size (MiB) #GT # analysis #matching # overestimated # underestimated # not found # not existing time needed (hh:mm:ss)\r\nVboxManage 5.0.24 0.97 33 45 32 – 1 – 9 0:06:12\r\nMySQL Server 5.7.11 23.91 78 117 69 1 7 1 – 11:36:17\r\nMongoDB 3.2.4 27.72 158 253 137 – 8 13 63 1:08:41\r\nNode.js 5.10.1 15.18 59 84 55 2 2 – 14 0:33:16\r\nFileZilla 3.13.1 (GCC 4.9) 4.42 21 9 3 6 4 8 1 1:19:59\r\nVboxRT.so 5.0.24 2.27 3 3 2 – – 1 1 0:00:02\r\nVboxXPCOM.so 5.0.24 1.06 8 14 3 – 2 3 1 0:00:05\r\nlibFLAC++.so 6.3.0 0.10 3 3 3 – – – – 0:00:01\r\nlibebml.so 1.3.3 0.14 2 2 2 – – – – 0:00:01\r\nlibmatroska.so 1.4.4 0.65 2 2 2 – – – – 0:00:17\r\nlibmusicbrainz5cc.so 5.1.0 0.56 3 2 1 – 1 1 – 0:00:01\r\nlibstdc++.so 6.0.18 0.93 5 24 2 – 2 1 – 0:00:01\r\nlibwx baseu-3.1.so 3.1.0 2.55 33 26 26 – – 7 – 0:00:47\r\nlibwx baseu net-3.1.so 3.1.0 0.29 5 7 4 – 1 – – 0:00:01\r\nlibwx gtk2u adv-3.1.so 3.1.0 1.94 20 23 17 1 1 1 – 0:00:21\r\nlibwx gtk2u aui-3.1.so 3.1.0 0.59 7 7 5 1 1 – – 0:00:01\r\nlibwx gtk2u core-3.1.so 3.1.0 5.92 41 46 31 6 2 2 1 0:01:17\r\nlibwx gtk2u html-3.1.so 3.1.0 0.79 5 9 2 2 1 – – 0:00:06\r\nlibwx gtk2u xrc-3.1.so 3.1.0 1.06 4 4 2 1 1 – – 0:00:03\r\nOverall, we observe that Marx is capable of precisely\r\nrecovering the information about the class hierarchies for many\r\ntypes of applications. We find that the results are better for\r\napplications than for shared libraries. For applications, the\r\nanalysis process was able to correctly reconstruct 84.8% of the\r\nhierarchies on average. Only 6.3% are underestimated and also\r\n6.3% of the hierarchies were not found. For shared libraries, on\r\naverage, 72.3% of the hierarchies were correctly reconstructed,\r\nwhile 8.5% of the hierarchies were underestimated and 11.3%\r\nwere not found. Consequently, we conclude that Marx is\r\nable to recover most of the class hierarchies of the target\r\nbinaries completely and therefore provides helpful information\r\nfor an analyst. The difference between applications and shared\r\nlibraries results stem from the fact that the analysis of a\r\nshared object misses a lot of context (cf. Section IV-A).\r\nShared objects are not written to be executed as a standalone\r\napplication. Hence, most functions are not called from within\r\nthe shared object, but only from an application, using the\r\ninterface exposed by the library.\r\nThis is also evident when looking at the time needed\r\nto analyze an application in comparison to a shared library.\r\nAlmost all of the tested shared libraries are analyzed in under a\r\nminute. The functions of applications are more connected with\r\neach other through calls. Since Marx follows these connections\r\nand analyzes the called functions within the current context, it\r\nneeds more time to analyze the whole application. In contrast,\r\nshared libraries tend to provide a rather “flat” functionality and\r\ndo not have so many connected functions. Hence, analyzing\r\nthem is faster.\r\nThe application with the best results is VboxManage. Marx\r\nunderestimated only one hierarchy and correctly reconstructed\r\nthe remaining 32. However, Marx also found 9 hierarchies\r\nthat do not exist in the application. Note that non-existing\r\nhierarchies are most likely not used in code constructs such\r\nas vcalls or object creation at a new operator. Hence, in\r\napplications such as vtable protection or type-safe object reuse\r\nsuch overestimations have no effect and do not influence the\r\nresults.\r\nFor the largest application, MongoDB, Marx was able\r\nto reconstruct 137 out of 158 hierarchies correctly. Only\r\n8 hierarchies were underestimated and 13 were not found\r\nduring the analysis. Most of these missing hierarchies are\r\nconnected via an abstract class which was not referenced in the\r\nbinary code (most likely due to compiler optimizations) and\r\nhence not found during the analysis. For the largest shared\r\nlibrary, libwx gtk2u core-3.1.so, 31 hierarchies were correctly\r\nreconstructed. 2 hierarchies were underestimated and only 2\r\nwere not found during the analysis.\r\nThe application FileZilla had to be compiled with GCC\r\n4.9 since it requires support for C++14, which is not available\r\nfor GCC 4.8. It has the worst results of all test cases, as\r\nonly 3 out of 21 hierarchies were reconstructed correctly. 6\r\nhierarchies were overestimated during reconstruction, 4 under\u0002estimated, and 8 not found at all. A manual evaluation of the\r\nunderestimated and missing hierarchies yields two reasons for\r\nthese results: First, most of these hierarchies are connected\r\nvia classes for which no vtable has been emitted by the\r\ncompiler, which is why Marx cannot leverage them. This is\r\ndue to optimization passes that remove these vtables from\r\nthe binary. A detailed discussion is given in Section VII.\r\nSecond, FileZilla makes heavy use of the wxWidgets library\r\n(i.e., the shared objects with libwx prefix in Table I). Some\r\nunderestimated hierarchies are connected via vtables from\r\nthese shared objects. Despite Marx’s inter-modular data flow\r\nability, it was not able to find a connection between all classes\r\nof the underestimated hierarchy with the external ones. A\r\nmanual investigation revealed that not all classes (despite their\r\nconnection to an external class according to RTTI) execute a\r\nlibrary function that overwrites the vtblptr—presumably due\r\nto compiler optimizations.\r\nB. Virtual Callsite Targets\r\nWith static analysis, it is hard to determine the target func\u0002tion of an indirect call. As noted earlier, for binaries compiled\r\nfrom C++ code, virtual functions are mostly implemented\r\nusing indirect call instructions. To assist a reverse engineer,\r\nour static analysis hence attempts to resolve the target set of a\r\nvcall as accurately as possible. To evaluate the correctness of\r\n10",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/6ee4e53a-3d02-4c07-9750-d0f76ff3b58b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20cd8a4c1e78bc5820e6122d45c539d3032e6ddc8463c5706b16207eddc2dd2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1060
      },
      {
        "segments": [
          {
            "segment_id": "6ee4e53a-3d02-4c07-9750-d0f76ff3b58b",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE I. RESULTS OF THE CLASS HIERARCHY RECONSTRUCTION ANALYSIS. size GIVES THE SIZE OF THE STRIPPED BINARY IN MIB. # GT AND #\r\nanalysis GIVE THE NUMBER OF HIERARCHIES IN THE GROUND TRUTH AND FOUND DURING THE ANALYSIS, RESPECTIVELY. # matching GIVES THE NUMBER\r\nOF HIERARCHIES THAT ARE CORRECTLY RECONSTRUCTED. # overestimated AND # underestimated GIVE THE NUMBER OF RECONSTRUCTED HIERARCHIES\r\nTHAT ARE OVERESTIMATED AND UNDERESTIMATED, RESPECTIVELY. # not found GIVES THE NUMBER OF HIERARCHIES THAT WERE NOT FOUND DURING\r\nTHE ANALYSIS. # not existing GIVES THE NUMBER OF HIERARCHIES THAT WERE FOUND DURING THE ANALYSIS BUT DO NOT EXIST IN THE GROUND TRUTH.\r\ntime needed GIVES THE TIME THAT THE STATIC ANALYSIS NEEDS TO COMPLETE.\r\nProgram size (MiB) #GT # analysis #matching # overestimated # underestimated # not found # not existing time needed (hh:mm:ss)\r\nVboxManage 5.0.24 0.97 33 45 32 – 1 – 9 0:06:12\r\nMySQL Server 5.7.11 23.91 78 117 69 1 7 1 – 11:36:17\r\nMongoDB 3.2.4 27.72 158 253 137 – 8 13 63 1:08:41\r\nNode.js 5.10.1 15.18 59 84 55 2 2 – 14 0:33:16\r\nFileZilla 3.13.1 (GCC 4.9) 4.42 21 9 3 6 4 8 1 1:19:59\r\nVboxRT.so 5.0.24 2.27 3 3 2 – – 1 1 0:00:02\r\nVboxXPCOM.so 5.0.24 1.06 8 14 3 – 2 3 1 0:00:05\r\nlibFLAC++.so 6.3.0 0.10 3 3 3 – – – – 0:00:01\r\nlibebml.so 1.3.3 0.14 2 2 2 – – – – 0:00:01\r\nlibmatroska.so 1.4.4 0.65 2 2 2 – – – – 0:00:17\r\nlibmusicbrainz5cc.so 5.1.0 0.56 3 2 1 – 1 1 – 0:00:01\r\nlibstdc++.so 6.0.18 0.93 5 24 2 – 2 1 – 0:00:01\r\nlibwx baseu-3.1.so 3.1.0 2.55 33 26 26 – – 7 – 0:00:47\r\nlibwx baseu net-3.1.so 3.1.0 0.29 5 7 4 – 1 – – 0:00:01\r\nlibwx gtk2u adv-3.1.so 3.1.0 1.94 20 23 17 1 1 1 – 0:00:21\r\nlibwx gtk2u aui-3.1.so 3.1.0 0.59 7 7 5 1 1 – – 0:00:01\r\nlibwx gtk2u core-3.1.so 3.1.0 5.92 41 46 31 6 2 2 1 0:01:17\r\nlibwx gtk2u html-3.1.so 3.1.0 0.79 5 9 2 2 1 – – 0:00:06\r\nlibwx gtk2u xrc-3.1.so 3.1.0 1.06 4 4 2 1 1 – – 0:00:03\r\nOverall, we observe that Marx is capable of precisely\r\nrecovering the information about the class hierarchies for many\r\ntypes of applications. We find that the results are better for\r\napplications than for shared libraries. For applications, the\r\nanalysis process was able to correctly reconstruct 84.8% of the\r\nhierarchies on average. Only 6.3% are underestimated and also\r\n6.3% of the hierarchies were not found. For shared libraries, on\r\naverage, 72.3% of the hierarchies were correctly reconstructed,\r\nwhile 8.5% of the hierarchies were underestimated and 11.3%\r\nwere not found. Consequently, we conclude that Marx is\r\nable to recover most of the class hierarchies of the target\r\nbinaries completely and therefore provides helpful information\r\nfor an analyst. The difference between applications and shared\r\nlibraries results stem from the fact that the analysis of a\r\nshared object misses a lot of context (cf. Section IV-A).\r\nShared objects are not written to be executed as a standalone\r\napplication. Hence, most functions are not called from within\r\nthe shared object, but only from an application, using the\r\ninterface exposed by the library.\r\nThis is also evident when looking at the time needed\r\nto analyze an application in comparison to a shared library.\r\nAlmost all of the tested shared libraries are analyzed in under a\r\nminute. The functions of applications are more connected with\r\neach other through calls. Since Marx follows these connections\r\nand analyzes the called functions within the current context, it\r\nneeds more time to analyze the whole application. In contrast,\r\nshared libraries tend to provide a rather “flat” functionality and\r\ndo not have so many connected functions. Hence, analyzing\r\nthem is faster.\r\nThe application with the best results is VboxManage. Marx\r\nunderestimated only one hierarchy and correctly reconstructed\r\nthe remaining 32. However, Marx also found 9 hierarchies\r\nthat do not exist in the application. Note that non-existing\r\nhierarchies are most likely not used in code constructs such\r\nas vcalls or object creation at a new operator. Hence, in\r\napplications such as vtable protection or type-safe object reuse\r\nsuch overestimations have no effect and do not influence the\r\nresults.\r\nFor the largest application, MongoDB, Marx was able\r\nto reconstruct 137 out of 158 hierarchies correctly. Only\r\n8 hierarchies were underestimated and 13 were not found\r\nduring the analysis. Most of these missing hierarchies are\r\nconnected via an abstract class which was not referenced in the\r\nbinary code (most likely due to compiler optimizations) and\r\nhence not found during the analysis. For the largest shared\r\nlibrary, libwx gtk2u core-3.1.so, 31 hierarchies were correctly\r\nreconstructed. 2 hierarchies were underestimated and only 2\r\nwere not found during the analysis.\r\nThe application FileZilla had to be compiled with GCC\r\n4.9 since it requires support for C++14, which is not available\r\nfor GCC 4.8. It has the worst results of all test cases, as\r\nonly 3 out of 21 hierarchies were reconstructed correctly. 6\r\nhierarchies were overestimated during reconstruction, 4 under\u0002estimated, and 8 not found at all. A manual evaluation of the\r\nunderestimated and missing hierarchies yields two reasons for\r\nthese results: First, most of these hierarchies are connected\r\nvia classes for which no vtable has been emitted by the\r\ncompiler, which is why Marx cannot leverage them. This is\r\ndue to optimization passes that remove these vtables from\r\nthe binary. A detailed discussion is given in Section VII.\r\nSecond, FileZilla makes heavy use of the wxWidgets library\r\n(i.e., the shared objects with libwx prefix in Table I). Some\r\nunderestimated hierarchies are connected via vtables from\r\nthese shared objects. Despite Marx’s inter-modular data flow\r\nability, it was not able to find a connection between all classes\r\nof the underestimated hierarchy with the external ones. A\r\nmanual investigation revealed that not all classes (despite their\r\nconnection to an external class according to RTTI) execute a\r\nlibrary function that overwrites the vtblptr—presumably due\r\nto compiler optimizations.\r\nB. Virtual Callsite Targets\r\nWith static analysis, it is hard to determine the target func\u0002tion of an indirect call. As noted earlier, for binaries compiled\r\nfrom C++ code, virtual functions are mostly implemented\r\nusing indirect call instructions. To assist a reverse engineer,\r\nour static analysis hence attempts to resolve the target set of a\r\nvcall as accurately as possible. To evaluate the correctness of\r\n10",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/6ee4e53a-3d02-4c07-9750-d0f76ff3b58b.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=20cd8a4c1e78bc5820e6122d45c539d3032e6ddc8463c5706b16207eddc2dd2c",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1060
      },
      {
        "segments": [
          {
            "segment_id": "acd61301-1cf8-4d5f-b633-24829f43a5da",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE II. RESULTS OF THE VIRTUAL CALLSITE RESOLUTION. # GT AND # analysis GIVE THE NUMBER OF VIRTUAL CALLSITES IN THE GROUND TRUTH\r\nAND THE FRAMEWORK’S RESULTS, RESPECTIVELY. # correct GIVES THE NUMBER OF VIRTUAL CALLSITES IDENTIFIED CORRECTLY. identified GIVES THE\r\nVALUE IN PERCENT OF HOW MANY VIRTUAL CALLSITES OF THE GROUND TRUTH ARE IDENTIFIED. # resolved GIVES THE NUMBER OF RESOLVED VIRTUAL\r\nCALLSITE TARGETS FOR THE NON-CONSERVATIVE AND CONSERVATIVE MODE (THE LATTER IN PARENTHESES). # matching GIVES THE NUMBER OF\r\nRESOLVED TARGETS WHICH MATCH COMPLETELY WITH THE GROUND TRUTH. # overestimated AND # underestimated GIVE THE NUMBER OF TARGET SETS\r\nTHAT ARE OVERESTIMATED AND UNDERESTIMATED, RESPECTIVELY. # not existing GIVES THE NUMBER OF VIRTUAL CALLLSITES RESOLVED THAT DO NOT\r\nEXIST IN THE GROUND TRUTH.\r\nFinding Virtual Callsites Resolving Virtual Callsites\r\nProgram #GT # analysis # correct identified # resolved #matching # overestimated # underestimated # not existing\r\nVboxManage ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\r\nMySQL Server ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\r\nMongoDB 14357 13369 12607 87.8% 736 (589) 159 (91) 550 (471) 27 (27) 0 (0)\r\nNode.js 4925 5591 4879 99.0% 798 (754) 166 (142) 629 (611) 1 (0) 2 (1)\r\nFileZilla 2779 2544 2495 89.7% 226 (210) 3 (3) 56 (48) 167 (159) 0 (0)\r\nthe analysis, we utilize the VTV (Virtual Table Verification)\r\nGCC pass [26] to generate the ground truth. VTV collects\r\nclass information at compile time and emits code that verifies\r\neach virtual call before (potentially) executing it. Verification\r\nis performed by checking the object’s vtable against a set of\r\nallowed vtables. In essence, this performs a check against a\r\nspecific class hierarchy. For our ground truth, we extract said\r\ninformation and try to match it to the vcall it guards. As test\r\ncases, we evaluated the applications used in Section VI-A.\r\nUnfortunately, we were unable to compile the applications\r\nMySQL Server and VBoxManage with VTV. More specifically,\r\nthe compiler crashed during the compilation of MySQL Server\r\nand for VBoxManage we were not able to pass the configure\r\nscript.\r\nTable II shows the results of the vcall target resolution.\r\nRemember that non-conservative mode did not require validity\r\nof the thisptr, but only a dependency on the vtblptr when\r\ncalculating the target address. As evident from the table, non\u0002conservative mode is able to resolve more vcalls during the\r\nanalysis. Furthermore, the false positive rate did not increase\r\nsignificantly.\r\nFor the application Node.js, only 2 vcalls were wrongly\r\ndetected in non-conservative mode, whereas only 1 was not\r\nfound in conservative mode. In turn, the non-conservative\r\nmode finds 43 vcalls more compared to conservative mode.\r\nAll in all, for Node.js, the analysis was able to identify 4,879\r\nvcalls correctly, which are 99.0% of all virtual callsites.\r\nThe worst results were achieved for FileZilla. The analysis\r\nwas only able to resolve 3 vcalls correctly and most of the re\u0002maining resolved vcalls were underestimated. This results from\r\nthe relatively poor results during class hierarchy reconstruction\r\nin comparison to the other applications. Due to missing and\r\nunderestimated hierarchies, Marx underestimates the targets\r\nof most of the resolved vcalls. However, 2,495 vcalls were\r\nidentified correctly, which are 89.7% of all virtual callsites.\r\nOverall, Marx is able to support an analyst by providing\r\nhim with potential target addresses for vcalls. Depending on\r\nthe precision of the class hierarchy reconstruction, the set of\r\ntarget addresses might be underestimated. However, most of\r\nthe target sets are overestimated such that the analyst does not\r\nmiss branches during the analysis. On average, 90.5% of all\r\nvirtual callsites were identified by Marx during the analysis.\r\nWhile the results of the call target resolution are helpful for\r\na reverse engineer, more comprehensive target sets can be\r\nobtained by combining our static approach with a dynamic\r\nprofiling phase (such as in Section V-A).\r\nC. VTable Protection\r\nWe focus the performance evaluation of our vtable protec\u0002tion implementation on two popular Linux C++ servers and\r\nthe seven C++ applications found in SPEC. Specifically, we\r\nevaluated our binary vtable protection with a cross-platform\r\nruntime environment for server-side web applications (Node.js\r\n5.10.1, statically compiled with Google’s v8 JavaScript engine)\r\nand a database server (MySQL 5.7.11). To benchmark Node.js,\r\nwe configured the Apache benchmark [1] to issue 250,000\r\nrequests with 10 concurrent connections and 10 requests per\r\nconnection for the default page. To benchmark MySQL, we\r\nconfigured the Sysbench OLTP benchmark [4] to issue 10,000\r\ntransactions using a read-write workload.\r\nWe evaluated our vtable protection instrumentation using\r\nthe analysis results from Marx. To determine the impact\r\non runtime performance, we measured the time to complete\r\nthe execution of the benchmarks and compared against the\r\nbaseline—i.e., the original version of the benchmark with no\r\nbinary instrumentation applied. Table III details our results.\r\nAs shown in the table, it is evident, considering the massive\r\nnumber of executed virtual calls, that our vtable protection\r\nperforms surprisingly well—10.8% runtime overhead across\r\nall the tested applications (geometric mean). Interestingly,\r\nthere seems to be no direct correlation between the number\r\nof executed virtual calls and the resulting overhead. SPEC\r\nbinaries astar and povray, for example, both execute over\r\n4.5 billion virtual calls—all resolved using Marx’s analysis\r\nresults—but yield fairly different runtime overheads: 3% for\r\nastar, vs 10% for povray, a delta that might be caused\r\nby CPU caching behavior. We believe that these results are\r\nencouraging: they demonstrate that enforcing vtable protection\r\n(or CFI) over likely (rather than precise) invariants by using a\r\nslow path for second-stage verification is feasible in practice.\r\nD. Type-safe Object Reuse\r\nTo evaluate our type-safe object reuse application, imple\u0002mented on top of Marx, we ran experiments on the same set of\r\napplications described in Section VI-C. Table IV presents our\r\nresults. The first two columns contain the number of unique\r\nnew (including new[]) callsites and types found by Marx’s\r\nanalysis. Next, we present the number of unique types caught\r\nby our library, followed by the number of times malloc, new\r\nand new[] were called (either typed or untyped) during the\r\nbenchmark. Finally, we show the overhead from our library.\r\nWe observe a slight speedup for astar, povray and soplex.\r\nAs can be observed from Table IV, the latter two are not heavy\r\n11",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/acd61301-1cf8-4d5f-b633-24829f43a5da.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8398b7b9b99afcfef07fead852271a50a9f00c358fd4e50f8adcd61609334f3b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1024
      },
      {
        "segments": [
          {
            "segment_id": "acd61301-1cf8-4d5f-b633-24829f43a5da",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE II. RESULTS OF THE VIRTUAL CALLSITE RESOLUTION. # GT AND # analysis GIVE THE NUMBER OF VIRTUAL CALLSITES IN THE GROUND TRUTH\r\nAND THE FRAMEWORK’S RESULTS, RESPECTIVELY. # correct GIVES THE NUMBER OF VIRTUAL CALLSITES IDENTIFIED CORRECTLY. identified GIVES THE\r\nVALUE IN PERCENT OF HOW MANY VIRTUAL CALLSITES OF THE GROUND TRUTH ARE IDENTIFIED. # resolved GIVES THE NUMBER OF RESOLVED VIRTUAL\r\nCALLSITE TARGETS FOR THE NON-CONSERVATIVE AND CONSERVATIVE MODE (THE LATTER IN PARENTHESES). # matching GIVES THE NUMBER OF\r\nRESOLVED TARGETS WHICH MATCH COMPLETELY WITH THE GROUND TRUTH. # overestimated AND # underestimated GIVE THE NUMBER OF TARGET SETS\r\nTHAT ARE OVERESTIMATED AND UNDERESTIMATED, RESPECTIVELY. # not existing GIVES THE NUMBER OF VIRTUAL CALLLSITES RESOLVED THAT DO NOT\r\nEXIST IN THE GROUND TRUTH.\r\nFinding Virtual Callsites Resolving Virtual Callsites\r\nProgram #GT # analysis # correct identified # resolved #matching # overestimated # underestimated # not existing\r\nVboxManage ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\r\nMySQL Server ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\r\nMongoDB 14357 13369 12607 87.8% 736 (589) 159 (91) 550 (471) 27 (27) 0 (0)\r\nNode.js 4925 5591 4879 99.0% 798 (754) 166 (142) 629 (611) 1 (0) 2 (1)\r\nFileZilla 2779 2544 2495 89.7% 226 (210) 3 (3) 56 (48) 167 (159) 0 (0)\r\nthe analysis, we utilize the VTV (Virtual Table Verification)\r\nGCC pass [26] to generate the ground truth. VTV collects\r\nclass information at compile time and emits code that verifies\r\neach virtual call before (potentially) executing it. Verification\r\nis performed by checking the object’s vtable against a set of\r\nallowed vtables. In essence, this performs a check against a\r\nspecific class hierarchy. For our ground truth, we extract said\r\ninformation and try to match it to the vcall it guards. As test\r\ncases, we evaluated the applications used in Section VI-A.\r\nUnfortunately, we were unable to compile the applications\r\nMySQL Server and VBoxManage with VTV. More specifically,\r\nthe compiler crashed during the compilation of MySQL Server\r\nand for VBoxManage we were not able to pass the configure\r\nscript.\r\nTable II shows the results of the vcall target resolution.\r\nRemember that non-conservative mode did not require validity\r\nof the thisptr, but only a dependency on the vtblptr when\r\ncalculating the target address. As evident from the table, non\u0002conservative mode is able to resolve more vcalls during the\r\nanalysis. Furthermore, the false positive rate did not increase\r\nsignificantly.\r\nFor the application Node.js, only 2 vcalls were wrongly\r\ndetected in non-conservative mode, whereas only 1 was not\r\nfound in conservative mode. In turn, the non-conservative\r\nmode finds 43 vcalls more compared to conservative mode.\r\nAll in all, for Node.js, the analysis was able to identify 4,879\r\nvcalls correctly, which are 99.0% of all virtual callsites.\r\nThe worst results were achieved for FileZilla. The analysis\r\nwas only able to resolve 3 vcalls correctly and most of the re\u0002maining resolved vcalls were underestimated. This results from\r\nthe relatively poor results during class hierarchy reconstruction\r\nin comparison to the other applications. Due to missing and\r\nunderestimated hierarchies, Marx underestimates the targets\r\nof most of the resolved vcalls. However, 2,495 vcalls were\r\nidentified correctly, which are 89.7% of all virtual callsites.\r\nOverall, Marx is able to support an analyst by providing\r\nhim with potential target addresses for vcalls. Depending on\r\nthe precision of the class hierarchy reconstruction, the set of\r\ntarget addresses might be underestimated. However, most of\r\nthe target sets are overestimated such that the analyst does not\r\nmiss branches during the analysis. On average, 90.5% of all\r\nvirtual callsites were identified by Marx during the analysis.\r\nWhile the results of the call target resolution are helpful for\r\na reverse engineer, more comprehensive target sets can be\r\nobtained by combining our static approach with a dynamic\r\nprofiling phase (such as in Section V-A).\r\nC. VTable Protection\r\nWe focus the performance evaluation of our vtable protec\u0002tion implementation on two popular Linux C++ servers and\r\nthe seven C++ applications found in SPEC. Specifically, we\r\nevaluated our binary vtable protection with a cross-platform\r\nruntime environment for server-side web applications (Node.js\r\n5.10.1, statically compiled with Google’s v8 JavaScript engine)\r\nand a database server (MySQL 5.7.11). To benchmark Node.js,\r\nwe configured the Apache benchmark [1] to issue 250,000\r\nrequests with 10 concurrent connections and 10 requests per\r\nconnection for the default page. To benchmark MySQL, we\r\nconfigured the Sysbench OLTP benchmark [4] to issue 10,000\r\ntransactions using a read-write workload.\r\nWe evaluated our vtable protection instrumentation using\r\nthe analysis results from Marx. To determine the impact\r\non runtime performance, we measured the time to complete\r\nthe execution of the benchmarks and compared against the\r\nbaseline—i.e., the original version of the benchmark with no\r\nbinary instrumentation applied. Table III details our results.\r\nAs shown in the table, it is evident, considering the massive\r\nnumber of executed virtual calls, that our vtable protection\r\nperforms surprisingly well—10.8% runtime overhead across\r\nall the tested applications (geometric mean). Interestingly,\r\nthere seems to be no direct correlation between the number\r\nof executed virtual calls and the resulting overhead. SPEC\r\nbinaries astar and povray, for example, both execute over\r\n4.5 billion virtual calls—all resolved using Marx’s analysis\r\nresults—but yield fairly different runtime overheads: 3% for\r\nastar, vs 10% for povray, a delta that might be caused\r\nby CPU caching behavior. We believe that these results are\r\nencouraging: they demonstrate that enforcing vtable protection\r\n(or CFI) over likely (rather than precise) invariants by using a\r\nslow path for second-stage verification is feasible in practice.\r\nD. Type-safe Object Reuse\r\nTo evaluate our type-safe object reuse application, imple\u0002mented on top of Marx, we ran experiments on the same set of\r\napplications described in Section VI-C. Table IV presents our\r\nresults. The first two columns contain the number of unique\r\nnew (including new[]) callsites and types found by Marx’s\r\nanalysis. Next, we present the number of unique types caught\r\nby our library, followed by the number of times malloc, new\r\nand new[] were called (either typed or untyped) during the\r\nbenchmark. Finally, we show the overhead from our library.\r\nWe observe a slight speedup for astar, povray and soplex.\r\nAs can be observed from Table IV, the latter two are not heavy\r\n11",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/acd61301-1cf8-4d5f-b633-24829f43a5da.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8398b7b9b99afcfef07fead852271a50a9f00c358fd4e50f8adcd61609334f3b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1024
      },
      {
        "segments": [
          {
            "segment_id": "2bbf2dcb-3104-495e-a5e7-31b7bee38ba3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE III. EVALUATION RESULTS FOR OUR BINARY VTABLE PROTECTION IMPLEMENTATION. FOR EACH BINARY, THE TABLE SHOWS (I) Binary\r\nInstrumentation DETAILS, DEPICTING THE NUMBER OF INSTRUMENTED vcalls, WRITTEN labels AND moved FUNCTIONS; (II) Runtime Statistics, LISTING THE\r\nNUMBER OF vcalls executed AT RUNTIME, THE NUMBER OF VCALLS FOR WHICH A MATCHING TYPE WAS FOUND AT THE TARGET FUNCTION (fastpath), THE\r\nNUMBER OF TIMES THE slowpath WAS ENTERED, AND THE NUMBER OF unique PATHS THAT REQUIRE JIT VERIFICATION; AND (III) Normalized Runtime,\r\nLISTING OUR VTABLE PROTECTION RUNTIME OVERHEAD WITHOUT VERIFICATION (hashing only) AND WITH A SYNTHETIC VERIFICATION TIMEOUT OF\r\n10MS PER UNIQUE PATH (+verification).\r\nBinary Instrumentation Runtime Statistics Normalized Runtime\r\nProgram # vcalls # labels #moved # vcalls executed # fastpath # slowpath # unique hashing only +verification\r\nMySQL 10,864 8,421 28,971 106,330,186 105,035,488 1,294,698 9 1.145 1.155\r\nNode.js 5,905 5,917 26,751 31,491,929 31,491,918 11 6 1.263 1.265\r\nastar 1 1 96 4,595,981,552 4,595,981,552 0 – 1.031 1.031\r\ndealII 1,434 1,428 7,217 96,751,718 96,751,718 0 – 1.012 1.012\r\nnamd 2 3 102 2,016 2,016 0 – 0.999 0.999\r\nomnetpp 706 725 1,949 2,061,547,468 2,061,206,142 341,326 361 1.067 1.083\r\npovray 109 111 1,622 4,704,273,295 4,704,273,295 0 – 1.103 1.103\r\nsoplex 497 498 873 1,772,890 1,155,673 617,217 661 1.016 1.086\r\nxalancbmk 9,303 9,340 12,808 8,306,798,756 8,306,260,183 538,573 111 1.264 1.272\r\ngeomean 342 350 2,318 91,018,910 86,672,172 0 67 1.096 1.108\r\nTABLE IV. EVALUATION RESULTS FOR OUR TYPE-SAFE OBJECT REUSE IMPLEMENTATION. FOR EACH BINARY, THE TABLE SHOWS (I) Marx Statistics,\r\nDEPICTING THE NUMBER OF EXTRACTED N E W CALLS AND THE NUMBER OF DIFFERENT T Y P E S; (II) Runtime Statistics, LISTING THE NUMBER OF USED\r\nT Y P E S, CALLS TO M A L L O C, N E W, AND THE N E W-ARRAY OPERATOR DURING EXECUTION, AND (III) Normalized Runtime.\r\nMarx Statistics Runtime Statistics Normalized Runtime\r\nProgram #new # types # types #malloc #new #new[] overhead\r\nMySQL 1,017 47 16 2,705,675 82,225 13 1.009\r\nNode.js 4,675 38 14 7,685,562 12,228,927 9,093,605 1.022\r\nastar 11 0 0 1,008,577 108,037 8 0.999\r\ndealII 1,632 11 5 48 144,642,689 6,616,448 1.016\r\nnamd 584 2 1 2 2 1,320 0.999\r\nomnetpp 717 9 1 45,950,697 0 221,218,929 1.028\r\npovray 54 7 6 2,414,075 83 176 0.995\r\nsoplex 20 6 2 3,718 3 4 0.997\r\nxalancbmk 2,051 167 46 6,854 135,148,541 158 1.046\r\ngeomean 350 6 2 56,309 6,032 3,888 1.012\r\nusers of the new and new[] operators, and although astar\r\nperforms many calls to new, we detected no types during its\r\nexecution. This is caused by the fact that astar does not rely\r\non many C++ features [16]: Marx recovered one vtable which\r\nis never written into a heap object in the program. Thus, the\r\nnew operator is never used with a type.\r\nOur results for the real-world applications Node.js and\r\nMySQL are much more realistic compared to the SPEC bench\u0002marks: our type-safe object reuse implementation captures a\r\nsignificant fraction of the C++ types as reconstructed by Marx.\r\nAlthough both applications heavily depend on C++ objects, the\r\noverhead imposed by the type-safe object reuse application\r\nis low. For example, in Node.js, we recorded more than 21\r\nmillion new objects, while its normalized runtime is 2.2%. We\r\nthink that these results are encouraging: type-safe object reuse\r\nprovides significant security invariants, while our experiments\r\nreport a performance overhead of less than 5% (geometric\r\nmean).\r\nVII. DISCUSSION\r\nIn the following, we discuss the effects of compiler opti\u0002mizations on our analysis and review several ways to optimize\r\nour prototype implementation.\r\nA. Compiler Optimizations and Lost Information\r\nEven though all of our evaluation results are encouraging,\r\nwe note that the biggest limitations of our approach are due\r\nto compiler optimizations and a loss of information on the\r\nbinary level. Inherently, Marx is dependent on vtables (and\r\nreferences to them) emitted by the compiler. Especially for\r\nabstract base classes, however, such relations may not be\r\nrevealed by certain vtable usage patterns; the information is\r\nsimply missing from the binary and we cannot recover this\r\ninformation. This increases the observable gap between the\r\nformal class hierarchy as set up by the programmer and the\r\nresults obtained by Marx, based on artifacts found in the\r\n(optimized) binary itself.\r\nSuch a case was encountered during the evaluation of\r\nFileZilla. A compiler optimization removed vtables of ab\u0002stract classes from the binary which were the base classes\r\nof complete hierarchies. As a result, the overwrite analysis\r\nfailed to join the smaller hierarchies. Since the vtables did\r\nnot have other characteristics that allows our approach to find\r\na connection (e. g., via heuristics discussed previously), the\r\nreconstructed hierarchies were either not complete or not found\r\nat all. Hence, the quality of our results depends on the size of\r\nthe gap between the formal and the actual class hierarchy as\r\nencoded in the binary.\r\nOther than this, we did not encounter any application\u0002specific idiom that affect the accuracy of our results.\r\nB. Improving Analysis Contexts\r\nSince our static analysis approach focuses on real-world\r\napplications, we had to weigh up precision against performance\r\nto be able to scale to complex binaries. Hence, we introduced\r\n12",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/2bbf2dcb-3104-495e-a5e7-31b7bee38ba3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=017ba61db310519b0160189e282dd1b97c12361baed0aa3f2c60b63703331bc7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 847
      },
      {
        "segments": [
          {
            "segment_id": "2bbf2dcb-3104-495e-a5e7-31b7bee38ba3",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "TABLE III. EVALUATION RESULTS FOR OUR BINARY VTABLE PROTECTION IMPLEMENTATION. FOR EACH BINARY, THE TABLE SHOWS (I) Binary\r\nInstrumentation DETAILS, DEPICTING THE NUMBER OF INSTRUMENTED vcalls, WRITTEN labels AND moved FUNCTIONS; (II) Runtime Statistics, LISTING THE\r\nNUMBER OF vcalls executed AT RUNTIME, THE NUMBER OF VCALLS FOR WHICH A MATCHING TYPE WAS FOUND AT THE TARGET FUNCTION (fastpath), THE\r\nNUMBER OF TIMES THE slowpath WAS ENTERED, AND THE NUMBER OF unique PATHS THAT REQUIRE JIT VERIFICATION; AND (III) Normalized Runtime,\r\nLISTING OUR VTABLE PROTECTION RUNTIME OVERHEAD WITHOUT VERIFICATION (hashing only) AND WITH A SYNTHETIC VERIFICATION TIMEOUT OF\r\n10MS PER UNIQUE PATH (+verification).\r\nBinary Instrumentation Runtime Statistics Normalized Runtime\r\nProgram # vcalls # labels #moved # vcalls executed # fastpath # slowpath # unique hashing only +verification\r\nMySQL 10,864 8,421 28,971 106,330,186 105,035,488 1,294,698 9 1.145 1.155\r\nNode.js 5,905 5,917 26,751 31,491,929 31,491,918 11 6 1.263 1.265\r\nastar 1 1 96 4,595,981,552 4,595,981,552 0 – 1.031 1.031\r\ndealII 1,434 1,428 7,217 96,751,718 96,751,718 0 – 1.012 1.012\r\nnamd 2 3 102 2,016 2,016 0 – 0.999 0.999\r\nomnetpp 706 725 1,949 2,061,547,468 2,061,206,142 341,326 361 1.067 1.083\r\npovray 109 111 1,622 4,704,273,295 4,704,273,295 0 – 1.103 1.103\r\nsoplex 497 498 873 1,772,890 1,155,673 617,217 661 1.016 1.086\r\nxalancbmk 9,303 9,340 12,808 8,306,798,756 8,306,260,183 538,573 111 1.264 1.272\r\ngeomean 342 350 2,318 91,018,910 86,672,172 0 67 1.096 1.108\r\nTABLE IV. EVALUATION RESULTS FOR OUR TYPE-SAFE OBJECT REUSE IMPLEMENTATION. FOR EACH BINARY, THE TABLE SHOWS (I) Marx Statistics,\r\nDEPICTING THE NUMBER OF EXTRACTED N E W CALLS AND THE NUMBER OF DIFFERENT T Y P E S; (II) Runtime Statistics, LISTING THE NUMBER OF USED\r\nT Y P E S, CALLS TO M A L L O C, N E W, AND THE N E W-ARRAY OPERATOR DURING EXECUTION, AND (III) Normalized Runtime.\r\nMarx Statistics Runtime Statistics Normalized Runtime\r\nProgram #new # types # types #malloc #new #new[] overhead\r\nMySQL 1,017 47 16 2,705,675 82,225 13 1.009\r\nNode.js 4,675 38 14 7,685,562 12,228,927 9,093,605 1.022\r\nastar 11 0 0 1,008,577 108,037 8 0.999\r\ndealII 1,632 11 5 48 144,642,689 6,616,448 1.016\r\nnamd 584 2 1 2 2 1,320 0.999\r\nomnetpp 717 9 1 45,950,697 0 221,218,929 1.028\r\npovray 54 7 6 2,414,075 83 176 0.995\r\nsoplex 20 6 2 3,718 3 4 0.997\r\nxalancbmk 2,051 167 46 6,854 135,148,541 158 1.046\r\ngeomean 350 6 2 56,309 6,032 3,888 1.012\r\nusers of the new and new[] operators, and although astar\r\nperforms many calls to new, we detected no types during its\r\nexecution. This is caused by the fact that astar does not rely\r\non many C++ features [16]: Marx recovered one vtable which\r\nis never written into a heap object in the program. Thus, the\r\nnew operator is never used with a type.\r\nOur results for the real-world applications Node.js and\r\nMySQL are much more realistic compared to the SPEC bench\u0002marks: our type-safe object reuse implementation captures a\r\nsignificant fraction of the C++ types as reconstructed by Marx.\r\nAlthough both applications heavily depend on C++ objects, the\r\noverhead imposed by the type-safe object reuse application\r\nis low. For example, in Node.js, we recorded more than 21\r\nmillion new objects, while its normalized runtime is 2.2%. We\r\nthink that these results are encouraging: type-safe object reuse\r\nprovides significant security invariants, while our experiments\r\nreport a performance overhead of less than 5% (geometric\r\nmean).\r\nVII. DISCUSSION\r\nIn the following, we discuss the effects of compiler opti\u0002mizations on our analysis and review several ways to optimize\r\nour prototype implementation.\r\nA. Compiler Optimizations and Lost Information\r\nEven though all of our evaluation results are encouraging,\r\nwe note that the biggest limitations of our approach are due\r\nto compiler optimizations and a loss of information on the\r\nbinary level. Inherently, Marx is dependent on vtables (and\r\nreferences to them) emitted by the compiler. Especially for\r\nabstract base classes, however, such relations may not be\r\nrevealed by certain vtable usage patterns; the information is\r\nsimply missing from the binary and we cannot recover this\r\ninformation. This increases the observable gap between the\r\nformal class hierarchy as set up by the programmer and the\r\nresults obtained by Marx, based on artifacts found in the\r\n(optimized) binary itself.\r\nSuch a case was encountered during the evaluation of\r\nFileZilla. A compiler optimization removed vtables of ab\u0002stract classes from the binary which were the base classes\r\nof complete hierarchies. As a result, the overwrite analysis\r\nfailed to join the smaller hierarchies. Since the vtables did\r\nnot have other characteristics that allows our approach to find\r\na connection (e. g., via heuristics discussed previously), the\r\nreconstructed hierarchies were either not complete or not found\r\nat all. Hence, the quality of our results depends on the size of\r\nthe gap between the formal and the actual class hierarchy as\r\nencoded in the binary.\r\nOther than this, we did not encounter any application\u0002specific idiom that affect the accuracy of our results.\r\nB. Improving Analysis Contexts\r\nSince our static analysis approach focuses on real-world\r\napplications, we had to weigh up precision against performance\r\nto be able to scale to complex binaries. Hence, we introduced\r\n12",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/2bbf2dcb-3104-495e-a5e7-31b7bee38ba3.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=017ba61db310519b0160189e282dd1b97c12361baed0aa3f2c60b63703331bc7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 847
      },
      {
        "segments": [
          {
            "segment_id": "54689588-e1a2-48f8-9d41-2d382f53bf7d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "limiting factors such as the call depth restriction and char\u0002acteristics that we deem as interesting in a basic block. One\r\nproblem that may arise with these restrictions is that we may\r\nmiss important information during our analysis. Consider, for\r\nexample, a function fimp which yields valuable information for\r\nour analysis, but is called from a fixed callsite. In the following,\r\nwe call such a function an important function. When our static\r\nanalysis processes the function’s caller and the basic block\r\nthat calls fimp is not considered interesting, it is highly likely\r\nthat no path is generated which ends up in fimp. Hence, our\r\nanalysis misses context that would be provided by the function\r\nand its results loose precision.\r\nA na¨ıve approach to tackle this problem is to consider\r\nall call instructions as interesting during the path generation\r\n(i. e., follow every call). This, however, does not scale to real\u0002world applications due to the path explosion problem. A better\r\nsolution is to mark those basic blocks with call instructions as\r\ninteresting that eventually reach important functions. In other\r\nwords, we recognize importance of functions as a transitive\r\nfunction which, in turn, impacts the importance of its callers.\r\nHowever, Marx analyzes the functions on a on-demand\r\nbasis and does not know if the target of a call instruction\r\nis important for the analysis process (i. e., it only takes infor\u0002mation local to the current function into account). In order to\r\nadd global information about the importance of a function into\r\nMarx’ decision process, we propose to add a preliminary pre\u0002processing step. In essence, we build a static call graph which\r\nallows to propagate information about important basic blocks\r\nup to its callers. During path generation, this can affect the\r\ndecision whether or not to follow an (otherwise uninteresting)\r\ncall. Additionally, this call graph can be enriched at analysis\r\ntime to include target sets resolved at a vcall. Further, it allows\r\nto dynamically adjust the call depth.\r\nC. Improving Shared Library Results\r\nAs shown in Section VI-A, the class hierarchy reconstruc\u0002tion of shared libraries is not as precise as for applications.\r\nThis is due to the fact that shared libraries are written to be\r\nused from other applications or shared libraries. Hence, most\r\nfunctions in a shared library are not called from within the\r\nvery same module. As a result, Marx has to analyze these\r\nfunctions without any context given by the caller (e. g., a vcall\r\nis using an object that is provided by the caller). This missing\r\ninformation leads to a lower precision in reconstructing the\r\nclass hierarchy and fewer vcalls are found. One way to tackle\r\nthis problem is to analyze the shared library in combination\r\nwith an application that is using it. Once a function inside\r\na shared library is called from the application, the analysis\r\nframework has a context that might help improving the results.\r\nHowever, this does not necessarily cover all exported functions\r\nof the shared library. Also, an analyst might not always have\r\nan application at hand that is using the shared library that he\r\nhas to analyze.\r\nD. Reconstructing RTTI\r\nAn interesting application of the class hierarchy reconstruc\u0002tion results is the subsequent reconstruction of RTTI associated\r\nwith vtables. This information can, in turn, be leveraged by\r\nother applications, such as analysis programs or protection\r\nmechanisms which are able to perform better when provided\r\nwith RTTI. Notably, this would be an easy way to incorporate\r\nour results in potentially closed-source applications which\r\nwould not require modifications to the programs themselves.\r\nHowever, since Marx is not able to recover the class hierarchies\r\nwith full precision in the general case, the applications have\r\nto be able to cope with a certain amount of imprecision.\r\nFurthermore, RTTI holds information about the inheritance\r\ndirection. More specifically, it only contains a pointer to the\r\nRTTI of parent classes. Currently, our analysis approach is\r\nnot able to extract the direction of the inheritance. Therefore,\r\nthe recovered RTTI would contain all classes that are in the\r\nsame hierarchy and therefore overestimate it. Still, we note\r\nthat extraction of the inheritance direction can be added in the\r\nfuture.\r\nE. Improving VTable Protection\r\nAs shown in Section VI-C, the results of Marx can be\r\nused for a binary-only CFI implementation focusing on vcalls.\r\nHowever, even with a dynamic profiling phase to improve\r\nthe results of our static analysis, the slow path of our imple\u0002mentation is still required by some applications, which leads\r\nto a relatively high performance overhead. In order to tackle\r\nthis problem, the implementation can be extended to use the\r\ntechnique proposed by Prakash et al. [21]. If our analysis\r\ncannot assign a reconstructed class hierarchy to a given vcall,\r\nthe CFI implementation can allow all functions at the same\r\noffset in any known vtable. This way, the implementation\r\nwould have two different protection granularities: For vcalls\r\nwith an assigned class hierarchy, the set of allowed functions\r\nlies within the class hierarchy. For vcalls without an assigned\r\nclass hierarchy, the set of allowed functions lies within the\r\nknown vtables. Hence, the verification at a vcall without an\r\nassigned class hierarchy can also be implemented using a\r\nsimple label check.\r\nVIII. RELATED WORK\r\nWe now review related work on the reconstruction of\r\nC++ class hierarchies and discuss how Marx advances the\r\nfield. Most similar to our static analysis approach is the\r\nwork conducted by Jin et al. [17]. Their approach, called\r\nobjdigger, uses symbolic execution and inter-procedural data\r\nflow analysis to discover objects of classes, their attributes,\r\nand methods. However, their approach does not reconstruct the\r\nclass hierarchy and only the ideas to recover it are described in\r\nthe paper (which are similar to our vtblptr overwrite analysis).\r\nFurthermore, the evaluation is only done on small test cases\r\nwith up to 10 classes instead of complex binaries.\r\nThe approach presented by Fokin et al. [12] focuses on\r\nreconstructing the class hierarchies of C++ programs. Their\r\napproach recovers the vtables in memory and analyzes them\r\nand their corresponding constructors. However, they focus on\r\nanalyzing the structure of the vtable size and the usage of pure\r\nvirtual functions to recover the direction of the inheritance. The\r\ndata-flow through the program is not considered in their work,\r\nleading to a certain imprecision.\r\nKatz et al. [18] proposed an approach to support an analyst\r\nthat reverse engineers C++ binaries based on machine learning.\r\nTheir approach outputs a probability that indicates what class\r\n13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/54689588-e1a2-48f8-9d41-2d382f53bf7d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=524074a887a0b3f124aaf3a0822c36bb7bac9cdbb6c9957688c535e9087c3df2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1065
      },
      {
        "segments": [
          {
            "segment_id": "54689588-e1a2-48f8-9d41-2d382f53bf7d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "limiting factors such as the call depth restriction and char\u0002acteristics that we deem as interesting in a basic block. One\r\nproblem that may arise with these restrictions is that we may\r\nmiss important information during our analysis. Consider, for\r\nexample, a function fimp which yields valuable information for\r\nour analysis, but is called from a fixed callsite. In the following,\r\nwe call such a function an important function. When our static\r\nanalysis processes the function’s caller and the basic block\r\nthat calls fimp is not considered interesting, it is highly likely\r\nthat no path is generated which ends up in fimp. Hence, our\r\nanalysis misses context that would be provided by the function\r\nand its results loose precision.\r\nA na¨ıve approach to tackle this problem is to consider\r\nall call instructions as interesting during the path generation\r\n(i. e., follow every call). This, however, does not scale to real\u0002world applications due to the path explosion problem. A better\r\nsolution is to mark those basic blocks with call instructions as\r\ninteresting that eventually reach important functions. In other\r\nwords, we recognize importance of functions as a transitive\r\nfunction which, in turn, impacts the importance of its callers.\r\nHowever, Marx analyzes the functions on a on-demand\r\nbasis and does not know if the target of a call instruction\r\nis important for the analysis process (i. e., it only takes infor\u0002mation local to the current function into account). In order to\r\nadd global information about the importance of a function into\r\nMarx’ decision process, we propose to add a preliminary pre\u0002processing step. In essence, we build a static call graph which\r\nallows to propagate information about important basic blocks\r\nup to its callers. During path generation, this can affect the\r\ndecision whether or not to follow an (otherwise uninteresting)\r\ncall. Additionally, this call graph can be enriched at analysis\r\ntime to include target sets resolved at a vcall. Further, it allows\r\nto dynamically adjust the call depth.\r\nC. Improving Shared Library Results\r\nAs shown in Section VI-A, the class hierarchy reconstruc\u0002tion of shared libraries is not as precise as for applications.\r\nThis is due to the fact that shared libraries are written to be\r\nused from other applications or shared libraries. Hence, most\r\nfunctions in a shared library are not called from within the\r\nvery same module. As a result, Marx has to analyze these\r\nfunctions without any context given by the caller (e. g., a vcall\r\nis using an object that is provided by the caller). This missing\r\ninformation leads to a lower precision in reconstructing the\r\nclass hierarchy and fewer vcalls are found. One way to tackle\r\nthis problem is to analyze the shared library in combination\r\nwith an application that is using it. Once a function inside\r\na shared library is called from the application, the analysis\r\nframework has a context that might help improving the results.\r\nHowever, this does not necessarily cover all exported functions\r\nof the shared library. Also, an analyst might not always have\r\nan application at hand that is using the shared library that he\r\nhas to analyze.\r\nD. Reconstructing RTTI\r\nAn interesting application of the class hierarchy reconstruc\u0002tion results is the subsequent reconstruction of RTTI associated\r\nwith vtables. This information can, in turn, be leveraged by\r\nother applications, such as analysis programs or protection\r\nmechanisms which are able to perform better when provided\r\nwith RTTI. Notably, this would be an easy way to incorporate\r\nour results in potentially closed-source applications which\r\nwould not require modifications to the programs themselves.\r\nHowever, since Marx is not able to recover the class hierarchies\r\nwith full precision in the general case, the applications have\r\nto be able to cope with a certain amount of imprecision.\r\nFurthermore, RTTI holds information about the inheritance\r\ndirection. More specifically, it only contains a pointer to the\r\nRTTI of parent classes. Currently, our analysis approach is\r\nnot able to extract the direction of the inheritance. Therefore,\r\nthe recovered RTTI would contain all classes that are in the\r\nsame hierarchy and therefore overestimate it. Still, we note\r\nthat extraction of the inheritance direction can be added in the\r\nfuture.\r\nE. Improving VTable Protection\r\nAs shown in Section VI-C, the results of Marx can be\r\nused for a binary-only CFI implementation focusing on vcalls.\r\nHowever, even with a dynamic profiling phase to improve\r\nthe results of our static analysis, the slow path of our imple\u0002mentation is still required by some applications, which leads\r\nto a relatively high performance overhead. In order to tackle\r\nthis problem, the implementation can be extended to use the\r\ntechnique proposed by Prakash et al. [21]. If our analysis\r\ncannot assign a reconstructed class hierarchy to a given vcall,\r\nthe CFI implementation can allow all functions at the same\r\noffset in any known vtable. This way, the implementation\r\nwould have two different protection granularities: For vcalls\r\nwith an assigned class hierarchy, the set of allowed functions\r\nlies within the class hierarchy. For vcalls without an assigned\r\nclass hierarchy, the set of allowed functions lies within the\r\nknown vtables. Hence, the verification at a vcall without an\r\nassigned class hierarchy can also be implemented using a\r\nsimple label check.\r\nVIII. RELATED WORK\r\nWe now review related work on the reconstruction of\r\nC++ class hierarchies and discuss how Marx advances the\r\nfield. Most similar to our static analysis approach is the\r\nwork conducted by Jin et al. [17]. Their approach, called\r\nobjdigger, uses symbolic execution and inter-procedural data\r\nflow analysis to discover objects of classes, their attributes,\r\nand methods. However, their approach does not reconstruct the\r\nclass hierarchy and only the ideas to recover it are described in\r\nthe paper (which are similar to our vtblptr overwrite analysis).\r\nFurthermore, the evaluation is only done on small test cases\r\nwith up to 10 classes instead of complex binaries.\r\nThe approach presented by Fokin et al. [12] focuses on\r\nreconstructing the class hierarchies of C++ programs. Their\r\napproach recovers the vtables in memory and analyzes them\r\nand their corresponding constructors. However, they focus on\r\nanalyzing the structure of the vtable size and the usage of pure\r\nvirtual functions to recover the direction of the inheritance. The\r\ndata-flow through the program is not considered in their work,\r\nleading to a certain imprecision.\r\nKatz et al. [18] proposed an approach to support an analyst\r\nthat reverse engineers C++ binaries based on machine learning.\r\nTheir approach outputs a probability that indicates what class\r\n13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/54689588-e1a2-48f8-9d41-2d382f53bf7d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=524074a887a0b3f124aaf3a0822c36bb7bac9cdbb6c9957688c535e9087c3df2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1065
      },
      {
        "segments": [
          {
            "segment_id": "5ff6b480-5100-4e02-8afe-c6d2280e96d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "is used at a given vcall. This is done by using sequences\r\nof instructions that can be assigned to a specific class as a\r\ntraining set. The trained model is then used to estimate other\r\nvcalls and the used class, with the goal of giving the analyst a\r\nhint where the control-flow might go next. Unfortunately, their\r\napproach ignores polymorphism and is only able to provide\r\none possible branch target. Additionally, their evaluation was\r\ndone on small applications (largest one has a size of around\r\n1MB) on a machine with 64 CPUs that took several hours.\r\nTherefore, their approach is not able to support an analyst on\r\nreverse engineering real-world C++ applications.\r\nThe binary analysis framework angr is presented by\r\nShoshitaishvili et al. [24]. Their work focuses on re\u0002implementing existing techniques for vulnerability identifica\u0002tion in order to compare them with each other. The introduced\r\nframework has a modular design and provides the possibility\r\nto be extended with new analysis techniques. The presented\r\nalgorithms of our approach could also be implemented with\r\nangr instead of writing an own framework. However, angr\r\nis written in Python and due to its performance, it is likely\r\nnot efficient for large real-world binaries such as Node.js or\r\nMySQL Server.\r\nPrakash et al. [21] presented vfGuard, a binary-only in\u0002direct call protection mechanism for C++ binaries. Their ap\u0002proach tries to protect vcalls by creating a whitelist with valid\r\ncalll targets. If the target address is not within the whitelist,\r\nan attack is assumed and the execution is terminated. The\r\nwhitelist is determined by the offset into the vtable that is\r\nused by the vcall. However, they do not try to recover the class\r\nhierarchies because of its difficulty and just allow any vtable\r\nat a vcall (with some additional filtering). T-VIP, proposed\r\nby Gawlik et al. [13], is also a binary-only approach to\r\nprotect virtual callsites from vtable hijacking attacks. However,\r\nthey do not recover C++ specific structures such as vtables,\r\nbut reduce the virtual callsite characteristics to two heuristic\r\npolicies. The first policy restricts the vtblptr to point to read\u0002only memory at a vcall. The second policy checks if a random\r\nfunction pointer in the vtable points to memory that is not\r\nwritable. Both policies narrow down the ability of an attacker\r\nto inject a crafted vtable. However, more advanced code-reuse\r\nattacks such as proposed by Schuster et al. [23] are not affected\r\nby these policies. Gawlik et al. also proposed a third policy\r\nto check if the used vtable resides in an allowed set built\r\nwith the help of the class hierarchy. However, they did not\r\nimplement this idea because previous existing work did not\r\nshow a practicable recovery of class hierarchies for real-world\r\nprograms.\r\nMost similar to our presented application of a type-safe\r\nobject reuse is Cling, a work presented by Akritidis [8]. Cling\r\nis a type-safe memory allocator used to mitigate use-after-free\r\nattacks. It modifies the heap allocation process to provide types\r\nfor each memory allocation that is made in the application.\r\nCling uses the address of the allocation site and size as a type\r\nfor its pools. Hence, a use-after-free bug only grants access\r\nto the remaining data of the same object type. In contrast,\r\nour presented application builds types on the base of the\r\nreconstructed class hierarchies. Since Cling is C++ agnostic\r\nin principle, the class hierarchy as reconstructed by Marx\r\ncan significantly improve it in handling C++ allocations. The\r\nbenefit is to reduce the number of typed pools (and memory\r\nusage) and also avoid expensive instrumentation for deriving\r\nthe run-time type. In a similar fashion, VTPin [22], a vtable\r\nhijacking protection for binaries, which is currenlty class\u0002agnostic, could potentially leverage the extracted hierarchies\r\nfor increasing the accuracy in collecting pinned vtable pointers.\r\nIX. CONCLUSION\r\nIn this paper, we presented a practical and efficient ap\u0002proach to reconstruct C++ class hierarchies from a given binary\r\napplication. Our static analysis follows data flow and tracks\r\nobjects through multiple paths through the target binary whilst\r\ntaking C++ characteristics into account. Hence, we recognize\r\nartifacts resulting from the way compilers implement high\u0002level features such as polymorphism and use them to recover\r\ninformation about the relation of classes in the binary.\r\nWe presented the design and implementation of a tool\r\ncalled Marx capable of performing the outlined approach\r\nand evaluated it on several large, real-world applications.\r\nThe results are promising: On average, 84.6% of the class\r\nhierarchies of applications and 73.3% of the class hierarchies\r\nof shared libraries were precisely reconstructed. The informa\u0002tion provided by our analysis can then be used to resolve\r\nthe sets of potential target functions of virtual callsites and\r\nhelps an analyst following control flow even across previously\r\nunresolvable indirect calls.\r\nFurthermore, we present two applications built atop of\r\nthe analysis results: an improved vtable protection mechanism\r\nfor binary executables, verifying the integrity of control flow,\r\nand type-safe object reuse, which enhances type-safe memory\r\nallocators. We demonstrate that, even in cases where the\r\nextracted class hierarchy is reconstructed imperfectly, practical\r\ndefenses that improve security while maintaining a reasonable\r\nperformance level can be developed based on our results. To\r\ncompensate for the imprecision of the analysis, our vtable\r\nprotection treats violations as anomalies and triggers more\r\nheavyweight checks on a slow path (trading off on perfor\u0002mance). On the other hand, our type-safe object reuse solu\u0002tion can gracefully tolerate type-to-pool mapping mismatches\r\n(trading off on security). In short, we show that it is possible\r\nto build fully conservative binary-level defense solutions on\r\ntop of imprecise information, exposing new interesting and\r\npreviously unexplored tradeoffs.\r\nSince we believe that our analysis framework Marx pro\u0002vides promising results in the analysis of large, real-world\r\napplications and hence represents a building block for future\r\nresearch, we make it available for the research community.\r\nACKNOWLEDGEMENTS\r\nWe would like to thank the anonymous reviewers for\r\ntheir comments. This work was supported by the European\r\nCommission through project H2020 ICT-32-2014 (SHARCS)\r\nunder Grant Agreement No. 644571, ERC Starting Grant No.\r\n640110 (BASTION), and by the Netherlands Organization for\r\nScientific Research through grants NWO 639.023.309 VICI\r\n(Dowsing) and NWO CSI-DHS 628.001.021.\r\nREFERENCES\r\n[1] Apache benchmark. http://httpd.apache.org/docs/2.0/programs/ab.html.\r\n14",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/5ff6b480-5100-4e02-8afe-c6d2280e96d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=941f2183ec9fcbcfad4760cfcf541e4f20646d21455b24a93bb870ad74257b9e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1014
      },
      {
        "segments": [
          {
            "segment_id": "5ff6b480-5100-4e02-8afe-c6d2280e96d2",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 14,
            "page_width": 612,
            "page_height": 792,
            "content": "is used at a given vcall. This is done by using sequences\r\nof instructions that can be assigned to a specific class as a\r\ntraining set. The trained model is then used to estimate other\r\nvcalls and the used class, with the goal of giving the analyst a\r\nhint where the control-flow might go next. Unfortunately, their\r\napproach ignores polymorphism and is only able to provide\r\none possible branch target. Additionally, their evaluation was\r\ndone on small applications (largest one has a size of around\r\n1MB) on a machine with 64 CPUs that took several hours.\r\nTherefore, their approach is not able to support an analyst on\r\nreverse engineering real-world C++ applications.\r\nThe binary analysis framework angr is presented by\r\nShoshitaishvili et al. [24]. Their work focuses on re\u0002implementing existing techniques for vulnerability identifica\u0002tion in order to compare them with each other. The introduced\r\nframework has a modular design and provides the possibility\r\nto be extended with new analysis techniques. The presented\r\nalgorithms of our approach could also be implemented with\r\nangr instead of writing an own framework. However, angr\r\nis written in Python and due to its performance, it is likely\r\nnot efficient for large real-world binaries such as Node.js or\r\nMySQL Server.\r\nPrakash et al. [21] presented vfGuard, a binary-only in\u0002direct call protection mechanism for C++ binaries. Their ap\u0002proach tries to protect vcalls by creating a whitelist with valid\r\ncalll targets. If the target address is not within the whitelist,\r\nan attack is assumed and the execution is terminated. The\r\nwhitelist is determined by the offset into the vtable that is\r\nused by the vcall. However, they do not try to recover the class\r\nhierarchies because of its difficulty and just allow any vtable\r\nat a vcall (with some additional filtering). T-VIP, proposed\r\nby Gawlik et al. [13], is also a binary-only approach to\r\nprotect virtual callsites from vtable hijacking attacks. However,\r\nthey do not recover C++ specific structures such as vtables,\r\nbut reduce the virtual callsite characteristics to two heuristic\r\npolicies. The first policy restricts the vtblptr to point to read\u0002only memory at a vcall. The second policy checks if a random\r\nfunction pointer in the vtable points to memory that is not\r\nwritable. Both policies narrow down the ability of an attacker\r\nto inject a crafted vtable. However, more advanced code-reuse\r\nattacks such as proposed by Schuster et al. [23] are not affected\r\nby these policies. Gawlik et al. also proposed a third policy\r\nto check if the used vtable resides in an allowed set built\r\nwith the help of the class hierarchy. However, they did not\r\nimplement this idea because previous existing work did not\r\nshow a practicable recovery of class hierarchies for real-world\r\nprograms.\r\nMost similar to our presented application of a type-safe\r\nobject reuse is Cling, a work presented by Akritidis [8]. Cling\r\nis a type-safe memory allocator used to mitigate use-after-free\r\nattacks. It modifies the heap allocation process to provide types\r\nfor each memory allocation that is made in the application.\r\nCling uses the address of the allocation site and size as a type\r\nfor its pools. Hence, a use-after-free bug only grants access\r\nto the remaining data of the same object type. In contrast,\r\nour presented application builds types on the base of the\r\nreconstructed class hierarchies. Since Cling is C++ agnostic\r\nin principle, the class hierarchy as reconstructed by Marx\r\ncan significantly improve it in handling C++ allocations. The\r\nbenefit is to reduce the number of typed pools (and memory\r\nusage) and also avoid expensive instrumentation for deriving\r\nthe run-time type. In a similar fashion, VTPin [22], a vtable\r\nhijacking protection for binaries, which is currenlty class\u0002agnostic, could potentially leverage the extracted hierarchies\r\nfor increasing the accuracy in collecting pinned vtable pointers.\r\nIX. CONCLUSION\r\nIn this paper, we presented a practical and efficient ap\u0002proach to reconstruct C++ class hierarchies from a given binary\r\napplication. Our static analysis follows data flow and tracks\r\nobjects through multiple paths through the target binary whilst\r\ntaking C++ characteristics into account. Hence, we recognize\r\nartifacts resulting from the way compilers implement high\u0002level features such as polymorphism and use them to recover\r\ninformation about the relation of classes in the binary.\r\nWe presented the design and implementation of a tool\r\ncalled Marx capable of performing the outlined approach\r\nand evaluated it on several large, real-world applications.\r\nThe results are promising: On average, 84.6% of the class\r\nhierarchies of applications and 73.3% of the class hierarchies\r\nof shared libraries were precisely reconstructed. The informa\u0002tion provided by our analysis can then be used to resolve\r\nthe sets of potential target functions of virtual callsites and\r\nhelps an analyst following control flow even across previously\r\nunresolvable indirect calls.\r\nFurthermore, we present two applications built atop of\r\nthe analysis results: an improved vtable protection mechanism\r\nfor binary executables, verifying the integrity of control flow,\r\nand type-safe object reuse, which enhances type-safe memory\r\nallocators. We demonstrate that, even in cases where the\r\nextracted class hierarchy is reconstructed imperfectly, practical\r\ndefenses that improve security while maintaining a reasonable\r\nperformance level can be developed based on our results. To\r\ncompensate for the imprecision of the analysis, our vtable\r\nprotection treats violations as anomalies and triggers more\r\nheavyweight checks on a slow path (trading off on perfor\u0002mance). On the other hand, our type-safe object reuse solu\u0002tion can gracefully tolerate type-to-pool mapping mismatches\r\n(trading off on security). In short, we show that it is possible\r\nto build fully conservative binary-level defense solutions on\r\ntop of imprecise information, exposing new interesting and\r\npreviously unexplored tradeoffs.\r\nSince we believe that our analysis framework Marx pro\u0002vides promising results in the analysis of large, real-world\r\napplications and hence represents a building block for future\r\nresearch, we make it available for the research community.\r\nACKNOWLEDGEMENTS\r\nWe would like to thank the anonymous reviewers for\r\ntheir comments. This work was supported by the European\r\nCommission through project H2020 ICT-32-2014 (SHARCS)\r\nunder Grant Agreement No. 644571, ERC Starting Grant No.\r\n640110 (BASTION), and by the Netherlands Organization for\r\nScientific Research through grants NWO 639.023.309 VICI\r\n(Dowsing) and NWO CSI-DHS 628.001.021.\r\nREFERENCES\r\n[1] Apache benchmark. http://httpd.apache.org/docs/2.0/programs/ab.html.\r\n14",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/5ff6b480-5100-4e02-8afe-c6d2280e96d2.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=941f2183ec9fcbcfad4760cfcf541e4f20646d21455b24a93bb870ad74257b9e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 1014
      },
      {
        "segments": [
          {
            "segment_id": "45a6542a-eb3f-417e-8a47-e4f5fa6ac1d4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "[2] IDAPython. https://github.com/idapython.\r\n[3] Itanium C++ ABI. https://mentorembedded.github.io/cxx-abi/abi.html.\r\n[4] SysBench. http://sysbench.sourceforge.net.\r\n[5] Valgrind. http://www.valgrind.org/.\r\n[6] C++ ABI for the ARM Architecture. http://infocenter.arm.com/help/\r\ntopic/com.arm.doc.ihi0041e/IHI0041E cppabi.pdf, 2015.\r\n[7] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-Flow\r\nIntegrity. In ACM Conference on Computer and Communications\r\nSecurity (CCS), 2005.\r\n[8] P. Akritidis. Cling: A Memory Allocator to Mitigate Dangling Pointers.\r\nIn USENIX Security Symposium, 2010.\r\n[9] D. Andriesse, X. Chen, V. van der Veen, A. Slowinska, and H. Bos.\r\nAn In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries.\r\nIn USENIX Security Symposium, 2016.\r\n[10] A. R. Bernat and B. P. Miller. Anywhere, Any-Time Binary Instrumen\u0002tation. In ACM SIGPLAN-SIGSOFT Workshop on Program Analysis\r\nfor Software Tools and Engineering (PASTE), 2011.\r\n[11] S. J. Crane, S. Volckaert, F. Schuster, C. Liebchen, P. Larsen, L. Davi,\r\nA.-R. Sadeghi, T. Holz, B. De Sutter, and M. Franz. It’s a TRaP: Table\r\nRandomization and Protection against Function-Reuse Attacks. In ACM\r\nConference on Computer and Communications Security (CCS), 2015.\r\n[12] A. Fokin, K. Troshina, and A. Chernov. Reconstruction of Class Hier\u0002archies for Decompilation of C++ Programs. In European Conference\r\non Software Maintenance and Reengineering (CSMR), 2010.\r\n[13] R. Gawlik and T. Holz. Towards Automated Integrity Protection of\r\nC++ Virtual Function Tables in Binary Programs. In Annual Computer\r\nSecurity Applications Conference (ACSAC).\r\n[14] J. Gray. C++: Under the Hood. http://www.openrce.org/articles/files/\r\njangrayhood.pdf, 1994.\r\n[15] I. Haller, E. Goktas¸, E. Athanasopoulos, G. Portokalidis, and H. Bos. ¨\r\nShrinkwrap: VTable protection without loose ends. In Annual Computer\r\nSecurity Applications Conference (ACSAC), 2015.\r\n[16] C. Isen and L. John. On the Object Orientedness of C++ programs in\r\nSPEC CPU 2006. In SPEC Benchmark Workshop. Citeseer, 2008.\r\n[17] W. Jin, C. Cohen, J. Gennari, C. Hines, S. Chaki, A. Gurfinkel,\r\nJ. Havrilla, and P. Narasimhan. Recovering C++ Objects From Binaries\r\nUsing Inter-Procedural Data-Flow Analysis. In ACM SIGPLAN Pro\u0002gram Protection and Reverse Engineering Workshop (PPREW), 2014.\r\n[18] O. Katz, R. El-Yaniv, and E. Yahav. Estimating Types in Binaries using\r\nPredictive Modeling. ACM Symposium on Principles of Programming\r\nLanguages (POPL), 2016.\r\n[19] J. Lettner, B. Kollenda, A. Homescu, P. Larsen, F. Schuster, L. Davi,\r\nA.-R. Sadeghi, T. Holz, and M. Franz. Subversive-C: Abusing and\r\nProtecting Dynamic Message Dispatch. In USENIX Annual Technical\r\nConference, 2016.\r\n[20] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia. Thwarting Memory\r\nDisclosure with Efficient Hypervisor-enforced Intra-domain Isolation.\r\nIn ACM Conference on Computer and Communications Security (CCS),\r\n2015.\r\n[21] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict Protection for Virtual\r\nFunction Calls in COTS C++ Binaries. In Symposium on Network and\r\nDistributed System Security (NDSS), 2015.\r\n[22] P. Sarbinowski, V. P. Kemerlis, C. Giuffrida, and E. Athanasopoulos.\r\nVTPin: Practical VTable Hijacking Protection for Binaries. In Annual\r\nComputer Security Applications Conference (ACSAC), 2016.\r\n[23] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and\r\nT. Holz. Counterfeit Object-oriented Programming: On the Difficulty\r\nof Preventing Code Reuse Attacks in C++ Applications. In IEEE\r\nSymposium on Security and Privacy (S&P), 2015.\r\n[24] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,\r\nA. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna.\r\n(State of) The Art of War: Offensive Techniques in Binary Analysis.\r\nIn IEEE Symposium on Security and Privacy (S&P), 2016.\r\n[25] B. Stroustrup. C++ Applications. http://www.stroustrup.com/\r\napplications.html.\r\n[26] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Erlingsson, ´\r\nL. Lozano, and G. Pike. Enforcing Forward-Edge Control-Flow In\u0002tegrity in GCC & LLVM. In USENIX Security Symposium, 2014.\r\n[27] V. van der Veen, D. Andriesse, E. Goktas¸, B. Gras, L. Sambuc, ¨\r\nA. Slowinska, H. Bos, and C. Giuffrida. Practical Context-Sensitive\r\nCFI. In ACM Conference on Computer and Communications Security\r\n(CCS), 2015.\r\n[28] V. van der Veen, E. Goktas, M. Contag, A. Pawlowski, X. Chen, ¨\r\nS. Rawat, H. Bos, T. Holz, E. Athanasopoulos, and C. Giuffrida. A\r\nTough call: Mitigating Advanced Code-Reuse Attacks At The Binary\r\nLevel. In IEEE Symposium on Security and Privacy (S&P), 2016.\r\n[29] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer, and D. Song.\r\nVTrust: Regaining Trust on Virtual Calls. In Symposium on Network\r\nand Distributed System Security (NDSS), 2016.\r\n15",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/45a6542a-eb3f-417e-8a47-e4f5fa6ac1d4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c488b16e6d32edd6079b69e2090a97280d5b51095ca2baa954508e41b4c7af8b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 684
      },
      {
        "segments": [
          {
            "segment_id": "45a6542a-eb3f-417e-8a47-e4f5fa6ac1d4",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 15,
            "page_width": 612,
            "page_height": 792,
            "content": "[2] IDAPython. https://github.com/idapython.\r\n[3] Itanium C++ ABI. https://mentorembedded.github.io/cxx-abi/abi.html.\r\n[4] SysBench. http://sysbench.sourceforge.net.\r\n[5] Valgrind. http://www.valgrind.org/.\r\n[6] C++ ABI for the ARM Architecture. http://infocenter.arm.com/help/\r\ntopic/com.arm.doc.ihi0041e/IHI0041E cppabi.pdf, 2015.\r\n[7] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-Flow\r\nIntegrity. In ACM Conference on Computer and Communications\r\nSecurity (CCS), 2005.\r\n[8] P. Akritidis. Cling: A Memory Allocator to Mitigate Dangling Pointers.\r\nIn USENIX Security Symposium, 2010.\r\n[9] D. Andriesse, X. Chen, V. van der Veen, A. Slowinska, and H. Bos.\r\nAn In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries.\r\nIn USENIX Security Symposium, 2016.\r\n[10] A. R. Bernat and B. P. Miller. Anywhere, Any-Time Binary Instrumen\u0002tation. In ACM SIGPLAN-SIGSOFT Workshop on Program Analysis\r\nfor Software Tools and Engineering (PASTE), 2011.\r\n[11] S. J. Crane, S. Volckaert, F. Schuster, C. Liebchen, P. Larsen, L. Davi,\r\nA.-R. Sadeghi, T. Holz, B. De Sutter, and M. Franz. It’s a TRaP: Table\r\nRandomization and Protection against Function-Reuse Attacks. In ACM\r\nConference on Computer and Communications Security (CCS), 2015.\r\n[12] A. Fokin, K. Troshina, and A. Chernov. Reconstruction of Class Hier\u0002archies for Decompilation of C++ Programs. In European Conference\r\non Software Maintenance and Reengineering (CSMR), 2010.\r\n[13] R. Gawlik and T. Holz. Towards Automated Integrity Protection of\r\nC++ Virtual Function Tables in Binary Programs. In Annual Computer\r\nSecurity Applications Conference (ACSAC).\r\n[14] J. Gray. C++: Under the Hood. http://www.openrce.org/articles/files/\r\njangrayhood.pdf, 1994.\r\n[15] I. Haller, E. Goktas¸, E. Athanasopoulos, G. Portokalidis, and H. Bos. ¨\r\nShrinkwrap: VTable protection without loose ends. In Annual Computer\r\nSecurity Applications Conference (ACSAC), 2015.\r\n[16] C. Isen and L. John. On the Object Orientedness of C++ programs in\r\nSPEC CPU 2006. In SPEC Benchmark Workshop. Citeseer, 2008.\r\n[17] W. Jin, C. Cohen, J. Gennari, C. Hines, S. Chaki, A. Gurfinkel,\r\nJ. Havrilla, and P. Narasimhan. Recovering C++ Objects From Binaries\r\nUsing Inter-Procedural Data-Flow Analysis. In ACM SIGPLAN Pro\u0002gram Protection and Reverse Engineering Workshop (PPREW), 2014.\r\n[18] O. Katz, R. El-Yaniv, and E. Yahav. Estimating Types in Binaries using\r\nPredictive Modeling. ACM Symposium on Principles of Programming\r\nLanguages (POPL), 2016.\r\n[19] J. Lettner, B. Kollenda, A. Homescu, P. Larsen, F. Schuster, L. Davi,\r\nA.-R. Sadeghi, T. Holz, and M. Franz. Subversive-C: Abusing and\r\nProtecting Dynamic Message Dispatch. In USENIX Annual Technical\r\nConference, 2016.\r\n[20] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia. Thwarting Memory\r\nDisclosure with Efficient Hypervisor-enforced Intra-domain Isolation.\r\nIn ACM Conference on Computer and Communications Security (CCS),\r\n2015.\r\n[21] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict Protection for Virtual\r\nFunction Calls in COTS C++ Binaries. In Symposium on Network and\r\nDistributed System Security (NDSS), 2015.\r\n[22] P. Sarbinowski, V. P. Kemerlis, C. Giuffrida, and E. Athanasopoulos.\r\nVTPin: Practical VTable Hijacking Protection for Binaries. In Annual\r\nComputer Security Applications Conference (ACSAC), 2016.\r\n[23] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and\r\nT. Holz. Counterfeit Object-oriented Programming: On the Difficulty\r\nof Preventing Code Reuse Attacks in C++ Applications. In IEEE\r\nSymposium on Security and Privacy (S&P), 2015.\r\n[24] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,\r\nA. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna.\r\n(State of) The Art of War: Offensive Techniques in Binary Analysis.\r\nIn IEEE Symposium on Security and Privacy (S&P), 2016.\r\n[25] B. Stroustrup. C++ Applications. http://www.stroustrup.com/\r\napplications.html.\r\n[26] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Erlingsson, ´\r\nL. Lozano, and G. Pike. Enforcing Forward-Edge Control-Flow In\u0002tegrity in GCC & LLVM. In USENIX Security Symposium, 2014.\r\n[27] V. van der Veen, D. Andriesse, E. Goktas¸, B. Gras, L. Sambuc, ¨\r\nA. Slowinska, H. Bos, and C. Giuffrida. Practical Context-Sensitive\r\nCFI. In ACM Conference on Computer and Communications Security\r\n(CCS), 2015.\r\n[28] V. van der Veen, E. Goktas, M. Contag, A. Pawlowski, X. Chen, ¨\r\nS. Rawat, H. Bos, T. Holz, E. Athanasopoulos, and C. Giuffrida. A\r\nTough call: Mitigating Advanced Code-Reuse Attacks At The Binary\r\nLevel. In IEEE Symposium on Security and Privacy (S&P), 2016.\r\n[29] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer, and D. Song.\r\nVTrust: Regaining Trust on Virtual Calls. In Symposium on Network\r\nand Distributed System Security (NDSS), 2016.\r\n15",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/e0edbb48-7741-4158-90db-348d799f97dd/images/45a6542a-eb3f-417e-8a47-e4f5fa6ac1d4.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041644Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c488b16e6d32edd6079b69e2090a97280d5b51095ca2baa954508e41b4c7af8b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 684
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "```json\n{\n \"title\": \"MARX: Uncovering Class Hierarchies in C++ Programs\"\n}\n```"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "No response"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No response"
        }
      ]
    }
  }
}