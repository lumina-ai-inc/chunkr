{
  "file_name": "Introduction to x64 Assembly.pdf",
  "task_id": "43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "fe648fbc-8065-4413-8f19-34729277b56f",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "Introduction to x64 Assembly\r\nBy Chris Lomont, 2009, http://www.lomont.org\r\nIntroduction\r\nFor years PC programmers used x86 assembly to write performance critical code, however 32-bit \r\nPCs are being replaced with 64-bit ones, and the underlying assembly code has changed. This \r\nGem is an introduction to x64 assembly. No prior knowledge of x86 code is needed, although it \r\nmakes the transition easier.\r\nx64 is a generic name for the 64-bit extensions to Intel‟s and AMD‟s 32-bit x86 instruction set \r\narchitecture (ISA). AMD introduced the first version of x64, initially called x86-64 and later \r\nrenamed AMD64. Intel named their implementation IA-32e and then EMT64. There are some \r\nslight incompatibilities between the two versions, but most code works fine on both versions; \r\ndetails can be found in the manuals [AMD09, Intel09]. We call this intersection flavor x64.\r\nNeither is to be confused with Intel‟s Itanium 64-bit architecture, which is called IA-64.\r\nThis Gem won‟t cover hardware details such as caches, branch prediction, and other advanced \r\ntopics. Several references will be given at the end of the article for further reading on these areas.\r\nAssembly is often used for performance critical parts of a program, although it is difficult to \r\noutperform a good C++ compiler for most programmers. Assembly knowledge is useful for \r\ndebugging code – sometimes a compiler makes incorrect assembly code and stepping through \r\nthe code in a debugger helps locate the cause. Code optimizers sometimes make mistakes. \r\nAnother use for assembly is interfacing with or fixing code for which you have no source code. \r\nDisassembly lets you change/fix existing executables. Assembly is necessary if you want to \r\nknow how your language of choice works under the hood – why some things are slow and others \r\nare fast. Finally, assembly code knowledge is indispensible when diagnosing malware.\r\nArchitecture\r\nWhen learning assembly for a given platform, the first place to start is to learn the register set. \r\nGeneral Architecture\r\nSince the 64-bit registers allow access for many sizes and locations, we define a byte as 8 bits, a \r\nword as 16 bits, a double word as 32 bits, a quadword as 64 bits, and a double quadword as 128 \r\nbits. Intel stores bytes “little endian,” meaning lower significant bytes are stored in lower \r\nmemory addresses.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/fe648fbc-8065-4413-8f19-34729277b56f.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=398480bbe3ed7cc7e1170a0600b28a85c14b17e6c8a36eb55347c0243e6b56c4",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 371
      },
      {
        "segments": [
          {
            "segment_id": "a69534ab-6ec6-49c0-b5be-e86c1a3fa5ea",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 1 – General Architecture\r\nFigure 1 shows sixteen general purpose 64-bit registers, the first eight of which are labeled (for \r\nhistorical reasons) RAX, RBX, RCX, RDX, RBP, RSI, RDI, and RSP. The second eight are \r\nnamed R8-R15. By replacing the initial R with an E on the first eight registers it is possible to\r\naccess the lower 32 bits (EAX for RAX). Similarly for RAX, RBX, RCX, and RDX access to the \r\nlower 16 bits is possible by removing the initial R (AX for RAX), and the lower byte of the these \r\nby switching the X for L (AL for AX), and the higher byte of the low 16 bits using an H (AH for \r\nAX). The new registers R8 to R15 can be accessed in a similar manner like this: R8 (qword), \r\nR8D (lower dword), R8W (lowest word), R8B (lowest byte MASM style, Intel style R8L). Note \r\nthere is no R8H.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/a69534ab-6ec6-49c0-b5be-e86c1a3fa5ea.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9a220db3f847eda94ccf231a83aca8800efc319ff5e8c748167f72137fac1b42",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 153
      },
      {
        "segments": [
          {
            "segment_id": "7d1dbea3-c69a-4f95-8a18-36ce00fb8010",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "There are odd limitations accessing the byte registers due to coding issues in the REX opcode \r\nprefix used for the new registers: an instruction cannot reference a legacy high byte (AH, BH, \r\nCH, DH) and one of the new byte registers at the same time (such as R11B) but it can use legacy \r\nlow bytes (AL, BL, CL, DL). This is enforced by changing (AH, BH, CH, DH) to (BPL, SPL, \r\nDIL, SIL) for instructions using a REX prefix.\r\nThe 64-bit instruction pointer RIP points to the next instruction to be executed, and supports a \r\n64-bit flat memory model. Memory address layout in current operating systems is covered later.\r\nThe stack pointer RSP points to the last item pushed onto the stack, which grows toward lower \r\naddresses. The stack is used to store return addresses for subroutines, for passing parameters in \r\nhigher level languages such as C/C++, and for storing “shadow space” covered in calling \r\nconventions.\r\nThe RFLAGS register stores flags used for results of operations and for controlling the \r\nprocessor. This is formed from the x86 32-bit register EFLAGS by adding a higher 32 bits which \r\nare reserved and currently unused. Table 1 lists the most useful flags. Most of the other flags are \r\nused for operating system level tasks and should always be set to the value previously read.\r\nTable 1 – Common Flags\r\nSymbol Bit Name Set if….\r\nCF 0 Carry Operation generated a carry or borrow\r\nPF 2 Parity Last byte has even number of 1‟s, else 0\r\nAF 4 Adjust Denotes Binary Coded Decimal in-byte carry\r\nZF 6 Zero Result was 0\r\nSF 7 Sign Most significant bit of result is 1\r\nOF 11 Overflow Overflow on signed operation\r\nDF 10 Direction Direction string instructions operate (increment or decrement)\r\nID 21 Identification Changeability denotes presence of CPUID instruction\r\nThe floating point unit (FPU) contains eight registers FPR0-FPR7, status and control registers, \r\nand a few other specialized registers. FPR0-7 can each store one value of the types shown in \r\nTable 2. Floating point operations conform to IEEE 754. Note that most C/C++ compilers \r\nsupport the 32 and 64 bit types as float and double, but not the 80-bit one available from \r\nassembly. These registers share space with the eight 64-bit MMX registers.\r\nTable 2 – Floating Point Types\r\nData Type Length Precision \r\n(bits)\r\nDecimal digits \r\nPrecision\r\nDecimal Range\r\nSingle Precision 32 24 7 1.18*10^-38 to 3.40*10^38\r\nDouble Precision 64 53 15 2.23 *10^-308 to 1.79*10^308\r\nExtended Precision 80 64 19 3.37*10^-4932 to 1.18*10^4932",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/7d1dbea3-c69a-4f95-8a18-36ce00fb8010.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=be71a15180a0da3f2dc941c741a85c4f4eb581de408be27f31e0d3727018eeaf",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 417
      },
      {
        "segments": [
          {
            "segment_id": "d39ccd87-7cb9-46da-82b1-baf402d4fc6d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "Binary Coded Decimal (BCD) is supported by a few 8-bit instructions, and an oddball format \r\nsupported on the floating point registers gives an 80 bit, 17 digit BCD type.\r\nThe sixteen 128-bit XMM registers (eight more than x86) are covered in more detail below.\r\nFinal registers include segment registers (mostly unused in x64), control registers, memory \r\nmanagement registers, debug registers, virtualization registers, performance registers tracking all \r\nsorts of internal parameters (cache hits/misses, branch hits/misses, micro-ops executed, timing, \r\nand much more). The most notable performance opcode is RDTSC which is used to count \r\nprocessor cycles for profiling small pieces of code.\r\nFull details are available in the five volume set “Intel® 64 and IA-32 Architectures Software \r\nDeveloper's Manuals” at http://www.intel.com/products/processor/manuals/. They are available\r\nas for free download as PDF, order on CD, and often can be ordered for free as a hardcover set \r\nwhen listed.\r\nSIMD Architecture\r\nSingle Instruction Multiple Data (SIMD) instructions execute a single command on multiple \r\npieces of data in parallel and are a common usage for assembly routines. MMX and SSE \r\ncommands (using the MMX and XMM registers respectively) support SIMD operations, which \r\nperform an instruction on up to eight pieces of data in parallel. For example, eight bytes can be \r\nadded to eight bytes in one instruction using MMX.\r\nThe eight 64-bit MMX registers MMX0-MMX7 are aliased on top of FPR0-7, which means any \r\ncode mixing FP and MMX operations must be careful not to overwrite required values. The \r\nMMX instructions operate on integer types, allowing byte, word, and doubleword operations to \r\nbe performed on values in the MMX registers in parallel. Most MMX instructions begin with „P‟ \r\nfor “packed”. Arithmetic, shift/rotate, comparison, ex: PCMPGTB “Compare packed signed byte \r\nintegers for greater than”.\r\nThe sixteen 128-bit XMM registers allow parallel operations on four single or two double \r\nprecision values per instruction. Some instructions also work on packed byte, word, doubleword, \r\nand quadword integers. These instructions, called the Streaming SIMD Extensions (SSE), come \r\nin many flavors: SSE, SSE2, SSE3, SSSE3, SSE4, and perhaps more by the time this prints. Intel \r\nhas announced more extensions along these lines called Advanced Vector Extensions (AVX), \r\nwith a new 256 bit wide datapath. SSE instructions contain move, arithmetic, comparison, \r\nshuffling and unpacking, and bitwise operations on both floating point and integer types. \r\nInstruction names include such beauties as PMULHUW and RSQRTPS. Finally SSE introduced \r\nsome instructions for memory pre-fetching (for performance) and memory fences (for multi\u0002threaded safety).\r\nTable 3 lists some command sets, the register types operated on, the number of items \r\nmanipulated in parallel, and the item type. For example, using SSE3 and the 128-bit XMM ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/d39ccd87-7cb9-46da-82b1-baf402d4fc6d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2148c69dcafc23ba4f45b62060f4c79eca439da9713921df5ac5cb979718473a",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 436
      },
      {
        "segments": [
          {
            "segment_id": "8817c691-3106-4f31-8649-bbbac4dc012c",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 5,
            "page_width": 612,
            "page_height": 792,
            "content": "registers, you can operate on 2 (must be 64-bit) floating point values in parallel, or even 16 (must \r\nbe byte sized) integer values in parallel.\r\nTo find which technologies a given chip supports there is a CPUID instruction that returns \r\nprocessor specific information.\r\nTable 3\r\nTechnology Register size/type Item type Items in Parallel\r\nMMX 64 MMX Integer 8, 4, 2, 1\r\nSSE 64 MMX Integer 8,4,2,1\r\nSSE 128 XMM Float 4\r\nSSE2/SSE3/SSSE3… 64 MMX Integer 2,1\r\nSSE2/SSE3/SSSE3… 128 XMM Float 2\r\nSSE2/SSE3/SSSE3… 128 XMM Integer 16,8,4,2,1\r\nTools\r\nAssemblers\r\nAn internet search reveals x64 capable assemblers such as the Netwide Assembler NASM\r\n[NASM09], a NASM rewrite called YASM [YASM09], the fast Flat Assembler FASM\r\n[FASM09], and the traditional Microsoft MASM. There is even a free IDE for x86 and x64 \r\nassembly called WinASM. Each assembler has varying support for other assemblers‟ macros and \r\nsyntax, but assembly code is not source-compatible across assemblers like C++ or Java are.\r\nFor the examples below I use the 64-bit version of MASM, ML64.EXE, freely available in the \r\nplatform SDK. For the examples below note that MASM syntax is of the form \r\nInstruction Destination, Source\r\nSome assemblers reverse source and destination, so be read your documentation carefully.\r\nC/C++ Compilers\r\nC/C++ compilers often allow embedding assembly in the code using inline assembly, but Visual \r\nStudio C/C++ removed this for x64 code, likely to simplify the task of the code optimizer. This \r\nleaves two options: use separate assembly files and an external assembler or use intrinsics\r\n[Birtolo08, MSDNInt09] from the header file “intrn.h”. Other compilers feature similar options.\r\nSome reasons to use intrinsics:\r\n Inline asm not supported in x64.\r\n Ease of use: you can use variable names instead of having to juggle register allocation \r\nmanually.\r\n More cross-platform than assembly: the compiler maker can port the intrinsics to various \r\narchitectures.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/8817c691-3106-4f31-8649-bbbac4dc012c.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=8024ea0257f766e2759ab5949563e5e1f76efe34e9d284f41680daaef4d0d866",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 304
      },
      {
        "segments": [
          {
            "segment_id": "bcde572b-84e8-462d-a047-1902722ec603",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 6,
            "page_width": 612,
            "page_height": 792,
            "content": " The optimizer works better with intrinsics.\r\nFor example, Visual Studio 2008 has an intrinsic \r\nunsigned short _rot16(unsigned short a, unsigned char b)\r\nwhich rotates the bits in a 16-bit value right b bits and returns the answer. Doing this in C gives\r\nunsigned short a1 = (b>>c)|(b<<(16-c));\r\nwhich expands to fifteen assembly instructions (in debug builds - in release builds whole \r\nprogram optimization made it harder to separate, but it was of a similar length), while using the \r\nequivalent intrinsic\r\nunsigned short a2 = _rotr16(b,c);\r\nexpands to four instructions. For more information read the header file and documentation.\r\nInstruction Basics\r\nAddressing Modes\r\nBefore covering some basic instructions, you need to understand addressing modes, which are \r\nways an instruction can access registers or memory. Common addressing modes with examples:\r\n Immediate: the value is stored in the instruction.\r\nADD EAX, 14 ; add 14 into 32-bit EAX\r\n Register to register\r\nADD R8L, AL ; add 8 bit AL into R8L\r\n Indirect: this allows using an 8, 16, or 32 bit displacement, any general purpose registers \r\nfor base and index, and a scale of 1, 2, 4, or 8 to multiply the index. Technically, these \r\ncan also be prefixed with segment FS: or GS: but this is rarely required.\r\nMOV R8W, 1234[8*RAX+RCX] ; move word at address 8*RAX+RCX+1234 into R8W\r\nThere are many legal ways to write this. The following are equivalent\r\nMOV ECX, dword ptr table[RBX][RDI]\r\nMOV ECX, dword ptr table[RDI][RBX]\r\nMOV ECX, dword ptr table[RBX+RDI]\r\nMOV ECX, dword ptr [table+RBX+RDI]\r\nThe dword ptr tells the assembler how to encode the MOV instruction. \r\n RIP-relative addressing: this is new for x64 and allows accessing data tables and such in \r\nthe code relative to the current instruction pointer, making position independent code ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/bcde572b-84e8-462d-a047-1902722ec603.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a11a51cb0af622ee9b10108e7fa0800e6132548003e8f4759fc950cb96db732e",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 293
      },
      {
        "segments": [
          {
            "segment_id": "d3abf7dc-19e4-4748-8d41-2e844b1f67e6",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 7,
            "page_width": 612,
            "page_height": 792,
            "content": "easier to implement.\r\nMOV AL, [RIP] ; RIP points to the next instruction aka NOP\r\nNOP\r\nUnfortunately, MASM does not allows this form of opcode, but other assemblers like \r\nFASM and YASM do. Instead MASM embeds RIP-relative addressing implicitly.\r\nMOV EAX, TABLE ; uses RIP- relative addressing to get table address\r\n Specialized cases: some opcodes use registers in unique ways based on the opcode. For \r\nexample, signed integer division IDIV on a 64 bit operand value divides the 128-bit value \r\nin RDX:RAX by the value, storing the result in RAX and the remainder in RDX.\r\nInstruction Set\r\nTable 4 lists some common instructions. * denotes this entry is multiple opcodes where the * \r\ndenotes a suffix.\r\nTable 4 – Common Opcodes\r\nOpcode Meaning Opcode Meaning\r\nMOV Move to/from/between \r\nmemory and registers\r\nAND/OR/XOR/NOT Bitwise operations\r\nCMOV* Various conditional moves SHR/SAR Shift right logical/arithmetic\r\nXCHG Exchange SHL/SAL Shift left logical/arithmetic\r\nBSWAP Byte swap ROR/ROL Rotate right/left\r\nPUSH/POP Stack usage RCR/RCL Rotate right/left through carry \r\nbit\r\nADD/ADC Add/with carry BT/BTS/BTR Bit test/and set/and reset\r\nSUB/SBC Subtract/with carry JMP Unconditional jump\r\nMUL/IMUL Multiply/unsigned JE/JNE/JC/JNC/J* Jump if equal/not \r\nequal/carry/not carry/ many \r\nothers\r\nDIV/IDIV Divide/unsigned LOOP/LOOPE/LOOPNE Loop with ECX\r\nINC/DEC Increment/Decrement CALL/RET Call subroutine/return\r\nNEG Negate NOP No operation\r\nCMP Compare CPUID CPU information\r\nA common instruction is the LOOP instruction, which decrements RCX, ECX, or CX depending \r\non usage, and then jumps if the result is not 0. For example, \r\n XOR EAX, EAX ; zero out eax\r\n MOV ECX, 10 ; loop 10 times\r\nLabel: ; this is a label in assembly\r\n INX EAX ; increment eax\r\n LOOP Label ; decrement ECX, loop if not 0\r\nLess common opcodes implement string operations, repeat instruction prefixes, port I/O \r\ninstructions, flag set/clear/test, floating point operations (begin usually with a F, and support ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/d3abf7dc-19e4-4748-8d41-2e844b1f67e6.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=29bc7c0fbd705fbce6ba79bb84e13dabca37cf5c71ef21ddbb65a6d7ccb14691",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "11be0b0d-3e2f-45fc-9232-80c49431c723",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 8,
            "page_width": 612,
            "page_height": 792,
            "content": "move, to/from integer, arithmetic, comparison, transcendental, algebraic, and control functions), \r\ncache and memory opcodes for multithreading and performance issues, and more. The Intel \r\ndocumentation, volume 2, in two parts covers each opcode in detail.\r\nOperating Systems\r\n64-bit systems allow addressing 264 bytes of data in theory, but no current chips allow accessing \r\nall 16 exabytes (18,446,744,073,709,551,616 bytes). For example, AMD architecture uses only \r\nthe lower 48 bits of an address, and bits 48 through 63 must be a copy of bit 47 or the processor \r\nraises an exception. Thus addresses are 0 through 00007FFF`FFFFFFFF, and from \r\nFFFF8000`00000000 through FFFFFFFF`FFFFFFFF, for a total of 256 TB \r\n(281,474,976,710,656 bytes) of usable virtual address space. Another downside is that \r\naddressing all 64 bits of memory requires a lot more paging tables for the OS to store, using \r\nvaluable memory for systems with less than all 16 exabytes installed. Note these are virtual \r\naddresses, not physical addresses.\r\nAs a result, many operating systems use the higher half of this space for the OS, starting at the \r\ntop and growing down, while user programs use the lower half, starting at the bottom and \r\ngrowing upwards. Current Windows versions use 44 bits of addressing (16 terabytes = \r\n17,592,186,044,416 bytes). The resulting addressing is shown in ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/11be0b0d-3e2f-45fc-9232-80c49431c723.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=2a136160c61d811cd4cd06c90a1c6c29b04aa98cae8189bae40c26d98974c449",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 505
      },
      {
        "segments": [
          {
            "segment_id": "76929c9b-a56d-4232-80c9-634e60214385",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 9,
            "page_width": 612,
            "page_height": 792,
            "content": "Figure 2. The resulting addresses are not too important for user programs since addresses are \r\nassigned by the OS, but the distinction between user addresses and kernel addresses are useful \r\nfor debugging.\r\nA final OS related item relates to multithreaded programming, but this topic is too large to cover \r\nhere. The only mention is that there are memory barrier opcodes for helping to keep shared \r\nresources uncorrupted.\r\nFigure 2 – Memory Addressing\r\nCalling Conventions\r\nInterfacing with operating system libraries requires knowing how to pass parameters and manage \r\nthe stack. These details on a platform are called a calling convention. \r\nA common x64 calling convention is the Microsoft [MSDNCall09, Chen09, Pietrick05] x64 \r\ncalling convention used for C style function calling. Under Linux this would be called an \r\nApplication Binary Interface (ABI). Note the calling convention covered here is different than \r\nthe one used on x64 Linux systems. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/76929c9b-a56d-4232-80c9-634e60214385.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=5d7884362c5ba1e3a4b1af8ed23b554ac3e1b8dc879900c1f0e8261d0347c824",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 146
      },
      {
        "segments": [
          {
            "segment_id": "22f17ea5-0dda-4e48-80d9-6bcdf506d153",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 10,
            "page_width": 612,
            "page_height": 792,
            "content": "For the Microsoft x64 calling convention, the additional register space let fastcall be the only \r\ncalling convention (under x86 there were many: stdcall, thiscall, fastcall, cdecl, etc.). The rules\r\nfor interfacing with C/C++ style functions:\r\n RCX, RDX, R8, R9 are used for integer and pointer arguments in that order left to right.\r\n XMM0, 1, 2, and 3 are used for floating point arguments.\r\n Additional arguments are pushed on the stack left to right.\r\n Parameters less than 64 bits long are not zero extended; the high bits contain garbage. \r\n It is the caller‟s responsibility to allocate 32 bytes of “shadow space” (for storing RCX, \r\nRDX, R8, and R9 if needed) before calling the function.\r\n It is the caller‟s responsibility to clean the stack after the call.\r\n Integer return values (similar to x86) are returned in RAX if 64 bits or less.\r\n Floating point return values are returned in XMM0.\r\n Larger return values (structs) have space allocated on the stack by the caller, and RCX \r\nthen contains a pointer to the return space when the callee is called. Register usage for \r\ninteger parameters is then pushed one to the right. RAX returns this address to the caller.\r\n The stack is 16-byte aligned. The “call” instruction pushes an 8-byte return value, so the \r\nall non-leaf functions must adjust the stack by a value of the form 16n+8 when allocating \r\nstack space.\r\n Registers RAX, RCX, RDX, R8, R9, R10, and R11 are considered volatile and must be \r\nconsidered destroyed on function calls. \r\n RBX, RBP, RDI, RSI, R12, R14, R14, and R15 must be saved in any function using \r\nthem.\r\n Note there is no calling convention for the floating point (and thus MMX) registers.\r\n Further details (varargs, exception handling, stack unwinding) are at Microsoft‟s site.\r\nExamples\r\nArmed with the above, here are a few examples showing x64 usage. The first is a simple x64 \r\nstandalone assembly program that pops up a Windows MessageBox.\r\n; Sample x64 Assembly Program\r\n; Chris Lomont 2009 www.lomont.org\r\nextrn ExitProcess: PROC ; external functions in system libraries\r\nextrn MessageBoxA: PROC\r\n.data\r\ncaption db '64-bit hello!', 0\r\nmessage db 'Hello World!', 0\r\n.code\r\nStart PROC\r\n sub rsp,28h ; shadow space, aligns stack",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/22f17ea5-0dda-4e48-80d9-6bcdf506d153.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=e11bb75e2523245d3cb0bef4eba275644a409e067aeaf4c82b866bc9f69ac280",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 375
      },
      {
        "segments": [
          {
            "segment_id": "5979c69a-ecf2-4bec-87bb-381405249f8e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 11,
            "page_width": 612,
            "page_height": 792,
            "content": " mov rcx, 0 ; hWnd = HWND_DESKTOP\r\n lea rdx, message ; LPCSTR lpText\r\n lea r8, caption ; LPCSTR lpCaption\r\n mov r9d, 0 ; uType = MB_OK\r\n call MessageBoxA ; call MessageBox API function\r\n mov ecx, eax ; uExitCode = MessageBox(...)\r\n call ExitProcess\r\nStart ENDP\r\nEnd\r\nSave this as hello.asm, compile this with ML64, available in the Microsoft Windows x64 SDK as \r\nfollows:\r\nml64 hello.asm /link /subsystem:windows /defaultlib:kernel32.lib \r\n/defaultlib:user32.lib /entry:Start\r\nwhich makes a windows executable and links with appropriate libraries. Run the resulting \r\nexecutable hello.exe and you should get the message box to pop up.\r\nThe second example links an assembly file with a C/C++ file under Visual Studio 2008. Other \r\ncompiler systems are similar. First make sure your compiler is an x64 capable version. Then\r\n1. Create a new empty C++ console project. Create a function you‟d like to port to \r\nassembly, and call it from main.\r\n2. To change the default 32-bit build, select Build/Configuration Manager.\r\n3. Under Active Platform, select New…\r\n4. Under Platform, select x64. If it does not appear figure out how to add the 64-bit SDK \r\ntools and repeat.\r\n5. Compile and step into the code. Look under Debug/Windows/Disassembly to see the \r\nresulting code and interface needed for your assembly function.\r\n6. Create an assembly file, and add it to the project. It defaults to a 32 bit assembler which is \r\nfine.\r\n7. Open the assembly file properties, select all configurations, and edit the custom build \r\nstep.\r\n8. Put command line \r\nml64.exe /DWIN_X64 /Zi /c /Cp /Fl /Fo $(IntDir)\\$(InputName).obj \r\n$(InputName).asm\r\nand set outputs to \r\n$(IntDir)\\$(InputName).obj\r\n9. Build and run.\r\nFor example, in main.cpp we put a function CombineC that does some simple math on five \r\ninteger parameters and one double parameter, and returns a double answer. We duplicate that \r\nfunctionality in assembly in a separate file CombineA.asm in a function called CombineA. The \r\nC++ file is:",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/5979c69a-ecf2-4bec-87bb-381405249f8e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=b48937a1d7d167dd0c1cbe66b423077d425e1b85347ba41bcc1fe8ae6cfd4673",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 311
      },
      {
        "segments": [
          {
            "segment_id": "31631996-5f11-401d-aef8-c0f6c2e399bc",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 12,
            "page_width": 612,
            "page_height": 792,
            "content": "// C++ code to demonstrate x64 assembly file linking\r\n#include <iostream>\r\nusing namespace std;\r\ndouble CombineC(int a, int b, int c, int d, int e, double f)\r\n{\r\n return (a+b+c+d+e)/(f+1.5);\r\n}\r\n// NOTE: extern “C” needed to prevent C++ name mangling\r\nextern \"C\" double CombineA(int a, int b, int c, int d, int e, double \r\nf);\r\nint main(void)\r\n{\r\n cout << \"CombineC: \" << CombineC(1,2,3,4, 5, 6.1) << endl;\r\n cout << \"CombineA: \" << CombineA(1,2,3,4, 5, 6.1) << endl;\r\n return 0;\r\n}\r\nBe sure to make functions extern “C” linkage to prevent C++ name mangling. Assembly file \r\nCombineA.asm contains\r\n; Sample x64 Assembly Program\r\n.data\r\nrealVal REAL8 +1.5 ; this stores a real number in 8 bytes\r\n.code\r\nPUBLIC CombineA\r\nCombineA PROC\r\n ADD ECX, DWORD PTR [RSP+28H] ; add overflow parameter to first \r\nparameter\r\n ADD ECX, R9D ; add other three register parameters\r\n ADD ECX, R8D ;\r\n ADD ECX, EDX ;\r\n MOVD XMM0, ECX ; move doubleword ECX into XMM0\r\n CVTDQ2PD XMM0, XMM0 ; convert doubleword to floating point\r\n MOVSD XMM1, realVal ; load 1.5\r\n ADDSD XMM1, MMWORD PTR [RSP+30H] ; add parameter\r\n DIVSD XMM0, XMM1 ; do division, answer in xmm0\r\n RET ; return\r\nCombineA ENDP\r\nEnd\r\nRunning this should result in the value 1.97368 being output twice. ",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/31631996-5f11-401d-aef8-c0f6c2e399bc.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d03e83abe4b3b4916ce0120b5bb3166fddb665ea736440650fe73402a1e40554",
            "html": null,
            "markdown": null
          },
          {
            "segment_id": "c334b744-b3d7-4608-a524-f4aef70e951d",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 13,
            "page_width": 612,
            "page_height": 792,
            "content": "Conclusion\r\nThis has been a necessarily brief introduction to x64 assembly programming. The next step is to \r\nbrowse the Intel manuals. Manual 1 contains the architecture details and is a good start if you \r\nknow assembly. Other places are assembly books or online assembly tutorials. To get an \r\nunderstanding of how your code executes it is instructive to step through code in debugger, \r\nlooking at the disassembly, until you can read assembly code as well as your favorite language.\r\nFor C/C++ compilers, debug builds are much easier to read than release builds so be sure to start\r\nthere. Finally, read the forums at masm32.com for a lot of material.\r\nReferences\r\n[AMD09] “AMD64 Architecture Tech Docs,” available online at http://www.amd.com/us\u0002en/Processors/DevelopWithAMD/0,,30_2252_875_7044,00.html, 2009.\r\n[NASM09] See http://www.nasm.us/\r\n[YASM09] See http://www.tortall.net/projects/yasm/ \r\n[FLAT09] See http://www.flatassembler.net/\r\n[Birtolo08] “New Intrinsic Support in Visual Studio 2008”, Dylan Birtolo, \r\nhttp://blogs.msdn.com/vcblog/archive/2007/10/18/new-intrinsic-support-in-visual-studio\u00022008.aspx\r\n[Chen09] Raymond Chen, “The history of calling conventions, part 5: amd64,” available online \r\nat http://blogs.msdn.com/oldnewthing/archive/2004/01/14/58579.aspx, 2009.\r\n[Intel09] “Intel® 64 and IA-32 Architectures Software Developer's Manuals,” available online at \r\nhttp://www.intel.com/products/processor/manuals/ , 2009.\r\n[MSDNInt09] “Compiler Intrinsics,” available online at http://msdn.microsoft.com/en\u0002us/library/26td21ds.aspx, 2009.\r\n[MSDNCall09] “Calling Convention” http://msdn.microsoft.com/en-us/library/9b372w95.aspx\r\n[Pietrick05] “Everything You Need To Know To Start Programming 64-Bit Windows Systems”, \r\nMatt Pietrek, http://msdn.microsoft.com/en-us/magazine/cc300794.aspx, 2009.",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/43a6ce2b-b79f-4fec-a5f8-223fc8d69b7d/images/c334b744-b3d7-4608-a524-f4aef70e951d.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T041935Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c687aad76fa8172d3f52b411b5cc61f561ffcf87331939b87d285d703ba9759b",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 408
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Introduction to x64 Assembly\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "Chris Lomont"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "2009\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "The document mentions several locations within the CPU, such as registers (e.g., RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8-R15, XMM0-15, MMX0-7, FPR0-7, RIP, RSP, RFLAGS), stack, memory, specific bits within registers (e.g., AH, BH, CH, DH, AL, BL, CL, DL, BPL, SPL, DIL, SIL), and the floating-point unit (FPU). It also discusses memory addressing in user and kernel space.  Additionally, it mentions external locations like \"masm32.com\" and URLs for AMD, NASM, YASM, FASM, Intel, and Microsoft documentation.\n"
        }
      ]
    }
  }
}