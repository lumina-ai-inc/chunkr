{
  "file_name": "Inside IOCP.pdf",
  "task_id": "0fef8608-78ff-4aea-b56c-d52151f76f59",
  "output": {
    "chunks": [
      {
        "segments": [
          {
            "segment_id": "0d9f9a91-d1b2-48d9-a432-442b3c0c27bb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 1/4\r\nCopyright © 1998 Mark Russinovich\r\nLast updated July 30, 1998\r\nIntroduction\r\nWriting a high-performance server application requires implementing an efficient\r\nthreading model. Having either too few or too many server threads to process client\r\nrequests can lead to performance problems. For example, if a server creates a single\r\nthread to handle all requests clients can become starved since the server will be tied up\r\nprocessing one request at a time. Of course, a single thread could simultaneously\r\nprocess multiple requests, switching from one to another as I/O operations are started,\r\nbut this architecture introduces significant complexity and cannot take advantage of\r\nmultiprocessor systems. At the other extreme a server could create a big pool of threads\r\nso that virtually every client request is processed by a dedicated thread. This scenario\r\nusually leads to thread-thrashing, where lots of threads wake-up, perform some CPU\r\nprocessing, block waiting for I/O and then after request procesing is completed block\r\nagain waiting for a new request. If nothing else, context-switches are caused by the\r\nscheduler having to divide processor time among multiple active threads.\r\nThe goal of a server is to incur as few context switches as possible by having its\r\nthreads avoid unnecessary blocking, while at the same time maximizing parallelism by\r\nusing multiple threads. The ideal is for there to be a thread actively servicing a client\r\nrequest on every processor and for those threads not to block if there are additional\r\nrequests waiting when they complete a request. For this to work correctly however,\r\nthere must be a way for the application to activate another thread when one processing\r\na client request blocks on I/O (like when it reads from a file as part of the processing).\r\nWindows NT 3.5 introduced a set of APIs that make this goal relatively easy to\r\nachieve. The APIs are centered on an object called a completion port. In this article I'm\r\ngoing to provide an overview of how completion ports are used and then go inside\r\nthem to show you how Windows NT implements them.\r\nUsing I/O Completion Ports\r\nApplications use completion ports as the the focal point for the completion of I/O\r\nassociated with multiple file handles. Once a file is associated with a completion port\r\nany asynchronous I/O operations that complete on the file result in a completion packet\r\nbeing queued to the port. A thread can wait for any outstanding I/Os to complete on\r\nmultiple files simply by waiting for a completion packet to be queued on the\r\ncompletion port. The Win32 API provides similar functionality with the\r\nWaitForMultipleObjects API, but the advantage that completion ports have is that\r\nconcurrency, or the number of threads that an application has actively servicing client\r\nrequests, is controlled with the aid of the system.\r\nWhen an application creates a completion port it specifies a concurrency value. This\r\nvalue indicates the maximum number of threads associated with the port that should be\r\nrunning at any given point in time. As I stated earlier, the ideal is to have one thread\r\nactive at any given point in time for every processor in the system. The concurrency\r\nvalue associated with a port is used by NT to control how many threads an application\r\nhas active - if the number of active threads associated with a port equals the\r\nhttp://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.Gsohtml SEP NOV DEC\r\n1\r\n2009 2010 2011\r\n19 captures\r\n26 Jul 10 ‑ 15 Aug 13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/0d9f9a91-d1b2-48d9-a432-442b3c0c27bb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4893f760e34d3523f9835ed6c604bd4e0880b0703d73b77b84c343426f109720",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 585
      },
      {
        "segments": [
          {
            "segment_id": "0d9f9a91-d1b2-48d9-a432-442b3c0c27bb",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 1,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 1/4\r\nCopyright © 1998 Mark Russinovich\r\nLast updated July 30, 1998\r\nIntroduction\r\nWriting a high-performance server application requires implementing an efficient\r\nthreading model. Having either too few or too many server threads to process client\r\nrequests can lead to performance problems. For example, if a server creates a single\r\nthread to handle all requests clients can become starved since the server will be tied up\r\nprocessing one request at a time. Of course, a single thread could simultaneously\r\nprocess multiple requests, switching from one to another as I/O operations are started,\r\nbut this architecture introduces significant complexity and cannot take advantage of\r\nmultiprocessor systems. At the other extreme a server could create a big pool of threads\r\nso that virtually every client request is processed by a dedicated thread. This scenario\r\nusually leads to thread-thrashing, where lots of threads wake-up, perform some CPU\r\nprocessing, block waiting for I/O and then after request procesing is completed block\r\nagain waiting for a new request. If nothing else, context-switches are caused by the\r\nscheduler having to divide processor time among multiple active threads.\r\nThe goal of a server is to incur as few context switches as possible by having its\r\nthreads avoid unnecessary blocking, while at the same time maximizing parallelism by\r\nusing multiple threads. The ideal is for there to be a thread actively servicing a client\r\nrequest on every processor and for those threads not to block if there are additional\r\nrequests waiting when they complete a request. For this to work correctly however,\r\nthere must be a way for the application to activate another thread when one processing\r\na client request blocks on I/O (like when it reads from a file as part of the processing).\r\nWindows NT 3.5 introduced a set of APIs that make this goal relatively easy to\r\nachieve. The APIs are centered on an object called a completion port. In this article I'm\r\ngoing to provide an overview of how completion ports are used and then go inside\r\nthem to show you how Windows NT implements them.\r\nUsing I/O Completion Ports\r\nApplications use completion ports as the the focal point for the completion of I/O\r\nassociated with multiple file handles. Once a file is associated with a completion port\r\nany asynchronous I/O operations that complete on the file result in a completion packet\r\nbeing queued to the port. A thread can wait for any outstanding I/Os to complete on\r\nmultiple files simply by waiting for a completion packet to be queued on the\r\ncompletion port. The Win32 API provides similar functionality with the\r\nWaitForMultipleObjects API, but the advantage that completion ports have is that\r\nconcurrency, or the number of threads that an application has actively servicing client\r\nrequests, is controlled with the aid of the system.\r\nWhen an application creates a completion port it specifies a concurrency value. This\r\nvalue indicates the maximum number of threads associated with the port that should be\r\nrunning at any given point in time. As I stated earlier, the ideal is to have one thread\r\nactive at any given point in time for every processor in the system. The concurrency\r\nvalue associated with a port is used by NT to control how many threads an application\r\nhas active - if the number of active threads associated with a port equals the\r\nhttp://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.Gsohtml SEP NOV DEC\r\n1\r\n2009 2010 2011\r\n19 captures\r\n26 Jul 10 ‑ 15 Aug 13",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/0d9f9a91-d1b2-48d9-a432-442b3c0c27bb.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=4893f760e34d3523f9835ed6c604bd4e0880b0703d73b77b84c343426f109720",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 585
      },
      {
        "segments": [
          {
            "segment_id": "a80ece85-536f-4d0e-b2eb-34164da43399",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 2,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 2/4\r\nhas active - if the number of active threads associated with a port equals the\r\nconcurrency value then a thread that is waiting on the completion port will not be\r\nallowed to run. Instead, it is expected that one of the active threads will finish\r\nprocessing its current request and check to see if there's another packet waiting at the\r\nport - if there is then it simply grabs it and goes off to process it. When this happens\r\nthere is no context switch, and the CPUs are utilized to near their full capacity.\r\nFigure 1 below shows a high-level picture of completion port operation. Incoming\r\nclient requests cause completion packets to be queued at the port. A number of threads,\r\nup to the concurrency limit for the port, are allowed by NT to process client requests.\r\nAny additional threads associated with the port are blocked until the number of active\r\nthreads drops, as can happen when an active thread blocks on file I/O. I'll discuss this\r\nfurther a little later.\r\nA completion port is created with a call to the Win32 API CreateIoCompletionPort:\r\nHANDLE CreateIoCompletionPort(\r\nHANDLE FileHandle,\r\nHANDLE ExistingCompletionPort,\r\nDWORD CompletionKey ,\r\nDWORD NumberOfConcurrentThreads\r\n);\r\nTo create the port an application passes in a NULL for the ExistingCompletionPort\r\nparameter and indicates the concurreny value with the NumberOfConcurrentThreads\r\nparameter. If a FileHandle parameter is specified then the file handle becomes\r\nassociated with the port. When an I/O request that has been issued on the file handle\r\ncompletes a completion packet is queued to the completion port. To retrieve a\r\ncompletion packet and possibly block waiting for one to arrive a thread calls the\r\nGetQueuedCompletionStatus API:\r\nBOOL GetQueuedCompletionStatus(\r\nHANDLE CompletionPort,\r\nLPDWORD lpNumberOfBytesTransferred,\r\nLPDWORD CompletionKey ,\r\nLPOVERLAPPED *lpOverlapped,\r\nDWORD dwMiillisecondTimeout\r\n);\r\nThreads that block on a completion port become associated with the port and are\r\nwoken in LIFO order so that the thread that blocked most recently is the one that is\r\ngiven the next packet. Threads that block for long periods of time can have their stacks",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/a80ece85-536f-4d0e-b2eb-34164da43399.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=69448415f7a497b47fef41c3a76b352d1a293853affa292bf81f6a8cf40db4bc",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 354
      },
      {
        "segments": [
          {
            "segment_id": "efe67ccb-170f-4fb4-afa7-e4b1d01c8d4e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 3/4\r\ngiven the next packet. Threads that block for long periods of time can have their stacks\r\nswapped out to disk, so if there are more threads associated with a port then there is\r\nwork to process the in-memory footprints of threads blocked the longest are minimized.\r\nA server application will usually receive client requests via network endpoints that are\r\nrepresented as file handles. Examples include Winsock2 sockets or named pipes. As\r\nthe server creates its communications endpoints it associates them with a completion\r\nport and its threads wait for incoming requests by calling\r\nGetQueuedCompletionStatus on the port. When a thread is given a packet from the\r\ncompletion port it will go off and start processing the request, becoming an active\r\nthread. Many times a thread will block during its processing, like when it needs to read\r\nor write data to a file on disk, or when it synchronizes with other threads. Windows\r\nNT is clever enough to detect this and recognize that the completion port has one less\r\nactive thread. Therefore, when a thread becomes inactive because it blocks, a thread\r\nwaiting on the completion port will be woken if there is packet in the queue.\r\nMicrosoft's guidelines are to set the concurrency value roughly equal to the number of\r\nprocessors in a system. Note that it is possible for the number of active threads for a\r\ncompletion port to exceed the concurrency limit. Consider a case where the limit is\r\nspecified as 1. A client request comes in and a thread is dispatched to process the\r\nrequest, becoming active. A second requests comes in but a second thread waiting on\r\nthe port is not allowed to proceed because the concurrency limit has been reached.\r\nThen the first thread blocks waiting for a file I/O so it becomes inactive. The second\r\nthread is then released and while it is still active the first thread's file I/O is completes,\r\nmaking it active again. At that point in time, and until one of the threads blocks, the\r\nconcurrency value is 2, which is higher than the limit of 1. Most of the time the active\r\ncount will remain at or just above the concurrency limit.\r\nThe completion port API also makes it possible for a server application to queue\r\nprivately defined completion packets to a completion port using\r\nPostQueuedCompletionStatus. Servers typically use this function to inform its\r\nthreads of external events such as the need to shut down gracefully.\r\nCompletion Port Internals\r\nA call to the Win32 API CreateIoCompletionPort with a NULL completion port\r\nhandle results in the execution of the native API function NtCreateIoCompletion,\r\nwhich invokes the corresponding kernel-mode system service of the same name.\r\nInternally, completion ports are based on an undocumented executive synchronization\r\nobject called a Queue. Thus, the system service creates a completion port object and\r\ninitializes a queue object in the port's allocated memory (a pointer to the port also\r\npoints to the queue object since the queue is at the start of the port memory). A queue\r\nobject has (coincidentally) a concurrency value that is specified when a thread\r\ninitializes one, and in this case the value that is used is the one that was passed to\r\nCreateIoCompletionPort. KeInitializeQueue is the function that\r\nNtCreateIoCompletion calls to initialize a port's queue object.\r\nWhen an application calls CreateIoCompletionPort to associate a file handle with a\r\nport the Win32 API invokes the native function NtSetInformationFile with the file\r\nhandle as the primary parameter. The information class that is set is\r\nFileCompletionInformation and the completion port's handle and the CompletionKey\r\nparameter from CreateIoCompletionPort are the data values. NtSetInformationFile\r\ndereferences the file handle to obtain the file object and allocates a completion context\r\ndata structure, which is defined in NTDDK.H as:\r\ntypedef struct _IO_COMPLETION_CONTEXT {\r\nPVOID Port;\r\nULONG Key;\r\n} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;\r\nFinally, NtSetInformationFile sets the CompletionContext field in the file object to\r\npoint at the context structure. When an I/O operation completes on a file object the",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/efe67ccb-170f-4fb4-afa7-e4b1d01c8d4e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a8bed623e2d0a48d1c66f76022d7e0c9a5fcadefcb29d277a5847d3628da4ad7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 675
      },
      {
        "segments": [
          {
            "segment_id": "efe67ccb-170f-4fb4-afa7-e4b1d01c8d4e",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 3,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 3/4\r\ngiven the next packet. Threads that block for long periods of time can have their stacks\r\nswapped out to disk, so if there are more threads associated with a port then there is\r\nwork to process the in-memory footprints of threads blocked the longest are minimized.\r\nA server application will usually receive client requests via network endpoints that are\r\nrepresented as file handles. Examples include Winsock2 sockets or named pipes. As\r\nthe server creates its communications endpoints it associates them with a completion\r\nport and its threads wait for incoming requests by calling\r\nGetQueuedCompletionStatus on the port. When a thread is given a packet from the\r\ncompletion port it will go off and start processing the request, becoming an active\r\nthread. Many times a thread will block during its processing, like when it needs to read\r\nor write data to a file on disk, or when it synchronizes with other threads. Windows\r\nNT is clever enough to detect this and recognize that the completion port has one less\r\nactive thread. Therefore, when a thread becomes inactive because it blocks, a thread\r\nwaiting on the completion port will be woken if there is packet in the queue.\r\nMicrosoft's guidelines are to set the concurrency value roughly equal to the number of\r\nprocessors in a system. Note that it is possible for the number of active threads for a\r\ncompletion port to exceed the concurrency limit. Consider a case where the limit is\r\nspecified as 1. A client request comes in and a thread is dispatched to process the\r\nrequest, becoming active. A second requests comes in but a second thread waiting on\r\nthe port is not allowed to proceed because the concurrency limit has been reached.\r\nThen the first thread blocks waiting for a file I/O so it becomes inactive. The second\r\nthread is then released and while it is still active the first thread's file I/O is completes,\r\nmaking it active again. At that point in time, and until one of the threads blocks, the\r\nconcurrency value is 2, which is higher than the limit of 1. Most of the time the active\r\ncount will remain at or just above the concurrency limit.\r\nThe completion port API also makes it possible for a server application to queue\r\nprivately defined completion packets to a completion port using\r\nPostQueuedCompletionStatus. Servers typically use this function to inform its\r\nthreads of external events such as the need to shut down gracefully.\r\nCompletion Port Internals\r\nA call to the Win32 API CreateIoCompletionPort with a NULL completion port\r\nhandle results in the execution of the native API function NtCreateIoCompletion,\r\nwhich invokes the corresponding kernel-mode system service of the same name.\r\nInternally, completion ports are based on an undocumented executive synchronization\r\nobject called a Queue. Thus, the system service creates a completion port object and\r\ninitializes a queue object in the port's allocated memory (a pointer to the port also\r\npoints to the queue object since the queue is at the start of the port memory). A queue\r\nobject has (coincidentally) a concurrency value that is specified when a thread\r\ninitializes one, and in this case the value that is used is the one that was passed to\r\nCreateIoCompletionPort. KeInitializeQueue is the function that\r\nNtCreateIoCompletion calls to initialize a port's queue object.\r\nWhen an application calls CreateIoCompletionPort to associate a file handle with a\r\nport the Win32 API invokes the native function NtSetInformationFile with the file\r\nhandle as the primary parameter. The information class that is set is\r\nFileCompletionInformation and the completion port's handle and the CompletionKey\r\nparameter from CreateIoCompletionPort are the data values. NtSetInformationFile\r\ndereferences the file handle to obtain the file object and allocates a completion context\r\ndata structure, which is defined in NTDDK.H as:\r\ntypedef struct _IO_COMPLETION_CONTEXT {\r\nPVOID Port;\r\nULONG Key;\r\n} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;\r\nFinally, NtSetInformationFile sets the CompletionContext field in the file object to\r\npoint at the context structure. When an I/O operation completes on a file object the",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/efe67ccb-170f-4fb4-afa7-e4b1d01c8d4e.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a8bed623e2d0a48d1c66f76022d7e0c9a5fcadefcb29d277a5847d3628da4ad7",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 675
      },
      {
        "segments": [
          {
            "segment_id": "2fa240e0-145e-44ab-bfc3-1a9cd40fa719",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 4/4\r\npoint at the context structure. When an I/O operation completes on a file object the\r\ninternal I/O manager function IopCompleteRequest executes and, if the I/O was\r\nasynchronous, checks to see if the CompletionContext field in the file object is non\u0002NULL. If its non-NULL the I/O Manager allocates a completion packet and queues it\r\nto the completion port by calling KeInsertQueue with the port as the queue on which\r\nto insert the packet (remember that the completion port object and queue object are\r\nsynonymous).\r\nWhen GetQueuedCompletionStatus is invoked by a server thread, it calls the native\r\nAPI function NtRemoveIoCompletion, which transfers control to the\r\nNtRemoveIoCompletion system service. After validating parameters and translating\r\nthe completion port handle to a pointer to the port, NtRemoveIoCompletion calls\r\nKeRemoveQueue.\r\nAs you can see, KeRemoveQueue and KeInsertQueue are the engine behind\r\ncompletion ports and are the functions that determine whether a thread waiting for an\r\nI/O completion packet should be activated or not. Internally, a queue object maintains a\r\ncount of the current number of active threads and the maximum active threads. If the\r\ncurrent number equals or exceeds the maximum when a thread calls\r\nKeRemoveQueue, the thread will be put (in LIFO order) onto a list of threads waiting\r\nfor a turn to process a completion packet. The list of threads hangs off the queue\r\nobject. A thread's control block data structure has a pointer in it that references the\r\nqueue object of a queue that it is associated with; if the pointer is NULL then the\r\nthread is not associated with a queue.\r\nSo how does NT keep track of threads that become inactive because they block on\r\nsomething other than the completion port? The answer lies in the queue pointer in a\r\nthread's control block. The scheduler routines that are executed in response to a thread\r\nblocking (KeWaitForSingleObject, KeDelayExecutionThread, etc.) check the\r\nthread's queue pointer and if its not NULL they will call KiActivateWaiterQueue, a\r\nqueue-related function. KiActivateWaiterQueue decrements the count of active\r\nthreads associated with the queue, and if the result is less than the maximum and there\r\nis at least one completion packet in the queue then the thread at the front of the queue's\r\nthread list is woken and given the oldest packet. Conversely, whenever a thread that is\r\nassociated with a queue wakes up after blocking the scheduler executes the function\r\nKiUnwaitThread, which increments the queue's active count.\r\nFinally, the PostQueuedCompletionStatus Win32 API calls upon the native function\r\nNtSetIoCompletion. As with the other native APIs in the completion port group, this\r\none invokes a system service bearing the same name, which simply inserts that packet\r\nonto the completion port's queue using KeInsertQueue.\r\nNot Exported\r\nWindows NT's completion port API provides an easy-to-use and efficient way to\r\nmaximize a server's performance by minimizing context switches while obtaining high\u0002degrees of parallelism. The API is made possible with support in the I/O Manager,\r\nKernel, and system services. While the Queue object is exported for use by device\r\ndrivers (it is undocumented but its interfaces are relatively easy to figure out), the\r\ncompletion port APIs are not. However, if the queue interfaces are derived it is\r\npossible to mimick the completion port interfaces by simply using the queue routines\r\nand manually associating file objects with queues by setting the CompletionContext\r\nentry.\r\nBack to Top",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/2fa240e0-145e-44ab-bfc3-1a9cd40fa719.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9acaa9ba5480e53c388ff215652ca4f29b4b12ffde9073682ffeaa2ebd19e7c2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 569
      },
      {
        "segments": [
          {
            "segment_id": "2fa240e0-145e-44ab-bfc3-1a9cd40fa719",
            "bbox": {
              "left": 0,
              "top": 0,
              "width": 612,
              "height": 792
            },
            "page_number": 4,
            "page_width": 612,
            "page_height": 792,
            "content": "9/21/13 Sysinternals Freeware - Information for Windows NT and Windows 2000 - Inside I/O Completion Ports\r\nweb.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml 4/4\r\npoint at the context structure. When an I/O operation completes on a file object the\r\ninternal I/O manager function IopCompleteRequest executes and, if the I/O was\r\nasynchronous, checks to see if the CompletionContext field in the file object is non\u0002NULL. If its non-NULL the I/O Manager allocates a completion packet and queues it\r\nto the completion port by calling KeInsertQueue with the port as the queue on which\r\nto insert the packet (remember that the completion port object and queue object are\r\nsynonymous).\r\nWhen GetQueuedCompletionStatus is invoked by a server thread, it calls the native\r\nAPI function NtRemoveIoCompletion, which transfers control to the\r\nNtRemoveIoCompletion system service. After validating parameters and translating\r\nthe completion port handle to a pointer to the port, NtRemoveIoCompletion calls\r\nKeRemoveQueue.\r\nAs you can see, KeRemoveQueue and KeInsertQueue are the engine behind\r\ncompletion ports and are the functions that determine whether a thread waiting for an\r\nI/O completion packet should be activated or not. Internally, a queue object maintains a\r\ncount of the current number of active threads and the maximum active threads. If the\r\ncurrent number equals or exceeds the maximum when a thread calls\r\nKeRemoveQueue, the thread will be put (in LIFO order) onto a list of threads waiting\r\nfor a turn to process a completion packet. The list of threads hangs off the queue\r\nobject. A thread's control block data structure has a pointer in it that references the\r\nqueue object of a queue that it is associated with; if the pointer is NULL then the\r\nthread is not associated with a queue.\r\nSo how does NT keep track of threads that become inactive because they block on\r\nsomething other than the completion port? The answer lies in the queue pointer in a\r\nthread's control block. The scheduler routines that are executed in response to a thread\r\nblocking (KeWaitForSingleObject, KeDelayExecutionThread, etc.) check the\r\nthread's queue pointer and if its not NULL they will call KiActivateWaiterQueue, a\r\nqueue-related function. KiActivateWaiterQueue decrements the count of active\r\nthreads associated with the queue, and if the result is less than the maximum and there\r\nis at least one completion packet in the queue then the thread at the front of the queue's\r\nthread list is woken and given the oldest packet. Conversely, whenever a thread that is\r\nassociated with a queue wakes up after blocking the scheduler executes the function\r\nKiUnwaitThread, which increments the queue's active count.\r\nFinally, the PostQueuedCompletionStatus Win32 API calls upon the native function\r\nNtSetIoCompletion. As with the other native APIs in the completion port group, this\r\none invokes a system service bearing the same name, which simply inserts that packet\r\nonto the completion port's queue using KeInsertQueue.\r\nNot Exported\r\nWindows NT's completion port API provides an easy-to-use and efficient way to\r\nmaximize a server's performance by minimizing context switches while obtaining high\u0002degrees of parallelism. The API is made possible with support in the I/O Manager,\r\nKernel, and system services. While the Queue object is exported for use by device\r\ndrivers (it is undocumented but its interfaces are relatively easy to figure out), the\r\ncompletion port APIs are not. However, if the queue interfaces are derived it is\r\npossible to mimick the completion port interfaces by simply using the queue routines\r\nand manually associating file objects with queues by setting the CompletionContext\r\nentry.\r\nBack to Top",
            "segment_type": "Page",
            "ocr": null,
            "image": "https://storage.googleapis.com/chunkr-bucket-dev/ccf89702-e38e-4089-bd6b-77e3ba63c341/0fef8608-78ff-4aea-b56c-d52151f76f59/images/2fa240e0-145e-44ab-bfc3-1a9cd40fa719.jpg?x-id=GetObject&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GOOG1E6ZKWCYPX4LV42MGE7WJ66QU2EMDPF3DJ2IFHNTQIGHNC2STOGTWF75E%2F20241112%2Fauto%2Fs3%2Faws4_request&X-Amz-Date=20241112T040617Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=9acaa9ba5480e53c388ff215652ca4f29b4b12ffde9073682ffeaa2ebd19e7c2",
            "html": null,
            "markdown": null
          }
        ],
        "chunk_length": 569
      }
    ],
    "extracted_json": {
      "title": "Document Metadata",
      "schema_type": "object",
      "extracted_fields": [
        {
          "name": "title",
          "field_type": "string",
          "value": "Inside I/O Completion Ports\n"
        },
        {
          "name": "author",
          "field_type": "string",
          "value": "Mark Russinovich\n"
        },
        {
          "name": "date_published",
          "field_type": "string",
          "value": "July 30, 1998\n"
        },
        {
          "name": "location",
          "field_type": "string",
          "value": "No location is mentioned in the document.\n"
        }
      ]
    }
  }
}